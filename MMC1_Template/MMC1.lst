#[1]   MMC1.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Constants.asm
   14                       .include "Defines/Constants.asm"
    1                             ;; define constants here
    2                             
    3           0000      TITLE_IDX = $00
    4           0001      GAME_IDX = $01
    5           0002      GAMEOVER_IDX = $02
    6           0000      SPRITE_YPOS = $00
    7           0003      SPRITE_XPOS = $03
    8           0200      SPRITE_DATA = $0200
#[1]   MMC1.asm
#[2]   Defines/RamDefines.asm
   15                       .include "Defines/RamDefines.asm"
    1                             ;; define 0 page stuff here, and SRAM stuff if we have it
    2                             
#[3]   Defines/GeneralVars.asm
    3                             .include "Defines/GeneralVars.asm"
    1                             
    2           0000      temp1  .rs 1
    3           0001      temp2  .rs 1
    4           0002      temp3  .rs 1
    5           0003      temp4  .rs 1
    6           0004      sleeping .rs 1
    7           0005      game_mode  .rs 1
    8           0006      game_mode_switching .rs 1
    9           0007      table_address  .rs 2
   10           0009      jump_address  .rs 2
   11                     
#[2]   Defines/RamDefines.asm
#[3]   Defines/MapperVars.asm
    4                             .include "Defines/MapperVars.asm"
    1                             
    2           000B      mapper_address .rs 2
    3           000D      currentCHRBank .rs 1
    4           000E      currentPRGBank .rs 1
    5           000F      mapperDebugVar .rs 1
    6                     
    7                     
#[2]   Defines/RamDefines.asm
#[3]   Defines/ControllerVars.asm
    5                             .include "Defines/ControllerVars.asm"
    1                             
    2           0010      gamepad .rs 1
    3           0011      gamepadLast .rs 1
    4           0012      gamepadPressed .rs 1
#[2]   Defines/RamDefines.asm
    6                     
#[1]   MMC1.asm
#[2]   Macros/Macros.asm
   16                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/LoadAllPalMacro.asm
    3                             .include "Macros/LoadAllPalMacro.asm"
    1                     ;;macro to load all pallets in 1 go
    2                     ;; \1 = label to start at
    3                     ;; A, X, and tableAddress are clobbered here, Y is clobbered in the implementation
    4                     MACROLoadAllPal .macro
    5                     
    6                             LDY \1
    7                             TYA
    8                             ASL A
    9                             TAY
   10                             LDA (Palettes), y
   11                             INY
   12                             LDX (Palettes), y
   13                             JSR SetTableAddress
   14                             JSR loadAllPal_impl
   15                             
   16                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/LoadFullBackMacro.asm
    4                             .include "Macros/LoadFullBackMacro.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label to start at
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROLoadFullBackground .macro
    5                     
    6                             LDY \1
    7                             TYA
    8                             ASL A
    9                             TAY
   10                             LDA (NameTables), y
   11                             INY
   12                             LDX (NameTables), y
   13                             JSR SetTableAddress
   14                             JSR loadFullBackground_impl
   15                       
   16                       .endm
#[2]   Macros/Macros.asm
#[1]   MMC1.asm
   17                     
   18                     ;;**************************;;
   19                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   20                     ;;       PRG ROM            ;;
   21                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   22                     ;;**************************;; 
   23                     
#[2]   Banks/Bank0.asm
   24                       .include "Banks/Bank0.asm"
    1           0000        .bank 0
    2           8000        .org $8000
    3                       
    4  00:8000            TestBankA:
    5  00:8000  A9 01             LDA #$01
    6  00:8002  8D 0F 00          STA mapperDebugVar
    7  00:8005  60                RTS
    8                     
    9           0001        .bank 1
   10           A000        .org $A000
   11  01:A000  AD 01 00    LDA $01
#[1]   MMC1.asm
#[2]   Banks/Bank1.asm
   25                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
    4  02:8000            TestBankB:
    5  02:8000  A9 02             LDA #$02
    6  02:8002  8D 0F 00          STA mapperDebugVar
    7  02:8005  60                RTS
    8                     
    9           0003        .bank 3
   10           A000        .org $A000
   11  03:A000  AD 02 00    LDA $02
#[1]   MMC1.asm
#[2]   Banks/Bank2.asm
   26                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
    4  04:8000            TestBankC:
    5  04:8000  A9 03             LDA #$03
    6  04:8002  8D 0F 00          STA mapperDebugVar
    7  04:8005  60                RTS
    8                     
    9           0005        .bank 5
   10           A000        .org $A000
   11  05:A000  AD 03 00    LDA $03
#[1]   MMC1.asm
   27                     
   28           0006        .bank 6
   29           C000        .org $C000 
   30                     
   31                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   32                     ;;     Initialization       ;;
   33                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   34                     
#[2]   Routines/Init.asm
   35                       .include "Routines/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 5A C1    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 5E C1    JSR SetMapperControls
   34                       
   35  06:C040  20 9B C1    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   MMC1.asm
   36                     
   37                     
   38  06:C048  A9 00       LDA #TITLE_IDX
   39  06:C04A  20 1F C1    JSR ChangeGameMode
   40                     
   41  06:C04D            LoadSprites:
   42  06:C04D  A2 00       LDX #$00              ; start at 0
   43  06:C04F            LoadSpritesLoop:
   44  06:C04F  BD 3C EC    LDA Pointer, x        ; load data from address (sprites +  x)
   45  06:C052  9D 00 02    STA SPRITE_DATA, x          ; store into RAM address ($0200 + x)
   46  06:C055  E8          INX                   ; X = X + 1
   47  06:C056  E0 05       CPX #$05              ; Compare X to hex $10, decimal 16
   48  06:C058  D0 F5       BNE LoadSpritesLoop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
   49                                             ; if compare was equal to 16, keep going down   
   50                     
   51                     
   52  06:C05A  A9 90       LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   53  06:C05C  8D 00 20    STA $2000
   54                     
   55  06:C05F  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
   56  06:C061  8D 01 20    STA $2001
   57                       
   58                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   59                     ;;     Main Program         ;;
   60                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   61                     
   62  06:C064            Forever:
   63                     
   64  06:C064  EE 04 00    INC sleeping
   65                     
   66  06:C067            .loop
   67  06:C067  AD 04 00    LDA sleeping
   68  06:C06A  D0 FB       BNE .loop
   69                     
   70  06:C06C  20 7B C0    JSR Dynamic_Jump
   71  06:C06F  20 8E C0    JSR CallDynamicSubroutine
   72                     
   73  06:C072  4C 64 C0    JMP Forever     ;jump back to Forever, infinite loop
   74                       
   75                     ;; dynamic jump table
   76                     
   77  06:C075            JumpTable:
   78                     
   79  06:C075  91 C0       .word UpdateTitle
   80  06:C077  9C C0       .word UpdateGame
   81  06:C079  D9 C0       .word UpdateGameOver
   82                       
   83  06:C07B            Dynamic_Jump:
   84                     
   85                       ;;load up the label from the table above
   86  06:C07B  AD 05 00    LDA game_mode
   87  06:C07E  0A          ASL A
   88  06:C07F  A8          TAY
   89  06:C080  BE 75 C0    LDX (JumpTable), y
   90  06:C083  C8          INY
   91  06:C084  B9 75 C0    LDA (JumpTable), y
   92  06:C087  8E 09 00    STX jump_address
   93  06:C08A  8D 0A 00    STA jump_address+1
   94  06:C08D  60          RTS
   95                       
   96  06:C08E            CallDynamicSubroutine:
   97  06:C08E  6C 09 00    JMP [jump_address]
   98                       ;;RTS is called in the subroutine
   99                     
  100                       
#[2]   States/UpdateTitle.asm
  101                       .include "States/UpdateTitle.asm"
    1  06:C091            UpdateTitle:
    2                     
    3  06:C091  AD 10 00    LDA gamepad
    4  06:C094  F0 05       BEQ .noInputDetected
    5                       
    6  06:C096  A9 01         LDA #GAME_IDX
    7  06:C098  20 1F C1          JSR ChangeGameMode
    8                      
    9  06:C09B            .noInputDetected:
   10                      
   11  06:C09B  60          RTS
#[1]   MMC1.asm
#[2]   States/UpdateGame.asm
  102                       .include "States/UpdateGame.asm"
    1  06:C09C            UpdateGame:
    2                     
    3  06:C09C  AD 12 00    LDA gamepadPressed
    4  06:C09F  F0 37       BEQ .noInputDetected
    5                       
    6  06:C0A1  20 5A C1          JSR ResetMapper
    7  06:C0A4  EE 0D 00          INC currentCHRBank
    8  06:C0A7  AD 0D 00          LDA currentCHRBank
    9  06:C0AA  C9 03             CMP #$03
   10  06:C0AC  D0 02             BNE .dontModCHR
   11                             
   12  06:C0AE  A9 00             LDA #$00
   13                             
   14  06:C0B0            .dontModCHR:
   15  06:C0B0  8D 0D 00          STA currentCHRBank 
   16                             ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
   17  06:C0B3  0A                ASL A
   18  06:C0B4  18                CLC 
   19  06:C0B5  69 01             ADC #$01
   20  06:C0B7  20 7F C1          JSR LoadCHRBankB
   21                             
   22  06:C0BA  20 5A C1          JSR ResetMapper
   23  06:C0BD  EE 0E 00          INC currentPRGBank
   24  06:C0C0  AD 0E 00          LDA currentPRGBank
   25  06:C0C3  C9 03             CMP #$03
   26  06:C0C5  D0 02             BNE .dontModPRG
   27                             
   28  06:C0C7  A9 00             LDA #$00
   29                             
   30  06:C0C9            .dontModPRG:
   31  06:C0C9  8D 0E 00          STA currentPRGBank
   32  06:C0CC  20 69 C1          JSR LoadPRGBank
   33                      
   34  06:C0CF  20 00 80          JSR TestBankA
   35  06:C0D2  AD 0F 00          LDA mapperDebugVar
   36  06:C0D5  8D 00 60          STA $6000
   37                      
   38  06:C0D8            .noInputDetected:
   39                      
   40  06:C0D8  60          RTS
#[1]   MMC1.asm
#[2]   States/UpdateGameOver.asm
  103                       .include "States/UpdateGameOver.asm"
    1  06:C0D9            UpdateGameOver:
    2  06:C0D9  60          RTS
#[1]   MMC1.asm
  104                       
  105                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  106                     ;;     Routines             ;;
  107                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  108                     
  109                       
#[2]   Routines/BackgroundUtil.asm
  110                       .include "Routines/BackgroundUtil.asm"
    1                     ;;macro to load all pallets in 1 go
    2                     ;; table_address should be set in the preceding macro
    3                     ;; y is clobbered
    4  06:C0DA            loadAllPal_impl:
    5  06:C0DA  AD 02 20    LDA $2002             ; read PPU status to reset the high/low latch
    6  06:C0DD  A9 3F       LDA #$3F
    7  06:C0DF  8D 06 20    STA $2006             ; write the high byte of $3F00 address
    8  06:C0E2  A9 00       LDA #$00
    9  06:C0E4  8D 06 20    STA $2006             ; write the low byte of $3F00 address
   10  06:C0E7  A0 00       LDY #$00              ; start out at 0
   11  06:C0E9            loadPalettesLoop:
   12  06:C0E9  B1 07       LDA [table_address], y        ; load data from address (palette + the value in x)
   13  06:C0EB  8D 07 20    STA $2007             ; write to PPU
   14  06:C0EE  C8          INY                   ; X = X + 1
   15  06:C0EF  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   16  06:C0F1  D0 F6       BNE loadPalettesLoop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   17  06:C0F3  60          RTS
   18                     
   19  06:C0F4            loadFullBackground_impl:
   20                     
   21  06:C0F4  AD 02 20          LDA $2002             ; read PPU status to reset the high/low latch
   22  06:C0F7  A9 20             LDA #$20
   23  06:C0F9  8D 06 20          STA $2006             ; write the high byte of $2000 address
   24  06:C0FC  A9 00             LDA #$00
   25  06:C0FE  8D 06 20          STA $2006             ; write the low byte of $2000 address
   26                             
   27                             ;;set pointer
   28                             ;; set counters
   29  06:C101  A0 00             LDY #$00
   30  06:C103  A2 00             LDX #$00
   31                             
   32                             ;;start loop
   33                     
   34  06:C105            .outerloop:
   35                     
   36  06:C105            .innerloop:
   37                     
   38  06:C105  B1 07             LDA [table_address], y
   39  06:C107  8D 07 20          STA $2007
   40  06:C10A  C8                INY
   41  06:C10B  C0 00             CPY #$00
   42  06:C10D  D0 F6             BNE .innerloop
   43                     
   44  06:C10F  EE 08 00          INC table_address+1
   45                             
   46  06:C112  E8                INX
   47  06:C113  E0 04             CPX #$04
   48  06:C115  D0 EE             BNE .outerloop
   49  06:C117  60                RTS
   50                             
   51  06:C118            SetTableAddress:
   52                             
   53                             ;;A is low, X is high
   54  06:C118  8D 07 00          STA table_address
   55  06:C11B  8E 08 00          STX table_address+1
   56  06:C11E  60                RTS
   57                             
   58  06:C11F            ChangeGameMode:
   59                     
   60  06:C11F  8D 05 00    STA game_mode
   61  06:C122  8D 06 00    STA game_mode_switching
   62  06:C125  A9 00       LDA #$00
   63  06:C127  8D 01 20    STA $2001    ; disable rendering- reenable on NMI when not updating
   64  06:C12A  20 33 C1    JSR LoadGameModeBackground
   65  06:C12D  A9 00       LDA #$00
   66  06:C12F  8D 06 00    STA game_mode_switching
   67  06:C132  60          RTS
   68                             
   69                             
   70  06:C133            LoadGameModeBackground:
   71                     
   72                             MACROLoadAllPal game_mode
                          
       06:C133  AC 05 00          LDY game_mode
       06:C136  98                TYA
       06:C137  0A                ASL A
       06:C138  A8                TAY
       06:C139  B9 00 E0          LDA (Palettes), y
       06:C13C  C8                INY
       06:C13D  BE 00 E0          LDX (Palettes), y
       06:C140  20 18 C1          JSR SetTableAddress
       06:C143  20 DA C0          JSR loadAllPal_impl
                                  
   73                             MACROLoadFullBackground game_mode
                          
       06:C146  AC 05 00          LDY game_mode
       06:C149  98                TYA
       06:C14A  0A                ASL A
       06:C14B  A8                TAY
       06:C14C  B9 06 E0          LDA (NameTables), y
       06:C14F  C8                INY
       06:C150  BE 06 E0          LDX (NameTables), y
       06:C153  20 18 C1          JSR SetTableAddress
       06:C156  20 F4 C0          JSR loadFullBackground_impl
                            
   74  06:C159  60                RTS
   75                             
   76                       
#[1]   MMC1.asm
#[2]   Routines/MapperUtils.asm
  111                       .include "Routines/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:C15A            ResetMapper:
    7  06:C15A  EE 5A C1    inc ResetMapper
    8  06:C15D  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:C15E            SetMapperControls:
   23                       ;;A = controls
   24  06:C15E  AA          TAX
   25  06:C15F  A9 80       LDA #MAPPERCONTROL
   26  06:C161  8D 0C 00    STA mapper_address+1
   27  06:C164  8A          TXA
   28  06:C165  20 8A C1    JSR SendMapperCommand
   29  06:C168  60          RTS
   30                     
   31  06:C169            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:C169  AA                TAX
   35  06:C16A  A9 E0             LDA #PRGBANK
   36  06:C16C  8D 0C 00          STA mapper_address+1
   37  06:C16F  8A                TXA
   38  06:C170  20 8A C1          JSR SendMapperCommand
   39  06:C173  60                RTS
   40                             
   41  06:C174            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:C174  AA                TAX
   44  06:C175  A9 A0             LDA #CHRBANK1
   45  06:C177  8D 0C 00          STA mapper_address+1
   46  06:C17A  8A                TXA
   47  06:C17B  20 8A C1          JSR SendMapperCommand
   48  06:C17E  60                RTS
   49                             
   50  06:C17F            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:C17F  AA                TAX
   53  06:C180  A9 C0             LDA #CHRBANK2
   54  06:C182  8D 0C 00          STA mapper_address+1
   55  06:C185  8A                TXA
   56  06:C186  20 8A C1          JSR SendMapperCommand
   57  06:C189  60                RTS
   58                             
   59  06:C18A            SendMapperCommand:
   60                     
   61  06:C18A  A0 00             LDY #$00
   62                             
   63  06:C18C  91 0B             STA [mapper_address], y
   64  06:C18E  4A                LSR A
   65  06:C18F  91 0B             STA [mapper_address], y
   66  06:C191  4A                LSR A
   67  06:C192  91 0B             STA [mapper_address], y
   68  06:C194  4A                LSR A 
   69  06:C195  91 0B             STA [mapper_address], y
   70  06:C197  4A                LSR A
   71  06:C198  91 0B             STA [mapper_address], y
   72                             
   73  06:C19A  60                RTS
   74                             
   75  06:C19B            ResetBanks:
   76                     
   77  06:C19B  20 5A C1          JSR ResetMapper
   78  06:C19E  A9 00             LDA #$00
   79  06:C1A0  20 69 C1          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:C1A3  20 5A C1          JSR ResetMapper
   83  06:C1A6  A9 00             LDA #$00
   84  06:C1A8  20 74 C1          JSR LoadCHRBankA
   85  06:C1AB  A9 01             LDA #$01
   86  06:C1AD  20 7F C1          JSR LoadCHRBankB
   87  06:C1B0  60                RTS
   88                             
   89                       
#[1]   MMC1.asm
  112                       
  113                       
  114                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  115                     ;;     NMI                  ;;
  116                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  117                     
#[2]   Routines/NMI.asm
  118                       .include "Routines/NMI.asm"
    1                      
    2  06:C1B1            NMI:
    3                     
    4  06:C1B1  48          PHA                              ;protect the registers
    5  06:C1B2  8A          TXA
    6  06:C1B3  48          PHA
    7  06:C1B4  98          TYA
    8  06:C1B5  48          PHA
    9                       
   10  06:C1B6            nmi_started:
   11  06:C1B6  A9 00       LDA #$00
   12  06:C1B8  8D 03 20    STA $2003       ; set the low byte (00) of the RAM address
   13  06:C1BB  A9 02       LDA #$02
   14  06:C1BD  8D 14 40    STA $4014       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:C1C0  AD 06 00    LDA game_mode_switching
   17  06:C1C3  F0 03       BEQ update_controllers
   18  06:C1C5  4C 39 C2    JMP WakeUp
   19                     
   20  06:C1C8            update_controllers:
   21                     
#[3]   Routines/ReadControllers.asm
   22                       .include "Routines/ReadControllers.asm"
    1                     
    2  06:C1C8  8A            TXA
    3  06:C1C9  48                PHA
    4  06:C1CA  98                TYA
    5  06:C1CB  48                PHA
    6                     
    7  06:C1CC  A2 00             LDX #$00
    8                     
    9  06:C1CE            GamePadCheck:
   10  06:C1CE  A9 01             LDA #$01        ;load 1
   11  06:C1D0  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:C1D3  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:C1D4  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:C1D7  A9 80             LDA #$80
   18  06:C1D9  8D 10 00          STA gamepad
   19                     
   20  06:C1DC            ReadControllerABytesLoop:
   21  06:C1DC  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:C1DF  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:C1E1  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:C1E3  6E 10 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:C1E6  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:C1E8  AD 11 00          LDA gamepadLast
   31  06:C1EB  49 FF             EOR #$FF
   32  06:C1ED  2D 10 00          AND gamepad
   33  06:C1F0  8D 12 00          STA gamepadPressed
   34                             
   35                             
   36  06:C1F3  AD 10 00          LDA gamepad
   37  06:C1F6  8D 11 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:C1F9  68                PLA
   41  06:C1FA  A8                TAY
   42  06:C1FB  68                PLA
   43  06:C1FC  AA                TAX     
#[2]   Routines/NMI.asm
   23                       
   24                       
   25  06:C1FD  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   26  06:C1FF  8D 05 20    STA $2005
   27  06:C202  8D 05 20    STA $2005
   28                       
   29  06:C205  A9 90       LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   30  06:C207  8D 00 20    STA $2000
   31  06:C20A  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
   32  06:C20C  8D 01 20    STA $2001
   33                     
   34  06:C20F  AD 05 00    LDA game_mode
   35  06:C212  C9 00       CMP #TITLE_IDX
   36  06:C214  D0 23       BNE NotTitle
   37                             ;;load bank 0 for BG tiles
   38  06:C216  20 5A C1    JSR ResetMapper
   39  06:C219  A9 01       LDA #$01
   40  06:C21B  20 7F C1    JSR LoadCHRBankB
   41                                     
   42  06:C21E            WaitNotSprite0:
   43  06:C21E  AD 02 20    lda $2002
   44  06:C221  29 40       and #%01000000
   45  06:C223  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
   46                     
   47  06:C225            WaitSprite0:
   48  06:C225  AD 02 20    lda $2002
   49  06:C228  29 40       and #%01000000
   50  06:C22A  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
   51                     
   52  06:C22C  A2 05       ldx #$05                              ;do a scanline wait
   53  06:C22E            WaitScanline:
   54  06:C22E  CA          dex
   55  06:C22F  D0 FD       bne WaitScanline
   56                     
   57  06:C231  20 5A C1    JSR ResetMapper
   58  06:C234  A9 03       LDA #$03
   59  06:C236  20 7F C1    JSR LoadCHRBankB
   60                                     
   61                     
   62  06:C239            NotTitle:
   63                     
   64                     
   65  06:C239            WakeUp:
   66  06:C239  A9 00       LDA #$00
   67  06:C23B  8D 04 00    STA sleeping
   68                       
   69  06:C23E  68          PLA                              ;restore the registers
   70  06:C23F  A8          TAY 
   71  06:C240  68          PLA
   72  06:C241  AA          TAX
   73  06:C242  68          PLA
   74                     
   75  06:C243  40          RTI             ; return from interrupt
#[1]   MMC1.asm
  119                       
  120                     ;;**************************;;
  121                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122                     ;;       PRG ROM DATA       ;;
  123                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  124                     ;;**************************;; 
  125                       
  126                       
  127           0007        .bank 7
  128           E000        .org $E000
  129                     
#[2]   NameTables/Tables.asm
  130                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  0C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  1C E0     
       07:E004  2C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  3C E0       .word Title_Screen, Game_Screen, GameOver_Screen
       07:E008  3C E4     
       07:E00A  3C E8     
    8                     
    9  07:E00C            Title_Palette:
   10                     
   11  07:E00C              .incbin "NameTables/Title_PAL.pal"
   12                       
   13  07:E01C            Game_Palette:
   14                     
   15  07:E01C              .incbin "NameTables/Game_PAL.pal"
   16                       
   17  07:E02C            GameOver_Palette:
   18                     
   19  07:E02C              .incbin "NameTables/GameOver_PAL.pal"
   20                       
   21  07:E03C            Title_Screen:
   22                     
   23  07:E03C              .incbin "NameTables/Title_NT.nam"
   24                       
   25  07:E43C            Game_Screen: 
   26                     
   27  07:E43C              .incbin "NameTables/Game_NT.nam"
   28                       
   29  07:E83C            GameOver_Screen:
   30                     
   31  07:E83C              .incbin "NameTables/Game_NT.nam"
   32                       
   33                     
   34                       
   35                      
   36                             
#[1]   MMC1.asm
#[2]   Sprites/Sprites.asm
  131                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37                     
   38  07:EC3C            Pointer:
   39  07:EC3C  91 00 00          .db $91,$00,$00,$E8
       07:EC3F  E8        
#[1]   MMC1.asm
  132                     
  133           FFFA        .org $FFFA     ;first of the three vectors starts here
  134  07:FFFA  B1 C1       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  135                                        ;processor will jump to the label NMI:
  136  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  137                                        ;to the label RESET:
  138  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  139                       
  140                     ;;**************************;;
  141                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  142                     ;;      CHR ROM DATA        ;;
  143                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  144                     ;;**************************;; 
  145                       
  146           0008        .bank 8
  147           0000        .org $0000
  148  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  149                       
  150           0009        .bank 9
  151           0000        .org $0000
  152  09:0000              .incbin "CHRROM/Bank1.chr"
  153                       
  154           000A        .bank 10
  155           0000        .org $0000
  156  0A:0000              .incbin "CHRROM/Bank2.chr"
  157                       
  158           000B        .bank 11
  159           0000        .org $0000
  160  0B:0000              .incbin "CHRROM/Bank3.chr"
