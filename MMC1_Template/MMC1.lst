#[1]   MMC1.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/RamDefines.asm
   14                       .include "Defines/RamDefines.asm"
    1                             ;; define 0 page stuff here, and SRAM stuff if we have it
    2                             
    3           0000      temp1  .rs 1
    4           0001      temp2  .rs 1
    5           0002      temp3  .rs 1
    6           0003      temp4  .rs 1
    7           0004      sleeping .rs 1
    8           0005      game_mode  .rs 1
    9           0006      game_mode_switching .rs 1
   10           0007      table_address  .rs 2
   11           0009      jump_address  .rs 2
   12           000B      mapper_address .rs 2
   13           000D      gamepad .rs 1
   14           000E      gamepadLast .rs 1
   15           000F      gamepadPressed .rs 1
   16           0010      currentCHRBank .rs 1
   17           0011      currentPRGBank .rs 1
#[1]   MMC1.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/LoadAllPalMacro.asm
    3                             .include "Macros/LoadAllPalMacro.asm"
    1                     ;;macro to load all pallets in 1 go
    2                     ;; \1 = label to start at
    3                     ;; A, X, and tableAddress are clobbered here, Y is clobbered in the implementation
    4                     MACROLoadAllPal .macro
    5                     
    6                             LDY \1
    7                             TYA
    8                             ASL A
    9                             TAY
   10                             LDA (Palettes), y
   11                             INY
   12                             LDX (Palettes), y
   13                             JSR SetTableAddress
   14                             JSR loadAllPal_impl
   15                             
   16                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/LoadFullBackMacro.asm
    4                             .include "Macros/LoadFullBackMacro.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label to start at
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROLoadFullBackground .macro
    5                     
    6                             LDY \1
    7                             TYA
    8                             ASL A
    9                             TAY
   10                             LDA (NameTables), y
   11                             INY
   12                             LDX (NameTables), y
   13                             JSR SetTableAddress
   14                             JSR loadFullBackground_impl
   15                       
   16                       .endm
#[2]   Macros/Macros.asm
#[1]   MMC1.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
   23                       ;;.bank 0
   24                       ;;.org $8000
   25                       ;;NOP
   26                     
   27                       ;;.bank 1
   28                       ;;.org $A000
   29                       ;;NOP
   30                     
   31                       ;;.bank 2
   32                       ;;.org $8000
   33                       ;;NOP
   34                       
   35                       ;;.bank 3
   36                       ;;.org $A000
   37                       ;;NOP
   38                     
   39           0000        .bank 0
   40           C000        .org $C000 
   41                     
   42                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   43                     ;;     Initialization       ;;
   44                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   45                     
#[2]   Routines/Init.asm
   46                       .include "Routines/Init.asm"
    1  00:C000            RESET:
    2  00:C000  78          SEI          ; disable IRQs
    3  00:C001  D8          CLD          ; disable decimal mode
    4  00:C002  A2 40       LDX #$40
    5  00:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  00:C007  A2 FF       LDX #$FF
    7  00:C009  9A          TXS          ; Set up stack
    8  00:C00A  E8          INX          ; now X = 0
    9  00:C00B  8E 00 20    STX $2000    ; disable NMI
   10  00:C00E  8E 01 20    STX $2001    ; disable rendering
   11  00:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  00:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  00:C014  2C 02 20    BIT $2002
   15  00:C017  10 FB       BPL vblankwait1
   16                     
   17  00:C019            clrmem:
   18  00:C019  A9 00       LDA #$00
   19  00:C01B  9D 00 00    STA $0000, x
   20  00:C01E  9D 00 01    STA $0100, x
   21  00:C021  9D 00 03    STA $0300, x
   22  00:C024  9D 00 04    STA $0400, x
   23  00:C027  9D 00 05    STA $0500, x
   24  00:C02A  9D 00 06    STA $0600, x
   25  00:C02D  9D 00 07    STA $0700, x
   26  00:C030  A9 FE       LDA #$FE
   27  00:C032  9D 00 02    STA $0200, x
   28  00:C035  E8          INX
   29  00:C036  D0 E1       BNE clrmem
   30                        
   31  00:C038  20 29 C1    JSR ResetMapper
   32  00:C03B  A9 0E       LDA #$0E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  00:C03D  20 2D C1    JSR SetMapperControls
   34                       
   35  00:C040            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   36  00:C040  2C 02 20    BIT $2002
   37  00:C043  10 FB       BPL vblankwait2
#[1]   MMC1.asm
   47                     
   48                     
   49  00:C045  A9 00       LDA #TITLE_IDX
   50  00:C047  20 EE C0    JSR ChangeGameMode
   51                     
   52                     ;LoadSprites:
   53                     ;  LDX #$00              ; start at 0
   54                     ;LoadSpritesLoop:
   55                     ;  LDA sprites, x        ; load data from address (sprites +  x)
   56                     ;  STA $0200, x          ; store into RAM address ($0200 + x)
   57                     ;  INX                   ; X = X + 1
   58                     ;  CPX #$10              ; Compare X to hex $10, decimal 16
   59                     ;  BNE LoadSpritesLoop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
   60                                             ; if compare was equal to 16, keep going down   
   61                     
   62  00:C04A  A9 90       LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   63  00:C04C  8D 00 20    STA $2000
   64                     
   65  00:C04F  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
   66  00:C051  8D 01 20    STA $2001
   67                       
   68                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   69                     ;;     Main Program         ;;
   70                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   71                     
   72  00:C054            Forever:
   73                     
   74  00:C054  EE 04 00    INC sleeping
   75                     
   76  00:C057            .loop
   77  00:C057  AD 04 00    LDA sleeping
   78  00:C05A  D0 FB       BNE .loop
   79                     
   80  00:C05C  20 6B C0    JSR Dynamic_Jump
   81  00:C05F  20 7E C0    JSR CallDynamicSubroutine
   82                     
   83  00:C062  4C 54 C0    JMP Forever     ;jump back to Forever, infinite loop
   84                       
   85                     ;; dynamic jump table
   86                     
   87  00:C065            JumpTable:
   88                     
   89  00:C065  81 C0       .word UpdateTitle
   90  00:C067  8C C0       .word UpdateGame
   91  00:C069  A8 C0       .word UpdateGameOver
   92                       
   93  00:C06B            Dynamic_Jump:
   94                     
   95                       ;;load up the label from the table above
   96  00:C06B  AD 05 00    LDA game_mode
   97  00:C06E  0A          ASL A
   98  00:C06F  A8          TAY
   99  00:C070  BE 65 C0    LDX (JumpTable), y
  100  00:C073  C8          INY
  101  00:C074  B9 65 C0    LDA (JumpTable), y
  102  00:C077  8E 09 00    STX jump_address
  103  00:C07A  8D 0A 00    STA jump_address+1
  104  00:C07D  60          RTS
  105                       
  106  00:C07E            CallDynamicSubroutine:
  107  00:C07E  6C 09 00    JMP [jump_address]
  108                       ;;RTS is called in the subroutine
  109                     
  110                       
#[2]   States/UpdateTitle.asm
  111                       .include "States/UpdateTitle.asm"
    1  00:C081            UpdateTitle:
    2                     
    3  00:C081  AD 0D 00    LDA gamepad
    4  00:C084  F0 05       BEQ .noInputDetected
    5                       
    6  00:C086  A9 01         LDA #GAME_IDX
    7  00:C088  20 EE C0          JSR ChangeGameMode
    8                      
    9  00:C08B            .noInputDetected:
   10                      
   11  00:C08B  60          RTS
#[1]   MMC1.asm
#[2]   States/UpdateGame.asm
  112                       .include "States/UpdateGame.asm"
    1  00:C08C            UpdateGame:
    2                     
    3  00:C08C  AD 0F 00    LDA gamepadPressed
    4  00:C08F  F0 16       BEQ .noInputDetected
    5                       
    6  00:C091  20 29 C1          JSR ResetMapper
    7  00:C094  EE 10 00          INC currentCHRBank
    8  00:C097  AD 10 00          LDA currentCHRBank
    9  00:C09A  C9 03             CMP #$03
   10  00:C09C  D0 02             BNE .dontMod
   11                             
   12  00:C09E  A9 00             LDA #$00
   13                             
   14  00:C0A0            .dontMod:
   15  00:C0A0  8D 10 00          STA currentCHRBank 
   16  00:C0A3  0A                ASL A
   17  00:C0A4  20 43 C1          JSR LoadCHRBankA
   18                      
   19  00:C0A7            .noInputDetected:
   20                      
   21  00:C0A7  60          RTS
#[1]   MMC1.asm
#[2]   States/UpdateGameOver.asm
  113                       .include "States/UpdateGameOver.asm"
    1  00:C0A8            UpdateGameOver:
    2  00:C0A8  60          RTS
#[1]   MMC1.asm
  114                       
  115                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  116                     ;;     Routines             ;;
  117                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  118                     
  119                       
#[2]   Routines/BackgroundUtil.asm
  120                       .include "Routines/BackgroundUtil.asm"
    1                     ;;macro to load all pallets in 1 go
    2                     ;; table_address should be set in the preceding macro
    3                     ;; y is clobbered
    4  00:C0A9            loadAllPal_impl:
    5  00:C0A9  AD 02 20    LDA $2002             ; read PPU status to reset the high/low latch
    6  00:C0AC  A9 3F       LDA #$3F
    7  00:C0AE  8D 06 20    STA $2006             ; write the high byte of $3F00 address
    8  00:C0B1  A9 00       LDA #$00
    9  00:C0B3  8D 06 20    STA $2006             ; write the low byte of $3F00 address
   10  00:C0B6  A0 00       LDY #$00              ; start out at 0
   11  00:C0B8            loadPalettesLoop:
   12  00:C0B8  B1 07       LDA [table_address], y        ; load data from address (palette + the value in x)
   13  00:C0BA  8D 07 20    STA $2007             ; write to PPU
   14  00:C0BD  C8          INY                   ; X = X + 1
   15  00:C0BE  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   16  00:C0C0  D0 F6       BNE loadPalettesLoop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   17  00:C0C2  60          RTS
   18                     
   19  00:C0C3            loadFullBackground_impl:
   20                     
   21  00:C0C3  AD 02 20          LDA $2002             ; read PPU status to reset the high/low latch
   22  00:C0C6  A9 20             LDA #$20
   23  00:C0C8  8D 06 20          STA $2006             ; write the high byte of $2000 address
   24  00:C0CB  A9 00             LDA #$00
   25  00:C0CD  8D 06 20          STA $2006             ; write the low byte of $2000 address
   26                             
   27                             ;;set pointer
   28                             ;; set counters
   29  00:C0D0  A0 00             LDY #$00
   30  00:C0D2  A2 00             LDX #$00
   31                             
   32                             ;;start loop
   33                     
   34  00:C0D4            .outerloop:
   35                     
   36  00:C0D4            .innerloop:
   37                     
   38  00:C0D4  B1 07             LDA [table_address], y
   39  00:C0D6  8D 07 20          STA $2007
   40  00:C0D9  C8                INY
   41  00:C0DA  C0 00             CPY #$00
   42  00:C0DC  D0 F6             BNE .innerloop
   43                     
   44  00:C0DE  EE 08 00          INC table_address+1
   45                             
   46  00:C0E1  E8                INX
   47  00:C0E2  E0 04             CPX #$04
   48  00:C0E4  D0 EE             BNE .outerloop
   49  00:C0E6  60                RTS
   50                             
   51  00:C0E7            SetTableAddress:
   52                             
   53                             ;;A is low, X is high
   54  00:C0E7  8D 07 00          STA table_address
   55  00:C0EA  8E 08 00          STX table_address+1
   56  00:C0ED  60                RTS
   57                             
   58  00:C0EE            ChangeGameMode:
   59                     
   60  00:C0EE  8D 05 00    STA game_mode
   61  00:C0F1  8D 06 00    STA game_mode_switching
   62  00:C0F4  A9 00       LDA #$00
   63  00:C0F6  8D 01 20    STA $2001    ; disable rendering- reenable on NMI when not updating
   64  00:C0F9  20 02 C1    JSR LoadGameModeBackground
   65  00:C0FC  A9 00       LDA #$00
   66  00:C0FE  8D 06 00    STA game_mode_switching
   67  00:C101  60          RTS
   68                             
   69                             
   70  00:C102            LoadGameModeBackground:
   71                     
   72                             MACROLoadAllPal game_mode
                          
       00:C102  AC 05 00          LDY game_mode
       00:C105  98                TYA
       00:C106  0A                ASL A
       00:C107  A8                TAY
       00:C108  B9 10 E0          LDA (Palettes), y
       00:C10B  C8                INY
       00:C10C  BE 10 E0          LDX (Palettes), y
       00:C10F  20 E7 C0          JSR SetTableAddress
       00:C112  20 A9 C0          JSR loadAllPal_impl
                                  
   73                             MACROLoadFullBackground game_mode
                          
       00:C115  AC 05 00          LDY game_mode
       00:C118  98                TYA
       00:C119  0A                ASL A
       00:C11A  A8                TAY
       00:C11B  B9 16 E0          LDA (NameTables), y
       00:C11E  C8                INY
       00:C11F  BE 16 E0          LDX (NameTables), y
       00:C122  20 E7 C0          JSR SetTableAddress
       00:C125  20 C3 C0          JSR loadFullBackground_impl
                            
   74  00:C128  60                RTS
   75                             
   76                       
#[1]   MMC1.asm
#[2]   Routines/MapperUtils.asm
  121                       .include "Routines/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  00:C129            ResetMapper:
    7  00:C129  EE 29 C1    inc ResetMapper
    8  00:C12C  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  00:C12D            SetMapperControls:
   23                       ;;A = controls
   24  00:C12D  AA          TAX
   25  00:C12E  A9 80       LDA #MAPPERCONTROL
   26  00:C130  8D 0C 00    STA mapper_address+1
   27  00:C133  8A          TXA
   28  00:C134  20 59 C1    JSR SendMapperCommand
   29  00:C137  60          RTS
   30                     
   31  00:C138            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  00:C138  AA                TAX
   35  00:C139  A9 E0             LDA #PRGBANK
   36  00:C13B  8D 0C 00          STA mapper_address+1
   37  00:C13E  8A                TXA
   38  00:C13F  20 59 C1          JSR SendMapperCommand
   39  00:C142  60                RTS
   40                             
   41  00:C143            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  00:C143  AA                TAX
   44  00:C144  A9 A0             LDA #CHRBANK1
   45  00:C146  8D 0C 00          STA mapper_address+1
   46  00:C149  8A                TXA
   47  00:C14A  20 59 C1          JSR SendMapperCommand
   48  00:C14D  60                RTS
   49                             
   50  00:C14E            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  00:C14E  AA                TAX
   53  00:C14F  A9 C0             LDA #CHRBANK2
   54  00:C151  8D 0C 00          STA mapper_address+1
   55  00:C154  8A                TXA
   56  00:C155  20 59 C1          JSR SendMapperCommand
   57  00:C158  60                RTS
   58                             
   59  00:C159            SendMapperCommand:
   60                     
   61  00:C159  A0 00             LDY #$00
   62                             
   63  00:C15B  91 0B             STA [mapper_address], y
   64  00:C15D  4A                LSR A
   65  00:C15E  91 0B             STA [mapper_address], y
   66  00:C160  4A                LSR A
   67  00:C161  91 0B             STA [mapper_address], y
   68  00:C163  4A                LSR A 
   69  00:C164  91 0B             STA [mapper_address], y
   70  00:C166  4A                LSR A
   71  00:C167  91 0B             STA [mapper_address], y
   72                             
   73  00:C169  60                RTS
   74                             
   75                       
#[1]   MMC1.asm
  122                       
  123                       
  124                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  125                     ;;     NMI                  ;;
  126                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  127                     
#[2]   Routines/NMI.asm
  128                       .include "Routines/NMI.asm"
    1                      
    2  00:C16A            NMI:
    3                     
    4  00:C16A  48          PHA                              ;protect the registers
    5  00:C16B  8A          TXA
    6  00:C16C  48          PHA
    7  00:C16D  98          TYA
    8  00:C16E  48          PHA
    9                       
   10  00:C16F            nmi_started:
   11  00:C16F  A9 00       LDA #$00
   12  00:C171  8D 03 20    STA $2003       ; set the low byte (00) of the RAM address
   13  00:C174  A9 02       LDA #$02
   14  00:C176  8D 14 40    STA $4014       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  00:C179  AD 06 00    LDA game_mode_switching
   17  00:C17C  F0 03       BEQ update_controllers
   18  00:C17E  4C C8 C1    JMP WakeUp
   19                     
   20  00:C181            update_controllers:
   21                     
#[3]   Routines/ReadControllers.asm
   22                       .include "Routines/ReadControllers.asm"
    1                     
    2  00:C181  8A            TXA
    3  00:C182  48                PHA
    4  00:C183  98                TYA
    5  00:C184  48                PHA
    6                     
    7  00:C185  A2 00             LDX #$00
    8                     
    9  00:C187            GamePadCheck:
   10  00:C187  A9 01             LDA #$01        ;load 1
   11  00:C189  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  00:C18C  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  00:C18D  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  00:C190  A9 80             LDA #$80
   18  00:C192  8D 0D 00          STA gamepad
   19                     
   20  00:C195            ReadControllerABytesLoop:
   21  00:C195  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  00:C198  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  00:C19A  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  00:C19C  6E 0D 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  00:C19F  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  00:C1A1  AD 0E 00          LDA gamepadLast
   31  00:C1A4  49 FF             EOR #$FF
   32  00:C1A6  2D 0D 00          AND gamepad
   33  00:C1A9  8D 0F 00          STA gamepadPressed
   34                             
   35                             
   36  00:C1AC  AD 0D 00          LDA gamepad
   37  00:C1AF  8D 0E 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  00:C1B2  68                PLA
   41  00:C1B3  A8                TAY
   42  00:C1B4  68                PLA
   43  00:C1B5  AA                TAX     
#[2]   Routines/NMI.asm
   23                       
   24                         ;;This is the PPU clean up section, so rendering the next frame starts properly.
   25  00:C1B6  A9 90       LDA #%10010000   ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   26  00:C1B8  8D 00 20    STA $2000
   27  00:C1BB  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
   28  00:C1BD  8D 01 20    STA $2001
   29  00:C1C0  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   30  00:C1C2  8D 05 20    STA $2005
   31  00:C1C5  8D 05 20    STA $2005
   32                       
   33  00:C1C8            WakeUp:
   34  00:C1C8  A9 00       LDA #$00
   35  00:C1CA  8D 04 00    STA sleeping
   36                       
   37  00:C1CD  68          PLA                              ;restore the registers
   38  00:C1CE  A8          TAY 
   39  00:C1CF  68          PLA
   40  00:C1D0  AA          TAX
   41  00:C1D1  68          PLA
   42                     
   43  00:C1D2  40          RTI             ; return from interrupt
#[1]   MMC1.asm
  129                       
  130                     ;;**************************;;
  131                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  132                     ;;       PRG ROM DATA       ;;
  133                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  134                     ;;**************************;; 
  135                       
  136                       
  137           0001        .bank 1
  138           E000        .org $E000
  139                     
#[2]   NameTables/Tables.asm
  140                       .include "NameTables/Tables.asm"
    1  01:E000            sprites:
    2                          ;vert tile attr horiz
    3  01:E000  80 32 00    .db $80, $32, $00, $80   ;sprite 0
       01:E003  80        
    4  01:E004  80 33 00    .db $80, $33, $00, $88   ;sprite 1
       01:E007  88        
    5  01:E008  88 34 00    .db $88, $34, $00, $80   ;sprite 2
       01:E00B  80        
    6  01:E00C  88 35 00    .db $88, $35, $00, $88   ;sprite 3
       01:E00F  88        
    7                     
    8                     
    9           0000      TITLE_IDX = $00
   10           0001      GAME_IDX = $01
   11           0002      GAMEOVER_IDX = $02
   12                     
   13                     
   14  01:E010            Palettes:
   15                     
   16  01:E010  1C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       01:E012  2C E0     
       01:E014  3C E0     
   17                     
   18  01:E016            NameTables:
   19                     
   20  01:E016  4C E0       .word Title_Screen, Game_Screen, GameOver_Screen
       01:E018  4C E4     
       01:E01A  4C E8     
   21                     
   22  01:E01C            Title_Palette:
   23                     
   24  01:E01C              .incbin "NameTables/Title_PAL.pal"
   25                       
   26  01:E02C            Game_Palette:
   27                     
   28  01:E02C              .incbin "NameTables/Game_PAL.pal"
   29                       
   30  01:E03C            GameOver_Palette:
   31                     
   32  01:E03C              .incbin "NameTables/GameOver_PAL.pal"
   33                       
   34  01:E04C            Title_Screen:
   35                     
   36  01:E04C              .incbin "NameTables/Title_NT.nam"
   37                       
   38  01:E44C            Game_Screen: 
   39                     
   40  01:E44C              .incbin "NameTables/Game_NT.nam"
   41                       
   42  01:E84C            GameOver_Screen:
   43                     
   44  01:E84C              .incbin "NameTables/Game_NT.nam"
   45                       
   46                     
   47                       
   48                      
   49                             
#[1]   MMC1.asm
  141                     
  142           FFFA        .org $FFFA     ;first of the three vectors starts here
  143  01:FFFA  6A C1       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  144                                        ;processor will jump to the label NMI:
  145  01:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  146                                        ;to the label RESET:
  147  01:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  148                       
  149                     ;;**************************;;
  150                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  151                     ;;      CHR ROM DATA        ;;
  152                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  153                     ;;**************************;; 
  154                       
  155           0002        .bank 2
  156           0000        .org $0000
  157  02:0000              .incbin "CHRROM/Bank1.chr"   ;includes 8KB graphics file from SMB1
  158                       
  159           0003        .bank 3
  160           0000        .org $0000
  161  03:0000              .incbin "CHRROM/Bank2.chr"
  162                       
  163           0004        .bank 4
  164           0000        .org $0000
  165  04:0000              .incbin "CHRROM/Bank3.chr"
  166                       
