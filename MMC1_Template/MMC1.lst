#[1]   MMC1.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      tempx                   .rs 1
    6           0005      tempy                   .rs 1
    7           0006      time                    .rs 1
    8           0007      sleeping                .rs 1
    9           0008      game_mode               .rs 1
   10           0009      mode_state              .rs 1
   11           000A      NMI_locks               .rs 1
   12           000B      game_locks              .rs 1
   13           000C      pointer_address .rs 2
   14           000E      table_address   .rs 2
   15           0010      jump_address    .rs 2
   16                     
   17                     ;game modes
   18           0000      TITLE_IDX = $00
   19           0001      GAME_IDX = $01
   20           0002      GAMEOVER_IDX = $02
   21                     
   22                     ;locks for input and rendering
   23           0001      BGLOAD_NMI_LOCK = %00000001
   24           0001      EFFECT_GAME_LOCK = %00000001
   25                     
   26                     
   27                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           0012      gamepad                 .rs 1
   11           0013      gamepadLast     .rs 1
   12           0014      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           0015      PPU_PendingWrite        .rs 1
    2           0016      PPU_StringIdx           .rs 1
    3           0017      PPU_String                      .rs 32
    4                     
    5           0020      PPU_STRINGMAX = $20 ;up to size of a full nametable, I think
    6                     
    7           0000      SPRITE_YPOS = $00
    8           0003      SPRITE_XPOS = $03
    9           0200      SPRITE_DATA = $0200
   10                     
   11           2000      PPU_CTRL = $2000
   12           2001      PPU_MASK = $2001
   13           2002      PPU_STATUS = $2002
   14           2003      OAM_LO = $2003
   15           2004      OAM_DATA = $2004
   16           2005      PPU_SCROLL = $2005
   17           2006      PPU_ADDR = $2006
   18           2007      PPU_DATA = $2007
   19           4014      OAM_HI = $4014
   20                     
   21           0080      DRAW_VERTICAL = $80
   22           0000      DRAW_HORIZONTAL = $00
   23                     
   24           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           0037      mapper_address  .rs 2
    2           0039      currentCHRBankA .rs 1
    3           003A      currentCHRBankB .rs 1
    4           003B      currentPRGBank  .rs 1
    5           003C      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
    8                     ;; 0100 is the stack
    9                     ;; 0200 is sprite ram
   10           0300        .rsset $0300
   11           0400        .rsset $0400
   12           0500        .rsset $0500
   13           0600        .rsset $0600
   14           0700        .rsset $0700
   15           6000        .rsset $6000
#[3]   Defines/SaveVariables.asm
   16                       .include "Defines/SaveVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/ScreenStateVariables.asm
   17                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   18                     
#[1]   MMC1.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                       
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA #HIGH(\1)
   30                       JSR WriteToPPUString
   31                       LDA #LOW(\1)
   32                       JSR WriteToPPUString
   33                       LDA #\2
   34                       JSR WriteToPPUString
   35                       LDA \3
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                       
   40                     MACROAddPPUStringEntryTable .macro
   41                      
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA #HIGH(\1)
   45                       JSR WriteToPPUString
   46                       LDA #LOW(\1)
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA #\2
   50                       JSR WriteToPPUString
   51                       LDA #LOW(\3)
   52                       JSR WriteToPPUString
   53                       LDA #HIGH(\3)
   54                       JSR WriteToPPUString
   55                      
   56                       .endm
   57                     
   58                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   MMC1.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1           0000        .bank 0
    2           8000        .org $8000
    3                       
    4  00:8000            TestBankA:
    5  00:8000  A9 01             LDA #$01
    6  00:8002  8D 3C 00          STA mapperDebugVar
    7  00:8005  60                RTS
    8                     
    9           0001        .bank 1
   10           A000        .org $A000
   11  01:A000  AD 01 00    LDA $01
   12                       
   13           BFFA        .org $BFFA     ;first of the three vectors starts here
   14  01:BFFA  10 C3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   15                                        ;processor will jump to the label NMI:
   16  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   17                                        ;to the label RESET:
   18  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   MMC1.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
    4  02:8000            TestBankB:
    5  02:8000  A9 02             LDA #$02
    6  02:8002  8D 3C 00          STA mapperDebugVar
    7  02:8005  60                RTS
    8                     
    9           0003        .bank 3
   10           A000        .org $A000
   11  03:A000  AD 02 00    LDA $02
   12                     
   13           BFFA        .org $BFFA     ;first of the three vectors starts here
   14  03:BFFA  10 C3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   15                                        ;processor will jump to the label NMI:
   16  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   17                                        ;to the label RESET:
   18  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   MMC1.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
    4  04:8000            TestBankC:
    5  04:8000  A9 03             LDA #$03
    6  04:8002  8D 3C 00          STA mapperDebugVar
    7  04:8005  60                RTS
    8                     
    9           0005        .bank 5
   10           A000        .org $A000
   11  05:A000  AD 03 00    LDA $03
   12                     
   13           BFFA        .org $BFFA     ;first of the three vectors starts here
   14  05:BFFA  10 C3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   15                                        ;processor will jump to the label NMI:
   16  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   17                                        ;to the label RESET:
   18  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   MMC1.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 B9 C2    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 BD C2    JSR SetMapperControls
   34                       
   35  06:C040  20 FA C2    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   MMC1.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  20 E2 C0    JSR ChangeGameMode
   38                       
   39                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   40                       ; enable sprites, enable background, no clipping on left side
   41                       MACROSetPPUControl %10010000, %00011110
                          
       06:C04D  A9 90       LDA #%10010000  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
       06:C04F  8D 00 20    STA PPU_CTRL
       06:C052  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
       06:C054  8D 01 20    STA PPU_MASK
                                  
   42                     
   43                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   44                     ;;     Main Program         ;;
   45                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   46                     
   47  06:C057            Forever:
   48                     
   49  06:C057  EE 07 00    INC sleeping
   50                     
   51  06:C05A            .loop
   52  06:C05A  AD 07 00    LDA sleeping
   53  06:C05D  D0 FB       BNE .loop
   54                       
   55  06:C05F  20 68 C0    JSR GameLoop
   56  06:C062  EE 06 00    INC time
   57                     
   58  06:C065  4C 57 C0    JMP Forever     ;jump back to Forever, infinite loop
   59                       
   60                     ;; dynamic jump table
   61                     
   62  06:C068            GameLoop:
   63                     
   64                       MACROCallDynamicJump game_mode
                          
       06:C068  AD 08 00    LDA game_mode
       06:C06B  20 64 C1    JSR Dynamic_Jump
                                  
   65                       ;; we'll pop the return address here as the table index, so 
   66                       ;; the routine we pick will return us to whatever called Game Loop
   67                       ;; when it returns
   68                     
   69  06:C06E            GameLoopJumpTable:
   70                     
   71  06:C06E  74 C0       .word UpdateTitle
   72  06:C070  84 C0       .word UpdateGame
   73  06:C072  D2 C0       .word UpdateGameOver
   74                       
   75                     
   76                       ;;RTS is called in the subroutine
   77                     
   78                       
#[2]   Routines/Game_States/UpdateTitle.asm
   79                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C074            UpdateTitle:
    2                     
    3  06:C074  AD 0A 00    LDA NMI_locks
    4  06:C077  D0 0A       BNE .noInputDetected
    5                     
    6  06:C079  AD 14 00    LDA gamepadPressed
    7  06:C07C  F0 05       BEQ .noInputDetected
    8                       
    9  06:C07E  A9 01         LDA #GAME_IDX
   10  06:C080  20 E2 C0          JSR ChangeGameMode
   11                      
   12  06:C083            .noInputDetected:
   13                      
   14  06:C083  60          RTS
#[1]   MMC1.asm
#[2]   Routines/Game_States/UpdateGame.asm
   80                       .include "Routines/Game_States/UpdateGame.asm"
    1  06:C084            UpdateGame:
    2                     
    3  06:C084  AD 0A 00    LDA NMI_locks
    4  06:C087  F0 01       BEQ .unlocked
    5                       
    6  06:C089  60          RTS
    7                       
    8  06:C08A            .unlocked:
    9                     
   10  06:C08A  20 8E C0    JSR DoUpdateGame
   11  06:C08D  60          RTS
   12                       
   13  06:C08E            DoUpdateGame:
   14                     
   15  06:C08E  AD 09 00    LDA mode_state
   16  06:C091  20 64 C1    JSR Dynamic_Jump
   17                       
   18  06:C094            UpdateGameJumpTable:
   19                     
   20  06:C094  9A C0       .word UpdateGameIntro
   21  06:C096  9E C0       .word UpdateGamePlay
   22  06:C098  CC C0       .word UpdateGameExit
   23                     
   24  06:C09A            UpdateGameIntro:
   25                       
   26  06:C09A  EE 09 00    INC mode_state
   27  06:C09D  60          RTS
   28                       
   29  06:C09E            UpdateGamePlay:
   30                     
   31                       MACROAddPPUStringEntryRawData $2065, DRAW_HORIZONTAL, #$01
                          
       06:C09E  A9 01       LDA #$01
       06:C0A0  8D 15 00    STA PPU_PendingWrite
       06:C0A3  A9 20       LDA #HIGH($2065)
       06:C0A5  20 73 C2    JSR WriteToPPUString
       06:C0A8  A9 65       LDA #LOW($2065)
       06:C0AA  20 73 C2    JSR WriteToPPUString
       06:C0AD  A9 00       LDA #DRAW_HORIZONTAL
       06:C0AF  20 73 C2    JSR WriteToPPUString
       06:C0B2  A9 01       LDA #$01
       06:C0B4  20 73 C2    JSR WriteToPPUString
                            
   32  06:C0B7  AD 06 00    LDA time
   33  06:C0BA  20 73 C2    JSR WriteToPPUString
   34                       
   35  06:C0BD  AD 14 00    LDA gamepadPressed
   36  06:C0C0  F0 09       BEQ .leave
   37  06:C0C2  29 08       AND #GAMEPAD_START
   38  06:C0C4  D0 02       BNE .changeModeState
   39  06:C0C6  F0 03       BEQ .leave
   40                       
   41                     
   42  06:C0C8            .changeModeState:
   43                     
   44  06:C0C8  EE 09 00      INC mode_state
   45                     
   46  06:C0CB            .leave:
   47                      
   48  06:C0CB  60          RTS
   49                       
   50  06:C0CC            UpdateGameExit:
   51                     
   52  06:C0CC  A9 02       LDA #GAMEOVER_IDX
   53  06:C0CE  20 E2 C0    JSR ChangeGameMode
   54  06:C0D1  60          RTS
   55                             
   56                       
   57                       
   58                       
   59                     ;;      JSR ResetMapper
   60                     ;;      INC currentCHRBank
   61                     ;;      LDA currentCHRBank
   62                     ;;      CMP #$03
   63                     ;;      BNE .dontModCHR
   64                             
   65                     ;;      LDA #$00
   66                     
   67                     ;;.dontModCHR:
   68                     ;;      STA currentCHRBank 
   69                     ;;      ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
   70                     ;;      ASL A
   71                     ;;      CLC 
   72                     ;;      ADC #$01
   73                     ;;      JSR LoadCHRBankB
   74                     ;;      
   75                     ;;      JSR ResetMapper
   76                     ;;      INC currentPRGBank
   77                     ;;      LDA currentPRGBank
   78                     ;;      CMP #$03
   79                     ;;      BNE .dontModPRG
   80                             
   81                     ;;      LDA #$00
   82                             
   83                     ;;.dontModPRG:
   84                     ;;       STA currentPRGBank
   85                     ;;       JSR LoadPRGBank
   86                      
   87                     ;;       JSR TestBankA
   88                     ;;       LDA mapperDebugVar
   89                     ;;       STA $6000
   90                     ;;       JMP .noInputDetected
   91                              
   92                       
#[1]   MMC1.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   81                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C0D2            UpdateGameOver:
    2                     
    3  06:C0D2  AD 0A 00    LDA NMI_locks
    4  06:C0D5  D0 0A       BNE .noInputDetected
    5                     
    6  06:C0D7  AD 14 00    LDA gamepadPressed
    7  06:C0DA  F0 05       BEQ .noInputDetected
    8                       
    9  06:C0DC  A9 00         LDA #TITLE_IDX
   10  06:C0DE  20 E2 C0          JSR ChangeGameMode
   11                      
   12  06:C0E1            .noInputDetected:
   13                      
   14  06:C0E1  60          RTS
#[1]   MMC1.asm
   82                       
   83                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   84                     ;;     Routines             ;;
   85                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   86                     
   87                     
#[2]   Routines/Common/GameModeRoutines.asm
   88                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C0E2            ChangeGameMode:
    2  06:C0E2  8D 08 00    STA game_mode
    3  06:C0E5  A9 00       LDA #$00
    4  06:C0E7  8D 09 00    STA mode_state
    5  06:C0EA  20 81 C2    JSR ClearPPUString
    6  06:C0ED  20 F1 C0    JSR LoadGameModeScreen
    7  06:C0F0  60          RTS
    8                       
    9  06:C0F1            LoadGameModeScreen:
   10                     
   11                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C0F1  AD 0A 00    LDA NMI_locks
       06:C0F4  09 01       ORA #BGLOAD_NMI_LOCK
       06:C0F6  8D 0A 00    STA NMI_locks
                                  
   12                       
   13  06:C0F9  A9 00       LDA #$00
   14  06:C0FB  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   15                     
   16  06:C0FE  20 1F C1    JSR LoadGameModeBackground
   17  06:C101  20 4B C1    JSR LoadGameModeSprites
   18                     
   19                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C104  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C106  49 FF       EOR #$FF
       06:C108  2D 0A 00    AND NMI_locks  
       06:C10B  8D 0A 00    STA NMI_locks
                          
   20                     
   21                       
   22                       ;; load the CHR bank for this mode
   23  06:C10E  20 B9 C2    JSR ResetMapper
   24                       ;;remember, we're loading the SECOND set in each chr bank
   25                       ;;so we'll take the index from the game mode chr table and add one mult 2
   26  06:C111  AE 08 00    LDX game_mode
   27  06:C114  BD 61 C1    LDA gameModeInitCHRROM, x
   28  06:C117  0A          ASL A
   29  06:C118  18          CLC 
   30  06:C119  69 01       ADC #$01
   31  06:C11B  20 DE C2    JSR LoadCHRBankB
   32                       
   33  06:C11E  60          RTS
   34                       
   35  06:C11F            LoadGameModeBackground:
   36                             
   37                       MACROGetDoubleIndex game_mode
                          
       06:C11F  AD 08 00          LDA game_mode
       06:C122  0A                ASL A
       06:C123  A8                TAY
                                  
   38  06:C124  8C 00 00    STY temp1
   39                             
   40                       MACROGetLabelPointer Palettes, table_address
                          
       06:C127  A9 E0             LDA #HIGH(Palettes)
       06:C129  A2 00             LDX #LOW(Palettes)
                                  
       06:C12B  8E 0E 00          STX table_address
       06:C12E  8D 0F 00          STA table_address+1
                                  
   41  06:C131  20 8A C1    JSR GetTableAtIndex
   42                     
   43  06:C134  20 97 C1    JSR LoadFullPaletteFromTable
   44                             
   45  06:C137  AC 00 00    LDY temp1
   46                       MACROGetLabelPointer NameTables, table_address
                          
       06:C13A  A9 E0             LDA #HIGH(NameTables)
       06:C13C  A2 06             LDX #LOW(NameTables)
                                  
       06:C13E  8E 0E 00          STX table_address
       06:C141  8D 0F 00          STA table_address+1
                                  
   47  06:C144  20 8A C1    JSR GetTableAtIndex
   48                             
   49  06:C147  20 B7 C1    JSR LoadFullBackgroundFromTable
   50                       
   51  06:C14A  60          RTS
   52                       
   53  06:C14B            LoadGameModeSprites:
   54                     
   55                       MACROGetDoubleIndex game_mode  
                          
       06:C14B  AD 08 00          LDA game_mode
       06:C14E  0A                ASL A
       06:C14F  A8                TAY
                                  
   56                       MACROGetLabelPointer Sprites, table_address
                          
       06:C150  A9 EC             LDA #HIGH(Sprites)
       06:C152  A2 6C             LDX #LOW(Sprites)
                                  
       06:C154  8E 0E 00          STX table_address
       06:C157  8D 0F 00          STA table_address+1
                                  
   57  06:C15A  20 8A C1    JSR GetTableAtIndex
   58  06:C15D  20 66 C2    JSR LoadSprites_impl
   59                       
   60  06:C160  60          RTS
   61                       
   62  06:C161            gameModeInitCHRROM:
   63  06:C161  00 02 02          .db $00, $02, $02
#[1]   MMC1.asm
#[2]   Routines/Utils/PointerUtils.asm
   89                       .include "Routines/Utils/PointerUtils.asm"
    1  06:C164            Dynamic_Jump:
    2                     
    3  06:C164  0A          ASL A                                 ;; double the index passed into A
    4  06:C165  8E 04 00    STX tempx
    5  06:C168  8C 05 00    STY tempy
    6  06:C16B  A8          TAY
    7  06:C16C  C8          INY  
    8  06:C16D  68          PLA
    9  06:C16E  8D 10 00    STA jump_address
   10  06:C171  68          PLA 
   11  06:C172  8D 11 00    STA jump_address+1            
   12  06:C175  B1 10       LDA [jump_address], y
   13  06:C177  AA          TAX
   14  06:C178  C8          INY
   15  06:C179  B1 10       LDA [jump_address], y
   16  06:C17B  8E 10 00    STX jump_address
   17  06:C17E  8D 11 00    STA jump_address+1
   18  06:C181  AE 04 00    LDX tempx
   19  06:C184  AC 05 00    LDY tempy
   20  06:C187  6C 10 00    JMP [jump_address]
   21                       
   22  06:C18A            GetTableAtIndex:
   23                     
   24  06:C18A  B1 0E             LDA [table_address], y
   25  06:C18C  AA                TAX
   26  06:C18D  C8                INY
   27  06:C18E  B1 0E             LDA [table_address], y
   28                             
   29  06:C190            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:C190  8E 0E 00          STX table_address
   33  06:C193  8D 0F 00          STA table_address+1
   34  06:C196  60                RTS
#[1]   MMC1.asm
#[2]   Routines/Utils/PPUUtils.asm
   90                       .include "Routines/Utils/PPUUtils.asm"
    1  06:C197            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:C197  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C19A  A9 3F       LDA #HIGH($3F00)
       06:C19C  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C19F  A9 00       LDA #LOW($3F00)
       06:C1A1  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:C1A4  A0 00       LDY #$00              ; start out at 0
    5  06:C1A6  A2 00       LDX #$00
    6  06:C1A8            .loop:
    7  06:C1A8  B1 0E       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:C1AA  8D 07 20    STA PPU_DATA            ; write to PPU
    9  06:C1AD  9D 00 60    STA Palette_Copy, x
   10  06:C1B0  C8          INY                   ; X = X + 1
   11  06:C1B1  E8          INX
   12  06:C1B2  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   13  06:C1B4  D0 F2       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   14  06:C1B6  60          RTS
   15                     
   16  06:C1B7            LoadFullBackgroundFromTable:
   17                     
   18                             MACROSetPPUAddress $2000
                          
       06:C1B7  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C1BA  A9 20       LDA #HIGH($2000)
       06:C1BC  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C1BF  A9 00       LDA #LOW($2000)
       06:C1C1  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
   19                             
   20                             ;;set pointer
   21                             ;; set counters
   22  06:C1C4  A0 00             LDY #$00
   23  06:C1C6  A2 00             LDX #$00
   24                             
   25                             ;;start loop
   26                     
   27  06:C1C8            .outerloop:
   28                     
   29  06:C1C8            .innerloop:
   30                     
   31  06:C1C8  B1 0E             LDA [table_address], y
   32  06:C1CA  8D 07 20          STA PPU_DATA
   33  06:C1CD  C8                INY
   34  06:C1CE  C0 00             CPY #$00
   35  06:C1D0  D0 F6             BNE .innerloop
   36                     
   37  06:C1D2  EE 0F 00          INC table_address+1
   38                             
   39  06:C1D5  E8                INX
   40  06:C1D6  E0 04             CPX #$04
   41  06:C1D8  D0 EE             BNE .outerloop
   42  06:C1DA  60                RTS
   43                             
   44                     
   45           0000      DATA_LEN = temp1
   46           0001      WRITE_SETTINGS = temp2
   47                             
   48  06:C1DB            ProcessPPUString:
   49                     
   50  06:C1DB  AD 15 00          LDA PPU_PendingWrite
   51  06:C1DE  F0 6F             BEQ .leave
   52  06:C1E0  A0 00             LDY #$00
   53                             
   54  06:C1E2  A9 17             LDA #LOW(PPU_String)
   55  06:C1E4  8D 0C 00          STA pointer_address
   56  06:C1E7  A9 00             LDA #HIGH(PPU_String)
   57  06:C1E9  8D 0D 00          STA pointer_address + 1
   58                     
   59  06:C1EC            .outerloop:
   60  06:C1EC  AD 02 20          LDA PPU_STATUS
   61  06:C1EF  B1 0C             LDA [pointer_address], y
   62  06:C1F1  F0 59             BEQ .finish
   63  06:C1F3  8D 06 20          STA PPU_ADDR
   64  06:C1F6  C8                INY
   65  06:C1F7  B1 0C             LDA [pointer_address], y
   66  06:C1F9  8D 06 20          STA PPU_ADDR
   67  06:C1FC  C8            INY 
   68  06:C1FD  B1 0C             LDA [pointer_address], y
   69  06:C1FF  8D 01 00          STA WRITE_SETTINGS
   70  06:C202  C8                INY
   71                             
   72  06:C203  AD 00 20          LDA PPU_CTRL
   73  06:C206  29 FB             AND #$FB
   74  06:C208  8D 00 20          STA PPU_CTRL
   75                             
   76  06:C20B  AD 01 00          LDA WRITE_SETTINGS
   77  06:C20E  29 80             AND #%10000000
   78  06:C210  F0 06             BEQ .checkTable
   79  06:C212  0D 00 20          ORA PPU_CTRL 
   80  06:C215  8D 00 20          STA PPU_CTRL 
   81                             
   82  06:C218            .checkTable:
   83  06:C218  AD 01 00          LDA WRITE_SETTINGS
   84  06:C21B  29 40             AND #%01000000
   85  06:C21D  F0 16             BEQ .rawData
   86                             
   87  06:C21F  B1 0C             LDA [pointer_address], y
   88  06:C221  8D 0E 00          STA table_address
   89  06:C224  C8                INY 
   90  06:C225  B1 0C             LDA [pointer_address], y
   91  06:C227  8D 0F 00          STA table_address + 1
   92  06:C22A  C8                INY
   93  06:C22B  98                TYA 
   94  06:C22C  48                PHA
   95  06:C22D  20 50 C2          JSR WriteToPPUFromTable
   96  06:C230  68                PLA
   97  06:C231  A8                TAY
   98  06:C232  4C EC C1          JMP .outerloop
   99                     
  100  06:C235            .rawData:
  101                     
  102  06:C235  B1 0C             LDA [pointer_address], y
  103  06:C237  C8                INY
  104  06:C238  8D 00 00          STA DATA_LEN
  105                     
  106  06:C23B  A2 00             LDX #$00
  107                     
  108  06:C23D            .innerloop:
  109                             
  110  06:C23D  B1 0C             LDA [pointer_address], y
  111  06:C23F  8D 07 20          STA PPU_DATA
  112  06:C242  C8                INY
  113  06:C243  E8                INX
  114  06:C244  EC 00 00          CPX DATA_LEN
  115  06:C247  D0 F4             BNE .innerloop
  116  06:C249  4C EC C1          JMP .outerloop
  117                             
  118  06:C24C            .finish:
  119  06:C24C  20 81 C2          JSR ClearPPUString
  120  06:C24F            .leave:
  121  06:C24F  60                RTS
  122                             
  123  06:C250            WriteToPPUFromTable:
  124  06:C250  A0 00             LDY #$00
  125  06:C252  B1 0E             LDA [table_address], y
  126  06:C254  C8                INY
  127  06:C255  8D 00 00          STA DATA_LEN
  128  06:C258            .innerloop:
  129  06:C258  B1 0E             LDA [table_address], y
  130  06:C25A  8D 07 20          STA PPU_DATA
  131  06:C25D  C8                INY
  132  06:C25E  CC 00 00          CPY DATA_LEN
  133  06:C261  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  134  06:C263  F0 F3             BEQ .innerloop
  135  06:C265  60                RTS
  136                       
  137  06:C266            LoadSprites_impl:
  138  06:C266  A0 00       LDY #$00              ; start at 0
  139                       
  140  06:C268            .loop:
  141  06:C268  B1 0E       LDA [table_address], y; load data from address (sprites +  x)
  142  06:C26A  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  143  06:C26D  C8          INY                   ; X = X + 1
  144  06:C26E  C0 05       CPY #$05              ; Compare X to hex $10, decimal 16
  145  06:C270  D0 F6       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  146                                             ; if compare was equal to 16, keep going down   
  147  06:C272  60          RTS
  148                     
  149                     
  150  06:C273            WriteToPPUString:
  151                     
  152  06:C273  AE 16 00          LDX PPU_StringIdx
  153  06:C276  E0 20             CPX #PPU_STRINGMAX
  154  06:C278  F0 06             BEQ .finish
  155                             
  156  06:C27A  9D 17 00          STA PPU_String, x
  157  06:C27D  EE 16 00          INC PPU_StringIdx
  158                                     
  159  06:C280            .finish:
  160  06:C280  60                RTS
  161                     
  162  06:C281            ClearPPUString:
  163                             
  164  06:C281  A9 00             LDA #$00
  165  06:C283  8D 16 00          STA PPU_StringIdx
  166  06:C286  8D 17 00          STA PPU_String
  167  06:C289  8D 15 00          STA PPU_PendingWrite
  168  06:C28C  60                RTS
  169                     
  170                     
  171                             
  172                     
  173  06:C28D            DetectSprite0:
  174  06:C28D            WaitNotSprite0:
  175  06:C28D  AD 02 20    lda PPU_STATUS
  176  06:C290  29 40       and #SPRITE_0_MASK
  177  06:C292  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  178                     
  179  06:C294            WaitSprite0:
  180  06:C294  AD 02 20    lda $2002
  181  06:C297  29 40       and #SPRITE_0_MASK
  182  06:C299  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  183                     
  184  06:C29B  A2 05       ldx #$05                              ;do a scanline wait
  185  06:C29D            WaitScanline:
  186  06:C29D  CA          dex
  187  06:C29E  D0 FD       bne WaitScanline
  188  06:C2A0  60          RTS
  189                     
  190  06:C2A1            NameTableMemList:
  191  06:C2A1  00 20       .word $2000, $2400, $2800, $2C00
       06:C2A3  00 24     
       06:C2A5  00 28     
       06:C2A7  00 2C     
  192  06:C2A9            PalettesMemList:
  193  06:C2A9  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:C2AB  04 3F     
       06:C2AD  08 3F     
       06:C2AF  0C 3F     
  194  06:C2B1  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:C2B3  14 3F     
       06:C2B5  18 3F     
       06:C2B7  1C 3F     
#[1]   MMC1.asm
#[2]   Routines/Utils/MapperUtils.asm
   91                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:C2B9            ResetMapper:
    7  06:C2B9  EE B9 C2    inc ResetMapper
    8  06:C2BC  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:C2BD            SetMapperControls:
   23                       ;;A = controls
   24  06:C2BD  AA          TAX
   25  06:C2BE  A9 80       LDA #MAPPERCONTROL
   26  06:C2C0  8D 38 00    STA mapper_address+1
   27  06:C2C3  8A          TXA
   28  06:C2C4  20 E9 C2    JSR SendMapperCommand
   29  06:C2C7  60          RTS
   30                     
   31  06:C2C8            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:C2C8  AA                TAX
   35  06:C2C9  A9 E0             LDA #PRGBANK
   36  06:C2CB  8D 38 00          STA mapper_address+1
   37  06:C2CE  8A                TXA
   38  06:C2CF  20 E9 C2          JSR SendMapperCommand
   39  06:C2D2  60                RTS
   40                             
   41  06:C2D3            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:C2D3  AA                TAX
   44  06:C2D4  A9 A0             LDA #CHRBANK1
   45  06:C2D6  8D 38 00          STA mapper_address+1
   46  06:C2D9  8A                TXA
   47  06:C2DA  20 E9 C2          JSR SendMapperCommand
   48  06:C2DD  60                RTS
   49                             
   50  06:C2DE            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:C2DE  AA                TAX
   53  06:C2DF  A9 C0             LDA #CHRBANK2
   54  06:C2E1  8D 38 00          STA mapper_address+1
   55  06:C2E4  8A                TXA
   56  06:C2E5  20 E9 C2          JSR SendMapperCommand
   57  06:C2E8  60                RTS
   58                             
   59  06:C2E9            SendMapperCommand:
   60                     
   61  06:C2E9  A0 00             LDY #$00
   62                             
   63  06:C2EB  91 37             STA [mapper_address], y
   64  06:C2ED  4A                LSR A
   65  06:C2EE  91 37             STA [mapper_address], y
   66  06:C2F0  4A                LSR A
   67  06:C2F1  91 37             STA [mapper_address], y
   68  06:C2F3  4A                LSR A 
   69  06:C2F4  91 37             STA [mapper_address], y
   70  06:C2F6  4A                LSR A
   71  06:C2F7  91 37             STA [mapper_address], y
   72                             
   73  06:C2F9  60                RTS
   74                             
   75  06:C2FA            ResetBanks:
   76                     
   77  06:C2FA  20 B9 C2          JSR ResetMapper
   78  06:C2FD  A9 00             LDA #$00
   79  06:C2FF  20 C8 C2          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:C302  20 B9 C2          JSR ResetMapper
   83  06:C305  A9 00             LDA #$00
   84  06:C307  20 D3 C2          JSR LoadCHRBankA
   85  06:C30A  A9 01             LDA #$01
   86  06:C30C  20 DE C2          JSR LoadCHRBankB
   87  06:C30F  60                RTS
   88                             
   89                       
#[1]   MMC1.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   92                       .include "Routines/Game_Routines/ScreenEffects.asm"
#[1]   MMC1.asm
   93                       
   94                       
   95                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   96                     ;;     NMI                  ;;
   97                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   98                     
#[2]   Routines/Common/NMI.asm
   99                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:C310            NMI:
    3                     
    4  06:C310  48          PHA                              ;protect the registers
    5  06:C311  8A          TXA
    6  06:C312  48          PHA
    7  06:C313  98          TYA
    8  06:C314  48          PHA
    9                       
   10  06:C315            nmi_started:
   11  06:C315  A9 00       LDA #$00
   12  06:C317  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:C31A  A9 02       LDA #$02
   14  06:C31C  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:C31F  AD 0A 00    LDA NMI_locks
   17  06:C322  F0 03       BEQ update_controllers
   18  06:C324  4C 83 C3    JMP WakeUp
   19                     
   20  06:C327            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:C327  8A            TXA
    3  06:C328  48                PHA
    4  06:C329  98                TYA
    5  06:C32A  48                PHA
    6                     
    7  06:C32B  A2 00             LDX #$00
    8                     
    9  06:C32D            GamePadCheck:
   10  06:C32D  A9 01             LDA #$01        ;load 1
   11  06:C32F  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:C332  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:C333  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:C336  A9 80             LDA #$80
   18  06:C338  8D 12 00          STA gamepad
   19                     
   20  06:C33B            ReadControllerABytesLoop:
   21  06:C33B  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:C33E  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:C340  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:C342  6E 12 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:C345  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:C347  AD 13 00          LDA gamepadLast
   31  06:C34A  49 FF             EOR #$FF
   32  06:C34C  2D 12 00          AND gamepad
   33  06:C34F  8D 14 00          STA gamepadPressed
   34                             
   35                             
   36  06:C352  AD 12 00          LDA gamepad
   37  06:C355  8D 13 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:C358  68                PLA
   41  06:C359  A8                TAY
   42  06:C35A  68                PLA
   43  06:C35B  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:C35C  20 DB C1    JSR ProcessPPUString
   25                       
   26                       
   27  06:C35F  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:C361  8D 05 20    STA PPU_SCROLL
   29  06:C364  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33                       MACROSetPPUControl %10010000, %00011110 
                          
       06:C367  A9 90       LDA #%10010000  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
       06:C369  8D 00 20    STA PPU_CTRL
       06:C36C  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
       06:C36E  8D 01 20    STA PPU_MASK
                                  
   34                     
   35  06:C371            NMIUpdate:
   36                     
   37  06:C371  20 77 C3    JSR StateNMIUpdate
   38  06:C374  4C 83 C3    JMP WakeUp
   39                     
   40  06:C377            StateNMIUpdate:
   41                     
   42                       MACROCallDynamicJump game_mode
                          
       06:C377  AD 08 00    LDA game_mode
       06:C37A  20 64 C1    JSR Dynamic_Jump
                                  
   43                     
   44  06:C37D            NMIJumpTable:
   45                     
   46  06:C37D  8E C3       .word UpdateTitleNMI
   47  06:C37F  A2 C3       .word UpdateGameNMI
   48  06:C381  A3 C3       .word UpdateGameOverNMI
   49                     
   50  06:C383            WakeUp:
   51  06:C383  A9 00       LDA #$00
   52  06:C385  8D 07 00    STA sleeping
   53                       
   54  06:C388  68          PLA             ;restore the registers
   55  06:C389  A8          TAY 
   56  06:C38A  68          PLA
   57  06:C38B  AA          TAX
   58  06:C38C  68          PLA
   59                     
   60  06:C38D  40          RTI             ; return from interrupt
   61                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   62                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:C38E            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4  06:C38E  20 B9 C2    JSR ResetMapper
    5  06:C391  A9 01       LDA #$01
    6  06:C393  20 DE C2    JSR LoadCHRBankB
    7                                     
    8  06:C396  20 8D C2    JSR DetectSprite0
    9                     
   10  06:C399  20 B9 C2    JSR ResetMapper
   11  06:C39C  A9 03       LDA #$03
   12  06:C39E  20 DE C2    JSR LoadCHRBankB
   13                       
   14  06:C3A1  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   63                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:C3A2            UpdateGameNMI:
    2  06:C3A2  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   64                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:C3A3            UpdateGameOverNMI:
    2  06:C3A3  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   MMC1.asm
  100                       
  101                     ;;**************************;;
  102                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  103                     ;;       PRG ROM DATA       ;;
  104                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  105                     ;;**************************;; 
  106                       
  107           0007        .bank 7
  108           E000        .org $E000
  109                     
#[2]   NameTables/Tables.asm
  110                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  0C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  2C E0     
       07:E004  4C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  6C E0       .word Title_Screen, Game_Screen, GameOver_Screen
       07:E008  6C E4     
       07:E00A  6C E8     
    8                     
    9  07:E00C            Title_Palette:
   10                     
   11  07:E00C              .incbin "NameTables/Title_PAL.pal"
   12  07:E01C              .incbin "NameTables/Title_PAL.pal"
   13                       
   14  07:E02C            Game_Palette:
   15                     
   16  07:E02C              .incbin "NameTables/Game_PAL.pal"
   17  07:E03C              .incbin "NameTables/Game_PAL.pal"
   18                       
   19  07:E04C            GameOver_Palette:
   20                     
   21  07:E04C              .incbin "NameTables/GameOver_PAL.pal"
   22  07:E05C              .incbin "NameTables/GameOver_PAL.pal"
   23                       
   24  07:E06C            Title_Screen:
   25                     
   26  07:E06C              .incbin "NameTables/Title_NT.nam"
   27                       
   28  07:E46C            Game_Screen: 
   29                     
   30  07:E46C              .incbin "NameTables/Game_NT.nam"
   31                       
   32  07:E86C            GameOver_Screen:
   33                     
   34  07:E86C              .incbin "NameTables/Game_NT.nam"
   35                       
   36                     
   37                       
   38                      
   39                             
#[1]   MMC1.asm
#[2]   Sprites/Sprites.asm
  111                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:EC6C            Sprites:
   38  07:EC6C  72 EC             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:EC6E  76 EC     
       07:EC70  7A EC     
   39                     
   40  07:EC72            Title_Sprites:
   41  07:EC72  90 00 00          .db $90,$00,$00,$E8
       07:EC75  E8        
   42  07:EC76            Game_Sprites:
   43  07:EC76  00 00 00          .db $00,$00,$00,$00
       07:EC79  00        
   44  07:EC7A            GameOver_Sprites:
   45  07:EC7A  00 00 00          .db $00,$00,$00,$00
       07:EC7D  00        
#[1]   MMC1.asm
  112                     
  113           FFFA        .org $FFFA     ;first of the three vectors starts here
  114  07:FFFA  10 C3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  115                                        ;processor will jump to the label NMI:
  116  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  117                                        ;to the label RESET:
  118  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  119                       
  120                     ;;**************************;;
  121                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122                     ;;      CHR ROM DATA        ;;
  123                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  124                     ;;**************************;; 
  125                       
  126           0008        .bank 8
  127           0000        .org $0000
  128  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  129                       
  130           0009        .bank 9
  131           0000        .org $0000
  132  09:0000              .incbin "CHRROM/Bank1.chr"
  133                       
  134           000A        .bank 10
  135           0000        .org $0000
  136  0A:0000              .incbin "CHRROM/Bank2.chr"
  137                       
  138           000B        .bank 11
  139           0000        .org $0000
  140  0B:0000              .incbin "CHRROM/Bank3.chr"
