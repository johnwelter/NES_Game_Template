#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      tempx                   .rs 1
    6           0005      tempy                   .rs 1
    7           0006      time                    .rs 1
    8           0007      sleeping                .rs 1
    9           0008      game_mode               .rs 1
   10           0009      mode_state              .rs 1
   11           000A      NMI_locks               .rs 1
   12           000B      game_locks              .rs 1
   13           000C      pointer_address .rs 2
   14           000E      table_address   .rs 2
   15           0010      jump_address    .rs 2
   16                     
   17                     ;game modes
   18           0000      TITLE_IDX = $00
   19           0001      GAME_IDX = $01
   20           0002      GAMEOVER_IDX = $02
   21                     
   22                     ;locks for input and rendering
   23           0001      BGLOAD_NMI_LOCK = %00000001
   24           0001      EFFECT_GAME_LOCK = %00000001
   25                     
   26                     
   27                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEBAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0012      gamepad                 .rs 1
   17           0013      gamepadLast     .rs 1
   18           0014      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           0015      PPU_PendingWrite        .rs 1
    2           0016      PPU_StringIdx           .rs 1
    3           0017      PPU_String                      .rs 32
    4                     
    5           0020      PPU_STRINGMAX = $20 ;up to size of a full nametable, I think
    6                     
    7           0000      SPRITE_YPOS = $00
    8           0003      SPRITE_XPOS = $03
    9           0200      SPRITE_DATA = $0200
   10                     
   11           2000      PPU_CTRL = $2000
   12           2001      PPU_MASK = $2001
   13           2002      PPU_STATUS = $2002
   14           2003      OAM_LO = $2003
   15           2004      OAM_DATA = $2004
   16           2005      PPU_SCROLL = $2005
   17           2006      PPU_ADDR = $2006
   18           2007      PPU_DATA = $2007
   19           4014      OAM_HI = $4014
   20                     
   21           0080      DRAW_VERTICAL = $80
   22           0000      DRAW_HORIZONTAL = $00
   23                     
   24           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           0037      mapper_address  .rs 2
    2           0039      currentCHRBankA .rs 1
    3           003A      currentCHRBankB .rs 1
    4           003B      currentPRGBank  .rs 1
    5           003C      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    8                       .include "Defines/GameVariables.asm"
    1           003D      puzzle_address          .rs 2
    2           003F      clue_start_address      .rs 2
    3           0041      clue_draw_address       .rs 2
    4           0043      clueTableIndex          .rs 1
    5           0044      clueLineIndex           .rs 1
    6           0045      clueOffsetShift         .rs 1
    7           0046      clueDrawOffset          .rs 2
    8           0048      clueDrawAdd                     .rs 1
    9           0049      clueDrawDecSize         .rs 1
   10           004A      clueParity                      .rs 1
   11           004B      mouse_location          .rs 2
   12           004D      currentPaintTile        .rs 1
   13                     
#[2]   Defines/Defines.asm
    9                     ;; 0100 is the stack
   10                     ;; 0200 is sprite ram
   11           0300        .rsset $0300
   12           0400        .rsset $0400
   13           0500        .rsset $0500
   14           0600        .rsset $0600
   15           0700        .rsset $0700
   16           6000        .rsset $6000
#[3]   Defines/SaveVariables.asm
   17                       .include "Defines/SaveVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/ScreenStateVariables.asm
   18                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   19                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                       
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                       
   40                     MACROAddPPUStringEntryTable .macro
   41                      
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       JSR WriteToPPUString
   51                       LDA #LOW(\4)
   52                       JSR WriteToPPUString
   53                       LDA #HIGH(\4)
   54                       JSR WriteToPPUString
   55                      
   56                       .endm
   57                     
   58                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1           0000        .bank 0
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  00:8000            cat:
    2  00:8000  03 7E 00    .db $03, $7E, $00, $0A
       00:8003  0A        
    3  00:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       00:8007  60 1E F0  
       00:800A  3E F8 3F  
       00:800D  F8 7F FC  
       00:8010  7F FC 47  
       00:8013  C4 7B BC  
       00:8016  7F FC 7C  
       00:8019  7C 76 DC  
       00:801C  39 38 1F  
       00:801F  F0 00 00  
    4  00:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       00:8025  FF 54 FF  
       00:8028  65 FF 23  
       00:802B  60 FF 13  
       00:802E  70 FF 11  
       00:8031  80 FF 26  
       00:8034  FF 11 80  
       00:8037  FF 13 70  
       00:803A  FF 23 60  
       00:803D  FF 65 FF  
       00:8040  54 FF 70  
       00:8043  FF 00 FF  
    5  00:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       00:8049  FF 44 FF  
       00:804C  55 FF B0  
       00:804F  FF D0 FF  
       00:8052  D0 FF 15  
       00:8055  10 FF 43  
       00:8058  40 FF D0  
       00:805B  FF 55 FF  
       00:805E  32 23 FF  
       00:8061  31 30 FF  
       00:8064  90 FF 00  
       00:8067  FF        
    6  00:8068            catImage:
    7  00:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $04, $FF
       00:806B  55 56 95  
       00:806E  A5 55 6A  
       00:8071  9A A5 56  
       00:8074  AA 6A A5  
       00:8077  5A AA AA  
       00:807A  95 AA 66  
       00:807D  6A 96 AA  
       00:8080  9A AA 58  
       00:8083  0A E8 09  
       00:8086  6A 8F CA  
       00:8089  A5 9A FF  
       00:808C  E9 96 AF  
       00:808F  57 EA 59  
       00:8092  CF 7C D9  
       00:8095  5F C3 0F  
       00:8098  D5 5F FF  
       00:809B  FD 55 55  
       00:809E  55 55 04  
       00:80A1  FF        
    8  00:80A2            catName:
    9  00:80A2  0C 0A 1D    .db $0C, $0A, $1D, $FF
       00:80A5  FF        
#[2]   Banks/Bank0.asm
    5                     
    6                     
    7           0001        .bank 1
    8           A000        .org $A000
    9                       
   10  01:A000  00 80       .word cat
   11                       
   12           BFFA        .org $BFFA     ;first of the three vectors starts here
   13  01:BFFA  9E C5       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   14                                        ;processor will jump to the label NMI:
   15  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   16                                        ;to the label RESET:
   17  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
    4  02:8000            TestBankB:
    5  02:8000  A9 02             LDA #$02
    6  02:8002  8D 3C 00          STA mapperDebugVar
    7  02:8005  60                RTS
    8                     
    9           0003        .bank 3
   10           A000        .org $A000
   11  03:A000  AD 02 00    LDA $02
   12                     
   13           BFFA        .org $BFFA     ;first of the three vectors starts here
   14  03:BFFA  9E C5       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   15                                        ;processor will jump to the label NMI:
   16  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   17                                        ;to the label RESET:
   18  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
    4  04:8000            TestBankC:
    5  04:8000  A9 03             LDA #$03
    6  04:8002  8D 3C 00          STA mapperDebugVar
    7  04:8005  60                RTS
    8                     
    9           0005        .bank 5
   10           A000        .org $A000
   11  05:A000  AD 03 00    LDA $03
   12                     
   13           BFFA        .org $BFFA     ;first of the three vectors starts here
   14  05:BFFA  9E C5       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   15                                        ;processor will jump to the label NMI:
   16  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   17                                        ;to the label RESET:
   18  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 5B C4    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 5F C4    JSR SetMapperControls
   34                       
   35  06:C040  20 9C C4    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  20 75 C2    JSR ChangeGameMode
   38                       
   39                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   40                       ; enable sprites, enable background, no clipping on left side
   41                       MACROSetPPUControl %10010000, %00011110
                          
       06:C04D  A9 90       LDA #%10010000  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
       06:C04F  8D 00 20    STA PPU_CTRL
       06:C052  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
       06:C054  8D 01 20    STA PPU_MASK
                                  
   42                     
   43                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   44                     ;;     Main Program         ;;
   45                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   46                     
   47  06:C057            Forever:
   48                     
   49  06:C057  EE 07 00    INC sleeping
   50                     
   51  06:C05A            .loop
   52  06:C05A  AD 07 00    LDA sleeping
   53  06:C05D  D0 FB       BNE .loop
   54                       
   55  06:C05F  20 68 C0    JSR GameLoop
   56  06:C062  EE 06 00    INC time
   57                     
   58  06:C065  4C 57 C0    JMP Forever     ;jump back to Forever, infinite loop
   59                       
   60                     ;; dynamic jump table
   61                     
   62  06:C068            GameLoop:
   63                     
   64                       MACROCallDynamicJump game_mode
                          
       06:C068  AD 08 00    LDA game_mode
       06:C06B  20 F7 C2    JSR Dynamic_Jump
                                  
   65                       ;; we'll pop the return address here as the table index, so 
   66                       ;; the routine we pick will return us to whatever called Game Loop
   67                       ;; when it returns
   68                     
   69  06:C06E            GameLoopJumpTable:
   70                     
   71  06:C06E  74 C0       .word UpdateTitle
   72  06:C070  84 C0       .word UpdateGame
   73  06:C072  65 C2       .word UpdateGameOver
   74                       
   75                     
   76                       ;;RTS is called in the subroutine
   77                     
   78                       
#[2]   Routines/Game_States/UpdateTitle.asm
   79                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C074            UpdateTitle:
    2                     
    3  06:C074  AD 0A 00    LDA NMI_locks
    4  06:C077  D0 0A       BNE .noInputDetected
    5                     
    6  06:C079  AD 14 00    LDA gamepadPressed
    7  06:C07C  F0 05       BEQ .noInputDetected
    8                       
    9  06:C07E  A9 01         LDA #GAME_IDX
   10  06:C080  20 75 C2          JSR ChangeGameMode
   11                      
   12  06:C083            .noInputDetected:
   13                      
   14  06:C083  60          RTS
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   80                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6                     
    7                     ;;this will change with puzzle sizes
    8           005A      VERT_MIN = $5A
    9           00DA      VERT_MAX = $DA
   10           006A      HORI_MIN = $6A
   11           00EA      HORI_MAX = $EA
   12                     
   13           618E      MOUSE_START = $618E
   14                     
   15  06:C084            UpdateGame:
   16                     
   17  06:C084  AD 0A 00    LDA NMI_locks
   18  06:C087  F0 01       BEQ .unlocked
   19                       
   20  06:C089  60          RTS
   21                       
   22  06:C08A            .unlocked:
   23                     
   24  06:C08A  20 8E C0    JSR DoUpdateGame
   25  06:C08D  60          RTS
   26                       
   27  06:C08E            DoUpdateGame:
   28                     
   29  06:C08E  AD 09 00    LDA mode_state
   30  06:C091  20 F7 C2    JSR Dynamic_Jump
   31                       
   32  06:C094            UpdateGameJumpTable:
   33                     
   34  06:C094  9E C0       .word UpdateGameInit
   35  06:C096  F9 C0       .word UpdateDrawVertClues
   36  06:C098  21 C1       .word UpdateDrawHoriClues
   37  06:C09A  2A C1       .word UpdateGamePlay
   38  06:C09C  E7 C1       .word UpdateGameExit
   39                     
   40  06:C09E            UpdateGameInit:
   41                     
   42                       ;; get the puzzle table in the puzzle address
   43                       MACROGetLabelPointer $A000, table_address
                          
       06:C09E  A9 A0             LDA #HIGH($A000)
       06:C0A0  A2 00             LDX #LOW($A000)
                                  
       06:C0A2  8E 0E 00          STX table_address
       06:C0A5  8D 0F 00          STA table_address+1
                                  
   44                       MACROGetDoubleIndex #$00
                          
       06:C0A8  A9 00             LDA #$00
       06:C0AA  0A                ASL A
       06:C0AB  A8                TAY
                                  
   45  06:C0AC  20 1D C3    JSR GetTableAtIndex
   46                       MACROGetPointer table_address, puzzle_address
                          
       06:C0AF  AD 0E 00          LDA table_address
       06:C0B2  8D 3D 00          STA puzzle_address
       06:C0B5  AD 0F 00          LDA table_address+1
       06:C0B8  8D 3E 00          STA puzzle_address+1
                          
   47                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C0BB  A9 61             LDA #HIGH(MOUSE_START)
       06:C0BD  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C0BF  8E 4B 00          STX mouse_location
       06:C0C2  8D 4C 00          STA mouse_location+1
                                  
   48                       
   49                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   50  06:C0C5  AD 3D 00    LDA puzzle_address
   51  06:C0C8  18          CLC
   52  06:C0C9  69 22       ADC #34
   53  06:C0CB  8D 3D 00    STA puzzle_address
   54  06:C0CE  A9 00       LDA #$00
   55  06:C0D0  6D 3E 00    ADC puzzle_address+1
   56  06:C0D3  8D 3E 00    STA puzzle_address+1
   57                     
   58  06:C0D6  A9 00       LDA #$00
   59  06:C0D8  8D 43 00    STA clueTableIndex
   60  06:C0DB  8D 44 00    STA clueLineIndex
   61  06:C0DE  8D 4A 00    STA clueParity
   62  06:C0E1  8D 45 00    STA clueOffsetShift
   63                       
   64  06:C0E4  A9 20       LDA #$20
   65  06:C0E6  8D 48 00    STA clueDrawAdd
   66                        
   67                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C0E9  A9 21             LDA #HIGH(VERT_CLUES)
       06:C0EB  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C0ED  8E 3F 00          STX clue_start_address
       06:C0F0  8D 40 00          STA clue_start_address+1
                                  
   68  06:C0F3  20 2A C5    JSR ResetClueDrawAddress
   69                         
   70  06:C0F6  EE 09 00    INC mode_state
   71                     
   72  06:C0F9            UpdateDrawVertClues:
   73                       
   74  06:C0F9  20 B2 C4    JSR PopulateClues
   75  06:C0FC  90 22       BCC .leave
   76                       
   77  06:C0FE            .changeModeState:
   78                     
   79  06:C0FE  A9 00       LDA #$00
   80  06:C100  8D 44 00    STA clueLineIndex
   81  06:C103  8D 4A 00    STA clueParity
   82                       
   83  06:C106  A9 05       LDA #$05
   84  06:C108  8D 45 00    STA clueOffsetShift
   85                       
   86  06:C10B  A9 01       LDA #$01
   87  06:C10D  8D 48 00    STA clueDrawAdd
   88                        
   89                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C110  A9 21             LDA #HIGH(HORI_CLUES)
       06:C112  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C114  8E 3F 00          STX clue_start_address
       06:C117  8D 40 00          STA clue_start_address+1
                                  
   90  06:C11A  20 2A C5    JSR ResetClueDrawAddress
   91                     
   92  06:C11D  EE 09 00    INC mode_state
   93  06:C120            .leave:
   94  06:C120  60          RTS
   95                       
   96  06:C121            UpdateDrawHoriClues:
   97                     
   98  06:C121  20 B2 C4    JSR PopulateClues
   99  06:C124  90 03       BCC .leave
  100                     
  101  06:C126            .changeModeState:
  102                     
  103  06:C126  EE 09 00    INC mode_state
  104  06:C129            .leave:
  105  06:C129  60          RTS
  106                       
  107  06:C12A            UpdateGamePlay:
  108                         
  109  06:C12A  A9 00       LDA #$00
  110  06:C12C  8D 00 00    STA temp1
  111  06:C12F  8D 01 00    STA temp2
  112  06:C132  8D 02 00    STA temp3
  113                     
  114                       
  115  06:C135  AD 14 00    LDA gamepadPressed
  116  06:C138  F0 6A       BEQ .updatePaint  
  117                       
  118  06:C13A            .parseInputs:
  119                     
  120  06:C13A  29 F0       AND #GAMEPAD_MOVE
  121  06:C13C  F0 1E       BEQ .checkPaintPress
  122  06:C13E  0A          ASL A
  123  06:C13F  90 03       BCC .checkLeft
  124  06:C141  EE 00 00    INC temp1
  125  06:C144            .checkLeft:
  126  06:C144  0A          ASL A
  127  06:C145  90 03       BCC .checkDown
  128  06:C147  CE 00 00    DEC temp1
  129  06:C14A            .checkDown:
  130  06:C14A  0A          ASL A
  131  06:C14B  90 03       BCC .checkUp
  132  06:C14D  EE 01 00    INC temp2
  133  06:C150            .checkUp:
  134  06:C150  0A          ASL A
  135  06:C151  90 03       BCC .move
  136  06:C153  CE 01 00    DEC temp2
  137                       
  138  06:C156            .move:
  139                      
  140  06:C156  20 ED C1    JSR MoveMouse
  141                       
  142  06:C159            .updateMousePos:
  143                     
  144  06:C159  20 2E C2    JSR UpdateMouseScreenPos
  145                       
  146  06:C15C            .checkPaintPress:
  147                     
  148  06:C15C  AD 14 00    LDA gamepadPressed
  149  06:C15F  29 03       AND #GAMEPAD_AB
  150  06:C161  F0 41       BEQ .updatePaint
  151                       ;;A or B pressed, get current tile
  152                       
  153  06:C163  8D 00 00    STA temp1
  154                       
  155  06:C166  A0 00       LDY #$00
  156  06:C168  B1 4B       LDA [mouse_location], y
  157  06:C16A  8D 01 00    STA temp2
  158                       
  159                         ;;A treats X and Clear as clear
  160                             ;;B treats mark and clear as clear
  161                             ;;clear->mark->x
  162                             
  163                     
  164  06:C16D  C9 7C       CMP #$7C      ;check if this is a marked tile
  165  06:C16F  B0 0F       BCS .getClearTile
  166                       ;;cleared tile- store off marked tile to paint with instead
  167                       ;;not a clear tile- a mark or an x - check A or B  
  168  06:C171  4E 00 00    LSR temp1
  169  06:C174  B0 05       BCS .getMarkTile
  170                       
  171  06:C176            .getXTile:
  172  06:C176  A9 80       LDA #$80
  173  06:C178  4C 9E C1    JMP .finishGetTile
  174                       
  175  06:C17B            .getMarkTile:
  176  06:C17B  A9 70       LDA #$70
  177  06:C17D  4C 9E C1    JMP .finishGetTile
  178                     
  179  06:C180            .getClearTile:
  180                       
  181  06:C180  4E 00 00    LSR temp1
  182  06:C183  90 0A       BCC .checkB
  183  06:C185  AD 01 00    LDA temp2
  184  06:C188  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  185  06:C18A  90 0D       BCC .clearTile
  186  06:C18C  4C 7B C1    JMP .getMarkTile
  187                       
  188  06:C18F            .checkB:
  189                       
  190  06:C18F  AD 01 00   LDA temp2
  191  06:C192  C9 8C      CMP #$8C
  192  06:C194  B0 03      BCS .clearTile
  193  06:C196  4C 76 C1   JMP .getXTile
  194                       
  195  06:C199            .clearTile:
  196  06:C199  A9 60       LDA #$60
  197  06:C19B  4C 9E C1    JMP .finishGetTile
  198                       
  199  06:C19E            .finishGetTile:
  200  06:C19E  8D 4D 00    STA currentPaintTile
  201  06:C1A1  4C AB C1    JMP .setTile
  202                     
  203                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  204                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  205                     ;;we can load the nametable into memory as we draw it
  206                     
  207  06:C1A4            .updatePaint:
  208                     
  209  06:C1A4  AD 12 00    LDA gamepad
  210  06:C1A7  29 03       AND #GAMEPAD_AB
  211  06:C1A9  F0 3B       BEQ .leave  
  212                       
  213  06:C1AB            .setTile:
  214                     
  215  06:C1AB  B1 4B       LDA [mouse_location], y
  216  06:C1AD  29 0F       AND #$0F
  217  06:C1AF  0D 4D 00    ORA currentPaintTile
  218  06:C1B2  91 4B       STA [mouse_location], y
  219  06:C1B4  8D 00 00    STA temp1
  220                       
  221  06:C1B7  AD 4C 00    LDA mouse_location+1
  222  06:C1BA  29 3F       AND #$3F
  223  06:C1BC  8D 01 00    STA temp2
  224                       
  225                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C1BF  A9 01       LDA #$01
       06:C1C1  8D 15 00    STA PPU_PendingWrite
       06:C1C4  AD 01 00    LDA temp2
       06:C1C7  20 15 C4    JSR WriteToPPUString
       06:C1CA  AD 4B 00    LDA mouse_location
       06:C1CD  20 15 C4    JSR WriteToPPUString
       06:C1D0  A9 00       LDA #DRAW_HORIZONTAL
       06:C1D2  20 15 C4    JSR WriteToPPUString
       06:C1D5  A9 01       LDA #$01
       06:C1D7  20 15 C4    JSR WriteToPPUString
                            
  226  06:C1DA  AD 00 00    LDA temp1
  227  06:C1DD  20 15 C4    JSR WriteToPPUString
  228  06:C1E0  4C E6 C1    JMP .leave
  229                       
  230                       ;;update the painting
  231  06:C1E3            .changeModeState:
  232                     
  233  06:C1E3  EE 09 00    INC mode_state
  234                     
  235  06:C1E6            .leave:
  236                      
  237  06:C1E6  60          RTS
  238                       
  239  06:C1E7            UpdateGameExit:
  240                     
  241  06:C1E7  A9 02       LDA #GAMEOVER_IDX
  242  06:C1E9  20 75 C2    JSR ChangeGameMode
  243  06:C1EC  60          RTS
  244                       
  245  06:C1ED            MoveMouse:
  246                     
  247  06:C1ED  AD 00 00    LDA temp1
  248  06:C1F0  0E 00 00    ASL temp1
  249  06:C1F3  0E 00 00    ASL temp1
  250  06:C1F6  0E 00 00    ASL temp1
  251                       
  252  06:C1F9  AD 01 00    LDA temp2
  253  06:C1FC  0E 01 00    ASL temp2 
  254  06:C1FF  0E 01 00    ASL temp2
  255  06:C202  0E 01 00    ASL temp2
  256                       
  257  06:C205  A2 03       LDX #SPRITE_XPOS
  258  06:C207  BD 00 02    LDA SPRITE_DATA, x
  259  06:C20A  18          CLC
  260  06:C20B  6D 00 00    ADC temp1
  261                       ;;check against borders
  262  06:C20E  C9 6A       CMP #HORI_MIN
  263  06:C210  F0 07       BEQ .moveVert
  264  06:C212  C9 EA       CMP #HORI_MAX
  265  06:C214  F0 03       BEQ .moveVert
  266  06:C216  9D 00 02    STA SPRITE_DATA, x
  267                     
  268  06:C219            .moveVert:
  269                     
  270  06:C219  A2 00       LDX #SPRITE_YPOS
  271  06:C21B  BD 00 02    LDA SPRITE_DATA, x
  272  06:C21E  18          CLC
  273  06:C21F  6D 01 00    ADC temp2
  274                       ;;check against borders
  275  06:C222  C9 5A       CMP #VERT_MIN
  276  06:C224  F0 07       BEQ .leave
  277  06:C226  C9 DA       CMP #VERT_MAX
  278  06:C228  F0 03       BEQ .leave
  279  06:C22A  9D 00 02    STA SPRITE_DATA, x
  280                     
  281  06:C22D            .leave:
  282  06:C22D  60          RTS
  283                             
  284  06:C22E            UpdateMouseScreenPos:
  285                     
  286  06:C22E  A2 00       LDX #$00
  287  06:C230  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  288  06:C233  4A          LSR A                                         ;0yyy yy..
  289  06:C234  4A          LSR A                                         ;00yy yyy.
  290  06:C235  4A          LSR A                                         ;000y yyyy
  291  06:C236  8D 00 00    STA temp1
  292  06:C239  E8          INX
  293  06:C23A  E8          INX
  294  06:C23B  E8          INX   
  295  06:C23C  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  296  06:C23F  29 F8       AND #$F8                       ;              ;  xxxx x000
  297  06:C241  8D 01 00    STA temp2                      ;      ;  
  298  06:C244  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  299  06:C247  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  300  06:C24A  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  301  06:C24D  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  302  06:C250  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  303  06:C253  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  304                       
  305  06:C256  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  306  06:C259  09 60       ORA #$60                       ;              ;  0110 00yy
  307                       
  308  06:C25B  8D 4C 00    STA mouse_location+1
  309  06:C25E  AD 01 00    LDA temp2
  310  06:C261  8D 4B 00    STA mouse_location
  311                       
  312  06:C264            .leave:
  313  06:C264  60          RTS
  314                     
  315                     ;;using the line index and a given count based on the direction, 
  316                       
  317                     ;;      JSR ResetMapper
  318                     ;;      INC currentCHRBank
  319                     ;;      LDA currentCHRBank
  320                     ;;      CMP #$03
  321                     ;;      BNE .dontModCHR
  322                             
  323                     ;;      LDA #$00
  324                     
  325                     ;;.dontModCHR:
  326                     ;;      STA currentCHRBank 
  327                     ;;      ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
  328                     ;;      ASL A
  329                     ;;      CLC 
  330                     ;;      ADC #$01
  331                     ;;      JSR LoadCHRBankB
  332                     ;;      
  333                     ;;      JSR ResetMapper
  334                     ;;      INC currentPRGBank
  335                     ;;      LDA currentPRGBank
  336                     ;;      CMP #$03
  337                     ;;      BNE .dontModPRG
  338                             
  339                     ;;      LDA #$00
  340                             
  341                     ;;.dontModPRG:
  342                     ;;       STA currentPRGBank
  343                     ;;       JSR LoadPRGBank
  344                      
  345                     ;;       JSR TestBankA
  346                     ;;       LDA mapperDebugVar
  347                     ;;       STA $6000
  348                     ;;       JMP .noInputDetected
  349                     
  350                     
  351                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   81                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C265            UpdateGameOver:
    2                     
    3  06:C265  AD 0A 00    LDA NMI_locks
    4  06:C268  D0 0A       BNE .noInputDetected
    5                     
    6  06:C26A  AD 14 00    LDA gamepadPressed
    7  06:C26D  F0 05       BEQ .noInputDetected
    8                       
    9  06:C26F  A9 00         LDA #TITLE_IDX
   10  06:C271  20 75 C2          JSR ChangeGameMode
   11                      
   12  06:C274            .noInputDetected:
   13                      
   14  06:C274  60          RTS
#[1]   Picross.asm
   82                       
   83                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   84                     ;;     Routines             ;;
   85                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   86                     
   87                     
#[2]   Routines/Common/GameModeRoutines.asm
   88                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C275            ChangeGameMode:
    2  06:C275  8D 08 00    STA game_mode
    3  06:C278  A9 00       LDA #$00
    4  06:C27A  8D 09 00    STA mode_state
    5  06:C27D  20 23 C4    JSR ClearPPUString
    6  06:C280  20 84 C2    JSR LoadGameModeScreen
    7  06:C283  60          RTS
    8                       
    9  06:C284            LoadGameModeScreen:
   10                     
   11                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C284  AD 0A 00    LDA NMI_locks
       06:C287  09 01       ORA #BGLOAD_NMI_LOCK
       06:C289  8D 0A 00    STA NMI_locks
                                  
   12                       
   13  06:C28C  A9 00       LDA #$00
   14  06:C28E  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   15                     
   16  06:C291  20 B2 C2    JSR LoadGameModeBackground
   17  06:C294  20 DE C2    JSR LoadGameModeSprites
   18                     
   19                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C297  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C299  49 FF       EOR #$FF
       06:C29B  2D 0A 00    AND NMI_locks  
       06:C29E  8D 0A 00    STA NMI_locks
                          
   20                     
   21                       
   22                       ;; load the CHR bank for this mode
   23  06:C2A1  20 5B C4    JSR ResetMapper
   24                       ;;remember, we're loading the SECOND set in each chr bank
   25                       ;;so we'll take the index from the game mode chr table and add one mult 2
   26  06:C2A4  AE 08 00    LDX game_mode
   27  06:C2A7  BD F4 C2    LDA gameModeInitCHRROM, x
   28  06:C2AA  0A          ASL A
   29  06:C2AB  18          CLC 
   30  06:C2AC  69 01       ADC #$01
   31  06:C2AE  20 80 C4    JSR LoadCHRBankB
   32                       
   33  06:C2B1  60          RTS
   34                       
   35  06:C2B2            LoadGameModeBackground:
   36                             
   37                       MACROGetDoubleIndex game_mode
                          
       06:C2B2  AD 08 00          LDA game_mode
       06:C2B5  0A                ASL A
       06:C2B6  A8                TAY
                                  
   38  06:C2B7  8C 00 00    STY temp1
   39                             
   40                       MACROGetLabelPointer Palettes, table_address
                          
       06:C2BA  A9 E0             LDA #HIGH(Palettes)
       06:C2BC  A2 00             LDX #LOW(Palettes)
                                  
       06:C2BE  8E 0E 00          STX table_address
       06:C2C1  8D 0F 00          STA table_address+1
                                  
   41  06:C2C4  20 1D C3    JSR GetTableAtIndex
   42                     
   43  06:C2C7  20 2A C3    JSR LoadFullPaletteFromTable
   44                             
   45  06:C2CA  AC 00 00    LDY temp1
   46                       MACROGetLabelPointer NameTables, table_address
                          
       06:C2CD  A9 E0             LDA #HIGH(NameTables)
       06:C2CF  A2 06             LDX #LOW(NameTables)
                                  
       06:C2D1  8E 0E 00          STX table_address
       06:C2D4  8D 0F 00          STA table_address+1
                                  
   47  06:C2D7  20 1D C3    JSR GetTableAtIndex
   48                             
   49  06:C2DA  20 4A C3    JSR LoadFullBackgroundFromTable
   50                       
   51  06:C2DD  60          RTS
   52                       
   53  06:C2DE            LoadGameModeSprites:
   54                     
   55                       MACROGetDoubleIndex game_mode  
                          
       06:C2DE  AD 08 00          LDA game_mode
       06:C2E1  0A                ASL A
       06:C2E2  A8                TAY
                                  
   56                       MACROGetLabelPointer Sprites, table_address
                          
       06:C2E3  A9 EC             LDA #HIGH(Sprites)
       06:C2E5  A2 6C             LDX #LOW(Sprites)
                                  
       06:C2E7  8E 0E 00          STX table_address
       06:C2EA  8D 0F 00          STA table_address+1
                                  
   57  06:C2ED  20 1D C3    JSR GetTableAtIndex
   58  06:C2F0  20 08 C4    JSR LoadSprites_impl
   59                       
   60  06:C2F3  60          RTS
   61                       
   62  06:C2F4            gameModeInitCHRROM:
   63  06:C2F4  00 02 02          .db $00, $02, $02
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   89                       .include "Routines/Utils/PointerUtils.asm"
    1  06:C2F7            Dynamic_Jump:
    2                     
    3  06:C2F7  0A          ASL A                                 ;; double the index passed into A
    4  06:C2F8  8E 04 00    STX tempx
    5  06:C2FB  8C 05 00    STY tempy
    6  06:C2FE  A8          TAY
    7  06:C2FF  C8          INY  
    8  06:C300  68          PLA
    9  06:C301  8D 10 00    STA jump_address
   10  06:C304  68          PLA 
   11  06:C305  8D 11 00    STA jump_address+1            
   12  06:C308  B1 10       LDA [jump_address], y
   13  06:C30A  AA          TAX
   14  06:C30B  C8          INY
   15  06:C30C  B1 10       LDA [jump_address], y
   16  06:C30E  8E 10 00    STX jump_address
   17  06:C311  8D 11 00    STA jump_address+1
   18  06:C314  AE 04 00    LDX tempx
   19  06:C317  AC 05 00    LDY tempy
   20  06:C31A  6C 10 00    JMP [jump_address]
   21                       
   22  06:C31D            GetTableAtIndex:
   23                     
   24  06:C31D  B1 0E             LDA [table_address], y
   25  06:C31F  AA                TAX
   26  06:C320  C8                INY
   27  06:C321  B1 0E             LDA [table_address], y
   28                             
   29  06:C323            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:C323  8E 0E 00          STX table_address
   33  06:C326  8D 0F 00          STA table_address+1
   34  06:C329  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   90                       .include "Routines/Utils/PPUUtils.asm"
    1  06:C32A            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:C32A  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C32D  A9 3F       LDA #HIGH($3F00)
       06:C32F  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C332  A9 00       LDA #LOW($3F00)
       06:C334  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:C337  A0 00       LDY #$00              ; start out at 0
    5  06:C339  A2 00       LDX #$00
    6  06:C33B            .loop:
    7  06:C33B  B1 0E       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:C33D  8D 07 20    STA PPU_DATA            ; write to PPU
    9  06:C340  9D 00 64    STA Palette_Copy, x
   10  06:C343  C8          INY                   ; X = X + 1
   11  06:C344  E8          INX
   12  06:C345  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   13  06:C347  D0 F2       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   14  06:C349  60          RTS
   15                     
   16  06:C34A            LoadFullBackgroundFromTable:
   17                     
   18                             MACROSetPPUAddress $2000
                          
       06:C34A  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C34D  A9 20       LDA #HIGH($2000)
       06:C34F  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C352  A9 00       LDA #LOW($2000)
       06:C354  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
   19                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:C357  A9 60             LDA #HIGH(Screen_Copy)
       06:C359  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:C35B  8E 0C 00          STX pointer_address
       06:C35E  8D 0D 00          STA pointer_address+1
                                  
   20                             
   21                             ;;set pointer
   22                             ;; set counters
   23  06:C361  A0 00             LDY #$00
   24  06:C363  A2 00             LDX #$00
   25                             
   26                             ;;start loop
   27                     
   28  06:C365            .outerloop:
   29                     
   30  06:C365            .innerloop:
   31                     
   32  06:C365  B1 0E             LDA [table_address], y
   33  06:C367  8D 07 20          STA PPU_DATA
   34  06:C36A  91 0C             STA [pointer_address],y
   35  06:C36C  C8                INY
   36  06:C36D  C0 00             CPY #$00
   37  06:C36F  D0 F4             BNE .innerloop
   38                     
   39  06:C371  EE 0D 00          INC pointer_address+1
   40  06:C374  EE 0F 00          INC table_address+1
   41                             
   42  06:C377  E8                INX
   43  06:C378  E0 04             CPX #$04
   44  06:C37A  D0 E9             BNE .outerloop
   45  06:C37C  60                RTS
   46                             
   47                     
   48           0000      DATA_LEN = temp1
   49           0001      WRITE_SETTINGS = temp2
   50                             
   51  06:C37D            ProcessPPUString:
   52                     
   53  06:C37D  AD 15 00          LDA PPU_PendingWrite
   54  06:C380  F0 6F             BEQ .leave
   55  06:C382  A0 00             LDY #$00
   56                             
   57  06:C384  A9 17             LDA #LOW(PPU_String)
   58  06:C386  8D 0C 00          STA pointer_address
   59  06:C389  A9 00             LDA #HIGH(PPU_String)
   60  06:C38B  8D 0D 00          STA pointer_address + 1
   61                     
   62  06:C38E            .outerloop:
   63  06:C38E  AD 02 20          LDA PPU_STATUS
   64  06:C391  B1 0C             LDA [pointer_address], y
   65  06:C393  F0 59             BEQ .finish
   66  06:C395  8D 06 20          STA PPU_ADDR
   67  06:C398  C8                INY
   68  06:C399  B1 0C             LDA [pointer_address], y
   69  06:C39B  8D 06 20          STA PPU_ADDR
   70  06:C39E  C8            INY 
   71  06:C39F  B1 0C             LDA [pointer_address], y
   72  06:C3A1  8D 01 00          STA WRITE_SETTINGS
   73  06:C3A4  C8                INY
   74                             
   75  06:C3A5  AD 00 20          LDA PPU_CTRL
   76  06:C3A8  29 FB             AND #$FB
   77  06:C3AA  8D 00 20          STA PPU_CTRL
   78                             
   79  06:C3AD  AD 01 00          LDA WRITE_SETTINGS
   80  06:C3B0  29 80             AND #%10000000
   81  06:C3B2  F0 06             BEQ .checkTable
   82  06:C3B4  0D 00 20          ORA PPU_CTRL 
   83  06:C3B7  8D 00 20          STA PPU_CTRL 
   84                             
   85  06:C3BA            .checkTable:
   86  06:C3BA  AD 01 00          LDA WRITE_SETTINGS
   87  06:C3BD  29 40             AND #%01000000
   88  06:C3BF  F0 16             BEQ .rawData
   89                             
   90  06:C3C1  B1 0C             LDA [pointer_address], y
   91  06:C3C3  8D 0E 00          STA table_address
   92  06:C3C6  C8                INY 
   93  06:C3C7  B1 0C             LDA [pointer_address], y
   94  06:C3C9  8D 0F 00          STA table_address + 1
   95  06:C3CC  C8                INY
   96  06:C3CD  98                TYA 
   97  06:C3CE  48                PHA
   98  06:C3CF  20 F2 C3          JSR WriteToPPUFromTable
   99  06:C3D2  68                PLA
  100  06:C3D3  A8                TAY
  101  06:C3D4  4C 8E C3          JMP .outerloop
  102                     
  103  06:C3D7            .rawData:
  104                     
  105  06:C3D7  B1 0C             LDA [pointer_address], y
  106  06:C3D9  C8                INY
  107  06:C3DA  8D 00 00          STA DATA_LEN
  108                     
  109  06:C3DD  A2 00             LDX #$00
  110                     
  111  06:C3DF            .innerloop:
  112                             
  113  06:C3DF  B1 0C             LDA [pointer_address], y
  114  06:C3E1  8D 07 20          STA PPU_DATA
  115  06:C3E4  C8                INY
  116  06:C3E5  E8                INX
  117  06:C3E6  EC 00 00          CPX DATA_LEN
  118  06:C3E9  D0 F4             BNE .innerloop
  119  06:C3EB  4C 8E C3          JMP .outerloop
  120                             
  121  06:C3EE            .finish:
  122  06:C3EE  20 23 C4          JSR ClearPPUString
  123  06:C3F1            .leave:
  124  06:C3F1  60                RTS
  125                             
  126  06:C3F2            WriteToPPUFromTable:
  127  06:C3F2  A0 00             LDY #$00
  128  06:C3F4  B1 0E             LDA [table_address], y
  129  06:C3F6  C8                INY
  130  06:C3F7  8D 00 00          STA DATA_LEN
  131  06:C3FA            .innerloop:
  132  06:C3FA  B1 0E             LDA [table_address], y
  133  06:C3FC  8D 07 20          STA PPU_DATA
  134  06:C3FF  C8                INY
  135  06:C400  CC 00 00          CPY DATA_LEN
  136  06:C403  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  137  06:C405  F0 F3             BEQ .innerloop
  138  06:C407  60                RTS
  139                       
  140  06:C408            LoadSprites_impl:
  141  06:C408  A0 00       LDY #$00              ; start at 0
  142                       
  143  06:C40A            .loop:
  144  06:C40A  B1 0E       LDA [table_address], y; load data from address (sprites +  x)
  145  06:C40C  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  146  06:C40F  C8          INY                   ; X = X + 1
  147  06:C410  C0 05       CPY #$05              ; Compare X to hex $10, decimal 16
  148  06:C412  D0 F6       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  149                                             ; if compare was equal to 16, keep going down   
  150  06:C414  60          RTS
  151                     
  152                     
  153  06:C415            WriteToPPUString:
  154                     
  155  06:C415  AE 16 00          LDX PPU_StringIdx
  156  06:C418  E0 20             CPX #PPU_STRINGMAX
  157  06:C41A  F0 06             BEQ .finish
  158                             
  159  06:C41C  9D 17 00          STA PPU_String, x
  160  06:C41F  EE 16 00          INC PPU_StringIdx
  161                                     
  162  06:C422            .finish:
  163  06:C422  60                RTS
  164                     
  165  06:C423            ClearPPUString:
  166                             
  167  06:C423  A9 00             LDA #$00
  168  06:C425  8D 16 00          STA PPU_StringIdx
  169  06:C428  8D 17 00          STA PPU_String
  170  06:C42B  8D 15 00          STA PPU_PendingWrite
  171  06:C42E  60                RTS
  172                     
  173  06:C42F            DetectSprite0:
  174  06:C42F            WaitNotSprite0:
  175  06:C42F  AD 02 20    lda PPU_STATUS
  176  06:C432  29 40       and #SPRITE_0_MASK
  177  06:C434  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  178                     
  179  06:C436            WaitSprite0:
  180  06:C436  AD 02 20    lda $2002
  181  06:C439  29 40       and #SPRITE_0_MASK
  182  06:C43B  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  183                     
  184  06:C43D  A2 05       ldx #$05                              ;do a scanline wait
  185  06:C43F            WaitScanline:
  186  06:C43F  CA          dex
  187  06:C440  D0 FD       bne WaitScanline
  188  06:C442  60          RTS
  189                     
  190  06:C443            NameTableMemList:
  191  06:C443  00 20       .word $2000, $2400, $2800, $2C00
       06:C445  00 24     
       06:C447  00 28     
       06:C449  00 2C     
  192  06:C44B            PalettesMemList:
  193  06:C44B  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:C44D  04 3F     
       06:C44F  08 3F     
       06:C451  0C 3F     
  194  06:C453  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:C455  14 3F     
       06:C457  18 3F     
       06:C459  1C 3F     
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   91                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:C45B            ResetMapper:
    7  06:C45B  EE 5B C4    inc ResetMapper
    8  06:C45E  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:C45F            SetMapperControls:
   23                       ;;A = controls
   24  06:C45F  AA          TAX
   25  06:C460  A9 80       LDA #MAPPERCONTROL
   26  06:C462  8D 38 00    STA mapper_address+1
   27  06:C465  8A          TXA
   28  06:C466  20 8B C4    JSR SendMapperCommand
   29  06:C469  60          RTS
   30                     
   31  06:C46A            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:C46A  AA                TAX
   35  06:C46B  A9 E0             LDA #PRGBANK
   36  06:C46D  8D 38 00          STA mapper_address+1
   37  06:C470  8A                TXA
   38  06:C471  20 8B C4          JSR SendMapperCommand
   39  06:C474  60                RTS
   40                             
   41  06:C475            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:C475  AA                TAX
   44  06:C476  A9 A0             LDA #CHRBANK1
   45  06:C478  8D 38 00          STA mapper_address+1
   46  06:C47B  8A                TXA
   47  06:C47C  20 8B C4          JSR SendMapperCommand
   48  06:C47F  60                RTS
   49                             
   50  06:C480            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:C480  AA                TAX
   53  06:C481  A9 C0             LDA #CHRBANK2
   54  06:C483  8D 38 00          STA mapper_address+1
   55  06:C486  8A                TXA
   56  06:C487  20 8B C4          JSR SendMapperCommand
   57  06:C48A  60                RTS
   58                             
   59  06:C48B            SendMapperCommand:
   60                     
   61  06:C48B  A0 00             LDY #$00
   62                             
   63  06:C48D  91 37             STA [mapper_address], y
   64  06:C48F  4A                LSR A
   65  06:C490  91 37             STA [mapper_address], y
   66  06:C492  4A                LSR A
   67  06:C493  91 37             STA [mapper_address], y
   68  06:C495  4A                LSR A 
   69  06:C496  91 37             STA [mapper_address], y
   70  06:C498  4A                LSR A
   71  06:C499  91 37             STA [mapper_address], y
   72                             
   73  06:C49B  60                RTS
   74                             
   75  06:C49C            ResetBanks:
   76                     
   77  06:C49C  20 5B C4          JSR ResetMapper
   78  06:C49F  A9 00             LDA #$00
   79  06:C4A1  20 6A C4          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:C4A4  20 5B C4          JSR ResetMapper
   83  06:C4A7  A9 00             LDA #$00
   84  06:C4A9  20 75 C4          JSR LoadCHRBankA
   85  06:C4AC  A9 01             LDA #$01
   86  06:C4AE  20 80 C4          JSR LoadCHRBankB
   87  06:C4B1  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   92                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:C4B2            PopulateClues:
    2                     
    3  06:C4B2            .getByte:
    4  06:C4B2  AC 43 00    LDY clueTableIndex
    5  06:C4B5  B1 3D       LDA [puzzle_address], y
    6  06:C4B7  D0 07       BNE .checkNewLine
    7  06:C4B9  EE 43 00    INC clueTableIndex
    8  06:C4BC  A9 00       LDA #$00
    9  06:C4BE  F0 38       BEQ .drawClue
   10                       ;was 0, set up a draw
   11  06:C4C0            .checkNewLine
   12  06:C4C0  C9 FF       CMP #$FF
   13  06:C4C2  D0 17       BNE .getClue
   14                       
   15                       ;;was FF- need to inc stuff
   16  06:C4C4  EE 43 00    INC clueTableIndex
   17  06:C4C7  A9 00       LDA #$00
   18  06:C4C9  8D 4A 00    STA clueParity
   19                       
   20  06:C4CC  EE 44 00    INC clueLineIndex
   21  06:C4CF  AD 44 00    LDA clueLineIndex
   22  06:C4D2  C9 0F       CMP #$0F
   23                       ;CMP #$01
   24  06:C4D4  F0 28       BEQ .leave    ;carry will be set
   25                       
   26  06:C4D6  20 70 C5    JSR CreateOffsetFromIndex
   27                      
   28  06:C4D9  D0 D7       BNE .getByte
   29                       
   30  06:C4DB            .getClue:
   31                       ;;clues go from high nibble to low nibble
   32  06:C4DB  48          PHA 
   33  06:C4DC  AD 4A 00    LDA clueParity
   34  06:C4DF  D0 0A       BNE .getSecondClue
   35  06:C4E1  EE 4A 00    INC clueParity
   36  06:C4E4  68          PLA
   37  06:C4E5  4A          LSR A
   38  06:C4E6  4A          LSR A
   39  06:C4E7  4A          LSR A
   40  06:C4E8  4A          LSR A         ;move clue over to lower nibble
   41  06:C4E9  D0 0D       BNE .drawClue
   42                       
   43  06:C4EB            .getSecondClue:
   44                     
   45  06:C4EB  CE 4A 00    DEC clueParity
   46  06:C4EE  EE 43 00    INC clueTableIndex
   47  06:C4F1  68          PLA 
   48  06:C4F2  29 0F       AND #$0F
   49  06:C4F4  D0 02       BNE .drawClue
   50                       ;;if 0, skip
   51  06:C4F6  F0 BA       BEQ .getByte
   52                      
   53  06:C4F8            .drawClue:
   54                       
   55  06:C4F8  09 40       ORA #$40
   56  06:C4FA  20 FF C4    JSR WriteClueByteToPPUString
   57  06:C4FD  18          CLC
   58                       
   59  06:C4FE            .leave:
   60  06:C4FE  60          RTS
   61                       
   62  06:C4FF            WriteClueByteToPPUString:
   63                     
   64  06:C4FF  8D 00 00    STA temp1 ;store off the tile value
   65                     
   66                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:C502  A9 01       LDA #$01
       06:C504  8D 15 00    STA PPU_PendingWrite
       06:C507  AD 42 00    LDA clue_draw_address+1
       06:C50A  20 15 C4    JSR WriteToPPUString
       06:C50D  AD 41 00    LDA clue_draw_address
       06:C510  20 15 C4    JSR WriteToPPUString
       06:C513  A9 00       LDA #DRAW_HORIZONTAL
       06:C515  20 15 C4    JSR WriteToPPUString
       06:C518  A9 01       LDA #$01
       06:C51A  20 15 C4    JSR WriteToPPUString
                            
   67  06:C51D  AD 00 00    LDA temp1
   68  06:C520  20 15 C4    JSR WriteToPPUString
   69                       
   70  06:C523  AD 48 00    LDA clueDrawAdd
   71  06:C526  20 4D C5    JSR SubFromClueDrawAddress
   72                         
   73  06:C529  60          RTS
   74                       
   75  06:C52A            ResetClueDrawAddress:
   76                     
   77                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:C52A  AD 3F 00          LDA clue_start_address
       06:C52D  8D 41 00          STA clue_draw_address
       06:C530  AD 40 00          LDA clue_start_address+1
       06:C533  8D 42 00          STA clue_draw_address+1
                          
   78                       
   79  06:C536  60          RTS
   80                       
   81  06:C537            AddToClueDrawAddress:
   82                     
   83  06:C537  8D 00 00    STA temp1
   84                       
   85  06:C53A  AD 41 00    LDA clue_draw_address
   86  06:C53D  18          CLC
   87  06:C53E  6D 00 00    ADC temp1
   88  06:C541  8D 41 00    STA clue_draw_address
   89  06:C544  AD 42 00    LDA clue_draw_address+1
   90  06:C547  69 00       ADC #$00
   91  06:C549  8D 42 00    STA clue_draw_address+1
   92                       
   93  06:C54C  60          RTS
   94                         
   95  06:C54D            SubFromClueDrawAddress:
   96                     
   97  06:C54D  8D 00 00    STA temp1
   98                       
   99  06:C550  AD 41 00    LDA clue_draw_address
  100  06:C553  38          SEC
  101  06:C554  ED 00 00    SBC temp1
  102  06:C557  8D 41 00    STA clue_draw_address
  103  06:C55A  AD 42 00    LDA clue_draw_address+1
  104  06:C55D  E9 00       SBC #$00
  105  06:C55F  8D 42 00    STA clue_draw_address+1
  106                       
  107  06:C562  60          RTS
  108                       
  109  06:C563            AddToClueDrawAddressHi:
  110                     
  111  06:C563  8D 00 00    STA temp1
  112                       
  113  06:C566  AD 42 00    LDA clue_draw_address+1
  114  06:C569  6D 00 00    ADC temp1
  115  06:C56C  8D 42 00    STA clue_draw_address+1
  116                       
  117  06:C56F  60          RTS
  118                       
  119  06:C570            CreateOffsetFromIndex:
  120                     
  121                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  122  06:C570  AD 44 00    LDA clueLineIndex
  123  06:C573  8D 46 00    STA clueDrawOffset
  124  06:C576  A9 00       LDA #$00
  125  06:C578  8D 47 00    STA clueDrawOffset+1
  126                       
  127  06:C57B  AD 45 00    LDA clueOffsetShift   
  128  06:C57E  F0 0E       BEQ .addOffset
  129                       
  130  06:C580  A2 00       LDX #$00
  131                       
  132  06:C582            .loopShift:
  133  06:C582  0E 46 00    ASL clueDrawOffset
  134  06:C585  2E 47 00    ROL clueDrawOffset+1
  135  06:C588  E8          INX
  136  06:C589  EC 45 00    CPX clueOffsetShift
  137  06:C58C  D0 F4       BNE .loopShift
  138                       
  139  06:C58E            .addOffset:
  140                       
  141  06:C58E  20 2A C5    JSR ResetClueDrawAddress
  142  06:C591  AD 46 00    LDA clueDrawOffset
  143  06:C594  20 37 C5    JSR AddToClueDrawAddress 
  144  06:C597  AD 47 00    LDA clueDrawOffset+1
  145  06:C59A  20 63 C5    JSR AddToClueDrawAddressHi
  146                       
  147  06:C59D  60          RTS
#[1]   Picross.asm
   93                       
   94                       
   95                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   96                     ;;     NMI                  ;;
   97                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   98                     
#[2]   Routines/Common/NMI.asm
   99                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:C59E            NMI:
    3                     
    4  06:C59E  48          PHA                              ;protect the registers
    5  06:C59F  8A          TXA
    6  06:C5A0  48          PHA
    7  06:C5A1  98          TYA
    8  06:C5A2  48          PHA
    9                       
   10  06:C5A3            nmi_started:
   11  06:C5A3  A9 00       LDA #$00
   12  06:C5A5  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:C5A8  A9 02       LDA #$02
   14  06:C5AA  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:C5AD  AD 0A 00    LDA NMI_locks
   17  06:C5B0  F0 03       BEQ update_controllers
   18  06:C5B2  4C 11 C6    JMP WakeUp
   19                     
   20  06:C5B5            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:C5B5  8A            TXA
    3  06:C5B6  48                PHA
    4  06:C5B7  98                TYA
    5  06:C5B8  48                PHA
    6                     
    7  06:C5B9  A2 00             LDX #$00
    8                     
    9  06:C5BB            GamePadCheck:
   10  06:C5BB  A9 01             LDA #$01        ;load 1
   11  06:C5BD  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:C5C0  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:C5C1  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:C5C4  A9 80             LDA #$80
   18  06:C5C6  8D 12 00          STA gamepad
   19                     
   20  06:C5C9            ReadControllerABytesLoop:
   21  06:C5C9  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:C5CC  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:C5CE  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:C5D0  6E 12 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:C5D3  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:C5D5  AD 13 00          LDA gamepadLast
   31  06:C5D8  49 FF             EOR #$FF
   32  06:C5DA  2D 12 00          AND gamepad
   33  06:C5DD  8D 14 00          STA gamepadPressed
   34                             
   35                             
   36  06:C5E0  AD 12 00          LDA gamepad
   37  06:C5E3  8D 13 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:C5E6  68                PLA
   41  06:C5E7  A8                TAY
   42  06:C5E8  68                PLA
   43  06:C5E9  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:C5EA  20 7D C3    JSR ProcessPPUString
   25                       
   26                       
   27  06:C5ED  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:C5EF  8D 05 20    STA PPU_SCROLL
   29  06:C5F2  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33                       MACROSetPPUControl %10010000, %00011110 
                          
       06:C5F5  A9 90       LDA #%10010000  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
       06:C5F7  8D 00 20    STA PPU_CTRL
       06:C5FA  A9 1E       LDA #%00011110   ; enable sprites, enable background, no clipping on left side
       06:C5FC  8D 01 20    STA PPU_MASK
                                  
   34                     
   35  06:C5FF            NMIUpdate:
   36                     
   37  06:C5FF  20 05 C6    JSR StateNMIUpdate
   38  06:C602  4C 11 C6    JMP WakeUp
   39                     
   40  06:C605            StateNMIUpdate:
   41                     
   42                       MACROCallDynamicJump game_mode
                          
       06:C605  AD 08 00    LDA game_mode
       06:C608  20 F7 C2    JSR Dynamic_Jump
                                  
   43                     
   44  06:C60B            NMIJumpTable:
   45                     
   46  06:C60B  1C C6       .word UpdateTitleNMI
   47  06:C60D  30 C6       .word UpdateGameNMI
   48  06:C60F  31 C6       .word UpdateGameOverNMI
   49                     
   50  06:C611            WakeUp:
   51  06:C611  A9 00       LDA #$00
   52  06:C613  8D 07 00    STA sleeping
   53                       
   54  06:C616  68          PLA             ;restore the registers
   55  06:C617  A8          TAY 
   56  06:C618  68          PLA
   57  06:C619  AA          TAX
   58  06:C61A  68          PLA
   59                     
   60  06:C61B  40          RTI             ; return from interrupt
   61                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   62                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:C61C            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4  06:C61C  20 5B C4    JSR ResetMapper
    5  06:C61F  A9 01       LDA #$01
    6  06:C621  20 80 C4    JSR LoadCHRBankB
    7                                     
    8  06:C624  20 2F C4    JSR DetectSprite0
    9                     
   10  06:C627  20 5B C4    JSR ResetMapper
   11  06:C62A  A9 03       LDA #$03
   12  06:C62C  20 80 C4    JSR LoadCHRBankB
   13                       
   14  06:C62F  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   63                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:C630            UpdateGameNMI:
    2  06:C630  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   64                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:C631            UpdateGameOverNMI:
    2  06:C631  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
  100                       
  101                     ;;**************************;;
  102                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  103                     ;;       PRG ROM DATA       ;;
  104                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  105                     ;;**************************;; 
  106                       
  107           0007        .bank 7
  108           E000        .org $E000
  109                     
#[2]   NameTables/Tables.asm
  110                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  0C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  2C E0     
       07:E004  4C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  6C E0       .word Title_Screen, Game_Screen, GameOver_Screen
       07:E008  6C E4     
       07:E00A  6C E8     
    8                     
    9  07:E00C            Title_Palette:
   10                     
   11  07:E00C              .incbin "NameTables/Title_PAL.pal"
   12  07:E01C              .incbin "NameTables/Title_PAL.pal"
   13                       
   14  07:E02C            Game_Palette:
   15                     
   16  07:E02C              .incbin "NameTables/Game_PAL.pal"
   17  07:E03C              .incbin "NameTables/Game_PAL.pal"
   18                       
   19  07:E04C            GameOver_Palette:
   20                     
   21  07:E04C              .incbin "NameTables/GameOver_PAL.pal"
   22  07:E05C              .incbin "NameTables/GameOver_PAL.pal"
   23                       
   24  07:E06C            Title_Screen:
   25                     
   26  07:E06C              .incbin "NameTables/Title_NT.nam"
   27                       
   28  07:E46C            Game_Screen: 
   29                     
   30  07:E46C              .incbin "NameTables/Game_NT.nam"
   31                       
   32  07:E86C            GameOver_Screen:
   33                     
   34  07:E86C              .incbin "NameTables/Game_NT.nam"
   35                       
   36                     
   37                       
   38                      
   39                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  111                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:EC6C            Sprites:
   38  07:EC6C  72 EC             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:EC6E  76 EC     
       07:EC70  7A EC     
   39                     
   40  07:EC72            Title_Sprites:
   41  07:EC72  90 00 00          .db $90,$00,$00,$E8
       07:EC75  E8        
   42  07:EC76            Game_Sprites:
   43  07:EC76  62 00 03          .db $62,$00,$03,$72
       07:EC79  72        
   44  07:EC7A            GameOver_Sprites:
   45  07:EC7A  00 00 00          .db $00,$00,$00,$00
       07:EC7D  00        
#[1]   Picross.asm
  112                     
  113           FFFA        .org $FFFA     ;first of the three vectors starts here
  114  07:FFFA  9E C5       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  115                                        ;processor will jump to the label NMI:
  116  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  117                                        ;to the label RESET:
  118  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  119                       
  120                     ;;**************************;;
  121                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122                     ;;      CHR ROM DATA        ;;
  123                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  124                     ;;**************************;; 
  125                       
  126           0008        .bank 8
  127           0000        .org $0000
  128  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  129                       
  130           0009        .bank 9
  131           0000        .org $0000
  132  09:0000              .incbin "CHRROM/Bank1.chr"
  133                       
  134           000A        .bank 10
  135           0000        .org $0000
  136  0A:0000              .incbin "CHRROM/Bank2.chr"
  137                       
  138           000B        .bank 11
  139           0000        .org $0000
  140  0B:0000              .incbin "CHRROM/Bank3.chr"
