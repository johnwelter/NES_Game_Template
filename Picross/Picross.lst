#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      tempx                   .rs 1
    6           0005      tempy                   .rs 1
    7           0006      time                    .rs 1
    8           0007      sleeping                .rs 1
    9           0008      game_mode               .rs 1
   10           0009      mode_state              .rs 1
   11           000A      NMI_locks               .rs 1
   12           000B      game_locks              .rs 1
   13           000C      pointer_address .rs 2
   14           000E      table_address   .rs 2
   15           0010      jump_address    .rs 2
   16                     
   17                     ;game modes
   18           0000      TITLE_IDX = $00
   19           0001      GAME_IDX = $01
   20           0002      GAMEOVER_IDX = $02
   21                     
   22                     ;locks for input and rendering
   23           0001      BGLOAD_NMI_LOCK = %00000001
   24           0001      EFFECT_GAME_LOCK = %00000001
   25                     
   26                     
   27                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           0012      gamepad                 .rs 1
   19           0013      gamepadLast     .rs 1
   20           0014      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           0015      PPU_Control                     .rs 1
    2           0016      PPU_Mask                        .rs 1
    3           0017      PPU_ScrollX                     .rs 1
    4           0018      PPU_ScrollY                     .rs 1
    5           0019      PPU_ScrollNT            .rs 1   ;first two bits
    6           001A      PPU_NT                          .rs 1
    7                     
    8           001B      PPU_PendingWrite        .rs 1
    9           001C      PPU_StringIdx           .rs 1
   10           001D      PPU_String                      .rs 32
   11                     
   12           0020      PPU_STRINGMAX = $20 ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           003D      mapper_address  .rs 2
    2           003F      currentCHRBankA .rs 1
    3           0040      currentCHRBankB .rs 1
    4           0041      currentPRGBank  .rs 1
    5           0042      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1           0043      bank_index      .rs 1
    2           0044      puzzle_index .rs 1
    3                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           0045      puzzle_address          .rs 2
    2           0047      clues_address           .rs 2
    3           0049      clue_start_address      .rs 2
    4           004B      clue_draw_address       .rs 2
    5           004D      clueTableIndex          .rs 1
    6           004E      clueLineIndex           .rs 1
    7           004F      clueOffsetShift         .rs 1
    8           0050      clueDrawOffset          .rs 2
    9           0052      clueDrawAdd                     .rs 1
   10           0053      clueDrawDecSize         .rs 1
   11           0054      clueParity                      .rs 1
   12           0055      mouse_location          .rs 2
   13           0057      mouse_index                     .rs 2
   14           0059      currentPaintTile        .rs 1
   15           005A      solutionCount           .rs 1
   16           005B      nonSolutionCount        .rs 1
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/SaveVariables.asm
   18                       .include "Defines/SaveVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/ScreenStateVariables.asm
   19                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   20                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1           0000        .bank 0
    2           8000        .org $8000
    3                       
#[3]   Puzzles/house.asm
    4                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  03 82 00    .db $03, $82, $00, $01
       00:8003  01        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  11 18 1E    .db $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1C 0E FF  
#[2]   Banks/Bank0.asm
    5                     
    6           0001        .bank 1
    7           A000        .org $A000
    8                       
    9  01:A000  00 80       .word house
   10                       
   11           BFFA        .org $BFFA     ;first of the three vectors starts here
   12  01:BFFA  CC CA       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   13                                        ;processor will jump to the label NMI:
   14  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   15                                        ;to the label RESET:
   16  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  03 62 00    .db $03, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  0F 1B 18    .db $0F, $1B, $18, $10, $FF
       02:80A7  10 FF     
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                     
    9  03:A000  00 80       .word frog
   10                     
   11           BFFA        .org $BFFA     ;first of the three vectors starts here
   12  03:BFFA  CC CA       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   13                                        ;processor will jump to the label NMI:
   14  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   15                                        ;to the label RESET:
   16  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  03 7E 00    .db $03, $7E, $00, $0A
       04:8003  0A        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  0C 0A 1D    .db $0C, $0A, $1D, $FF
       04:80A5  FF        
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8  05:A000  00 80       .word cat
    9                     
   10           BFFA        .org $BFFA     ;first of the three vectors starts here
   11  05:BFFA  CC CA       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   12                                        ;processor will jump to the label NMI:
   13  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   14                                        ;to the label RESET:
   15  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 94 C8    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 98 C8    JSR SetMapperControls
   34                       
   35  06:C040  20 D5 C8    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  20 FD C5    JSR ChangeGameMode
   38  06:C04D  20 6B C8    JSR InitPPUControl
   39                       
   40                     
   41                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   42                     ;;     Main Program         ;;
   43                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   44                     
   45  06:C050            Forever:
   46                     
   47  06:C050  EE 07 00    INC sleeping
   48                     
   49  06:C053            .loop
   50  06:C053  AD 07 00    LDA sleeping
   51  06:C056  D0 FB       BNE .loop
   52                       
   53  06:C058  20 61 C0    JSR GameLoop
   54  06:C05B  EE 06 00    INC time
   55                     
   56  06:C05E  4C 50 C0    JMP Forever     ;jump back to Forever, infinite loop
   57                       
   58                     ;; dynamic jump table
   59                     
   60  06:C061            GameLoop:
   61                     
   62                       MACROCallDynamicJump game_mode
                          
       06:C061  AD 08 00    LDA game_mode
       06:C064  20 AD C6    JSR Dynamic_Jump
                                  
   63                       ;; we'll pop the return address here as the table index, so 
   64                       ;; the routine we pick will return us to whatever called Game Loop
   65                       ;; when it returns
   66                     
   67  06:C067            GameLoopJumpTable:
   68                     
   69  06:C067  6D C0       .word UpdateTitle
   70  06:C069  4D C2       .word UpdateGame
   71  06:C06B  EA C5       .word UpdateGameOver
   72                       
   73                     
   74                       ;;RTS is called in the subroutine
   75                     
   76                       
#[2]   Routines/Game_States/UpdateTitle.asm
   77                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C06D            UpdateTitle:
    2                     
    3  06:C06D  AD 0A 00    LDA NMI_locks
    4  06:C070  F0 01       BEQ .unlocked
    5                       
    6  06:C072  60          RTS
    7                       
    8  06:C073            .unlocked:
    9                     
   10  06:C073  20 77 C0    JSR DoUpdateTitle  
   11  06:C076  60          RTS
   12                       
   13  06:C077            DoUpdateTitle:
   14                     
   15  06:C077  AD 09 00    LDA mode_state
   16  06:C07A  20 AD C6    JSR Dynamic_Jump
   17                         
   18  06:C07D            UpdateTitleJumpTable:
   19                     
   20  06:C07D  89 C0       .word UpdateTitleInit
   21  06:C07F  9A C0       .word UpdateBankSelection
   22  06:C081  B3 C0       .word UpdateScroll
   23  06:C083  D5 C0       .word UpdatePuzzleSelection
   24  06:C085  12 C1       .word UpdateScrollBack
   25  06:C087  2F C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2, BANK3
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C089            UpdateTitleInit:
   35                     
   36  06:C089  20 47 C8    JSR TurnOnSprites
   37                       
   38  06:C08C  A9 00       LDA #$00
   39  06:C08E  8D 57 00    STA mouse_index
   40  06:C091  A9 00       LDA #$00
   41  06:C093  8D 58 00    STA mouse_index+1
   42                     
   43  06:C096            .changeModeState:
   44                     
   45  06:C096  EE 09 00    INC mode_state
   46  06:C099            .leave:
   47  06:C099  60          RTS
   48                       
   49  06:C09A            UpdateBankSelection:
   50                     
   51  06:C09A  20 A6 C1    JSR UpdateBankPointer
   52                       
   53  06:C09D  AD 14 00    LDA gamepadPressed
   54  06:C0A0  29 01       AND #GAMEPAD_A
   55  06:C0A2  F0 0E       BEQ .leave
   56                       
   57  06:C0A4            .changeModeState:
   58                     
   59  06:C0A4  AD 57 00    LDA mouse_index
   60  06:C0A7  8D 43 00    STA bank_index
   61  06:C0AA  A9 FF       LDA #$FF
   62  06:C0AC  20 8E C1    JSR SetPointerSprite
   63                       
   64  06:C0AF  EE 09 00    INC mode_state
   65  06:C0B2            .leave:
   66  06:C0B2  60          RTS
   67                       
   68  06:C0B3            UpdateScroll:
   69  06:C0B3  EE 17 00    INC PPU_ScrollX
   70  06:C0B6  EE 17 00    INC PPU_ScrollX
   71  06:C0B9  EE 17 00    INC PPU_ScrollX
   72  06:C0BC  EE 17 00    INC PPU_ScrollX
   73  06:C0BF  D0 13       BNE .leave
   74  06:C0C1  AD 19 00    LDA PPU_ScrollNT
   75  06:C0C4  49 01       EOR #%00000001
   76  06:C0C6  8D 19 00    STA PPU_ScrollNT
   77                       
   78  06:C0C9            .changeModeState:
   79  06:C0C9  A9 01       LDA #$01
   80  06:C0CB  20 8E C1    JSR SetPointerSprite
   81  06:C0CE  20 54 C1    JSR InitPuzzlePointer
   82  06:C0D1  EE 09 00    INC mode_state
   83  06:C0D4            .leave:
   84  06:C0D4  60          RTS
   85                       
   86  06:C0D5            UpdatePuzzleSelection:
   87                     
   88  06:C0D5  20 E2 C1    JSR UpdatePuzzlePointer
   89                       
   90  06:C0D8  AD 14 00    LDA gamepadPressed
   91  06:C0DB  29 02       AND #GAMEPAD_B
   92  06:C0DD  D0 15       BNE .changeToScrollBack
   93  06:C0DF  AD 14 00    LDA gamepadPressed
   94  06:C0E2  29 09       AND #GAMEPAD_CONFIRM
   95  06:C0E4  F0 2B       BEQ .leave
   96                       
   97                       ;on start, get the 2D mouse index into a 1D index- then store in puzzle_index
   98                       ;for now, we only have one puzzle each, just store 0
   99  06:C0E6  A9 00       LDA #$00
  100  06:C0E8  8D 44 00    STA puzzle_index
  101  06:C0EB  EE 09 00    INC mode_state
  102  06:C0EE  EE 09 00    INC mode_state
  103  06:C0F1  4C 11 C1    JMP .leave
  104                       
  105  06:C0F4            .changeToScrollBack:
  106                      
  107  06:C0F4  A9 FF       LDA #$FF
  108  06:C0F6  20 8E C1    JSR SetPointerSprite
  109  06:C0F9  20 4C C1    JSR InitBankPointer
  110                       
  111  06:C0FC  A9 00       LDA #$00
  112  06:C0FE  8D 18 00    STA PPU_ScrollY
  113  06:C101  A9 FC       LDA #$FC
  114  06:C103  8D 17 00    STA PPU_ScrollX
  115  06:C106  AD 19 00    LDA PPU_ScrollNT
  116  06:C109  29 FE       AND #$FE
  117  06:C10B  8D 19 00    STA PPU_ScrollNT
  118                       
  119  06:C10E  EE 09 00    INC mode_state
  120  06:C111            .leave:
  121  06:C111  60          RTS
  122                       
  123  06:C112            UpdateScrollBack:
  124                     
  125  06:C112  CE 17 00    DEC PPU_ScrollX
  126  06:C115  CE 17 00    DEC PPU_ScrollX
  127  06:C118  CE 17 00    DEC PPU_ScrollX
  128  06:C11B  CE 17 00    DEC PPU_ScrollX
  129  06:C11E  D0 0E       BNE .leave
  130                       
  131  06:C120            .changeModeState:
  132                     
  133  06:C120  A9 01       LDA #$01
  134  06:C122  20 8E C1    JSR SetPointerSprite
  135  06:C125  CE 09 00    DEC mode_state
  136  06:C128  CE 09 00    DEC mode_state
  137  06:C12B  CE 09 00    DEC mode_state
  138                       
  139  06:C12E            .leave:
  140  06:C12E  60          RTS
  141                       
  142  06:C12F            UpdateTitleExit:
  143                     
  144                       ;;reset screen scroll
  145  06:C12F  A9 00       LDA #$00
  146  06:C131  8D 17 00    STA PPU_ScrollX
  147  06:C134  8D 19 00    STA PPU_ScrollNT
  148                       
  149                       ;;load bank
  150                     
  151  06:C137  20 94 C8    JSR ResetMapper
  152  06:C13A  AD 43 00    LDA bank_index
  153  06:C13D  8D 41 00    STA currentPRGBank
  154  06:C140  20 A3 C8    JSR LoadPRGBank
  155                         
  156  06:C143  20 50 C8    JSR TurnOffSprites
  157                             
  158  06:C146  A9 01       LDA #GAME_IDX
  159  06:C148  20 FD C5    JSR ChangeGameMode
  160                       
  161  06:C14B            .leave
  162  06:C14B  60          RTS
  163                       
  164  06:C14C            InitBankPointer:
  165                     
  166  06:C14C  A2 A0       LDX #$A0
  167  06:C14E  A9 60       LDA #$60
  168  06:C150  20 67 C1    JSR InitPointer
  169                       
  170  06:C153  60          RTS  
  171                       
  172  06:C154            InitPuzzlePointer:
  173                       
  174  06:C154  A2 AE       LDX #$AE
  175  06:C156  A9 10       LDA #$10
  176  06:C158  20 67 C1    JSR InitPointer
  177                       
  178  06:C15B  60          RTS
  179                     
  180  06:C15C            ResetMouseIndex:
  181                     
  182  06:C15C  A9 00       LDA #$00
  183  06:C15E  8D 57 00    STA mouse_index
  184  06:C161  A9 00       LDA #$00
  185  06:C163  8D 58 00    STA mouse_index+1
  186  06:C166  60          RTS
  187                     
  188  06:C167            InitPointer:
  189                     
  190  06:C167  20 6E C1    JSR SetPointerPosition
  191  06:C16A  20 5C C1    JSR ResetMouseIndex
  192  06:C16D  60          RTS  
  193                       
  194  06:C16E            SetPointerPosition:
  195                     
  196  06:C16E  48          PHA
  197  06:C16F  8A          TXA
  198  06:C170  20 78 C1    JSR SetPointerYPosition
  199  06:C173  68          PLA
  200  06:C174  20 83 C1    JSR SetPointerXPosition
  201                      
  202  06:C177  60          RTS
  203                       
  204  06:C178            SetPointerYPosition:
  205                       
  206  06:C178  48          PHA
  207  06:C179  A9 00       LDA #SPRITE_YPOS
  208  06:C17B  20 99 C1    JSR GetPointerDataIndexInX
  209  06:C17E  68          PLA
  210  06:C17F  9D 00 02    STA SPRITE_DATA, x
  211  06:C182  60          RTS
  212                       
  213  06:C183            SetPointerXPosition:  
  214                       
  215  06:C183  48          PHA
  216  06:C184  A9 03       LDA #SPRITE_XPOS
  217  06:C186  20 99 C1    JSR GetPointerDataIndexInX
  218  06:C189  68          PLA
  219  06:C18A  9D 00 02    STA SPRITE_DATA, x 
  220  06:C18D  60          RTS
  221                     
  222  06:C18E            SetPointerSprite:
  223                     
  224                     ;; A has aprite we want
  225  06:C18E  48          PHA
  226  06:C18F  A9 01       LDA #SPRITE_ID
  227  06:C191  20 99 C1    JSR GetPointerDataIndexInX
  228  06:C194  68          PLA
  229  06:C195  9D 00 02    STA SPRITE_DATA, x
  230  06:C198  60          RTS
  231                       
  232  06:C199            GetPointerDataIndexInX:
  233                     
  234  06:C199  8D 02 00    STA temp3
  235  06:C19C  A9 01       LDA #$01
  236  06:C19E  0A          ASL A
  237  06:C19F  0A          ASL A
  238  06:C1A0  18          CLC
  239  06:C1A1  6D 02 00    ADC temp3
  240  06:C1A4  AA          TAX
  241                       
  242  06:C1A5  60          RTS
  243                       
  244                       
  245  06:C1A6            UpdateBankPointer:
  246                      
  247                       ;;bank pointer is 1D, will loop between 0->3
  248  06:C1A6  AD 14 00    LDA gamepadPressed
  249  06:C1A9  F0 36       BEQ .leave 
  250                       
  251  06:C1AB  A9 00       LDA #$00
  252  06:C1AD  8D 00 00    STA temp1
  253                       
  254  06:C1B0            .parseInputs:
  255  06:C1B0  AD 14 00    LDA gamepadPressed
  256  06:C1B3  29 30       AND #GAMEPAD_VERT
  257  06:C1B5  F0 2A       BEQ .leave
  258  06:C1B7  0A          ASL A
  259  06:C1B8  0A          ASL A
  260  06:C1B9            .checkDown:
  261  06:C1B9  0A          ASL A
  262  06:C1BA  90 03       BCC .checkUp
  263  06:C1BC  EE 00 00    INC temp1
  264  06:C1BF            .checkUp:
  265  06:C1BF  0A          ASL A
  266  06:C1C0  90 03       BCC .move
  267  06:C1C2  CE 00 00    DEC temp1
  268  06:C1C5            .move:
  269                       
  270  06:C1C5  AD 57 00    LDA mouse_index
  271  06:C1C8  18          CLC
  272  06:C1C9  6D 00 00    ADC temp1
  273  06:C1CC  C9 02       CMP #$02
  274  06:C1CE  F0 04       BEQ .skipMod
  275  06:C1D0  90 02       BCC .skipMod
  276  06:C1D2  A9 00       LDA #$00
  277  06:C1D4            .skipMod:
  278  06:C1D4  8D 57 00    STA mouse_index
  279                       ;; mult mouse_index by 16
  280  06:C1D7  0A          ASL A
  281  06:C1D8  0A          ASL A
  282  06:C1D9  0A          ASL A
  283  06:C1DA  0A          ASL A
  284  06:C1DB  18          CLC
  285  06:C1DC  69 A0       ADC #$A0
  286  06:C1DE  20 78 C1    JSR SetPointerYPosition
  287                     
  288  06:C1E1            .leave:
  289                       
  290  06:C1E1  60          RTS
  291                       
  292  06:C1E2            UpdatePuzzlePointer:
  293                     
  294                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  295  06:C1E2  AD 14 00    LDA gamepadPressed
  296  06:C1E5  F0 65       BEQ .leave 
  297                       
  298  06:C1E7  A9 00       LDA #$00
  299  06:C1E9  8D 00 00    STA temp1
  300  06:C1EC  8D 01 00    STA temp2
  301                       
  302  06:C1EF            .parseInputs:
  303  06:C1EF  AD 14 00    LDA gamepadPressed
  304  06:C1F2  29 F0       AND #GAMEPAD_MOVE
  305  06:C1F4  F0 56       BEQ .leave
  306  06:C1F6  0A          ASL A
  307  06:C1F7  90 03       BCC .checkLeft
  308  06:C1F9  EE 00 00    INC temp1
  309  06:C1FC            .checkLeft:
  310  06:C1FC  0A          ASL A
  311  06:C1FD  90 03       BCC .checkDown
  312  06:C1FF  CE 00 00    DEC temp1
  313  06:C202            .checkDown:
  314  06:C202  0A          ASL A
  315  06:C203  90 03       BCC .checkUp
  316  06:C205  EE 01 00    INC temp2
  317  06:C208            .checkUp:
  318  06:C208  0A          ASL A
  319  06:C209  90 03       BCC .move
  320  06:C20B  CE 01 00    DEC temp2
  321                       
  322  06:C20E            .move:
  323                     
  324  06:C20E  AD 57 00    LDA mouse_index
  325  06:C211  18          CLC
  326  06:C212  6D 01 00    ADC temp2
  327  06:C215  C9 02       CMP #$02
  328  06:C217  F0 04       BEQ .skipYMod
  329  06:C219  90 02       BCC .skipYMod
  330  06:C21B  A9 00       LDA #$00
  331  06:C21D            .skipYMod:
  332  06:C21D  8D 57 00    STA mouse_index
  333                       ;; mult mouse_index by 16
  334  06:C220  0A          ASL A
  335  06:C221  0A          ASL A
  336  06:C222  0A          ASL A
  337  06:C223  0A          ASL A
  338  06:C224  18          CLC
  339  06:C225  69 AE       ADC #$AE
  340  06:C227  20 78 C1    JSR SetPointerYPosition
  341                       
  342  06:C22A  AD 58 00    LDA mouse_index+1
  343  06:C22D  18          CLC
  344  06:C22E  6D 00 00    ADC temp1
  345  06:C231  C9 08       CMP #$08
  346  06:C233  F0 04       BEQ .skipXMod
  347  06:C235  90 02       BCC .skipXMod
  348  06:C237  A9 00       LDA #$00
  349  06:C239            .skipXMod:
  350  06:C239  8D 58 00    STA mouse_index+1
  351                       ;; we need to move 3 tiles each- so index * 3 * 8,
  352  06:C23C  18          CLC
  353  06:C23D  6D 58 00    ADC mouse_index+1
  354  06:C240  6D 58 00    ADC mouse_index+1
  355  06:C243  0A          ASL A
  356  06:C244  0A          ASL A
  357  06:C245  0A          ASL A
  358  06:C246  18          CLC
  359  06:C247  69 10       ADC #$10
  360  06:C249  20 83 C1    JSR SetPointerXPosition
  361                       
  362  06:C24C            .leave:
  363                       
  364  06:C24C  60          RTS
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   78                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6                     
    7                     ;;this will change with puzzle sizes
    8           005A      VERT_MIN = $5A ;12 - 1
    9           00DA      VERT_MAX = $DA
   10           006A      HORI_MIN = $6A ;14 - 1
   11           00EA      HORI_MAX = $EA
   12                     
   13           618E      MOUSE_START = $618E
   14                     
   15  06:C24D            UpdateGame:
   16                     
   17  06:C24D  AD 0A 00    LDA NMI_locks
   18  06:C250  F0 01       BEQ .unlocked
   19                       
   20  06:C252  60          RTS
   21                       
   22  06:C253            .unlocked:
   23                     
   24  06:C253  20 57 C2    JSR DoUpdateGame
   25  06:C256  60          RTS
   26                       
   27  06:C257            DoUpdateGame:
   28                     
   29  06:C257  AD 09 00    LDA mode_state
   30  06:C25A  20 AD C6    JSR Dynamic_Jump
   31                       
   32  06:C25D            UpdateGameJumpTable:
   33                     
   34  06:C25D  6F C2       .word UpdateGameInit
   35  06:C25F  D6 C2       .word UpdateDrawVertClues
   36  06:C261  FE C2       .word UpdateDrawHoriClues
   37  06:C263  0A C3       .word UpdateGamePlay
   38  06:C265  55 C4       .word UpdateClearPuzzle
   39  06:C267  68 C4       .word UpdateMoveScreen
   40  06:C269  CE C4       .word UpdateDrawImage
   41  06:C26B  3B C5       .word UpdateWaitInput
   42  06:C26D  44 C5       .word UpdateGameExit
   43                     
   44  06:C26F            UpdateGameInit:
   45                     
   46                       ;; get the puzzle table in the puzzle address
   47                       MACROGetLabelPointer $A000, table_address
                          
       06:C26F  A9 A0             LDA #HIGH($A000)
       06:C271  A2 00             LDX #LOW($A000)
                                  
       06:C273  8E 0E 00          STX table_address
       06:C276  8D 0F 00          STA table_address+1
                                  
   48                       MACROGetDoubleIndex #$00
                          
       06:C279  A9 00             LDA #$00
       06:C27B  0A                ASL A
       06:C27C  A8                TAY
                                  
   49  06:C27D  20 D3 C6    JSR GetTableAtIndex
   50                       MACROGetPointer table_address, puzzle_address
                          
       06:C280  AD 0E 00          LDA table_address
       06:C283  8D 45 00          STA puzzle_address
       06:C286  AD 0F 00          LDA table_address+1
       06:C289  8D 46 00          STA puzzle_address+1
                          
   51                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C28C  A9 61             LDA #HIGH(MOUSE_START)
       06:C28E  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C290  8E 55 00          STX mouse_location
       06:C293  8D 56 00          STA mouse_location+1
                                  
   52                       
   53                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   54  06:C296  AD 45 00    LDA puzzle_address
   55  06:C299  18          CLC
   56  06:C29A  69 22       ADC #34
   57  06:C29C  8D 47 00    STA clues_address
   58  06:C29F  A9 00       LDA #$00
   59  06:C2A1  6D 46 00    ADC puzzle_address+1
   60  06:C2A4  8D 48 00    STA clues_address+1
   61                     
   62  06:C2A7  A9 00       LDA #$00
   63  06:C2A9  8D 4D 00    STA clueTableIndex
   64  06:C2AC  8D 4E 00    STA clueLineIndex
   65  06:C2AF  8D 54 00    STA clueParity
   66  06:C2B2  8D 4F 00    STA clueOffsetShift
   67  06:C2B5  8D 57 00    STA mouse_index
   68  06:C2B8  8D 58 00    STA mouse_index+1
   69  06:C2BB  8D 5A 00    STA solutionCount
   70  06:C2BE  8D 5B 00    STA nonSolutionCount
   71                       
   72  06:C2C1  A9 20       LDA #$20
   73  06:C2C3  8D 52 00    STA clueDrawAdd
   74                        
   75                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C2C6  A9 21             LDA #HIGH(VERT_CLUES)
       06:C2C8  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C2CA  8E 49 00          STX clue_start_address
       06:C2CD  8D 4A 00          STA clue_start_address+1
                                  
   76  06:C2D0  20 63 C9    JSR ResetClueDrawAddress
   77                         
   78  06:C2D3  EE 09 00    INC mode_state
   79                     
   80  06:C2D6            UpdateDrawVertClues:
   81                       
   82  06:C2D6  20 EB C8    JSR PopulateClues
   83  06:C2D9  90 22       BCC .leave
   84                       
   85  06:C2DB            .changeModeState:
   86                     
   87  06:C2DB  A9 00       LDA #$00
   88  06:C2DD  8D 4E 00    STA clueLineIndex
   89  06:C2E0  8D 54 00    STA clueParity
   90                       
   91  06:C2E3  A9 05       LDA #$05
   92  06:C2E5  8D 4F 00    STA clueOffsetShift
   93                       
   94  06:C2E8  A9 01       LDA #$01
   95  06:C2EA  8D 52 00    STA clueDrawAdd
   96                        
   97                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C2ED  A9 21             LDA #HIGH(HORI_CLUES)
       06:C2EF  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C2F1  8E 49 00          STX clue_start_address
       06:C2F4  8D 4A 00          STA clue_start_address+1
                                  
   98  06:C2F7  20 63 C9    JSR ResetClueDrawAddress
   99                     
  100  06:C2FA  EE 09 00    INC mode_state
  101  06:C2FD            .leave:
  102  06:C2FD  60          RTS
  103                       
  104  06:C2FE            UpdateDrawHoriClues:
  105                     
  106  06:C2FE  20 EB C8    JSR PopulateClues
  107  06:C301  90 06       BCC .leave
  108                     
  109  06:C303            .changeModeState:
  110  06:C303  20 47 C8    JSR TurnOnSprites
  111  06:C306  EE 09 00    INC mode_state
  112  06:C309            .leave:
  113  06:C309  60          RTS
  114                       
  115  06:C30A            UpdateGamePlay:
  116                         
  117  06:C30A  A9 00       LDA #$00
  118  06:C30C  8D 00 00    STA temp1
  119  06:C30F  8D 01 00    STA temp2
  120  06:C312  8D 02 00    STA temp3
  121                     
  122                       
  123  06:C315  AD 14 00    LDA gamepadPressed
  124  06:C318  F0 6A       BEQ .updatePaint  
  125                       
  126  06:C31A            .parseInputs:
  127                     
  128  06:C31A  29 F0       AND #GAMEPAD_MOVE
  129  06:C31C  F0 1E       BEQ .checkPaintPress
  130  06:C31E  0A          ASL A
  131  06:C31F  90 03       BCC .checkLeft
  132  06:C321  EE 00 00    INC temp1
  133  06:C324            .checkLeft:
  134  06:C324  0A          ASL A
  135  06:C325  90 03       BCC .checkDown
  136  06:C327  CE 00 00    DEC temp1
  137  06:C32A            .checkDown:
  138  06:C32A  0A          ASL A
  139  06:C32B  90 03       BCC .checkUp
  140  06:C32D  EE 01 00    INC temp2
  141  06:C330            .checkUp:
  142  06:C330  0A          ASL A
  143  06:C331  90 03       BCC .move
  144  06:C333  CE 01 00    DEC temp2
  145                       
  146  06:C336            .move:
  147                      
  148  06:C336  20 55 C5    JSR MoveMouse
  149  06:C339  20 96 C5    JSR UpdateMouseScreenPos
  150                       
  151  06:C33C            .checkPaintPress:
  152                     
  153  06:C33C  AD 14 00    LDA gamepadPressed
  154  06:C33F  29 03       AND #GAMEPAD_AB
  155  06:C341  F0 41       BEQ .updatePaint
  156                       ;;A or B pressed, get current tile
  157                       
  158  06:C343  8D 00 00    STA temp1
  159                       
  160  06:C346  A0 00       LDY #$00
  161  06:C348  B1 55       LDA [mouse_location], y
  162  06:C34A  8D 01 00    STA temp2
  163                       
  164                         ;;A treats X and Clear as clear
  165                             ;;B treats mark and clear as clear
  166                             ;;clear->mark->x
  167                             
  168                     
  169  06:C34D  C9 7C       CMP #$7C      ;check if this is a marked tile
  170  06:C34F  B0 0F       BCS .getClearTile
  171                       ;;cleared tile- store off marked tile to paint with instead
  172                       ;;not a clear tile- a mark or an x - check A or B  
  173  06:C351  4E 00 00    LSR temp1
  174  06:C354  B0 05       BCS .getMarkTile
  175                       
  176  06:C356            .getXTile:
  177  06:C356  A9 80       LDA #$80
  178  06:C358  4C 7E C3    JMP .finishGetTile
  179                       
  180  06:C35B            .getMarkTile:
  181  06:C35B  A9 70       LDA #$70
  182  06:C35D  4C 7E C3    JMP .finishGetTile
  183                     
  184  06:C360            .getClearTile:
  185                       
  186  06:C360  4E 00 00    LSR temp1
  187  06:C363  90 0A       BCC .checkB
  188  06:C365  AD 01 00    LDA temp2
  189  06:C368  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  190  06:C36A  90 0D       BCC .clearTile
  191  06:C36C  4C 5B C3    JMP .getMarkTile
  192                       
  193  06:C36F            .checkB:
  194                       
  195  06:C36F  AD 01 00   LDA temp2
  196  06:C372  C9 8C      CMP #$8C
  197  06:C374  B0 03      BCS .clearTile
  198  06:C376  4C 56 C3   JMP .getXTile
  199                       
  200  06:C379            .clearTile:
  201  06:C379  A9 60       LDA #$60
  202  06:C37B  4C 7E C3    JMP .finishGetTile
  203                       
  204  06:C37E            .finishGetTile:
  205  06:C37E  8D 59 00    STA currentPaintTile
  206  06:C381  4C 8C C3    JMP .setTile
  207                     
  208                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  209                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  210                     ;;we can load the nametable into memory as we draw it
  211                     
  212  06:C384            .updatePaint:
  213                     
  214  06:C384  AD 12 00    LDA gamepad
  215  06:C387  29 03       AND #GAMEPAD_AB
  216  06:C389  D0 01       BNE .setTile
  217  06:C38B  60          RTS  
  218                       
  219  06:C38C            .setTile:
  220                     
  221                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  222  06:C38C  AD 58 00    LDA mouse_index+1
  223  06:C38F  0A          ASL A
  224  06:C390  18          CLC
  225  06:C391  69 04       ADC #$04 ;; add to get past header
  226  06:C393  8D 00 00    STA temp1
  227                       
  228                       ;;div X position by 8 to get the byte index
  229  06:C396  AD 57 00    LDA mouse_index
  230  06:C399  4A          LSR A
  231  06:C39A  4A          LSR A
  232  06:C39B  4A          LSR A
  233  06:C39C  F0 03       BEQ .getMask
  234                       
  235  06:C39E  EE 00 00    INC temp1
  236                       
  237  06:C3A1            .getMask:
  238                       
  239  06:C3A1  AD 57 00    LDA mouse_index
  240  06:C3A4  29 07       AND #$07
  241  06:C3A6  AA          TAX
  242  06:C3A7  A9 80       LDA #$80
  243  06:C3A9  E0 00       CPX #$00
  244  06:C3AB  F0 04       BEQ .storeMask
  245                     
  246  06:C3AD            .maskLoop:
  247  06:C3AD  4A          LSR A
  248  06:C3AE  CA          DEX
  249  06:C3AF  D0 FC       BNE .maskLoop
  250  06:C3B1            .storeMask:
  251  06:C3B1  8D 01 00    STA temp2
  252                     
  253  06:C3B4  AC 00 00    LDY temp1
  254  06:C3B7  B1 45       LDA [puzzle_address], y
  255  06:C3B9  2D 01 00    AND temp2
  256  06:C3BC  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  257                     
  258  06:C3BF  A0 00       LDY #$00
  259  06:C3C1  B1 55       LDA [mouse_location], y
  260  06:C3C3  8D 02 00    STA temp3
  261  06:C3C6  29 F0       AND #$F0
  262  06:C3C8  CD 59 00    CMP currentPaintTile
  263  06:C3CB  D0 01       BNE .diffTiles
  264  06:C3CD  60          RTS
  265                       
  266  06:C3CE            .diffTiles:
  267                       ;;tiles are different- check if the current tile is marked as a solution tile
  268  06:C3CE  C9 70       CMP #$70
  269  06:C3D0  D0 0B       BNE .checkNewMark
  270                       ;;if erasing a mark, check if the tile was part of the solution
  271  06:C3D2  AD 00 00    LDA temp1
  272  06:C3D5  D0 18       BNE .antiMark
  273  06:C3D7  CE 5B 00    DEC nonSolutionCount
  274  06:C3DA  4C F8 C3    JMP .overwriteTile
  275                       
  276  06:C3DD            .checkNewMark:
  277                     
  278  06:C3DD  AD 59 00    LDA currentPaintTile
  279  06:C3E0  C9 70       CMP #$70
  280  06:C3E2  D0 14       BNE .overwriteTile
  281                       
  282  06:C3E4  AD 00 00    LDA temp1
  283  06:C3E7  D0 0C       BNE .proMark
  284  06:C3E9  EE 5B 00    INC nonSolutionCount 
  285  06:C3EC  4C F8 C3    JMP .overwriteTile  
  286                       
  287  06:C3EF            .antiMark:
  288  06:C3EF  CE 5A 00    DEC solutionCount
  289  06:C3F2  4C F8 C3    JMP .overwriteTile
  290  06:C3F5            .proMark:   
  291                       
  292  06:C3F5  EE 5A 00    INC solutionCount
  293                       
  294  06:C3F8            .overwriteTile:
  295                       ;;overwrite tile
  296  06:C3F8  AD 02 00    LDA temp3
  297  06:C3FB  29 0F       AND #$0F
  298  06:C3FD  0D 59 00    ORA currentPaintTile
  299  06:C400  A0 00       LDY #$00
  300  06:C402  91 55       STA [mouse_location], y
  301  06:C404  8D 00 00    STA temp1
  302                       
  303  06:C407  AD 56 00    LDA mouse_location+1
  304  06:C40A  29 3F       AND #$3F
  305  06:C40C  8D 01 00    STA temp2
  306                         
  307                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C40F  A9 01       LDA #$01
       06:C411  8D 1B 00    STA PPU_PendingWrite
       06:C414  AD 01 00    LDA temp2
       06:C417  20 FF C7    JSR WriteToPPUString
       06:C41A  AD 55 00    LDA mouse_location
       06:C41D  20 FF C7    JSR WriteToPPUString
       06:C420  A9 00       LDA #DRAW_HORIZONTAL
       06:C422  20 FF C7    JSR WriteToPPUString
       06:C425  A9 01       LDA #$01 
       06:C427  20 FF C7    JSR WriteToPPUString
                            
  308  06:C42A  AD 00 00    LDA temp1
  309  06:C42D  20 FF C7    JSR WriteToPPUString
  310                       
  311  06:C430            .checkSolution: 
  312                     
  313  06:C430  A0 01       LDY #$01
  314  06:C432  B1 45       LDA [puzzle_address], y
  315  06:C434  CD 5A 00    CMP solutionCount
  316  06:C437  D0 1B       BNE .leave
  317  06:C439  AD 5B 00    LDA nonSolutionCount
  318  06:C43C  F0 03       BEQ .changeModeState
  319                       
  320  06:C43E  4C 54 C4    JMP .leave
  321                       
  322                       ;;update the painting
  323  06:C441            .changeModeState:
  324                      
  325  06:C441  20 50 C8    JSR TurnOffSprites
  326                        
  327  06:C444  A9 00       LDA #$00
  328  06:C446  8D 4B 00    STA clue_draw_address
  329  06:C449  8D 4E 00    STA clueLineIndex
  330  06:C44C  A9 20       LDA #$20
  331  06:C44E  8D 4C 00    STA clue_draw_address+1
  332                       
  333  06:C451  EE 09 00    INC mode_state
  334                     
  335  06:C454            .leave:
  336                      
  337  06:C454  60          RTS
  338                       
  339  06:C455            UpdateClearPuzzle:
  340                     
  341  06:C455  20 D7 C9    JSR ClearPuzzle
  342  06:C458  AD 4E 00    LDA clueLineIndex
  343  06:C45B  C9 1E       CMP #30
  344  06:C45D  D0 08       BNE .leave
  345                       
  346  06:C45F            .changeModeState:
  347                     
  348  06:C45F  A9 00       LDA #$00
  349  06:C461  8D 4E 00    STA clueLineIndex ;using this as a scroller
  350  06:C464  EE 09 00    INC mode_state
  351                     
  352  06:C467            .leave:
  353                      
  354  06:C467  60          RTS
  355  06:C468            UpdateMoveScreen:
  356                       
  357                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  358                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  359                       
  360  06:C468  AD 4E 00    LDA clueLineIndex
  361  06:C46B  29 10       AND #$10
  362  06:C46D  D0 1D       BNE .scrollY
  363                       
  364                       ;;scroll X over
  365  06:C46F  AD 4E 00    LDA clueLineIndex
  366  06:C472  29 0F       AND #$0F
  367  06:C474  0A          ASL A
  368  06:C475  0A          ASL A
  369  06:C476  0A          ASL A ;mult by 8
  370  06:C477  8D 17 00    STA PPU_ScrollX
  371                       
  372  06:C47A  EE 4E 00    INC clueLineIndex
  373  06:C47D  AD 4E 00    LDA clueLineIndex
  374  06:C480  C9 06       CMP #$06
  375  06:C482  D0 49       BNE .leave
  376  06:C484  A9 10       LDA #$10
  377  06:C486  8D 4E 00    STA clueLineIndex
  378  06:C489  4C CD C4    JMP .leave
  379                       
  380  06:C48C            .scrollY:
  381                     
  382  06:C48C  AD 4E 00    LDA clueLineIndex
  383  06:C48F  29 0F       AND #$0F
  384  06:C491  0A          ASL A
  385  06:C492  0A          ASL A
  386  06:C493  0A          ASL A ;mult by 8
  387  06:C494  8D 18 00    STA PPU_ScrollY
  388                     
  389  06:C497  EE 4E 00    INC clueLineIndex
  390  06:C49A  AD 4E 00    LDA clueLineIndex
  391  06:C49D  29 0F       AND #$0F
  392  06:C49F  C9 05       CMP #$05
  393  06:C4A1  D0 2A       BNE .leave
  394                       
  395  06:C4A3            .changeModeState:
  396                     
  397  06:C4A3  A9 8E       LDA #$8E
  398  06:C4A5  8D 4B 00    STA clue_draw_address
  399  06:C4A8  A9 21       LDA #$21
  400  06:C4AA  8D 4C 00    STA clue_draw_address+1
  401                       
  402  06:C4AD  AD 47 00    LDA clues_address
  403  06:C4B0  18          CLC
  404  06:C4B1  6D 4D 00    ADC clueTableIndex
  405  06:C4B4  8D 47 00    STA clues_address
  406  06:C4B7  AD 48 00    LDA clues_address+1
  407  06:C4BA  69 00       ADC #$00
  408  06:C4BC  8D 48 00    STA clues_address+1
  409                       
  410  06:C4BF  A9 00       LDA #$00
  411  06:C4C1  8D 4D 00    STA clueTableIndex
  412  06:C4C4  8D 4E 00    STA clueLineIndex
  413  06:C4C7  8D 4F 00    STA clueOffsetShift
  414                     
  415  06:C4CA  EE 09 00    INC mode_state
  416                     
  417  06:C4CD            .leave:
  418                      
  419  06:C4CD  60          RTS
  420  06:C4CE            UpdateDrawImage:
  421  06:C4CE  20 23 CA    JSR DrawImage
  422  06:C4D1  AD 4E 00    LDA clueLineIndex
  423  06:C4D4  C9 E1       CMP #225
  424  06:C4D6  D0 62       BNE .leave
  425                       
  426  06:C4D8            .changeModeState:
  427                     
  428                       ;;do a palette draw
  429                       ;;puzzle address + 03 has the desired palette offset
  430                     
  431  06:C4D8  A0 03       LDY #$03
  432  06:C4DA  B1 45       LDA [puzzle_address],y
  433  06:C4DC  29 0F       AND #$0F
  434  06:C4DE  AA          TAX
  435                       
  436  06:C4DF  B1 45       LDA [puzzle_address],y
  437  06:C4E1  29 10       AND #$10
  438  06:C4E3  D0 15       BNE .storeBottomVals
  439                       
  440  06:C4E5  8A          TXA
  441  06:C4E6  09 10       ORA #$10
  442  06:C4E8  8D 00 00    STA temp1
  443  06:C4EB  8A          TXA
  444  06:C4EC  09 20       ORA #$20
  445  06:C4EE  8D 01 00    STA temp2
  446  06:C4F1  8A          TXA
  447  06:C4F2  09 30       ORA #$30
  448  06:C4F4  8D 02 00    STA temp3
  449                     
  450  06:C4F7  4C 0C C5    JMP .loadPalToPPUStr
  451                       
  452  06:C4FA            .storeBottomVals:
  453                     
  454  06:C4FA  8A          TXA
  455  06:C4FB  09 00       ORA #$00
  456  06:C4FD  8D 00 00    STA temp1
  457  06:C500  8A          TXA
  458  06:C501  09 10       ORA #$10
  459  06:C503  8D 01 00    STA temp2
  460  06:C506  8A          TXA
  461  06:C507  09 20       ORA #$20
  462  06:C509  8D 02 00    STA temp3
  463                       
  464  06:C50C            .loadPalToPPUStr:
  465                       
  466                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C50C  A9 01       LDA #$01
       06:C50E  8D 1B 00    STA PPU_PendingWrite
       06:C511  A9 3F       LDA #$3F
       06:C513  20 FF C7    JSR WriteToPPUString
       06:C516  A9 01       LDA #$01
       06:C518  20 FF C7    JSR WriteToPPUString
       06:C51B  A9 00       LDA #DRAW_HORIZONTAL
       06:C51D  20 FF C7    JSR WriteToPPUString
       06:C520  A9 03       LDA #03 
       06:C522  20 FF C7    JSR WriteToPPUString
                            
  467  06:C525  AD 00 00    LDA temp1
  468  06:C528  20 FF C7    JSR WriteToPPUString
  469  06:C52B  AD 01 00    LDA temp2
  470  06:C52E  20 FF C7    JSR WriteToPPUString
  471  06:C531  AD 02 00    LDA temp3
  472  06:C534  20 FF C7    JSR WriteToPPUString
  473                       
  474  06:C537  EE 09 00    INC mode_state
  475                     
  476  06:C53A            .leave:
  477                      
  478  06:C53A  60          RTS
  479  06:C53B            UpdateWaitInput:
  480                     
  481  06:C53B  AD 14 00    LDA gamepadPressed
  482  06:C53E  F0 03       BEQ .leave
  483                       
  484  06:C540            .changeModeState:
  485                     
  486  06:C540  EE 09 00    INC mode_state
  487                     
  488  06:C543            .leave:
  489                      
  490  06:C543  60          RTS
  491                       
  492  06:C544            UpdateGameExit:
  493                     
  494  06:C544  A9 00       LDA #$00
  495  06:C546  8D 17 00    STA PPU_ScrollX
  496  06:C549  8D 18 00    STA PPU_ScrollY
  497  06:C54C  8D 19 00    STA PPU_ScrollNT
  498                       
  499  06:C54F  A9 02       LDA #GAMEOVER_IDX
  500  06:C551  20 FD C5    JSR ChangeGameMode
  501  06:C554  60          RTS
  502                       
  503  06:C555            MoveMouse:
  504                     
  505  06:C555  AD 00 00    LDA temp1
  506  06:C558  0E 00 00    ASL temp1
  507  06:C55B  0E 00 00    ASL temp1
  508  06:C55E  0E 00 00    ASL temp1
  509                       
  510  06:C561  AD 01 00    LDA temp2
  511  06:C564  0E 01 00    ASL temp2 
  512  06:C567  0E 01 00    ASL temp2
  513  06:C56A  0E 01 00    ASL temp2
  514                       
  515  06:C56D  A2 03       LDX #SPRITE_XPOS
  516  06:C56F  BD 00 02    LDA SPRITE_DATA, x
  517  06:C572  18          CLC
  518  06:C573  6D 00 00    ADC temp1
  519                       ;;check against borders
  520  06:C576  C9 6A       CMP #HORI_MIN
  521  06:C578  F0 07       BEQ .moveVert
  522  06:C57A  C9 EA       CMP #HORI_MAX
  523  06:C57C  F0 03       BEQ .moveVert
  524  06:C57E  9D 00 02    STA SPRITE_DATA, x
  525                     
  526  06:C581            .moveVert:
  527                     
  528  06:C581  A2 00       LDX #SPRITE_YPOS
  529  06:C583  BD 00 02    LDA SPRITE_DATA, x
  530  06:C586  18          CLC
  531  06:C587  6D 01 00    ADC temp2
  532                       ;;check against borders
  533  06:C58A  C9 5A       CMP #VERT_MIN
  534  06:C58C  F0 07       BEQ .leave
  535  06:C58E  C9 DA       CMP #VERT_MAX
  536  06:C590  F0 03       BEQ .leave
  537  06:C592  9D 00 02    STA SPRITE_DATA, x
  538                     
  539  06:C595            .leave:
  540  06:C595  60          RTS
  541                             
  542  06:C596            UpdateMouseScreenPos:
  543                     
  544  06:C596  A2 00       LDX #$00
  545  06:C598  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  546  06:C59B  4A          LSR A                                         ;0yyy yy..
  547  06:C59C  4A          LSR A                                         ;00yy yyy.
  548  06:C59D  4A          LSR A                                         ;000y yyyy
  549  06:C59E  8D 00 00    STA temp1
  550  06:C5A1  8D 58 00    STA mouse_index+1
  551  06:C5A4  E8          INX
  552  06:C5A5  E8          INX
  553  06:C5A6  E8          INX   
  554  06:C5A7  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  555  06:C5AA  29 F8       AND #$F8                       ;              ;  xxxx x000
  556  06:C5AC  8D 01 00    STA temp2                      ;      ;  
  557  06:C5AF  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  558  06:C5B2  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  559  06:C5B5  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  560  06:C5B8  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  561  06:C5BB  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  562  06:C5BE  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  563  06:C5C1  AD 01 00    LDA temp2
  564  06:C5C4  29 1F       AND #$1F
  565  06:C5C6  8D 57 00    STA mouse_index
  566                       
  567  06:C5C9  AD 57 00    LDA mouse_index
  568  06:C5CC  38          SEC 
  569  06:C5CD  E9 0E       SBC #$0E
  570  06:C5CF  8D 57 00    STA mouse_index
  571                       
  572  06:C5D2  AD 58 00    LDA mouse_index+1
  573  06:C5D5  38          SEC 
  574  06:C5D6  E9 0C       SBC #$0C
  575  06:C5D8  8D 58 00    STA mouse_index+1
  576                       
  577                       ;subtract starting offsets for mouse index
  578                       
  579  06:C5DB  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  580  06:C5DE  09 60       ORA #$60                       ;              ;  0110 00yy
  581                       
  582  06:C5E0  8D 56 00    STA mouse_location+1
  583  06:C5E3  AD 01 00    LDA temp2
  584  06:C5E6  8D 55 00    STA mouse_location
  585                       
  586  06:C5E9            .leave:
  587  06:C5E9  60          RTS
  588                       
  589                     ;;using the line index and a given count based on the direction, 
  590                       
  591                     ;;      JSR ResetMapper
  592                     ;;      INC currentCHRBank
  593                     ;;      LDA currentCHRBank
  594                     ;;      CMP #$03
  595                     ;;      BNE .dontModCHR
  596                             
  597                     ;;      LDA #$00
  598                     
  599                     ;;.dontModCHR:
  600                     ;;      STA currentCHRBank 
  601                     ;;      ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
  602                     ;;      ASL A
  603                     ;;      CLC 
  604                     ;;      ADC #$01
  605                     ;;      JSR LoadCHRBankB
  606                     ;;      
  607                     ;;      JSR ResetMapper
  608                     ;;      INC currentPRGBank
  609                     ;;      LDA currentPRGBank
  610                     ;;      CMP #$03
  611                     ;;      BNE .dontModPRG
  612                             
  613                     ;;      LDA #$00
  614                             
  615                     ;;.dontModPRG:
  616                     ;;       STA currentPRGBank
  617                     ;;       JSR LoadPRGBank
  618                      
  619                     ;;       JSR TestBankA
  620                     ;;       LDA mapperDebugVar
  621                     ;;       STA $6000
  622                     ;;       JMP .noInputDetected
  623                     
  624                     
  625                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   79                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C5EA            UpdateGameOver:
    2                     
    3  06:C5EA  20 47 C8    JSR TurnOnSprites
    4                       
    5  06:C5ED  AD 0A 00    LDA NMI_locks
    6  06:C5F0  D0 0A       BNE .noInputDetected
    7                     
    8  06:C5F2  AD 14 00    LDA gamepadPressed
    9  06:C5F5  F0 05       BEQ .noInputDetected
   10                       
   11  06:C5F7  A9 00         LDA #TITLE_IDX
   12  06:C5F9  20 FD C5          JSR ChangeGameMode
   13                      
   14  06:C5FC            .noInputDetected:
   15                      
   16  06:C5FC  60          RTS
#[1]   Picross.asm
   80                       
   81                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   82                     ;;     Routines             ;;
   83                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   84                     
   85                     
#[2]   Routines/Common/GameModeRoutines.asm
   86                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C5FD            ChangeGameMode:
    2  06:C5FD  8D 08 00    STA game_mode
    3  06:C600  A9 00       LDA #$00
    4  06:C602  8D 09 00    STA mode_state
    5  06:C605  20 13 C8    JSR ClearPPUString
    6  06:C608  20 0C C6    JSR LoadGameModeScreen
    7  06:C60B  60          RTS
    8                       
    9  06:C60C            LoadGameModeScreen:
   10                     
   11                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C60C  AD 0A 00    LDA NMI_locks
       06:C60F  09 01       ORA #BGLOAD_NMI_LOCK
       06:C611  8D 0A 00    STA NMI_locks
                                  
   12                       
   13  06:C614  A9 00       LDA #$00
   14  06:C616  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   15                     
   16  06:C619  20 47 C6    JSR LoadGameModeBackground
   17  06:C61C  20 8A C6    JSR LoadGameModeSprites
   18                     
   19                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C61F  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C621  49 FF       EOR #$FF
       06:C623  2D 0A 00    AND NMI_locks  
       06:C626  8D 0A 00    STA NMI_locks
                          
   20                     
   21                       
   22                       ;; load the CHR bank for this mode
   23  06:C629  20 94 C8    JSR ResetMapper
   24                       ;;remember, we're loading the SECOND set in each chr bank
   25                       ;;so we'll take the index from the game mode chr table and add one mult 2
   26  06:C62C  AE 08 00    LDX game_mode
   27  06:C62F  BD A7 C6    LDA gameModeInitCHRROMB, x
   28  06:C632  0A          ASL A
   29  06:C633  18          CLC 
   30  06:C634  69 01       ADC #$01
   31  06:C636  20 B9 C8    JSR LoadCHRBankB
   32                       
   33  06:C639  20 94 C8    JSR ResetMapper
   34  06:C63C  AE 08 00    LDX game_mode
   35  06:C63F  BD AA C6    LDA gameModeInitCHRROMA, x
   36  06:C642  0A          ASL A
   37  06:C643  20 AE C8    JSR LoadCHRBankA
   38                       
   39                       
   40                       
   41  06:C646  60          RTS
   42                       
   43  06:C647            LoadGameModeBackground:
   44                             
   45                       MACROGetDoubleIndex game_mode
                          
       06:C647  AD 08 00          LDA game_mode
       06:C64A  0A                ASL A
       06:C64B  A8                TAY
                                  
   46  06:C64C  8C 00 00    STY temp1
   47                             
   48                       MACROGetLabelPointer Palettes, table_address
                          
       06:C64F  A9 E0             LDA #HIGH(Palettes)
       06:C651  A2 00             LDX #LOW(Palettes)
                                  
       06:C653  8E 0E 00          STX table_address
       06:C656  8D 0F 00          STA table_address+1
                                  
   49  06:C659  20 D3 C6    JSR GetTableAtIndex
   50                     
   51  06:C65C  20 E0 C6    JSR LoadFullPaletteFromTable
   52                             
   53  06:C65F  AC 00 00    LDY temp1
   54                       MACROGetLabelPointer NameTables, table_address
                          
       06:C662  A9 E0             LDA #HIGH(NameTables)
       06:C664  A2 06             LDX #LOW(NameTables)
                                  
       06:C666  8E 0E 00          STX table_address
       06:C669  8D 0F 00          STA table_address+1
                                  
   55  06:C66C  20 D3 C6    JSR GetTableAtIndex
   56                             
   57  06:C66F  A9 00       LDA #$00
   58  06:C671  20 00 C7    JSR LoadFullBackgroundFromTable
   59                       
   60  06:C674  AC 00 00    LDY temp1
   61                       MACROGetLabelPointer NameTables2, table_address
                          
       06:C677  A9 E0             LDA #HIGH(NameTables2)
       06:C679  A2 0C             LDX #LOW(NameTables2)
                                  
       06:C67B  8E 0E 00          STX table_address
       06:C67E  8D 0F 00          STA table_address+1
                                  
   62  06:C681  20 D3 C6    JSR GetTableAtIndex
   63                       
   64  06:C684  A9 01       LDA #$01
   65  06:C686  20 00 C7    JSR LoadFullBackgroundFromTable
   66                       
   67  06:C689  60          RTS
   68                       
   69  06:C68A            LoadGameModeSprites:
   70                     
   71                       MACROGetDoubleIndex game_mode  
                          
       06:C68A  AD 08 00          LDA game_mode
       06:C68D  0A                ASL A
       06:C68E  A8                TAY
                                  
   72                       MACROGetLabelPointer Sprites, table_address
                          
       06:C68F  A9 F4             LDA #HIGH(Sprites)
       06:C691  A2 72             LDX #LOW(Sprites)
                                  
       06:C693  8E 0E 00          STX table_address
       06:C696  8D 0F 00          STA table_address+1
                                  
   73  06:C699  20 D3 C6    JSR GetTableAtIndex
   74  06:C69C  A0 00       LDY #$00
   75  06:C69E  B1 0E       LDA [table_address],y
   76  06:C6A0  EE 0E 00    INC table_address
   77  06:C6A3  20 E8 C7    JSR LoadSprites_impl
   78                       
   79  06:C6A6  60          RTS
   80                       
   81  06:C6A7            gameModeInitCHRROMB:
   82  06:C6A7  00 02 02          .db $00, $02, $02
   83  06:C6AA            gameModeInitCHRROMA:
   84  06:C6AA  00 02 02          .db $00, $02, $02
   85                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   87                       .include "Routines/Utils/PointerUtils.asm"
    1  06:C6AD            Dynamic_Jump:
    2                     
    3  06:C6AD  0A          ASL A                                 ;; double the index passed into A
    4  06:C6AE  8E 04 00    STX tempx
    5  06:C6B1  8C 05 00    STY tempy
    6  06:C6B4  A8          TAY
    7  06:C6B5  C8          INY  
    8  06:C6B6  68          PLA
    9  06:C6B7  8D 10 00    STA jump_address
   10  06:C6BA  68          PLA 
   11  06:C6BB  8D 11 00    STA jump_address+1            
   12  06:C6BE  B1 10       LDA [jump_address], y
   13  06:C6C0  AA          TAX
   14  06:C6C1  C8          INY
   15  06:C6C2  B1 10       LDA [jump_address], y
   16  06:C6C4  8E 10 00    STX jump_address
   17  06:C6C7  8D 11 00    STA jump_address+1
   18  06:C6CA  AE 04 00    LDX tempx
   19  06:C6CD  AC 05 00    LDY tempy
   20  06:C6D0  6C 10 00    JMP [jump_address]
   21                       
   22  06:C6D3            GetTableAtIndex:
   23                     
   24  06:C6D3  B1 0E             LDA [table_address], y
   25  06:C6D5  AA                TAX
   26  06:C6D6  C8                INY
   27  06:C6D7  B1 0E             LDA [table_address], y
   28                             
   29  06:C6D9            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:C6D9  8E 0E 00          STX table_address
   33  06:C6DC  8D 0F 00          STA table_address+1
   34  06:C6DF  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   88                       .include "Routines/Utils/PPUUtils.asm"
    1  06:C6E0            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:C6E0  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C6E3  A9 3F       LDA #HIGH($3F00)
       06:C6E5  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C6E8  A9 00       LDA #LOW($3F00)
       06:C6EA  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:C6ED  A0 00       LDY #$00              ; start out at 0
    5  06:C6EF  A2 00       LDX #$00
    6  06:C6F1            .loop:
    7  06:C6F1  B1 0E       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:C6F3  8D 07 20    STA PPU_DATA            ; write to PPU
    9  06:C6F6  9D 00 68    STA Palette_Copy, x
   10  06:C6F9  C8          INY                   ; X = X + 1
   11  06:C6FA  E8          INX
   12  06:C6FB  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   13  06:C6FD  D0 F2       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   14  06:C6FF  60          RTS
   15                     
   16  06:C700            LoadFullBackgroundFromTable:
   17                     
   18                         ;;use A as an index for which nametable to write to
   19  06:C700  20 33 C8          JSR SetNametableFromIndex
   20  06:C703  8A                TXA
   21  06:C704  4A                LSR A
   22  06:C705  29 01             AND #$01
   23  06:C707  D0 0D             BNE .copyScreenB
   24                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:C709  A9 60             LDA #HIGH(Screen_Copy)
       06:C70B  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:C70D  8E 0C 00          STX pointer_address
       06:C710  8D 0D 00          STA pointer_address+1
                                  
   25  06:C713  4C 20 C7          JMP .setCounters
   26                             
   27  06:C716            .copyScreenB:
   28                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:C716  A9 64             LDA #HIGH(ScreenB_Copy)
       06:C718  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:C71A  8E 0C 00          STX pointer_address
       06:C71D  8D 0D 00          STA pointer_address+1
                                  
   29                             
   30                             ;;set pointer
   31                             ;; set counters
   32  06:C720            .setCounters:
   33  06:C720  A0 00             LDY #$00
   34  06:C722  A2 00             LDX #$00
   35                             
   36                             ;;start loop
   37                     
   38  06:C724            .outerloop:
   39                     
   40  06:C724            .innerloop:
   41                     
   42  06:C724  B1 0E             LDA [table_address], y
   43  06:C726  8D 07 20          STA PPU_DATA
   44  06:C729  91 0C             STA [pointer_address],y
   45  06:C72B  C8                INY
   46  06:C72C  C0 00             CPY #$00
   47  06:C72E  D0 F4             BNE .innerloop
   48                     
   49  06:C730  EE 0D 00          INC pointer_address+1
   50  06:C733  EE 0F 00          INC table_address+1
   51                             
   52  06:C736  E8                INX
   53  06:C737  E0 04             CPX #$04
   54  06:C739  D0 E9             BNE .outerloop
   55  06:C73B  60                RTS
   56                             
   57                     
   58           0000      DATA_LEN = temp1
   59           0001      WRITE_SETTINGS = temp2
   60                             
   61  06:C73C            ProcessPPUString:
   62                     
   63  06:C73C  AD 1B 00          LDA PPU_PendingWrite
   64  06:C73F  D0 01             BNE .continueProcess
   65  06:C741  60                RTS
   66                             
   67  06:C742            .continueProcess:
   68  06:C742  A0 00             LDY #$00
   69                             
   70  06:C744  A9 1D             LDA #LOW(PPU_String)
   71  06:C746  8D 0C 00          STA pointer_address
   72  06:C749  A9 00             LDA #HIGH(PPU_String)
   73  06:C74B  8D 0D 00          STA pointer_address + 1
   74                     
   75  06:C74E            .outerloop:
   76  06:C74E  AD 02 20          LDA PPU_STATUS
   77  06:C751  B1 0C             LDA [pointer_address], y
   78  06:C753  F0 79             BEQ .finish
   79  06:C755  8D 06 20          STA PPU_ADDR
   80  06:C758  C8                INY
   81  06:C759  B1 0C             LDA [pointer_address], y
   82  06:C75B  8D 06 20          STA PPU_ADDR
   83  06:C75E  C8            INY 
   84  06:C75F  B1 0C             LDA [pointer_address], y
   85  06:C761  8D 01 00          STA WRITE_SETTINGS
   86  06:C764  C8                INY
   87                             
   88  06:C765  AD 00 20          LDA PPU_CTRL
   89  06:C768  29 FB             AND #$FB
   90  06:C76A  8D 00 20          STA PPU_CTRL
   91                             
   92  06:C76D  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
   93  06:C770  29 80             AND #%10000000
   94  06:C772  F0 06             BEQ .checkRepeat
   95  06:C774  0D 00 20          ORA PPU_CTRL 
   96  06:C777  8D 00 20          STA PPU_CTRL 
   97                             
   98                             
   99  06:C77A            .checkRepeat:
  100  06:C77A  AD 01 00    LDA WRITE_SETTINGS
  101  06:C77D  29 40       AND #%01000000
  102  06:C77F  F0 19       BEQ .checkTable
  103                       
  104  06:C781  AD 01 00    LDA WRITE_SETTINGS
  105  06:C784  29 3F       AND #$3F
  106  06:C786  8D 00 00    STA DATA_LEN
  107                       ;;the usual data length byte is now the repeatable byte
  108  06:C789  A2 00       LDX #$00
  109                       
  110  06:C78B            .repeatLoop:
  111  06:C78B  B1 0C       LDA [pointer_address], y
  112  06:C78D  8D 07 20    STA PPU_DATA
  113  06:C790  E8          INX 
  114  06:C791  EC 00 00    CPX DATA_LEN
  115  06:C794  D0 F5       BNE .repeatLoop
  116  06:C796  C8          INY
  117  06:C797  4C 4E C7    JMP .outerloop
  118                             
  119  06:C79A            .checkTable:
  120  06:C79A  AD 01 00          LDA WRITE_SETTINGS
  121  06:C79D  29 20             AND #%00100000
  122  06:C79F  F0 16             BEQ .rawData
  123                             
  124  06:C7A1  B1 0C             LDA [pointer_address], y
  125  06:C7A3  8D 0E 00          STA table_address
  126  06:C7A6  C8                INY 
  127  06:C7A7  B1 0C             LDA [pointer_address], y
  128  06:C7A9  8D 0F 00          STA table_address + 1
  129  06:C7AC  C8                INY
  130  06:C7AD  98                TYA 
  131  06:C7AE  48                PHA
  132  06:C7AF  20 D2 C7          JSR WriteToPPUFromTable
  133  06:C7B2  68                PLA
  134  06:C7B3  A8                TAY
  135  06:C7B4  4C 4E C7          JMP .outerloop
  136                             
  137  06:C7B7            .rawData:
  138                     
  139  06:C7B7  B1 0C             LDA [pointer_address], y
  140  06:C7B9  C8                INY
  141  06:C7BA  8D 00 00          STA DATA_LEN
  142                     
  143  06:C7BD  A2 00             LDX #$00
  144                     
  145  06:C7BF            .innerloop:
  146                             
  147  06:C7BF  B1 0C             LDA [pointer_address], y
  148  06:C7C1  8D 07 20          STA PPU_DATA
  149  06:C7C4  C8                INY
  150  06:C7C5  E8                INX
  151  06:C7C6  EC 00 00          CPX DATA_LEN
  152  06:C7C9  D0 F4             BNE .innerloop
  153  06:C7CB  4C 4E C7          JMP .outerloop
  154                             
  155  06:C7CE            .finish:
  156  06:C7CE  20 13 C8          JSR ClearPPUString
  157  06:C7D1            .leave:
  158  06:C7D1  60                RTS
  159                             
  160  06:C7D2            WriteToPPUFromTable:
  161  06:C7D2  A0 00             LDY #$00
  162  06:C7D4  B1 0E             LDA [table_address], y
  163  06:C7D6  C8                INY
  164  06:C7D7  8D 00 00          STA DATA_LEN
  165  06:C7DA            .innerloop:
  166  06:C7DA  B1 0E             LDA [table_address], y
  167  06:C7DC  8D 07 20          STA PPU_DATA
  168  06:C7DF  C8                INY
  169  06:C7E0  CC 00 00          CPY DATA_LEN
  170  06:C7E3  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  171  06:C7E5  F0 F3             BEQ .innerloop
  172  06:C7E7  60                RTS
  173                       
  174  06:C7E8            LoadSprites_impl:
  175                       ;;A will be the amount of sprites to load
  176  06:C7E8  8D 00 00    STA DATA_LEN
  177  06:C7EB  0E 00 00    ASL DATA_LEN
  178  06:C7EE  0E 00 00    ASL DATA_LEN
  179                       
  180  06:C7F1  A0 00       LDY #$00              ; start at 0
  181                       
  182  06:C7F3            .loop:
  183  06:C7F3  B1 0E       LDA [table_address], y; load data from address (sprites +  x)
  184  06:C7F5  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  185  06:C7F8  C8          INY                   ; X = X + 1
  186  06:C7F9  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  187  06:C7FC  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  188                                             ; if compare was equal to 16, keep going down   
  189  06:C7FE  60          RTS
  190                     
  191                     
  192  06:C7FF            WriteToPPUString:
  193                     
  194  06:C7FF  AE 1C 00          LDX PPU_StringIdx
  195  06:C802  E0 20             CPX #PPU_STRINGMAX
  196  06:C804  F0 0C             BEQ .finish
  197                             
  198  06:C806  9D 1D 00          STA PPU_String, x
  199  06:C809  EE 1C 00          INC PPU_StringIdx
  200  06:C80C  E8                INX
  201  06:C80D  A9 00             LDA #$00
  202  06:C80F  9D 1D 00          STA PPU_String, x
  203                                     
  204  06:C812            .finish:
  205  06:C812  60                RTS
  206                     
  207  06:C813            ClearPPUString:
  208                             
  209  06:C813  A9 00             LDA #$00
  210  06:C815  8D 1C 00          STA PPU_StringIdx
  211  06:C818  8D 1D 00          STA PPU_String
  212  06:C81B  8D 1B 00          STA PPU_PendingWrite
  213  06:C81E  60                RTS
  214                     
  215  06:C81F            DetectSprite0:
  216  06:C81F            WaitNotSprite0:
  217  06:C81F  AD 02 20    lda PPU_STATUS
  218  06:C822  29 40       and #SPRITE_0_MASK
  219  06:C824  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  220                     
  221  06:C826            WaitSprite0:
  222  06:C826  AD 02 20    lda $2002
  223  06:C829  29 40       and #SPRITE_0_MASK
  224  06:C82B  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  225                     
  226  06:C82D  A2 05       ldx #$05                              ;do a scanline wait
  227  06:C82F            WaitScanline:
  228  06:C82F  CA          dex
  229  06:C830  D0 FD       bne WaitScanline
  230  06:C832  60          RTS
  231                     
  232                     
  233  06:C833            SetNametableFromIndex:
  234                     
  235  06:C833  48          PHA
  236  06:C834  AD 02 20    LDA PPU_STATUS
  237  06:C837  68          PLA
  238  06:C838  0A          ASL A
  239  06:C839  AA          TAX
  240  06:C83A  BD 7D C8    LDA NameTableMemList+1, x
  241  06:C83D  8D 06 20    STA PPU_ADDR
  242  06:C840  BD 7C C8    LDA NameTableMemList, x
  243  06:C843  8D 06 20    STA PPU_ADDR
  244  06:C846  60          RTS
  245                       
  246  06:C847            TurnOnSprites:
  247                      
  248  06:C847  AD 16 00    LDA PPU_Mask
  249  06:C84A  09 10       ORA #%00010000
  250  06:C84C  8D 16 00    STA PPU_Mask
  251  06:C84F  60          RTS
  252                       
  253  06:C850            TurnOffSprites:
  254                       
  255  06:C850  AD 16 00    LDA PPU_Mask
  256  06:C853  29 EF       AND #%11101111
  257  06:C855  8D 16 00    STA PPU_Mask
  258  06:C858  60          RTS
  259                     
  260  06:C859            UpdatePPUControl:
  261                     
  262  06:C859  AD 15 00    LDA PPU_Control
  263  06:C85C  29 FC       AND #$FC
  264  06:C85E  0D 1A 00    ORA PPU_NT
  265  06:C861  8D 00 20    STA PPU_CTRL
  266  06:C864  AD 16 00    LDA PPU_Mask
  267  06:C867  8D 01 20    STA PPU_MASK
  268  06:C86A  60          RTS
  269                       
  270  06:C86B            InitPPUControl:
  271                       
  272                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  273                       ; enable sprites, enable background, no clipping on left side
  274  06:C86B  A9 90       LDA #%10010000
  275  06:C86D  8D 00 20    STA PPU_CTRL
  276  06:C870  8D 15 00    STA PPU_Control
  277  06:C873  A9 1E       LDA #%00011110
  278  06:C875  8D 01 20    STA PPU_MASK
  279  06:C878  8D 16 00    STA PPU_Mask
  280  06:C87B  60          RTS
  281                     
  282  06:C87C            NameTableMemList:
  283  06:C87C  00 20       .word $2000, $2400, $2800, $2C00
       06:C87E  00 24     
       06:C880  00 28     
       06:C882  00 2C     
  284  06:C884            PalettesMemList:
  285  06:C884  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:C886  04 3F     
       06:C888  08 3F     
       06:C88A  0C 3F     
  286  06:C88C  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:C88E  14 3F     
       06:C890  18 3F     
       06:C892  1C 3F     
  287                       
  288           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   89                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:C894            ResetMapper:
    7  06:C894  EE 94 C8    inc ResetMapper
    8  06:C897  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:C898            SetMapperControls:
   23                       ;;A = controls
   24  06:C898  AA          TAX
   25  06:C899  A9 80       LDA #MAPPERCONTROL
   26  06:C89B  8D 3E 00    STA mapper_address+1
   27  06:C89E  8A          TXA
   28  06:C89F  20 C4 C8    JSR SendMapperCommand
   29  06:C8A2  60          RTS
   30                     
   31  06:C8A3            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:C8A3  AA                TAX
   35  06:C8A4  A9 E0             LDA #PRGBANK
   36  06:C8A6  8D 3E 00          STA mapper_address+1
   37  06:C8A9  8A                TXA
   38  06:C8AA  20 C4 C8          JSR SendMapperCommand
   39  06:C8AD  60                RTS
   40                             
   41  06:C8AE            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:C8AE  AA                TAX
   44  06:C8AF  A9 A0             LDA #CHRBANK1
   45  06:C8B1  8D 3E 00          STA mapper_address+1
   46  06:C8B4  8A                TXA
   47  06:C8B5  20 C4 C8          JSR SendMapperCommand
   48  06:C8B8  60                RTS
   49                             
   50  06:C8B9            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:C8B9  AA                TAX
   53  06:C8BA  A9 C0             LDA #CHRBANK2
   54  06:C8BC  8D 3E 00          STA mapper_address+1
   55  06:C8BF  8A                TXA
   56  06:C8C0  20 C4 C8          JSR SendMapperCommand
   57  06:C8C3  60                RTS
   58                             
   59  06:C8C4            SendMapperCommand:
   60                     
   61  06:C8C4  A0 00             LDY #$00
   62                             
   63  06:C8C6  91 3D             STA [mapper_address], y
   64  06:C8C8  4A                LSR A
   65  06:C8C9  91 3D             STA [mapper_address], y
   66  06:C8CB  4A                LSR A
   67  06:C8CC  91 3D             STA [mapper_address], y
   68  06:C8CE  4A                LSR A 
   69  06:C8CF  91 3D             STA [mapper_address], y
   70  06:C8D1  4A                LSR A
   71  06:C8D2  91 3D             STA [mapper_address], y
   72                             
   73  06:C8D4  60                RTS
   74                             
   75  06:C8D5            ResetBanks:
   76                     
   77  06:C8D5  20 94 C8          JSR ResetMapper
   78  06:C8D8  A9 00             LDA #$00
   79  06:C8DA  20 A3 C8          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:C8DD  20 94 C8          JSR ResetMapper
   83  06:C8E0  A9 00             LDA #$00
   84  06:C8E2  20 AE C8          JSR LoadCHRBankA
   85  06:C8E5  A9 01             LDA #$01
   86  06:C8E7  20 B9 C8          JSR LoadCHRBankB
   87  06:C8EA  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   90                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:C8EB            PopulateClues:
    2                     
    3  06:C8EB            .getByte:
    4  06:C8EB  AC 4D 00    LDY clueTableIndex
    5  06:C8EE  B1 47       LDA [clues_address], y
    6  06:C8F0  D0 07       BNE .checkNewLine
    7  06:C8F2  EE 4D 00    INC clueTableIndex
    8  06:C8F5  A9 00       LDA #$00
    9  06:C8F7  F0 38       BEQ .drawClue
   10                       ;was 0, set up a draw
   11  06:C8F9            .checkNewLine
   12  06:C8F9  C9 FF       CMP #$FF
   13  06:C8FB  D0 17       BNE .getClue
   14                       
   15                       ;;was FF- need to inc stuff
   16  06:C8FD  EE 4D 00    INC clueTableIndex
   17  06:C900  A9 00       LDA #$00
   18  06:C902  8D 54 00    STA clueParity
   19                       
   20  06:C905  EE 4E 00    INC clueLineIndex
   21  06:C908  AD 4E 00    LDA clueLineIndex
   22  06:C90B  C9 0F       CMP #$0F
   23                       ;CMP #$01
   24  06:C90D  F0 28       BEQ .leave    ;carry will be set
   25                       
   26  06:C90F  20 A9 C9    JSR CreateOffsetFromIndex
   27                      
   28  06:C912  D0 D7       BNE .getByte
   29                       
   30  06:C914            .getClue:
   31                       ;;clues go from high nibble to low nibble
   32  06:C914  48          PHA 
   33  06:C915  AD 54 00    LDA clueParity
   34  06:C918  D0 0A       BNE .getSecondClue
   35  06:C91A  EE 54 00    INC clueParity
   36  06:C91D  68          PLA
   37  06:C91E  4A          LSR A
   38  06:C91F  4A          LSR A
   39  06:C920  4A          LSR A
   40  06:C921  4A          LSR A         ;move clue over to lower nibble
   41  06:C922  D0 0D       BNE .drawClue
   42                       
   43  06:C924            .getSecondClue:
   44                     
   45  06:C924  CE 54 00    DEC clueParity
   46  06:C927  EE 4D 00    INC clueTableIndex
   47  06:C92A  68          PLA 
   48  06:C92B  29 0F       AND #$0F
   49  06:C92D  D0 02       BNE .drawClue
   50                       ;;if 0, skip
   51  06:C92F  F0 BA       BEQ .getByte
   52                      
   53  06:C931            .drawClue:
   54                       
   55  06:C931  09 40       ORA #$40
   56  06:C933  20 38 C9    JSR WriteClueByteToPPUString
   57  06:C936  18          CLC
   58                       
   59  06:C937            .leave:
   60  06:C937  60          RTS
   61                       
   62  06:C938            WriteClueByteToPPUString:
   63                     
   64  06:C938  8D 00 00    STA temp1 ;store off the tile value
   65                     
   66                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:C93B  A9 01       LDA #$01
       06:C93D  8D 1B 00    STA PPU_PendingWrite
       06:C940  AD 4C 00    LDA clue_draw_address+1
       06:C943  20 FF C7    JSR WriteToPPUString
       06:C946  AD 4B 00    LDA clue_draw_address
       06:C949  20 FF C7    JSR WriteToPPUString
       06:C94C  A9 00       LDA #DRAW_HORIZONTAL
       06:C94E  20 FF C7    JSR WriteToPPUString
       06:C951  A9 01       LDA #$01 
       06:C953  20 FF C7    JSR WriteToPPUString
                            
   67  06:C956  AD 00 00    LDA temp1
   68  06:C959  20 FF C7    JSR WriteToPPUString
   69                       
   70  06:C95C  AD 52 00    LDA clueDrawAdd
   71  06:C95F  20 86 C9    JSR SubFromClueDrawAddress
   72                         
   73  06:C962  60          RTS
   74                       
   75  06:C963            ResetClueDrawAddress:
   76                     
   77                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:C963  AD 49 00          LDA clue_start_address
       06:C966  8D 4B 00          STA clue_draw_address
       06:C969  AD 4A 00          LDA clue_start_address+1
       06:C96C  8D 4C 00          STA clue_draw_address+1
                          
   78                       
   79  06:C96F  60          RTS
   80                       
   81  06:C970            AddToClueDrawAddress:
   82                     
   83  06:C970  8D 00 00    STA temp1
   84                       
   85  06:C973  AD 4B 00    LDA clue_draw_address
   86  06:C976  18          CLC
   87  06:C977  6D 00 00    ADC temp1
   88  06:C97A  8D 4B 00    STA clue_draw_address
   89  06:C97D  AD 4C 00    LDA clue_draw_address+1
   90  06:C980  69 00       ADC #$00
   91  06:C982  8D 4C 00    STA clue_draw_address+1
   92                       
   93  06:C985  60          RTS
   94                         
   95  06:C986            SubFromClueDrawAddress:
   96                     
   97  06:C986  8D 00 00    STA temp1
   98                       
   99  06:C989  AD 4B 00    LDA clue_draw_address
  100  06:C98C  38          SEC
  101  06:C98D  ED 00 00    SBC temp1
  102  06:C990  8D 4B 00    STA clue_draw_address
  103  06:C993  AD 4C 00    LDA clue_draw_address+1
  104  06:C996  E9 00       SBC #$00
  105  06:C998  8D 4C 00    STA clue_draw_address+1
  106                       
  107  06:C99B  60          RTS
  108                       
  109  06:C99C            AddToClueDrawAddressHi:
  110                     
  111  06:C99C  8D 00 00    STA temp1
  112                       
  113  06:C99F  AD 4C 00    LDA clue_draw_address+1
  114  06:C9A2  6D 00 00    ADC temp1
  115  06:C9A5  8D 4C 00    STA clue_draw_address+1
  116                       
  117  06:C9A8  60          RTS
  118                       
  119  06:C9A9            CreateOffsetFromIndex:
  120                     
  121                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  122  06:C9A9  AD 4E 00    LDA clueLineIndex
  123  06:C9AC  8D 50 00    STA clueDrawOffset
  124  06:C9AF  A9 00       LDA #$00
  125  06:C9B1  8D 51 00    STA clueDrawOffset+1
  126                       
  127  06:C9B4  AD 4F 00    LDA clueOffsetShift   
  128  06:C9B7  F0 0E       BEQ .addOffset
  129                       
  130  06:C9B9  A2 00       LDX #$00
  131                       
  132  06:C9BB            .loopShift:
  133  06:C9BB  0E 50 00    ASL clueDrawOffset
  134  06:C9BE  2E 51 00    ROL clueDrawOffset+1
  135  06:C9C1  E8          INX
  136  06:C9C2  EC 4F 00    CPX clueOffsetShift
  137  06:C9C5  D0 F4       BNE .loopShift
  138                       
  139  06:C9C7            .addOffset:
  140                       
  141  06:C9C7  20 63 C9    JSR ResetClueDrawAddress
  142  06:C9CA  AD 50 00    LDA clueDrawOffset
  143  06:C9CD  20 70 C9    JSR AddToClueDrawAddress 
  144  06:C9D0  AD 51 00    LDA clueDrawOffset+1
  145  06:C9D3  20 9C C9    JSR AddToClueDrawAddressHi
  146                       
  147  06:C9D6  60          RTS  
  148                       
  149  06:C9D7            ClearPuzzle:
  150                     
  151                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  152                      
  153                       MACROGetLabelPointer ClearLineDefTables, table_address
                          
       06:C9D7  A9 CA             LDA #HIGH(ClearLineDefTables)
       06:C9D9  A2 AC             LDX #LOW(ClearLineDefTables)
                                  
       06:C9DB  8E 0E 00          STX table_address
       06:C9DE  8D 0F 00          STA table_address+1
                                  
  154  06:C9E1  A0 00       LDY #$00
  155  06:C9E3  20 D3 C6    JSR GetTableAtIndex
  156                       
  157                       
  158  06:C9E6  AC 4E 00    LDY clueLineIndex
  159  06:C9E9  B1 0E       LDA [table_address], y
  160  06:C9EB  8D 00 00    STA temp1
  161                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:C9EE  A9 01       LDA #$01
       06:C9F0  8D 1B 00    STA PPU_PendingWrite
       06:C9F3  AD 4C 00    LDA clue_draw_address+1
       06:C9F6  20 FF C7    JSR WriteToPPUString
       06:C9F9  AD 4B 00    LDA clue_draw_address
       06:C9FC  20 FF C7    JSR WriteToPPUString
       06:C9FF  A9 40       LDA #$40
       06:CA01  09 00       ORA #DRAW_HORIZONTAL
       06:CA03  0D 00 00    ORA temp1
       06:CA06  20 FF C7    JSR WriteToPPUString
       06:CA09  A9 24       LDA #$24
       06:CA0B  20 FF C7    JSR WriteToPPUString
                            
  162                       ;;no need to load anything else
  163                       
  164  06:CA0E  AD 4B 00    LDA clue_draw_address
  165  06:CA11  18          CLC
  166  06:CA12  69 20       ADC #32
  167  06:CA14  8D 4B 00    STA clue_draw_address
  168  06:CA17  AD 4C 00    LDA clue_draw_address+1
  169  06:CA1A  69 00       ADC #$00
  170  06:CA1C  8D 4C 00    STA clue_draw_address+1
  171                       
  172  06:CA1F  EE 4E 00    INC clueLineIndex
  173  06:CA22  60          RTS
  174                       
  175  06:CA23            DrawImage:
  176                     
  177                       ;;we have clueTableIndex, which should be at the image bytes now
  178                       ;;clue line index will keep track of our place in a byte
  179                        
  180  06:CA23  A9 00       LDA #$00
  181  06:CA25  8D 00 00    STA temp1
  182                       
  183  06:CA28  AD 4E 00    LDA clueLineIndex
  184  06:CA2B  29 03       AND #$03
  185  06:CA2D  8D 01 00    STA temp2
  186                     
  187  06:CA30  AC 4D 00    LDY clueTableIndex
  188  06:CA33  B1 47       LDA [clues_address], y
  189                     
  190  06:CA35  A2 00       LDX #$00
  191  06:CA37            .loop:
  192  06:CA37  0A          ASL A
  193  06:CA38  2E 00 00    ROL temp1
  194  06:CA3B  0A          ASL A
  195  06:CA3C  2E 00 00    ROL temp1
  196  06:CA3F  E8          INX
  197  06:CA40  EC 01 00    CPX temp2
  198  06:CA43  90 F2       BCC .loop
  199  06:CA45  F0 F0       BEQ .loop
  200                       
  201  06:CA47  AD 00 00    LDA temp1
  202  06:CA4A  29 03       AND #$03
  203  06:CA4C  18          CLC
  204  06:CA4D  69 24       ADC #$24
  205  06:CA4F  8D 00 00    STA temp1
  206                       
  207                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:CA52  A9 01       LDA #$01
       06:CA54  8D 1B 00    STA PPU_PendingWrite
       06:CA57  AD 4C 00    LDA clue_draw_address+1
       06:CA5A  20 FF C7    JSR WriteToPPUString
       06:CA5D  AD 4B 00    LDA clue_draw_address
       06:CA60  20 FF C7    JSR WriteToPPUString
       06:CA63  A9 00       LDA #DRAW_HORIZONTAL
       06:CA65  20 FF C7    JSR WriteToPPUString
       06:CA68  A9 01       LDA #$01 
       06:CA6A  20 FF C7    JSR WriteToPPUString
                            
  208  06:CA6D  AD 00 00    LDA temp1
  209  06:CA70  20 FF C7    JSR WriteToPPUString
  210                       
  211  06:CA73  EE 4F 00    INC clueOffsetShift
  212  06:CA76  EE 4E 00    INC clueLineIndex
  213  06:CA79  AD 4E 00    LDA clueLineIndex
  214  06:CA7C  29 03       AND #$03
  215  06:CA7E  D0 03       BNE .incDrawIndex
  216  06:CA80  EE 4D 00    INC clueTableIndex
  217                       
  218                       
  219  06:CA83            .incDrawIndex:  
  220  06:CA83  AD 4F 00    LDA clueOffsetShift
  221  06:CA86  C9 0F       CMP #$0F
  222  06:CA88  D0 19       BNE .incOnly
  223                       ;;add 32-15 = 17 to the draw address
  224  06:CA8A  AD 4B 00    LDA clue_draw_address
  225  06:CA8D  18          CLC
  226  06:CA8E  69 12       ADC #18
  227  06:CA90  8D 4B 00    STA clue_draw_address
  228  06:CA93  AD 4C 00    LDA clue_draw_address+1
  229  06:CA96  69 00       ADC #$00
  230  06:CA98  8D 4C 00    STA clue_draw_address+1
  231                       
  232  06:CA9B  A9 00       LDA #$00
  233  06:CA9D  8D 4F 00    STA clueOffsetShift
  234                       
  235  06:CAA0  4C AB CA    JMP .leave
  236                       
  237  06:CAA3            .incOnly:
  238                     
  239  06:CAA3  EE 4B 00    INC clue_draw_address
  240  06:CAA6  D0 03       BNE .leave
  241  06:CAA8  EE 4C 00    INC clue_draw_address+1
  242                       
  243  06:CAAB            .leave:
  244  06:CAAB  60          RTS
  245                     
  246  06:CAAC            ClearLineDefTables:
  247                     
  248  06:CAAC  AE CA       .word Clear15x15LineDefs
  249                     
  250  06:CAAE            Clear15x15LineDefs:
  251  06:CAAE  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:CAB1  20 20 20  
       06:CAB4  20 20 20  
       06:CAB7  20 20     
  252  06:CAB9  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:CABC  0D 0D 0D  
       06:CABF  0D 0D 0D  
       06:CAC2  0D 0D 0D  
       06:CAC5  0D 0D 0D  
       06:CAC8  0D 0D     
  253  06:CACA  20 20       .db $20, $20
#[1]   Picross.asm
   91                       
   92                       
   93                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   94                     ;;     NMI                  ;;
   95                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   96                     
#[2]   Routines/Common/NMI.asm
   97                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:CACC            NMI:
    3                     
    4  06:CACC  48          PHA                              ;protect the registers
    5  06:CACD  8A          TXA
    6  06:CACE  48          PHA
    7  06:CACF  98          TYA
    8  06:CAD0  48          PHA
    9                       
   10  06:CAD1            nmi_started:
   11  06:CAD1  A9 00       LDA #$00
   12  06:CAD3  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:CAD6  A9 02       LDA #$02
   14  06:CAD8  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:CADB  AD 0A 00    LDA NMI_locks
   17  06:CADE  F0 03       BEQ update_controllers
   18  06:CAE0  4C 4F CB    JMP WakeUp
   19                     
   20  06:CAE3            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:CAE3  8A            TXA
    3  06:CAE4  48                PHA
    4  06:CAE5  98                TYA
    5  06:CAE6  48                PHA
    6                     
    7  06:CAE7  A2 00             LDX #$00
    8                     
    9  06:CAE9            GamePadCheck:
   10  06:CAE9  A9 01             LDA #$01        ;load 1
   11  06:CAEB  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:CAEE  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:CAEF  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:CAF2  A9 80             LDA #$80
   18  06:CAF4  8D 12 00          STA gamepad
   19                     
   20  06:CAF7            ReadControllerABytesLoop:
   21  06:CAF7  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:CAFA  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:CAFC  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:CAFE  6E 12 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:CB01  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:CB03  AD 13 00          LDA gamepadLast
   31  06:CB06  49 FF             EOR #$FF
   32  06:CB08  2D 12 00          AND gamepad
   33  06:CB0B  8D 14 00          STA gamepadPressed
   34                             
   35                             
   36  06:CB0E  AD 12 00          LDA gamepad
   37  06:CB11  8D 13 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:CB14  68                PLA
   41  06:CB15  A8                TAY
   42  06:CB16  68                PLA
   43  06:CB17  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:CB18  20 3C C7    JSR ProcessPPUString
   25                       
   26                       
   27  06:CB1B  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:CB1D  8D 05 20    STA PPU_SCROLL
   29  06:CB20  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:CB23  20 59 C8    JSR UpdatePPUControl
   34                     
   35  06:CB26            NMIUpdate:
   36                     
   37  06:CB26  20 43 CB    JSR StateNMIUpdate
   38                       
   39  06:CB29  AD 15 00    LDA PPU_Control
   40  06:CB2C  29 FC       AND #$FC
   41  06:CB2E  0D 19 00    ORA PPU_ScrollNT
   42  06:CB31  8D 00 20    STA PPU_CTRL
   43                       
   44  06:CB34  AD 17 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:CB37  8D 05 20    STA PPU_SCROLL
   46  06:CB3A  AD 18 00    LDA PPU_ScrollY
   47  06:CB3D  8D 05 20    STA PPU_SCROLL
   48                     
   49  06:CB40  4C 4F CB    JMP WakeUp
   50                     
   51  06:CB43            StateNMIUpdate:
   52                     
   53                       MACROCallDynamicJump game_mode
                          
       06:CB43  AD 08 00    LDA game_mode
       06:CB46  20 AD C6    JSR Dynamic_Jump
                                  
   54                     
   55  06:CB49            NMIJumpTable:
   56                     
   57  06:CB49  5A CB       .word UpdateTitleNMI
   58  06:CB4B  5E CB       .word UpdateGameNMI
   59  06:CB4D  5F CB       .word UpdateGameOverNMI
   60                     
   61  06:CB4F            WakeUp:
   62  06:CB4F  A9 00       LDA #$00
   63  06:CB51  8D 07 00    STA sleeping
   64                       
   65  06:CB54  68          PLA             ;restore the registers
   66  06:CB55  A8          TAY 
   67  06:CB56  68          PLA
   68  06:CB57  AA          TAX
   69  06:CB58  68          PLA
   70                     
   71  06:CB59  40          RTI             ; return from interrupt
   72                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   73                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:CB5A            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:CB5A  20 1F C8    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:CB5D  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   74                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:CB5E            UpdateGameNMI:
    2  06:CB5E  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:CB5F            UpdateGameOverNMI:
    2  06:CB5F  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
   98                       
   99                     ;;**************************;;
  100                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  101                     ;;       PRG ROM DATA       ;;
  102                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  103                     ;;**************************;; 
  104                       
  105           0007        .bank 7
  106           E000        .org $E000
  107                     
#[2]   NameTables/Tables.asm
  108                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  12 E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  32 E0     
       07:E004  52 E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  72 E0       .word Title_Screen, Game_Screen, GameOver_Screen
       07:E008  72 E8     
       07:E00A  72 EC     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  72 E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  72 F0     
       07:E010  72 F0     
   12                     
   13  07:E012            Title_Palette:
   14                     
   15  07:E012              .incbin "NameTables/Title_PAL.pal"
   16  07:E022              .incbin "NameTables/Title_PAL.pal"
   17                       
   18  07:E032            Game_Palette:
   19                     
   20  07:E032              .incbin "NameTables/Game_PAL.pal"
   21  07:E042              .incbin "NameTables/Game_PAL.pal"
   22                       
   23  07:E052            GameOver_Palette:
   24                     
   25  07:E052              .incbin "NameTables/GameOver_PAL.pal"
   26  07:E062              .incbin "NameTables/GameOver_PAL.pal"
   27                       
   28  07:E072            Title_Screen:
   29                     
   30  07:E072              .incbin "NameTables/Title_NT.nam"
   31                       
   32  07:E472            Title_Second:
   33                     
   34  07:E472              .incbin "NameTables/Title_PuzzMen_NT.nam"
   35                       
   36  07:E872            Game_Screen: 
   37                     
   38  07:E872              .incbin "NameTables/Game_NT.nam"
   39                       
   40  07:EC72            GameOver_Screen:
   41                     
   42  07:EC72              .incbin "NameTables/GameOver_NT.nam"
   43                       
   44  07:F072            Blank_Screen:
   45                     
   46  07:F072              .incbin "NameTables/Blank_NT.nam"
   47                     
   48                       
   49                     
   50                       
   51                      
   52                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  109                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:F472            Sprites:
   38  07:F472  78 F4             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:F474  81 F4     
       07:F476  86 F4     
   39                     
   40  07:F478            Title_Sprites:
   41  07:F478  02            .db $02
   42  07:F479  85 00 00          .db $85,$00,$00,$E8
       07:F47C  E8        
   43  07:F47D  A0 01 00          .db $A0,$01,$00,$60
       07:F480  60        
   44  07:F481            Game_Sprites:
   45  07:F481  01            .db $01
   46  07:F482  62 00 03          .db $62,$00,$03,$72
       07:F485  72        
   47  07:F486            GameOver_Sprites:
   48  07:F486  01                .db $01
   49  07:F487  00 00 00          .db $00,$00,$00,$00
       07:F48A  00        
#[1]   Picross.asm
  110                     
  111           FFFA        .org $FFFA     ;first of the three vectors starts here
  112  07:FFFA  CC CA       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  113                                        ;processor will jump to the label NMI:
  114  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  115                                        ;to the label RESET:
  116  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  117                       
  118                     ;;**************************;;
  119                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  120                     ;;      CHR ROM DATA        ;;
  121                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122                     ;;**************************;; 
  123                       
  124           0008        .bank 8
  125           0000        .org $0000
  126  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  127                       
  128           0009        .bank 9
  129           0000        .org $0000
  130  09:0000              .incbin "CHRROM/Bank1.chr"
  131                       
  132           000A        .bank 10
  133           0000        .org $0000
  134  0A:0000              .incbin "CHRROM/Bank2.chr"
  135                       
  136           000B        .bank 11
  137           0000        .org $0000
  138  0B:0000              .incbin "CHRROM/Bank3.chr"
