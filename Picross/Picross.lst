#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      temp5                   .rs 1
    6           0005      temp6                   .rs 1
    7           0006      temp7                   .rs 1
    8           0007      temp8                   .rs 1
    9           0008      tempx                   .rs 1
   10           0009      tempy                   .rs 1
   11           000A      time                    .rs 1
   12           000B      scaledTime              .rs 1
   13           000C      sleeping                .rs 1
   14           000D      mode_loadFlags  .rs 1
   15           000E      game_mode               .rs 1
   16           000F      mode_state              .rs 1
   17           0010      NMI_locks               .rs 1
   18           0011      game_locks              .rs 1
   19           0012      pointer_address .rs 2
   20           0014      table_address   .rs 2
   21           0016      jump_address    .rs 2
   22                     
   23                     ;game modes
   24           0000      TITLE_IDX = $00
   25           0001      GAME_IDX = $01
   26           0002      GAMEOVER_IDX = $02
   27                     
   28                     ;locks for input and rendering
   29           0001      BGLOAD_NMI_LOCK = %00000001
   30           0001      EFFECT_GAME_LOCK = %00000001
   31                     
   32                     
   33                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           0018      gamepad                 .rs 1
   19           0019      gamepadLast     .rs 1
   20           001A      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           001B      PPU_Control                     .rs 1
    2           001C      PPU_Mask                        .rs 1
    3           001D      PPU_ScrollX                     .rs 1
    4           001E      PPU_ScrollY                     .rs 1
    5           001F      PPU_ScrollNT            .rs 1   ;first two bits
    6           0020      PPU_NT                          .rs 1
    7                     
    8           0021      PPU_PendingWrite        .rs 1
    9           0022      PPU_StringIdx           .rs 1
   10           0023      PPU_String                      .rs 128
   11                     
   12           004F      PPU_STRINGMAX = $4F ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           00A3      mapper_address  .rs 2
    2           00A5      currentCHRBankA .rs 1
    3           00A6      currentCHRBankB .rs 1
    4           00A7      currentPRGBank  .rs 1
    5           00A8      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           A000      PUZZLE_TABLE = $A000
    2           A01B      NAMES_TABLE = $A01B
    3           A036      SPRITES_TABLE = $A036
    4                     
    5           00A9      puzzle_address          .rs 2
    6           00AB      clues_address           .rs 2
    7           00AD      pause_address           .rs 2
    8           00AF      copy_address        .rs 2
    9           00B1      pause_draw_address  .rs 2
   10           00B3      clue_start_address      .rs 2
   11           00B5      clue_draw_address       .rs 2
   12           00B7      clueTableIndex          .rs 1
   13           00B8      clueLineIndex           .rs 1
   14           00B9      clueOffsetShift         .rs 1
   15           00BA      clueDrawAdd                     .rs 1
   16           00BB      clueDrawOffset          .rs 2
   17           00BD      clueDrawDecSize         .rs 1
   18           00BE      clueParity                      .rs 1
   19           00BF      mouse_location          .rs 2
   20           00C1      mouse_index                     .rs 2
   21           00C3      currentPaintTile        .rs 1
   22           00C4      solutionCount           .rs 1
   23           00C5      nonSolutionCount        .rs 1
   24           00C6      pauseState                      .rs 1
   25           00C7      pauseInputLock          .rs 1
   26           00C8      holdTimer                       .rs 1
   27           00C9      GameTime                        .rs 4   ;in order - second, ten second, minute, 10 minute - max out at 99 minutes
   28           00CD      targetGameMode          .rs 1
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/ScreenStateVariables.asm
   18                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   19           7000        .rsset $7000
#[3]   Defines/SaveVariables.asm
   20                       .include "Defines/SaveVariables.asm"
    1           7000      bank_index      .rs 1
    2           7001      puzzle_index .rs 1
    3                     ;we can save these for the continue
    4                     ;we'll save out data for the puzzles- just need to know if it's 1) complete and 2) the time
    5                     ;we can do that in 4 bytes each, so 324 bytes
    6           7002      puzzle_clear_data .rs 324
    7                     
#[2]   Defines/Defines.asm
   21                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1                     
    2                     
    3           0000        .bank 0
    4           8000        .org $8000
    5                       
#[3]   Puzzles/house.asm
    6                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  02 82 00    .db $02, $82, $00, $21
       00:8003  21        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  05 11 18    .db $05, $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1E 1C 0E  
       00:80B6  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test.asm
    7                       .include "Puzzles/test.asm"
    1  00:80B7            test:
    2  00:80B7  02 01 00    .db $02, $01, $00, $00
       00:80BA  00        
    3  00:80BB  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:80BE  00 00 00  
       00:80C1  00 00 00  
       00:80C4  00 00 00  
       00:80C7  00 00 00  
       00:80CA  00 00 00  
       00:80CD  00 00 00  
       00:80D0  00 00 00  
       00:80D3  00 00 00  
       00:80D6  00 00 00  
    4  00:80D9  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80DC  FF 00 FF  
       00:80DF  00 FF 00  
       00:80E2  FF 00 FF  
       00:80E5  00 FF 00  
       00:80E8  FF 00 FF  
       00:80EB  00 FF 00  
       00:80EE  FF 00 FF  
       00:80F1  00 FF 00  
       00:80F4  FF 00 FF  
    5  00:80F7  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80FA  FF 00 FF  
       00:80FD  00 FF 00  
       00:8100  FF 00 FF  
       00:8103  00 FF 00  
       00:8106  FF 00 FF  
       00:8109  00 FF 00  
       00:810C  FF 00 FF  
       00:810F  00 FF 00  
       00:8112  FF 00 FF  
    6  00:8115            testImage:
    7  00:8115  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8118  1B 1B 1B  
       00:811B  1B 1B 1B  
       00:811E  1B 1B 1B  
       00:8121  1B 1B 1B  
       00:8124  1B 1B 1B  
       00:8127  1B 1B 1B  
       00:812A  1B 1B 1B  
       00:812D  1B 1B 1B  
       00:8130  1B 1B 1B  
       00:8133  1B 1B 1B  
       00:8136  1B 1B 1B  
       00:8139  1B 1B 1B  
       00:813C  1B 1B 1B  
       00:813F  1B 1B 1B  
       00:8142  1B 1B 1B  
       00:8145  1B 1B 1B  
       00:8148  1B 1B 1B  
       00:814B  1B 1B 00  
       00:814E  FF        
    8  00:814F            testName:
    9  00:814F  04 1D 0E    .db $04, $1D, $0E, $1C, $1D, $FF
       00:8152  1C 1D FF  
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test5.asm
    8                       .include "Puzzles/test5.asm"
    1  00:8155            test5:
    2  00:8155  00 01 00    .db $00, $01, $00, $32
       00:8158  32        
    3  00:8159  80 00 00    .db $80, $00, $00, $00, $00
       00:815C  00 00     
    4  00:815E  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:8161  FF 00 FF  
       00:8164  00 FF 00  
       00:8167  FF        
    5  00:8168  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:816B  FF 00 FF  
       00:816E  00 FF 00  
       00:8171  FF        
    6  00:8172            test5Image:
    7  00:8172  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8175  1B 1B 1B  
       00:8178  00 FF     
    8  00:817A            test5Name:
    9  00:817A  05 1D 0E    .db $05, $1D, $0E, $1C, $1D, $05, $FF
       00:817D  1C 1D 05  
       00:8180  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test10.asm
    9                       .include "Puzzles/test10.asm"
    1  00:8181            test10:
    2  00:8181  01 01 00    .db $01, $01, $00, $16
       00:8184  16        
    3  00:8185  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:8188  00 00 00  
       00:818B  00 00 00  
       00:818E  00 00 00  
       00:8191  00 00 00  
       00:8194  00 00 00  
       00:8197  00 00     
    4  00:8199  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:819C  FF 00 FF  
       00:819F  00 FF 00  
       00:81A2  FF 00 FF  
       00:81A5  00 FF 00  
       00:81A8  FF 00 FF  
       00:81AB  00 FF     
    5  00:81AD  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:81B0  FF 00 FF  
       00:81B3  00 FF 00  
       00:81B6  FF 00 FF  
       00:81B9  00 FF 00  
       00:81BC  FF 00 FF  
       00:81BF  00 FF     
    6  00:81C1            test10Image:
    7  00:81C1  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $FF
       00:81C4  1B 1B 1B  
       00:81C7  1B 1B 1B  
       00:81CA  1B 1B 1B  
       00:81CD  1B 1B 1B  
       00:81D0  1B 1B 1B  
       00:81D3  1B 1B 1B  
       00:81D6  1B 1B 1B  
       00:81D9  1B FF     
    8  00:81DB            test10Name:
    9  00:81DB  06 1D 0E    .db $06, $1D, $0E, $1C, $1D, $01, $00, $FF
       00:81DE  1C 1D 01  
       00:81E1  00 FF     
#[2]   Banks/Bank0.asm
   10                     
   11           0001        .bank 1
   12           A000        .org $A000
   13                     ;puzzles
   14  01:A000  55 81       .word test5, test10, test, test, test, test, test, test, test
       01:A002  81 81     
       01:A004  B7 80     
       01:A006  B7 80     
       01:A008  B7 80     
       01:A00A  B7 80     
       01:A00C  B7 80     
       01:A00E  B7 80     
       01:A010  B7 80     
   15  01:A012  00 80       .word house, test, test, test, test, test, test, test, test
       01:A014  B7 80     
       01:A016  B7 80     
       01:A018  B7 80     
       01:A01A  B7 80     
       01:A01C  B7 80     
       01:A01E  B7 80     
       01:A020  B7 80     
       01:A022  B7 80     
   16  01:A024  00 80       .word house, test, test, test, test, test, test, test, test
       01:A026  B7 80     
       01:A028  B7 80     
       01:A02A  B7 80     
       01:A02C  B7 80     
       01:A02E  B7 80     
       01:A030  B7 80     
       01:A032  B7 80     
       01:A034  B7 80     
   17                     ;puzzle names
   18  01:A036  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A038  4F 81     
       01:A03A  4F 81     
       01:A03C  4F 81     
       01:A03E  4F 81     
       01:A040  4F 81     
       01:A042  4F 81     
       01:A044  4F 81     
       01:A046  4F 81     
   19  01:A048  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A04A  4F 81     
       01:A04C  4F 81     
       01:A04E  4F 81     
       01:A050  4F 81     
       01:A052  4F 81     
       01:A054  4F 81     
       01:A056  4F 81     
       01:A058  4F 81     
   20  01:A05A  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A05C  4F 81     
       01:A05E  4F 81     
       01:A060  4F 81     
       01:A062  4F 81     
       01:A064  4F 81     
       01:A066  4F 81     
       01:A068  4F 81     
       01:A06A  4F 81     
   21                     ;puzzle sprites
   22  01:A06C  00 00 00    .db $00, $00, $00, $00
       01:A06F  00        
   23  01:A070  00 00 00    .db $00, $00, $00, $00
       01:A073  00        
   24  01:A074  00 00 00    .db $00, $00, $00, $00
       01:A077  00        
   25  01:A078  00 00 00    .db $00, $00, $00, $00
       01:A07B  00        
   26  01:A07C  00 00 00    .db $00, $00, $00, $00
       01:A07F  00        
   27  01:A080  00 00 00    .db $00, $00, $00, $00
       01:A083  00        
   28  01:A084  00 00 00    .db $00, $00, $00, $00
       01:A087  00        
   29  01:A088  00 00 00    .db $00, $00, $00, $00
       01:A08B  00        
   30  01:A08C  00 00 00    .db $00, $00, $00, $00
       01:A08F  00        
   31  01:A090  00 00 00    .db $00, $00, $00, $00
       01:A093  00        
   32  01:A094  00 00 00    .db $00, $00, $00, $00
       01:A097  00        
   33  01:A098  00 00 00    .db $00, $00, $00, $00
       01:A09B  00        
   34  01:A09C  00 00 00    .db $00, $00, $00, $00
       01:A09F  00        
   35  01:A0A0  00 00 00    .db $00, $00, $00, $00
       01:A0A3  00        
   36  01:A0A4  00 00 00    .db $00, $00, $00, $00
       01:A0A7  00        
   37  01:A0A8  00 00 00    .db $00, $00, $00, $00
       01:A0AB  00        
   38  01:A0AC  00 00 00    .db $00, $00, $00, $00
       01:A0AF  00        
   39  01:A0B0  00 00 00    .db $00, $00, $00, $00
       01:A0B3  00        
   40  01:A0B4  00 00 00    .db $00, $00, $00, $00
       01:A0B7  00        
   41  01:A0B8  00 00 00    .db $00, $00, $00, $00
       01:A0BB  00        
   42  01:A0BC  00 00 00    .db $00, $00, $00, $00
       01:A0BF  00        
   43  01:A0C0  00 00 00    .db $00, $00, $00, $00
       01:A0C3  00        
   44  01:A0C4  00 00 00    .db $00, $00, $00, $00
       01:A0C7  00        
   45  01:A0C8  00 00 00    .db $00, $00, $00, $00
       01:A0CB  00        
   46  01:A0CC  00 00 00    .db $00, $00, $00, $00
       01:A0CF  00        
   47  01:A0D0  00 00 00    .db $00, $00, $00, $00
       01:A0D3  00        
   48  01:A0D4  00 00 00    .db $00, $00, $00, $00
       01:A0D7  00        
   49                       
   50                       
   51           BFFA        .org $BFFA     ;first of the three vectors starts here
   52  01:BFFA  3D D0       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   53                                        ;processor will jump to the label NMI:
   54  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   55                                        ;to the label RESET:
   56  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  02 62 00    .db $02, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  04 0F 1B    .db $04, $0F, $1B, $18, $10, $FF
       02:80A7  18 10 FF  
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                      
    9                     ;puzzles
   10  03:A000  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A002  00 80     
       03:A004  00 80     
       03:A006  00 80     
       03:A008  00 80     
       03:A00A  00 80     
       03:A00C  00 80     
       03:A00E  00 80     
       03:A010  00 80     
   11  03:A012  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A014  00 80     
       03:A016  00 80     
       03:A018  00 80     
       03:A01A  00 80     
       03:A01C  00 80     
       03:A01E  00 80     
       03:A020  00 80     
       03:A022  00 80     
   12  03:A024  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A026  00 80     
       03:A028  00 80     
       03:A02A  00 80     
       03:A02C  00 80     
       03:A02E  00 80     
       03:A030  00 80     
       03:A032  00 80     
       03:A034  00 80     
   13                     ;puzzle names
   14  03:A036  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A038  A4 80     
       03:A03A  A4 80     
       03:A03C  A4 80     
       03:A03E  A4 80     
       03:A040  A4 80     
       03:A042  A4 80     
       03:A044  A4 80     
       03:A046  A4 80     
   15  03:A048  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A04A  A4 80     
       03:A04C  A4 80     
       03:A04E  A4 80     
       03:A050  A4 80     
       03:A052  A4 80     
       03:A054  A4 80     
       03:A056  A4 80     
       03:A058  A4 80     
   16  03:A05A  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A05C  A4 80     
       03:A05E  A4 80     
       03:A060  A4 80     
       03:A062  A4 80     
       03:A064  A4 80     
       03:A066  A4 80     
       03:A068  A4 80     
       03:A06A  A4 80     
   17                     ;puzzle sprites
   18  03:A06C  00 00 00    .db $00, $00, $00, $00
       03:A06F  00        
   19  03:A070  00 00 00    .db $00, $00, $00, $00
       03:A073  00        
   20  03:A074  00 00 00    .db $00, $00, $00, $00
       03:A077  00        
   21  03:A078  00 00 00    .db $00, $00, $00, $00
       03:A07B  00        
   22  03:A07C  00 00 00    .db $00, $00, $00, $00
       03:A07F  00        
   23  03:A080  00 00 00    .db $00, $00, $00, $00
       03:A083  00        
   24  03:A084  00 00 00    .db $00, $00, $00, $00
       03:A087  00        
   25  03:A088  00 00 00    .db $00, $00, $00, $00
       03:A08B  00        
   26  03:A08C  00 00 00    .db $00, $00, $00, $00
       03:A08F  00        
   27  03:A090  00 00 00    .db $00, $00, $00, $00
       03:A093  00        
   28  03:A094  00 00 00    .db $00, $00, $00, $00
       03:A097  00        
   29  03:A098  00 00 00    .db $00, $00, $00, $00
       03:A09B  00        
   30  03:A09C  00 00 00    .db $00, $00, $00, $00
       03:A09F  00        
   31  03:A0A0  00 00 00    .db $00, $00, $00, $00
       03:A0A3  00        
   32  03:A0A4  00 00 00    .db $00, $00, $00, $00
       03:A0A7  00        
   33  03:A0A8  00 00 00    .db $00, $00, $00, $00
       03:A0AB  00        
   34  03:A0AC  00 00 00    .db $00, $00, $00, $00
       03:A0AF  00        
   35  03:A0B0  00 00 00    .db $00, $00, $00, $00
       03:A0B3  00        
   36  03:A0B4  00 00 00    .db $00, $00, $00, $00
       03:A0B7  00        
   37  03:A0B8  00 00 00    .db $00, $00, $00, $00
       03:A0BB  00        
   38  03:A0BC  00 00 00    .db $00, $00, $00, $00
       03:A0BF  00        
   39  03:A0C0  00 00 00    .db $00, $00, $00, $00
       03:A0C3  00        
   40  03:A0C4  00 00 00    .db $00, $00, $00, $00
       03:A0C7  00        
   41  03:A0C8  00 00 00    .db $00, $00, $00, $00
       03:A0CB  00        
   42  03:A0CC  00 00 00    .db $00, $00, $00, $00
       03:A0CF  00        
   43  03:A0D0  00 00 00    .db $00, $00, $00, $00
       03:A0D3  00        
   44  03:A0D4  00 00 00    .db $00, $00, $00, $00
       03:A0D7  00        
   45                       
   46                       
   47           BFFA        .org $BFFA     ;first of the three vectors starts here
   48  03:BFFA  3D D0       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   49                                        ;processor will jump to the label NMI:
   50  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   51                                        ;to the label RESET:
   52  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  02 7E 00    .db $02, $7E, $00, $2B
       04:8003  2B        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  03 0C 0A    .db $03, $0C, $0A, $1D, $FF
       04:80A5  1D FF     
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8                       
    9                     ;puzzles
   10  05:A000  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A002  00 80     
       05:A004  00 80     
       05:A006  00 80     
       05:A008  00 80     
       05:A00A  00 80     
       05:A00C  00 80     
       05:A00E  00 80     
       05:A010  00 80     
   11  05:A012  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A014  00 80     
       05:A016  00 80     
       05:A018  00 80     
       05:A01A  00 80     
       05:A01C  00 80     
       05:A01E  00 80     
       05:A020  00 80     
       05:A022  00 80     
   12  05:A024  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat
       05:A026  00 80     
       05:A028  00 80     
       05:A02A  00 80     
       05:A02C  00 80     
       05:A02E  00 80     
       05:A030  00 80     
       05:A032  00 80     
       05:A034  00 80     
   13                     ;puzzle names
   14  05:A036  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A038  A2 80     
       05:A03A  A2 80     
       05:A03C  A2 80     
       05:A03E  A2 80     
       05:A040  A2 80     
       05:A042  A2 80     
       05:A044  A2 80     
       05:A046  A2 80     
   15  05:A048  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A04A  A2 80     
       05:A04C  A2 80     
       05:A04E  A2 80     
       05:A050  A2 80     
       05:A052  A2 80     
       05:A054  A2 80     
       05:A056  A2 80     
       05:A058  A2 80     
   16  05:A05A  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName
       05:A05C  A2 80     
       05:A05E  A2 80     
       05:A060  A2 80     
       05:A062  A2 80     
       05:A064  A2 80     
       05:A066  A2 80     
       05:A068  A2 80     
       05:A06A  A2 80     
   17                     ;puzzle sprites
   18  05:A06C  00 00 00    .db $00, $00, $00, $00
       05:A06F  00        
   19  05:A070  00 00 00    .db $00, $00, $00, $00
       05:A073  00        
   20  05:A074  00 00 00    .db $00, $00, $00, $00
       05:A077  00        
   21  05:A078  00 00 00    .db $00, $00, $00, $00
       05:A07B  00        
   22  05:A07C  00 00 00    .db $00, $00, $00, $00
       05:A07F  00        
   23  05:A080  00 00 00    .db $00, $00, $00, $00
       05:A083  00        
   24  05:A084  00 00 00    .db $00, $00, $00, $00
       05:A087  00        
   25  05:A088  00 00 00    .db $00, $00, $00, $00
       05:A08B  00        
   26  05:A08C  00 00 00    .db $00, $00, $00, $00
       05:A08F  00        
   27  05:A090  00 00 00    .db $00, $00, $00, $00
       05:A093  00        
   28  05:A094  00 00 00    .db $00, $00, $00, $00
       05:A097  00        
   29  05:A098  00 00 00    .db $00, $00, $00, $00
       05:A09B  00        
   30  05:A09C  00 00 00    .db $00, $00, $00, $00
       05:A09F  00        
   31  05:A0A0  00 00 00    .db $00, $00, $00, $00
       05:A0A3  00        
   32  05:A0A4  00 00 00    .db $00, $00, $00, $00
       05:A0A7  00        
   33  05:A0A8  00 00 00    .db $00, $00, $00, $00
       05:A0AB  00        
   34  05:A0AC  00 00 00    .db $00, $00, $00, $00
       05:A0AF  00        
   35  05:A0B0  00 00 00    .db $00, $00, $00, $00
       05:A0B3  00        
   36  05:A0B4  00 00 00    .db $00, $00, $00, $00
       05:A0B7  00        
   37  05:A0B8  00 00 00    .db $00, $00, $00, $00
       05:A0BB  00        
   38  05:A0BC  00 00 00    .db $00, $00, $00, $00
       05:A0BF  00        
   39  05:A0C0  00 00 00    .db $00, $00, $00, $00
       05:A0C3  00        
   40  05:A0C4  00 00 00    .db $00, $00, $00, $00
       05:A0C7  00        
   41  05:A0C8  00 00 00    .db $00, $00, $00, $00
       05:A0CB  00        
   42  05:A0CC  00 00 00    .db $00, $00, $00, $00
       05:A0CF  00        
   43  05:A0D0  00 00 00    .db $00, $00, $00, $00
       05:A0D3  00        
   44  05:A0D4  00 00 00    .db $00, $00, $00, $00
       05:A0D7  00        
   45                     
   46           BFFA        .org $BFFA     ;first of the three vectors starts here
   47  05:BFFA  3D D0       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   48                                        ;processor will jump to the label NMI:
   49  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   50                                        ;to the label RESET:
   51  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 7A CC    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 7E CC    JSR SetMapperControls
   34                       
   35  06:C040  20 BB CC    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  A2 00       LDX #$00
   38  06:C04C  20 75 C9    JSR ChangeGameMode
   39  06:C04F  20 FF CB    JSR InitPPUControl
   40                       
   41                     
   42                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   43                     ;;     Main Program         ;;
   44                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   45                     
   46  06:C052            Forever:
   47                     
   48  06:C052  EE 0C 00    INC sleeping
   49                     
   50  06:C055            .loop
   51  06:C055  AD 0C 00    LDA sleeping
   52  06:C058  D0 FB       BNE .loop
   53                     
   54  06:C05A  EE 0A 00    INC time  
   55  06:C05D  AD C6 00    LDA pauseState
   56  06:C060  D0 03       BNE .skipScaleUpdate
   57  06:C062  EE 0B 00    INC scaledTime
   58  06:C065            .skipScaleUpdate:
   59  06:C065  20 6B C0    JSR GameLoop
   60                     
   61                     
   62  06:C068  4C 52 C0    JMP Forever     ;jump back to Forever, infinite loop
   63                       
   64                     ;; dynamic jump table
   65                     
   66  06:C06B            GameLoop:
   67                     
   68                       MACROCallDynamicJump game_mode
                          
       06:C06B  AD 0E 00    LDA game_mode
       06:C06E  20 32 CA    JSR Dynamic_Jump
                                  
   69                       ;; we'll pop the return address here as the table index, so 
   70                       ;; the routine we pick will return us to whatever called Game Loop
   71                       ;; when it returns
   72                     
   73  06:C071            GameLoopJumpTable:
   74                     
   75  06:C071  77 C0       .word UpdateTitle
   76  06:C073  A7 C2       .word UpdateGame
   77  06:C075  24 C9       .word UpdateGameOver
   78                       
   79                     
   80                       ;;RTS is called in the subroutine
   81                     
   82                       
#[2]   Routines/Game_States/UpdateTitle.asm
   83                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C077            UpdateTitle:
    2                     
    3  06:C077  AD 10 00    LDA NMI_locks
    4  06:C07A  F0 01       BEQ .unlocked
    5                       
    6  06:C07C  60          RTS
    7                       
    8  06:C07D            .unlocked:
    9                     
   10  06:C07D  20 81 C0    JSR DoUpdateTitle  
   11  06:C080  60          RTS
   12                       
   13  06:C081            DoUpdateTitle:
   14                     
   15  06:C081  AD 0F 00    LDA mode_state
   16  06:C084  20 32 CA    JSR Dynamic_Jump
   17                         
   18  06:C087            UpdateTitleJumpTable:
   19                     
   20  06:C087  93 C0       .word UpdateTitleInit
   21  06:C089  A4 C0       .word UpdateBankSelection
   22  06:C08B  CB C0       .word UpdateScroll
   23  06:C08D  EF C0       .word UpdatePuzzleSelection
   24  06:C08F  32 C1       .word UpdateScrollBack
   25  06:C091  51 C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C093            UpdateTitleInit:
   35                     
   36  06:C093  20 DB CB    JSR TurnOnSprites
   37                       
   38  06:C096  A9 00       LDA #$00
   39  06:C098  8D C1 00    STA mouse_index
   40  06:C09B  A9 00       LDA #$00
   41  06:C09D  8D C2 00    STA mouse_index+1
   42                     
   43  06:C0A0            .changeModeState:
   44                     
   45  06:C0A0  EE 0F 00    INC mode_state
   46  06:C0A3            .leave:
   47  06:C0A3  60          RTS
   48                       
   49  06:C0A4            UpdateBankSelection:
   50                     
   51  06:C0A4  20 F9 C1    JSR UpdateBankPointer
   52                       
   53  06:C0A7  AD 1A 00    LDA gamepadPressed
   54  06:C0AA  29 01       AND #GAMEPAD_A
   55  06:C0AC  F0 1C       BEQ .leave
   56                       
   57  06:C0AE            .changeModeState:
   58                     
   59                       ;;load bank
   60                       
   61  06:C0AE  AD C1 00    LDA mouse_index
   62  06:C0B1  8D 00 70    STA bank_index
   63  06:C0B4  A9 FF       LDA #$FF
   64  06:C0B6  A2 01       LDX #$01
   65  06:C0B8  20 DB C1    JSR SetSpriteImage
   66                        
   67                       ;;load bank
   68  06:C0BB  20 7A CC    JSR ResetMapper
   69  06:C0BE  AD 00 70    LDA bank_index
   70  06:C0C1  8D A7 00    STA currentPRGBank
   71  06:C0C4  20 89 CC    JSR LoadPRGBank
   72                     
   73  06:C0C7  EE 0F 00    INC mode_state
   74  06:C0CA            .leave:
   75  06:C0CA  60          RTS
   76                       
   77  06:C0CB            UpdateScroll:
   78  06:C0CB  EE 1D 00    INC PPU_ScrollX
   79  06:C0CE  EE 1D 00    INC PPU_ScrollX
   80  06:C0D1  EE 1D 00    INC PPU_ScrollX
   81  06:C0D4  EE 1D 00    INC PPU_ScrollX
   82  06:C0D7  D0 15       BNE .leave
   83  06:C0D9  AD 1F 00    LDA PPU_ScrollNT
   84  06:C0DC  49 01       EOR #%00000001
   85  06:C0DE  8D 1F 00    STA PPU_ScrollNT
   86                       
   87  06:C0E1            .changeModeState:
   88  06:C0E1  A9 01       LDA #$01
   89  06:C0E3  A2 01       LDX #$01
   90  06:C0E5  20 DB C1    JSR SetSpriteImage
   91  06:C0E8  20 9D C1    JSR InitPuzzlePointer
   92  06:C0EB  EE 0F 00    INC mode_state
   93  06:C0EE            .leave:
   94  06:C0EE  60          RTS
   95                       
   96  06:C0EF            UpdatePuzzleSelection:
   97                     
   98  06:C0EF  20 38 C2    JSR UpdatePuzzlePointer
   99                       
  100  06:C0F2  AD 1A 00    LDA gamepadPressed
  101  06:C0F5  29 02       AND #GAMEPAD_B
  102  06:C0F7  D0 10       BNE .changeToScrollBack
  103  06:C0F9  AD 1A 00    LDA gamepadPressed
  104  06:C0FC  29 09       AND #GAMEPAD_CONFIRM
  105  06:C0FE  F0 31       BEQ .leave
  106                       
  107  06:C100  EE 0F 00    INC mode_state
  108  06:C103  EE 0F 00    INC mode_state
  109  06:C106  4C 31 C1    JMP .leave
  110                       
  111  06:C109            .changeToScrollBack:
  112                      
  113  06:C109  A9 FF       LDA #$FF
  114  06:C10B  A2 01       LDX #$01
  115  06:C10D  20 DB C1    JSR SetSpriteImage
  116  06:C110  20 95 C1    JSR InitBankPointer
  117  06:C113  AD 00 70    LDA bank_index
  118  06:C116  8D C1 00    STA mouse_index
  119  06:C119  20 2B C2    JSR SetBankPointerFromIndex
  120                       
  121  06:C11C  A9 00       LDA #$00
  122  06:C11E  8D 1E 00    STA PPU_ScrollY
  123  06:C121  A9 FC       LDA #$FC
  124  06:C123  8D 1D 00    STA PPU_ScrollX
  125  06:C126  AD 1F 00    LDA PPU_ScrollNT
  126  06:C129  29 FE       AND #$FE
  127  06:C12B  8D 1F 00    STA PPU_ScrollNT
  128                       
  129  06:C12E  EE 0F 00    INC mode_state
  130  06:C131            .leave:
  131  06:C131  60          RTS
  132                       
  133  06:C132            UpdateScrollBack:
  134                     
  135  06:C132  CE 1D 00    DEC PPU_ScrollX
  136  06:C135  CE 1D 00    DEC PPU_ScrollX
  137  06:C138  CE 1D 00    DEC PPU_ScrollX
  138  06:C13B  CE 1D 00    DEC PPU_ScrollX
  139  06:C13E  D0 10       BNE .leave
  140                       
  141  06:C140            .changeModeState:
  142                     
  143  06:C140  A9 01       LDA #$01
  144  06:C142  A2 01       LDX #$01
  145  06:C144  20 DB C1    JSR SetSpriteImage
  146  06:C147  CE 0F 00    DEC mode_state
  147  06:C14A  CE 0F 00    DEC mode_state
  148  06:C14D  CE 0F 00    DEC mode_state
  149                       
  150  06:C150            .leave:
  151  06:C150  60          RTS
  152                       
  153  06:C151            UpdateTitleExit:
  154                     
  155                       ;;reset screen scroll
  156  06:C151  A9 00       LDA #$00
  157  06:C153  8D 1D 00    STA PPU_ScrollX
  158  06:C156  8D 1F 00    STA PPU_ScrollNT
  159                      
  160                       ;; we can also pick out the puzzle index
  161                       ;; we have the mouse indexes - one vert, one hori
  162                       ;; take vert, mult by 9- alternatively, mult by 8, add index 
  163                       ;; IE - ind = 1, mult 8 = 8, add 1 = 9
  164                       ;; add X index
  165  06:C159  AD C1 00    LDA mouse_index
  166  06:C15C  0A          ASL A
  167  06:C15D  0A          ASL A
  168  06:C15E  0A          ASL A
  169  06:C15F  18          CLC
  170  06:C160  6D C1 00    ADC mouse_index
  171  06:C163  6D C2 00    ADC mouse_index+1
  172  06:C166  8D 01 70    STA puzzle_index
  173                     
  174  06:C169  20 E4 CB    JSR TurnOffSprites
  175                       
  176                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C16C  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C16E  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C170  8E 14 00          STX table_address
       06:C173  8D 15 00          STA table_address+1
                                  
  177                       MACROGetDoubleIndex puzzle_index
                          
       06:C176  AD 01 70          LDA puzzle_index
       06:C179  0A                ASL A
       06:C17A  A8                TAY
                                  
  178  06:C17B  20 58 CA    JSR GetTableAtIndex
  179                       MACROGetPointer table_address, puzzle_address
                          
       06:C17E  AD 14 00          LDA table_address
       06:C181  8D A9 00          STA puzzle_address
       06:C184  AD 15 00          LDA table_address+1
       06:C187  8D AA 00          STA puzzle_address+1
                          
  180                     
  181  06:C18A  A0 00       LDY #$00
  182  06:C18C  B1 A9       LDA [puzzle_address], y
  183  06:C18E  AA          TAX
  184                     
  185  06:C18F  A9 01       LDA #GAME_IDX
  186  06:C191  20 75 C9    JSR ChangeGameMode
  187                       
  188  06:C194            .leave
  189  06:C194  60          RTS
  190                       
  191  06:C195            InitBankPointer:
  192                     
  193  06:C195  A2 A0       LDX #$A0
  194  06:C197  A9 60       LDA #$60
  195  06:C199  20 B0 C1    JSR InitPointer
  196                       
  197  06:C19C  60          RTS  
  198                       
  199  06:C19D            InitPuzzlePointer:
  200                       
  201  06:C19D  A2 AE       LDX #$AE
  202  06:C19F  A9 10       LDA #$10
  203  06:C1A1  20 B0 C1    JSR InitPointer
  204                       
  205  06:C1A4  60          RTS
  206                     
  207  06:C1A5            ResetMouseIndex:
  208                     
  209  06:C1A5  A9 00       LDA #$00
  210  06:C1A7  8D C1 00    STA mouse_index
  211  06:C1AA  A9 00       LDA #$00
  212  06:C1AC  8D C2 00    STA mouse_index+1
  213  06:C1AF  60          RTS
  214                     
  215  06:C1B0            InitPointer:
  216                     
  217  06:C1B0  20 B7 C1    JSR SetPointerPosition
  218  06:C1B3  20 A5 C1    JSR ResetMouseIndex
  219  06:C1B6  60          RTS  
  220                       
  221  06:C1B7            SetPointerPosition:
  222                     
  223  06:C1B7  48          PHA
  224  06:C1B8  8A          TXA
  225  06:C1B9  A2 01       LDX #$01
  226  06:C1BB  20 C5 C1    JSR SetSpriteYPosition
  227  06:C1BE  68          PLA
  228  06:C1BF  A2 01       LDX #$01
  229  06:C1C1  20 D0 C1    JSR SetSpriteXPosition
  230                      
  231  06:C1C4  60          RTS
  232                       
  233  06:C1C5            SetSpriteYPosition:
  234                       
  235  06:C1C5  48          PHA
  236  06:C1C6  A9 00       LDA #SPRITE_YPOS
  237  06:C1C8  20 E6 C1    JSR GetSpriteDataIndexInX
  238  06:C1CB  68          PLA
  239  06:C1CC  9D 00 02    STA SPRITE_DATA, x
  240  06:C1CF  60          RTS
  241                       
  242  06:C1D0            SetSpriteXPosition:  
  243                       
  244  06:C1D0  48          PHA
  245  06:C1D1  A9 03       LDA #SPRITE_XPOS
  246  06:C1D3  20 E6 C1    JSR GetSpriteDataIndexInX
  247  06:C1D6  68          PLA
  248  06:C1D7  9D 00 02    STA SPRITE_DATA, x 
  249  06:C1DA  60          RTS
  250                     
  251  06:C1DB            SetSpriteImage:
  252                     
  253                     ;; A has sprite image index we want
  254                     ;; X has the sprite index
  255  06:C1DB  48          PHA
  256  06:C1DC  A9 01       LDA #SPRITE_ID
  257  06:C1DE  20 E6 C1    JSR GetSpriteDataIndexInX
  258  06:C1E1  68          PLA
  259  06:C1E2  9D 00 02    STA SPRITE_DATA, x
  260  06:C1E5  60          RTS
  261                       
  262  06:C1E6            GetSpriteDataIndexInX:
  263                     
  264                       ;; A has data index we want to get
  265                       ;; X has sprite index
  266  06:C1E6  8D 02 00    STA temp3
  267  06:C1E9  8A          TXA
  268  06:C1EA  0A          ASL A
  269  06:C1EB  0A          ASL A
  270  06:C1EC  18          CLC
  271  06:C1ED  6D 02 00    ADC temp3
  272  06:C1F0  AA          TAX
  273                       
  274  06:C1F1  60          RTS  
  275  06:C1F2            GetSpriteData:
  276                     
  277                       ;;A is data we want
  278                       ;;X is Sprite
  279  06:C1F2  20 E6 C1    JSR GetSpriteDataIndexInX
  280  06:C1F5  BD 00 02    LDA SPRITE_DATA, x
  281  06:C1F8  60          RTS
  282                       
  283  06:C1F9            UpdateBankPointer:
  284                      
  285                       ;;bank pointer is 1D, will loop between 0->3
  286  06:C1F9  AD 1A 00    LDA gamepadPressed
  287  06:C1FC  D0 01       BNE .continue
  288  06:C1FE            .leaveEarly:
  289  06:C1FE  60          RTS
  290                       
  291  06:C1FF            .continue:
  292  06:C1FF  A9 00       LDA #$00
  293  06:C201  8D 00 00    STA temp1
  294                       
  295  06:C204            .parseInputs:
  296  06:C204  AD 1A 00    LDA gamepadPressed
  297  06:C207  29 30       AND #GAMEPAD_VERT
  298  06:C209  F0 F3       BEQ .leaveEarly
  299  06:C20B  0A          ASL A
  300  06:C20C  0A          ASL A
  301  06:C20D            .checkDown:
  302  06:C20D  0A          ASL A
  303  06:C20E  90 03       BCC .checkUp
  304  06:C210  EE 00 00    INC temp1
  305  06:C213            .checkUp:
  306  06:C213  0A          ASL A
  307  06:C214  90 03       BCC .move
  308  06:C216  CE 00 00    DEC temp1
  309  06:C219            .move:
  310                       
  311  06:C219  AD C1 00    LDA mouse_index
  312  06:C21C  18          CLC
  313  06:C21D  6D 00 00    ADC temp1
  314  06:C220  C9 02       CMP #$02
  315  06:C222  F0 04       BEQ .skipMod
  316  06:C224  90 02       BCC .skipMod
  317  06:C226  A9 00       LDA #$00
  318  06:C228            .skipMod:
  319  06:C228  8D C1 00    STA mouse_index
  320                       ;; mult mouse_index by 16
  321  06:C22B            SetBankPointerFromIndex:
  322                     
  323  06:C22B  0A          ASL A
  324  06:C22C  0A          ASL A
  325  06:C22D  0A          ASL A
  326  06:C22E  0A          ASL A
  327  06:C22F  18          CLC
  328  06:C230  69 A0       ADC #$A0
  329  06:C232  A2 01       LDX #$01
  330  06:C234  20 C5 C1    JSR SetSpriteYPosition
  331                     
  332  06:C237            .leave:
  333                       
  334  06:C237  60          RTS
  335                       
  336  06:C238            UpdatePuzzlePointer:
  337                     
  338                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  339  06:C238  AD 1A 00    LDA gamepadPressed
  340  06:C23B  F0 69       BEQ .leave 
  341                       
  342  06:C23D  A9 00       LDA #$00
  343  06:C23F  8D 00 00    STA temp1
  344  06:C242  8D 01 00    STA temp2
  345                       
  346  06:C245            .parseInputs:
  347  06:C245  AD 1A 00    LDA gamepadPressed
  348  06:C248  29 F0       AND #GAMEPAD_MOVE
  349  06:C24A  F0 5A       BEQ .leave
  350  06:C24C  0A          ASL A
  351  06:C24D  90 03       BCC .checkLeft
  352  06:C24F  EE 00 00    INC temp1
  353  06:C252            .checkLeft:
  354  06:C252  0A          ASL A
  355  06:C253  90 03       BCC .checkDown
  356  06:C255  CE 00 00    DEC temp1
  357  06:C258            .checkDown:
  358  06:C258  0A          ASL A
  359  06:C259  90 03       BCC .checkUp
  360  06:C25B  EE 01 00    INC temp2
  361  06:C25E            .checkUp:
  362  06:C25E  0A          ASL A
  363  06:C25F  90 03       BCC .move
  364  06:C261  CE 01 00    DEC temp2
  365                       
  366  06:C264            .move:
  367                     
  368  06:C264  AD C1 00    LDA mouse_index
  369  06:C267  18          CLC
  370  06:C268  6D 01 00    ADC temp2
  371  06:C26B  C9 02       CMP #$02
  372  06:C26D  F0 04       BEQ .skipYMod
  373  06:C26F  90 02       BCC .skipYMod
  374  06:C271  A9 00       LDA #$00
  375  06:C273            .skipYMod:
  376  06:C273  8D C1 00    STA mouse_index
  377                       ;; mult mouse_index by 16
  378  06:C276  0A          ASL A
  379  06:C277  0A          ASL A
  380  06:C278  0A          ASL A
  381  06:C279  0A          ASL A
  382  06:C27A  18          CLC
  383  06:C27B  69 AE       ADC #$AE
  384  06:C27D  A2 01       LDX #$01
  385  06:C27F  20 C5 C1    JSR SetSpriteYPosition
  386                       
  387  06:C282  AD C2 00    LDA mouse_index+1
  388  06:C285  18          CLC
  389  06:C286  6D 00 00    ADC temp1
  390  06:C289  C9 08       CMP #$08
  391  06:C28B  F0 04       BEQ .skipXMod
  392  06:C28D  90 02       BCC .skipXMod
  393  06:C28F  A9 00       LDA #$00
  394  06:C291            .skipXMod:
  395  06:C291  8D C2 00    STA mouse_index+1
  396                       ;; we need to move 3 tiles each- so index * 3 * 8,
  397  06:C294  18          CLC
  398  06:C295  6D C2 00    ADC mouse_index+1
  399  06:C298  6D C2 00    ADC mouse_index+1
  400  06:C29B  0A          ASL A
  401  06:C29C  0A          ASL A
  402  06:C29D  0A          ASL A
  403  06:C29E  18          CLC
  404  06:C29F  69 10       ADC #$10
  405  06:C2A1  A2 01       LDX #$01
  406  06:C2A3  20 D0 C1    JSR SetSpriteXPosition
  407                       
  408  06:C2A6            .leave:
  409                       
  410  06:C2A6  60          RTS
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   84                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6           20A8      BANK_LEVEL = $20A8
    7           20E5      TIMER_LOC = $20E5
    8                     
    9           618E      MOUSE_START = $618E
   10                     
   11           0010      HOLD_TIME = $10
   12           0004      HOLD_FREQ = $04
   13                     
   14  06:C2A7            UpdateGame:
   15                     
   16  06:C2A7  AD 10 00    LDA NMI_locks
   17  06:C2AA  F0 01       BEQ .unlocked
   18                       
   19  06:C2AC  60          RTS
   20                       
   21  06:C2AD            .unlocked:
   22                     
   23  06:C2AD  20 B1 C2    JSR DoUpdateGame
   24  06:C2B0  60          RTS
   25                       
   26  06:C2B1            DoUpdateGame:
   27                     
   28  06:C2B1  AD 0F 00    LDA mode_state
   29  06:C2B4  20 32 CA    JSR Dynamic_Jump
   30                       
   31  06:C2B7            UpdateGameJumpTable:
   32                     
   33  06:C2B7  CB C2       .word UpdateGameInit
   34  06:C2B9  77 C3       .word UpdateDrawVertClues
   35  06:C2BB  9F C3       .word UpdateDrawHoriClues
   36  06:C2BD  E5 C3       .word UpdateGamePlay
   37  06:C2BF  BC C5       .word UpdateClearPuzzle
   38  06:C2C1  CF C5       .word UpdateMoveScreen
   39  06:C2C3  48 C6       .word UpdateDrawImage
   40  06:C2C5  CE C6       .word UpdateWaitInput
   41  06:C2C7  E4 C6       .word UpdateGameFadeOut
   42  06:C2C9  F9 C6       .word UpdateGameExit
   43                     
   44  06:C2CB            UpdateGameInit:
   45                     
   46                       ;; get the puzzle table in the puzzle address
   47                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C2CB  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C2CD  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C2CF  8E 14 00          STX table_address
       06:C2D2  8D 15 00          STA table_address+1
                                  
   48                       MACROGetDoubleIndex puzzle_index
                          
       06:C2D5  AD 01 70          LDA puzzle_index
       06:C2D8  0A                ASL A
       06:C2D9  A8                TAY
                                  
   49  06:C2DA  20 58 CA    JSR GetTableAtIndex
   50                       MACROGetPointer table_address, puzzle_address
                          
       06:C2DD  AD 14 00          LDA table_address
       06:C2E0  8D A9 00          STA puzzle_address
       06:C2E3  AD 15 00          LDA table_address+1
       06:C2E6  8D AA 00          STA puzzle_address+1
                          
   51                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C2E9  A9 61             LDA #HIGH(MOUSE_START)
       06:C2EB  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C2ED  8E BF 00          STX mouse_location
       06:C2F0  8D C0 00          STA mouse_location+1
                                  
   52                       
   53                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   54  06:C2F3  A0 00       LDY #$00
   55  06:C2F5  B1 A9       LDA [puzzle_address], y
   56  06:C2F7  AA          TAX
   57  06:C2F8  BD 21 C9    LDA PuzzleHeaderSkips, x
   58  06:C2FB  8D 00 00    STA temp1
   59                       
   60  06:C2FE  AD A9 00    LDA puzzle_address
   61  06:C301  18          CLC
   62  06:C302  6D 00 00    ADC temp1
   63  06:C305  8D AB 00    STA clues_address
   64  06:C308  A9 00       LDA #$00
   65  06:C30A  6D AA 00    ADC puzzle_address+1
   66  06:C30D  8D AC 00    STA clues_address+1
   67                     
   68  06:C310  A9 00       LDA #$00
   69  06:C312  8D B7 00    STA clueTableIndex
   70  06:C315  8D B8 00    STA clueLineIndex
   71  06:C318  8D BE 00    STA clueParity
   72  06:C31B  8D B9 00    STA clueOffsetShift
   73  06:C31E  8D C1 00    STA mouse_index
   74  06:C321  8D C2 00    STA mouse_index+1
   75  06:C324  8D C4 00    STA solutionCount
   76  06:C327  8D C5 00    STA nonSolutionCount
   77  06:C32A  8D C9 00    STA GameTime
   78  06:C32D  8D CA 00    STA GameTime+1
   79  06:C330  8D CB 00    STA GameTime+2
   80  06:C333  8D CC 00    STA GameTime+3
   81                             
   82  06:C336  A9 20       LDA #$20
   83  06:C338  8D BA 00    STA clueDrawAdd
   84                        
   85                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C33B  A9 21             LDA #HIGH(VERT_CLUES)
       06:C33D  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C33F  8E B3 00          STX clue_start_address
       06:C342  8D B4 00          STA clue_start_address+1
                                  
   86  06:C345  20 6C CD    JSR ResetClueDrawAddress
   87                       
   88                       MACROAddPPUStringEntryRawData #HIGH(BANK_LEVEL), #LOW(BANK_LEVEL), #DRAW_HORIZONTAL, #$03
                          
       06:C348  A9 01       LDA #$01
       06:C34A  8D 21 00    STA PPU_PendingWrite
       06:C34D  A9 20       LDA #HIGH(BANK_LEVEL)
       06:C34F  20 93 CB    JSR WriteToPPUString
       06:C352  A9 A8       LDA #LOW(BANK_LEVEL)
       06:C354  20 93 CB    JSR WriteToPPUString
       06:C357  A9 00       LDA #DRAW_HORIZONTAL
       06:C359  20 93 CB    JSR WriteToPPUString
       06:C35C  A9 03       LDA #$03 
       06:C35E  20 93 CB    JSR WriteToPPUString
                            
   89  06:C361  AD 00 70    LDA bank_index
   90  06:C364  20 93 CB    JSR WriteToPPUString
   91  06:C367  A9 60       LDA #$60
   92  06:C369  20 93 CB    JSR WriteToPPUString
   93  06:C36C  AE 01 70    LDX puzzle_index
   94  06:C36F  E8          INX
   95  06:C370  8A          TXA 
   96  06:C371  20 93 CB    JSR WriteToPPUString
   97                       
   98  06:C374  EE 0F 00    INC mode_state
   99                     
  100  06:C377            UpdateDrawVertClues:
  101                       
  102  06:C377  20 D1 CC    JSR PopulateClues
  103  06:C37A  90 22       BCC .leave
  104                       
  105  06:C37C            .changeModeState:
  106                     
  107  06:C37C  A9 00       LDA #$00
  108  06:C37E  8D B8 00    STA clueLineIndex
  109  06:C381  8D BE 00    STA clueParity
  110                       
  111  06:C384  A9 05       LDA #$05
  112  06:C386  8D B9 00    STA clueOffsetShift
  113                       
  114  06:C389  A9 01       LDA #$01
  115  06:C38B  8D BA 00    STA clueDrawAdd
  116                        
  117                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C38E  A9 21             LDA #HIGH(HORI_CLUES)
       06:C390  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C392  8E B3 00          STX clue_start_address
       06:C395  8D B4 00          STA clue_start_address+1
                                  
  118  06:C398  20 6C CD    JSR ResetClueDrawAddress
  119                     
  120  06:C39B  EE 0F 00    INC mode_state
  121  06:C39E            .leave:
  122  06:C39E  60          RTS
  123                       
  124  06:C39F            UpdateDrawHoriClues:
  125                     
  126  06:C39F  20 D1 CC    JSR PopulateClues
  127  06:C3A2  90 40       BCC .leave
  128                     
  129  06:C3A4            .changeModeState:
  130  06:C3A4  20 DB CB    JSR TurnOnSprites
  131                       
  132                       ;;set the timer to 00
  133                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C3A7  A9 01       LDA #$01
       06:C3A9  8D 21 00    STA PPU_PendingWrite
       06:C3AC  A9 20       LDA #HIGH(TIMER_LOC)
       06:C3AE  20 93 CB    JSR WriteToPPUString
       06:C3B1  A9 E5       LDA #LOW(TIMER_LOC)
       06:C3B3  20 93 CB    JSR WriteToPPUString
       06:C3B6  A9 00       LDA #DRAW_HORIZONTAL
       06:C3B8  20 93 CB    JSR WriteToPPUString
       06:C3BB  A9 05       LDA #$05 
       06:C3BD  20 93 CB    JSR WriteToPPUString
                            
  134  06:C3C0  A9 00       LDA #$00
  135  06:C3C2  20 93 CB    JSR WriteToPPUString
  136  06:C3C5  A9 00       LDA #$00
  137  06:C3C7  20 93 CB    JSR WriteToPPUString
  138  06:C3CA  A9 61       LDA #$61
  139  06:C3CC  20 93 CB    JSR WriteToPPUString
  140  06:C3CF  A9 00       LDA #$00
  141  06:C3D1  20 93 CB    JSR WriteToPPUString
  142  06:C3D4  A9 00       LDA #$00
  143  06:C3D6  20 93 CB    JSR WriteToPPUString
  144                       
  145                       ;;reset time
  146  06:C3D9  A9 00       LDA #$00
  147  06:C3DB  8D 0A 00    STA time
  148  06:C3DE  8D 0B 00    STA scaledTime
  149                       
  150  06:C3E1  EE 0F 00    INC mode_state
  151  06:C3E4            .leave:
  152  06:C3E4  60          RTS
  153                       
  154  06:C3E5            UpdateGamePlay:
  155                         
  156  06:C3E5  AD C6 00    LDA pauseState
  157  06:C3E8  F0 04       BEQ .checkPause
  158  06:C3EA  20 4F C8    JSR UpdatePause
  159  06:C3ED  60          RTS
  160                       
  161  06:C3EE            .checkPause:
  162                       
  163  06:C3EE  AD 1A 00    LDA gamepadPressed
  164  06:C3F1  29 08       AND #GAMEPAD_START
  165  06:C3F3  F0 29       BEQ .updatePlay
  166  06:C3F5  A9 01       LDA #$01
  167  06:C3F7  8D C6 00    STA pauseState
  168  06:C3FA  A9 00       LDA #$00
  169  06:C3FC  8D B8 00    STA clueLineIndex 
  170  06:C3FF  8D B9 00    STA clueOffsetShift   
  171                     
  172  06:C402  A9 FF       LDA #$FF
  173  06:C404  A2 00       LDX #$00
  174  06:C406  20 DB C1    JSR SetSpriteImage
  175                     
  176                       ;;we need the pause screen table loaded
  177                       MACROGetLabelPointer Pause_Menu, pause_address
                          
       06:C409  A9 FC             LDA #HIGH(Pause_Menu)
       06:C40B  A2 7C             LDX #LOW(Pause_Menu)
                                  
       06:C40D  8E AD 00          STX pause_address
       06:C410  8D AE 00          STA pause_address+1
                                  
  178                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C413  A9 21             LDA #HIGH($210A)
       06:C415  A2 0A             LDX #LOW($210A)
                                  
       06:C417  8E B1 00          STX pause_draw_address
       06:C41A  8D B2 00          STA pause_draw_address+1
                                  
  179                       
  180                       
  181  06:C41D  60          RTS
  182                     
  183  06:C41E            .updatePlay:
  184                     
  185  06:C41E  20 D0 C7    JSR UpdateTimeDisplay
  186                             
  187  06:C421  A9 00       LDA #$00
  188  06:C423  8D 00 00    STA temp1
  189  06:C426  8D 01 00    STA temp2
  190  06:C429  8D 02 00    STA temp3
  191                       
  192  06:C42C            .checkPressed:  
  193                     
  194  06:C42C  AD 1A 00    LDA gamepadPressed
  195  06:C42F  29 F0       AND #GAMEPAD_MOVE
  196  06:C431  F0 0B       BEQ .checkHeld
  197                       
  198  06:C433  A9 10       LDA #HOLD_TIME
  199  06:C435  8D C8 00    STA holdTimer 
  200  06:C438  AD 1A 00    LDA gamepadPressed
  201  06:C43B  4C 52 C4    JMP .parseInputs
  202                       
  203  06:C43E            .checkHeld:
  204                       
  205  06:C43E  AD 18 00    LDA gamepad
  206  06:C441  29 F0       AND #GAMEPAD_MOVE
  207  06:C443  F0 2F       BEQ .checkPaintPress
  208                       
  209                       ;;decrement the hold timer
  210  06:C445  CE C8 00    DEC holdTimer
  211  06:C448  D0 2A       BNE .checkPaintPress
  212  06:C44A  A9 04       LDA #HOLD_FREQ
  213  06:C44C  8D C8 00    STA holdTimer
  214  06:C44F  AD 18 00    LDA gamepad
  215                     
  216  06:C452            .parseInputs:
  217                     
  218  06:C452  29 F0       AND #GAMEPAD_MOVE
  219  06:C454  F0 1E       BEQ .checkPaintPress
  220  06:C456  0A          ASL A
  221  06:C457  90 03       BCC .checkLeft
  222  06:C459  EE 00 00    INC temp1
  223  06:C45C            .checkLeft:
  224  06:C45C  0A          ASL A
  225  06:C45D  90 03       BCC .checkDown
  226  06:C45F  CE 00 00    DEC temp1
  227  06:C462            .checkDown:
  228  06:C462  0A          ASL A
  229  06:C463  90 03       BCC .checkUp
  230  06:C465  EE 01 00    INC temp2
  231  06:C468            .checkUp:
  232  06:C468  0A          ASL A
  233  06:C469  90 03       BCC .move
  234  06:C46B  CE 01 00    DEC temp2
  235                       
  236  06:C46E            .move:
  237                      
  238  06:C46E  20 14 C7    JSR MoveMouse
  239  06:C471  20 7C C7    JSR UpdateMouseScreenPos
  240                       
  241  06:C474            .checkPaintPress:
  242                     
  243  06:C474  AD 1A 00    LDA gamepadPressed
  244  06:C477  29 03       AND #GAMEPAD_AB
  245  06:C479  F0 41       BEQ .updatePaint
  246                       ;;A or B pressed, get current tile
  247                       
  248  06:C47B  8D 00 00    STA temp1
  249                       
  250  06:C47E  A0 00       LDY #$00
  251  06:C480  B1 BF       LDA [mouse_location], y
  252  06:C482  8D 01 00    STA temp2
  253                       
  254                         ;;A treats X and Clear as clear
  255                             ;;B treats mark and clear as clear
  256                             ;;clear->mark->x
  257                             
  258                     
  259  06:C485  C9 7C       CMP #$7C      ;check if this is a marked tile
  260  06:C487  B0 0F       BCS .getClearTile
  261                       ;;cleared tile- store off marked tile to paint with instead
  262                       ;;not a clear tile- a mark or an x - check A or B  
  263  06:C489  4E 00 00    LSR temp1
  264  06:C48C  B0 05       BCS .getMarkTile
  265                       
  266  06:C48E            .getXTile:
  267  06:C48E  A9 80       LDA #$80
  268  06:C490  4C B6 C4    JMP .finishGetTile
  269                       
  270  06:C493            .getMarkTile:
  271  06:C493  A9 70       LDA #$70
  272  06:C495  4C B6 C4    JMP .finishGetTile
  273                     
  274  06:C498            .getClearTile:
  275                       
  276  06:C498  4E 00 00    LSR temp1
  277  06:C49B  90 0A       BCC .checkB
  278  06:C49D  AD 01 00    LDA temp2
  279  06:C4A0  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  280  06:C4A2  90 0D       BCC .clearTile
  281  06:C4A4  4C 93 C4    JMP .getMarkTile
  282                       
  283  06:C4A7            .checkB:
  284                       
  285  06:C4A7  AD 01 00   LDA temp2
  286  06:C4AA  C9 8C      CMP #$8C
  287  06:C4AC  B0 03      BCS .clearTile
  288  06:C4AE  4C 8E C4   JMP .getXTile
  289                       
  290  06:C4B1            .clearTile:
  291  06:C4B1  A9 60       LDA #$60
  292  06:C4B3  4C B6 C4    JMP .finishGetTile
  293                       
  294  06:C4B6            .finishGetTile:
  295  06:C4B6  8D C3 00    STA currentPaintTile
  296  06:C4B9  4C CE C4    JMP .setTile
  297                     
  298                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  299                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  300                     ;;we can load the nametable into memory as we draw it
  301                     
  302  06:C4BC            .updatePaint:
  303                     
  304  06:C4BC  AD 18 00    LDA gamepad
  305  06:C4BF  29 03       AND #GAMEPAD_AB
  306  06:C4C1  D0 06       BNE .checkInputLock
  307                       
  308  06:C4C3  A9 00       LDA #$00
  309  06:C4C5  8D C7 00    STA pauseInputLock
  310                       
  311  06:C4C8            .leaveEarly:
  312  06:C4C8  60          RTS  
  313                     
  314  06:C4C9            .checkInputLock:
  315                     
  316                       ;;check if the input lock is on
  317  06:C4C9  2D C7 00    AND pauseInputLock
  318  06:C4CC  D0 FA       BNE .leaveEarly
  319                       
  320  06:C4CE            .setTile:
  321                       
  322                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  323  06:C4CE  AD C2 00    LDA mouse_index+1
  324                     ;;if the puzzle is a 5x5, we only have one byte per row, so no need to double this
  325  06:C4D1  8D 00 00    STA temp1
  326  06:C4D4  A0 00       LDY #$00
  327  06:C4D6  B1 A9       LDA [puzzle_address], y
  328  06:C4D8  F0 03       BEQ .skipDouble
  329  06:C4DA  0E 00 00    ASL temp1
  330  06:C4DD            .skipDouble:
  331  06:C4DD  AD 00 00    LDA temp1
  332  06:C4E0  18          CLC
  333  06:C4E1  69 04       ADC #$04 ;; add to get past header
  334  06:C4E3  8D 00 00    STA temp1
  335                       
  336                       ;;div X position by 8 to get the byte index
  337  06:C4E6  AD C1 00    LDA mouse_index
  338  06:C4E9  4A          LSR A
  339  06:C4EA  4A          LSR A
  340  06:C4EB  4A          LSR A
  341  06:C4EC  F0 03       BEQ .getMask
  342                       
  343  06:C4EE  EE 00 00    INC temp1
  344                       
  345  06:C4F1            .getMask:
  346                       
  347  06:C4F1  AD C1 00    LDA mouse_index
  348  06:C4F4  29 07       AND #$07
  349  06:C4F6  AA          TAX
  350  06:C4F7  A9 80       LDA #$80
  351  06:C4F9  E0 00       CPX #$00
  352  06:C4FB  F0 04       BEQ .storeMask
  353                     
  354  06:C4FD            .maskLoop:
  355  06:C4FD  4A          LSR A
  356  06:C4FE  CA          DEX
  357  06:C4FF  D0 FC       BNE .maskLoop
  358  06:C501            .storeMask:
  359  06:C501  8D 01 00    STA temp2
  360                     
  361  06:C504  AC 00 00    LDY temp1
  362  06:C507  B1 A9       LDA [puzzle_address], y
  363  06:C509  2D 01 00    AND temp2
  364  06:C50C  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  365                     
  366  06:C50F  A0 00       LDY #$00
  367  06:C511  B1 BF       LDA [mouse_location], y
  368  06:C513  8D 02 00    STA temp3
  369  06:C516  29 F0       AND #$F0
  370  06:C518  CD C3 00    CMP currentPaintTile
  371  06:C51B  D0 01       BNE .diffTiles
  372  06:C51D  60          RTS
  373                       
  374  06:C51E            .diffTiles:
  375                       ;;tiles are different- check if the current tile is marked as a solution tile
  376  06:C51E  C9 70       CMP #$70
  377  06:C520  D0 0B       BNE .checkNewMark
  378                       ;;if erasing a mark, check if the tile was part of the solution
  379  06:C522  AD 00 00    LDA temp1
  380  06:C525  D0 18       BNE .antiMark
  381  06:C527  CE C5 00    DEC nonSolutionCount
  382  06:C52A  4C 48 C5    JMP .overwriteTile
  383                       
  384  06:C52D            .checkNewMark:
  385                     
  386  06:C52D  AD C3 00    LDA currentPaintTile
  387  06:C530  C9 70       CMP #$70
  388  06:C532  D0 14       BNE .overwriteTile
  389                       
  390  06:C534  AD 00 00    LDA temp1
  391  06:C537  D0 0C       BNE .proMark
  392  06:C539  EE C5 00    INC nonSolutionCount 
  393  06:C53C  4C 48 C5    JMP .overwriteTile  
  394                       
  395  06:C53F            .antiMark:
  396  06:C53F  CE C4 00    DEC solutionCount
  397  06:C542  4C 48 C5    JMP .overwriteTile
  398  06:C545            .proMark:   
  399                       
  400  06:C545  EE C4 00    INC solutionCount
  401                       
  402  06:C548            .overwriteTile:
  403                       ;;overwrite tile
  404  06:C548  AD 02 00    LDA temp3
  405  06:C54B  29 0F       AND #$0F
  406  06:C54D  0D C3 00    ORA currentPaintTile
  407  06:C550  A0 00       LDY #$00
  408  06:C552  91 BF       STA [mouse_location], y
  409  06:C554  8D 00 00    STA temp1
  410                       
  411  06:C557  AD C0 00    LDA mouse_location+1
  412  06:C55A  29 3F       AND #$3F
  413  06:C55C  8D 01 00    STA temp2
  414                         
  415                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C55F  A9 01       LDA #$01
       06:C561  8D 21 00    STA PPU_PendingWrite
       06:C564  AD 01 00    LDA temp2
       06:C567  20 93 CB    JSR WriteToPPUString
       06:C56A  AD BF 00    LDA mouse_location
       06:C56D  20 93 CB    JSR WriteToPPUString
       06:C570  A9 00       LDA #DRAW_HORIZONTAL
       06:C572  20 93 CB    JSR WriteToPPUString
       06:C575  A9 01       LDA #$01 
       06:C577  20 93 CB    JSR WriteToPPUString
                            
  416  06:C57A  AD 00 00    LDA temp1
  417  06:C57D  20 93 CB    JSR WriteToPPUString
  418                       
  419                       ;;also copy to ... copy
  420  06:C580  AD B5 00    LDA clue_draw_address
  421  06:C583  8D AF 00    STA copy_address
  422  06:C586  AD B6 00    LDA clue_draw_address+1
  423  06:C589  29 0F       AND #$0F
  424  06:C58B  09 60       ORA #$60
  425  06:C58D  8D B0 00    STA copy_address+1
  426  06:C590  AD 00 00    LDA temp1
  427  06:C593  A0 00       LDY #$00
  428  06:C595  91 AF       STA [copy_address],y
  429                       
  430  06:C597            .checkSolution: 
  431                     
  432  06:C597  A0 01       LDY #$01
  433  06:C599  B1 A9       LDA [puzzle_address], y
  434  06:C59B  CD C4 00    CMP solutionCount
  435  06:C59E  D0 1B       BNE .leave
  436  06:C5A0  AD C5 00    LDA nonSolutionCount
  437  06:C5A3  F0 03       BEQ .changeModeState
  438                       
  439  06:C5A5  4C BB C5    JMP .leave
  440                       
  441                       ;;update the painting
  442  06:C5A8            .changeModeState:
  443                      
  444  06:C5A8  20 E4 CB    JSR TurnOffSprites
  445                        
  446  06:C5AB  A9 00       LDA #$00
  447  06:C5AD  8D B5 00    STA clue_draw_address
  448  06:C5B0  8D B8 00    STA clueLineIndex
  449  06:C5B3  A9 20       LDA #$20
  450  06:C5B5  8D B6 00    STA clue_draw_address+1
  451                       
  452  06:C5B8  EE 0F 00    INC mode_state
  453                     
  454  06:C5BB            .leave:
  455                      
  456  06:C5BB  60          RTS
  457                       
  458  06:C5BC            UpdateClearPuzzle:
  459                     
  460  06:C5BC  20 E0 CD    JSR ClearPuzzle
  461  06:C5BF  AD B8 00    LDA clueLineIndex
  462  06:C5C2  C9 1E       CMP #30
  463  06:C5C4  D0 08       BNE .leave
  464                       
  465  06:C5C6            .changeModeState:
  466                     
  467  06:C5C6  A9 00       LDA #$00
  468  06:C5C8  8D B8 00    STA clueLineIndex ;using this as a scroller
  469  06:C5CB  EE 0F 00    INC mode_state
  470                     
  471  06:C5CE            .leave:
  472                      
  473  06:C5CE  60          RTS
  474  06:C5CF            UpdateMoveScreen:
  475                       
  476                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  477                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  478                       
  479  06:C5CF  A0 00       LDY #$00
  480  06:C5D1  B1 A9       LDA [puzzle_address], y
  481  06:C5D3  AA          TAX
  482  06:C5D4  BD 1B C9    LDA PuzzleScrollHori, x
  483  06:C5D7  8D 00 00    STA temp1
  484  06:C5DA  BD 1E C9    LDA PuzzleScrollVert, x
  485  06:C5DD  8D 01 00    STA temp2
  486                       
  487  06:C5E0  AD B8 00    LDA clueLineIndex
  488  06:C5E3  29 10       AND #$10
  489  06:C5E5  D0 1E       BNE .scrollY
  490                       
  491                       ;;scroll X over
  492  06:C5E7  AD B8 00    LDA clueLineIndex
  493  06:C5EA  29 0F       AND #$0F
  494  06:C5EC  0A          ASL A
  495  06:C5ED  0A          ASL A
  496  06:C5EE  0A          ASL A ;mult by 8
  497  06:C5EF  8D 1D 00    STA PPU_ScrollX
  498                       
  499  06:C5F2  EE B8 00    INC clueLineIndex
  500  06:C5F5  AD B8 00    LDA clueLineIndex
  501  06:C5F8  CD 00 00    CMP temp1
  502  06:C5FB  D0 4A       BNE .leave
  503  06:C5FD  A9 10       LDA #$10
  504  06:C5FF  8D B8 00    STA clueLineIndex
  505  06:C602  4C 47 C6    JMP .leave
  506                       
  507  06:C605            .scrollY:
  508                     
  509  06:C605  AD B8 00    LDA clueLineIndex
  510  06:C608  29 0F       AND #$0F
  511  06:C60A  0A          ASL A
  512  06:C60B  0A          ASL A
  513  06:C60C  0A          ASL A ;mult by 8
  514  06:C60D  8D 1E 00    STA PPU_ScrollY
  515                     
  516  06:C610  EE B8 00    INC clueLineIndex
  517  06:C613  AD B8 00    LDA clueLineIndex
  518  06:C616  29 0F       AND #$0F
  519  06:C618  CD 01 00    CMP temp2
  520  06:C61B  D0 2A       BNE .leave
  521                       
  522  06:C61D            .changeModeState:
  523                     
  524  06:C61D  A9 8E       LDA #$8E
  525  06:C61F  8D B5 00    STA clue_draw_address
  526  06:C622  A9 21       LDA #$21
  527  06:C624  8D B6 00    STA clue_draw_address+1
  528                       
  529  06:C627  AD AB 00    LDA clues_address
  530  06:C62A  18          CLC
  531  06:C62B  6D B7 00    ADC clueTableIndex
  532  06:C62E  8D AB 00    STA clues_address
  533  06:C631  AD AC 00    LDA clues_address+1
  534  06:C634  69 00       ADC #$00
  535  06:C636  8D AC 00    STA clues_address+1
  536                       
  537  06:C639  A9 00       LDA #$00
  538  06:C63B  8D B7 00    STA clueTableIndex
  539  06:C63E  8D B8 00    STA clueLineIndex
  540  06:C641  8D B9 00    STA clueOffsetShift
  541                     
  542  06:C644  EE 0F 00    INC mode_state
  543                     
  544  06:C647            .leave:
  545                      
  546  06:C647  60          RTS
  547  06:C648            UpdateDrawImage:
  548                     
  549                       ;run it twice for a faster draw
  550  06:C648  20 C2 CE    JSR DrawImage
  551  06:C64B  AD B7 00    LDA clueTableIndex
  552  06:C64E  CD 09 00    CMP tempy
  553                       ;BEQ .changeModeState
  554                       
  555                       ;JSR DrawImage
  556                       ;LDA clueTableIndex
  557                       ;CMP tempy
  558  06:C651  D0 7A       BNE .leave
  559                       
  560  06:C653            .changeModeState:
  561                     
  562                       ;;do a palette draw
  563                       ;;puzzle address + 03 has the desired palette offset
  564                     
  565  06:C653  A0 03       LDY #$03
  566  06:C655  B1 A9       LDA [puzzle_address],y
  567  06:C657  29 0F       AND #$0F
  568  06:C659  AA          TAX
  569                       
  570  06:C65A  B1 A9       LDA [puzzle_address],y
  571  06:C65C  29 10       AND #$10
  572  06:C65E  F0 15       BEQ .storeBottomVals
  573                       
  574  06:C660  8A          TXA
  575  06:C661  09 10       ORA #$10
  576  06:C663  8D 01 00    STA temp2
  577  06:C666  8A          TXA
  578  06:C667  09 20       ORA #$20
  579  06:C669  8D 02 00    STA temp3
  580  06:C66C  8A          TXA
  581  06:C66D  09 30       ORA #$30
  582  06:C66F  8D 03 00    STA temp4
  583                     
  584  06:C672  4C 87 C6    JMP .checkKeepWhite
  585                       
  586  06:C675            .storeBottomVals:
  587                     
  588  06:C675  8A          TXA
  589  06:C676  09 00       ORA #$00
  590  06:C678  8D 01 00    STA temp2
  591  06:C67B  8A          TXA
  592  06:C67C  09 10       ORA #$10
  593  06:C67E  8D 02 00    STA temp3
  594  06:C681  8A          TXA
  595  06:C682  09 20       ORA #$20
  596  06:C684  8D 03 00    STA temp4
  597                       
  598  06:C687            .checkKeepWhite:
  599                       
  600  06:C687  B1 A9       LDA [puzzle_address],y
  601  06:C689  29 20       AND #$20
  602  06:C68B  F0 05       BEQ .loadPalToPPUStr
  603                       
  604  06:C68D  A9 30       LDA #$30
  605  06:C68F  8D 03 00    STA temp4
  606                       
  607                       
  608  06:C692            .loadPalToPPUStr:
  609                       
  610                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C692  A9 01       LDA #$01
       06:C694  8D 21 00    STA PPU_PendingWrite
       06:C697  A9 3F       LDA #$3F
       06:C699  20 93 CB    JSR WriteToPPUString
       06:C69C  A9 01       LDA #$01
       06:C69E  20 93 CB    JSR WriteToPPUString
       06:C6A1  A9 00       LDA #DRAW_HORIZONTAL
       06:C6A3  20 93 CB    JSR WriteToPPUString
       06:C6A6  A9 03       LDA #03 
       06:C6A8  20 93 CB    JSR WriteToPPUString
                            
  611  06:C6AB  AD 01 00    LDA temp2
  612  06:C6AE  20 93 CB    JSR WriteToPPUString
  613  06:C6B1  AD 02 00    LDA temp3
  614  06:C6B4  20 93 CB    JSR WriteToPPUString
  615  06:C6B7  AD 03 00    LDA temp4
  616  06:C6BA  20 93 CB    JSR WriteToPPUString
  617                       
  618  06:C6BD  A2 01       LDX #$01
  619  06:C6BF            .copyLoop:
  620                       ;;also store in the copy 
  621  06:C6BF  BD 00 00    LDA temp1, x
  622  06:C6C2  9D 00 68    STA Palette_Copy, x
  623  06:C6C5  E8          INX
  624  06:C6C6  E0 04       CPX #$04
  625  06:C6C8  D0 F5       BNE .copyLoop
  626                       
  627                       
  628  06:C6CA  EE 0F 00    INC mode_state
  629                     
  630  06:C6CD            .leave:
  631                      
  632  06:C6CD  60          RTS
  633                       
  634  06:C6CE            UpdateWaitInput:
  635                     
  636  06:C6CE  AD 1A 00    LDA gamepadPressed
  637  06:C6D1  F0 10       BEQ .leave
  638                       
  639  06:C6D3            .changeModeState:
  640  06:C6D3  A9 00       LDA #$00
  641  06:C6D5  8D 0A 00    STA time
  642  06:C6D8  8D 0B 00    STA scaledTime
  643  06:C6DB  A9 02       LDA #GAMEOVER_IDX
  644  06:C6DD  8D CD 00    STA targetGameMode
  645  06:C6E0  EE 0F 00    INC mode_state
  646                     
  647  06:C6E3            .leave:
  648                      
  649  06:C6E3  60          RTS
  650                       
  651  06:C6E4            UpdateGameFadeOut:
  652                     
  653  06:C6E4  AD 0A 00    LDA time
  654  06:C6E7  29 07       AND #$07
  655  06:C6E9  D0 0D       BNE .leave
  656                       ;;every 8 frames, decrement the palettes
  657  06:C6EB  20 10 CC    JSR FadeOutPalettes
  658  06:C6EE  B0 08       BCS .leave
  659                     
  660  06:C6F0            .changeModeState:
  661  06:C6F0  A9 00       LDA #$00
  662  06:C6F2  8D 0A 00    STA time
  663  06:C6F5  EE 0F 00    INC mode_state
  664  06:C6F8            .leave:
  665  06:C6F8  60          RTS  
  666                     
  667  06:C6F9            UpdateGameExit:
  668                     
  669  06:C6F9  AD 0A 00    LDA time
  670  06:C6FC  29 0F       AND #$0F
  671  06:C6FE  D0 13       BNE .leave
  672                     
  673  06:C700  A9 00       LDA #$00
  674  06:C702  8D 1D 00    STA PPU_ScrollX
  675  06:C705  8D 1E 00    STA PPU_ScrollY
  676  06:C708  8D 1F 00    STA PPU_ScrollNT
  677                       
  678  06:C70B  AD CD 00    LDA targetGameMode
  679  06:C70E  A2 00       LDX #$00
  680  06:C710  20 75 C9    JSR ChangeGameMode
  681  06:C713            .leave:
  682  06:C713  60          RTS
  683                       
  684  06:C714            MoveMouse:
  685                     
  686  06:C714  AD 00 00    LDA temp1
  687  06:C717  0E 00 00    ASL temp1
  688  06:C71A  0E 00 00    ASL temp1
  689  06:C71D  0E 00 00    ASL temp1
  690                       
  691  06:C720  AD 01 00    LDA temp2
  692  06:C723  0E 01 00    ASL temp2 
  693  06:C726  0E 01 00    ASL temp2
  694  06:C729  0E 01 00    ASL temp2
  695                       
  696  06:C72C  A0 00       LDY #$00
  697  06:C72E  B1 A9       LDA [puzzle_address], y ;puzzle size 0 = 5, 1 = 10, 2 = 15  
  698  06:C730  0A          ASL A
  699  06:C731  AA          TAX
  700  06:C732  BD 0F C9    LDA MouseMinimums, x
  701  06:C735  8D 02 00    STA temp3
  702  06:C738  BD 15 C9    LDA MouseMaximums, x
  703  06:C73B  8D 03 00    STA temp4
  704  06:C73E  8A          TXA
  705  06:C73F  48          PHA
  706                       
  707  06:C740  A2 03       LDX #SPRITE_XPOS
  708  06:C742  BD 00 02    LDA SPRITE_DATA, x
  709  06:C745  18          CLC
  710  06:C746  6D 00 00    ADC temp1
  711                       ;;check against borders
  712  06:C749  CD 02 00    CMP temp3
  713  06:C74C  F0 08       BEQ .moveVert 
  714  06:C74E  CD 03 00    CMP temp4
  715  06:C751  F0 03       BEQ .moveVert
  716  06:C753  9D 00 02    STA SPRITE_DATA, x
  717                     
  718  06:C756            .moveVert:
  719                     
  720  06:C756  68          PLA
  721  06:C757  AA          TAX
  722  06:C758  E8          INX
  723  06:C759  BD 0F C9    LDA MouseMinimums, x
  724  06:C75C  8D 02 00    STA temp3
  725  06:C75F  BD 15 C9    LDA MouseMaximums, x
  726  06:C762  8D 03 00    STA temp4
  727                     
  728  06:C765  A2 00       LDX #SPRITE_YPOS
  729  06:C767  BD 00 02    LDA SPRITE_DATA, x
  730  06:C76A  18          CLC
  731  06:C76B  6D 01 00    ADC temp2
  732                       ;;check against borders
  733  06:C76E  CD 02 00    CMP temp3
  734  06:C771  F0 08       BEQ .leave
  735  06:C773  CD 03 00    CMP temp4
  736  06:C776  F0 03       BEQ .leave
  737  06:C778  9D 00 02    STA SPRITE_DATA, x
  738                     
  739  06:C77B            .leave:
  740  06:C77B  60          RTS
  741                             
  742  06:C77C            UpdateMouseScreenPos:
  743                     
  744  06:C77C  A2 00       LDX #$00
  745  06:C77E  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  746  06:C781  4A          LSR A                                         ;0yyy yy..
  747  06:C782  4A          LSR A                                         ;00yy yyy.
  748  06:C783  4A          LSR A                                         ;000y yyyy
  749  06:C784  8D 00 00    STA temp1
  750  06:C787  8D C2 00    STA mouse_index+1
  751  06:C78A  E8          INX
  752  06:C78B  E8          INX
  753  06:C78C  E8          INX   
  754  06:C78D  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  755  06:C790  29 F8       AND #$F8                       ;              ;  xxxx x000
  756  06:C792  8D 01 00    STA temp2                      ;      ;  
  757  06:C795  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  758  06:C798  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  759  06:C79B  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  760  06:C79E  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  761  06:C7A1  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  762  06:C7A4  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  763  06:C7A7  AD 01 00    LDA temp2
  764  06:C7AA  29 1F       AND #$1F
  765  06:C7AC  8D C1 00    STA mouse_index
  766                       
  767  06:C7AF  AD C1 00    LDA mouse_index
  768  06:C7B2  38          SEC 
  769  06:C7B3  E9 0E       SBC #$0E
  770  06:C7B5  8D C1 00    STA mouse_index
  771                       
  772  06:C7B8  AD C2 00    LDA mouse_index+1
  773  06:C7BB  38          SEC 
  774  06:C7BC  E9 0C       SBC #$0C
  775  06:C7BE  8D C2 00    STA mouse_index+1
  776                       
  777                       ;subtract starting offsets for mouse index
  778                       
  779  06:C7C1  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  780  06:C7C4  09 60       ORA #$60                       ;              ;  0110 00yy
  781                       
  782  06:C7C6  8D C0 00    STA mouse_location+1
  783  06:C7C9  AD 01 00    LDA temp2
  784  06:C7CC  8D BF 00    STA mouse_location
  785                       
  786  06:C7CF            .leave:
  787  06:C7CF  60          RTS
  788                       
  789  06:C7D0            UpdateTimeDisplay:
  790                     
  791  06:C7D0  AD 0B 00    LDA scaledTime
  792  06:C7D3  C9 3C       CMP #60
  793  06:C7D5  D0 77       BNE .leave
  794                       
  795  06:C7D7  A9 00       LDA #$00
  796  06:C7D9  8D 0B 00    STA scaledTime
  797                       
  798  06:C7DC  EE C9 00    INC GameTime
  799  06:C7DF  AD C9 00    LDA GameTime
  800  06:C7E2  C9 0A       CMP #10
  801  06:C7E4  D0 32       BNE .printTime
  802                       
  803  06:C7E6  A9 00       LDA #$00
  804  06:C7E8  8D C9 00    STA GameTime
  805  06:C7EB  EE CA 00    INC GameTime+1
  806  06:C7EE  AD CA 00    LDA GameTime+1
  807  06:C7F1  C9 06       CMP #6
  808  06:C7F3  D0 23       BNE .printTime
  809                       
  810  06:C7F5  A9 00       LDA #$00
  811  06:C7F7  8D CA 00    STA GameTime+1
  812  06:C7FA  EE CB 00    INC GameTime+2
  813  06:C7FD  AD CB 00    LDA GameTime+2
  814  06:C800  C9 0A       CMP #10
  815  06:C802  D0 14       BNE .printTime
  816                       
  817  06:C804  A9 00       LDA #$00
  818  06:C806  8D CB 00    STA GameTime+2
  819  06:C809  EE CC 00    INC GameTime+3
  820  06:C80C  AD CC 00    LDA GameTime+3
  821  06:C80F  C9 0A       CMP #10
  822  06:C811  D0 05       BNE .printTime
  823                       
  824  06:C813  A9 00       LDA #$00
  825  06:C815  8D CC 00    STA GameTime+3
  826                       
  827  06:C818            .printTime:
  828                     
  829                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C818  A9 01       LDA #$01
       06:C81A  8D 21 00    STA PPU_PendingWrite
       06:C81D  A9 20       LDA #HIGH(TIMER_LOC)
       06:C81F  20 93 CB    JSR WriteToPPUString
       06:C822  A9 E5       LDA #LOW(TIMER_LOC)
       06:C824  20 93 CB    JSR WriteToPPUString
       06:C827  A9 00       LDA #DRAW_HORIZONTAL
       06:C829  20 93 CB    JSR WriteToPPUString
       06:C82C  A9 05       LDA #$05 
       06:C82E  20 93 CB    JSR WriteToPPUString
                            
  830  06:C831  AD CC 00    LDA GameTime+3
  831  06:C834  20 93 CB    JSR WriteToPPUString
  832  06:C837  AD CB 00    LDA GameTime+2
  833  06:C83A  20 93 CB    JSR WriteToPPUString
  834  06:C83D  A9 61       LDA #$61
  835  06:C83F  20 93 CB    JSR WriteToPPUString
  836  06:C842  AD CA 00    LDA GameTime+1
  837  06:C845  20 93 CB    JSR WriteToPPUString
  838  06:C848  AD C9 00    LDA GameTime
  839  06:C84B  20 93 CB    JSR WriteToPPUString
  840                       
  841                       
  842                       
  843  06:C84E            .leave: 
  844  06:C84E  60          RTS  
  845                       
  846  06:C84F            UpdatePause:
  847                     
  848                     ;;load screen
  849                     ;;update selection
  850                     ;; close - remove screen, then upause
  851                     ;; quit - jump to fade out
  852  06:C84F  AD C6 00    LDA pauseState
  853  06:C852  20 32 CA    JSR Dynamic_Jump
  854                     
  855  06:C855            UpdatePauseJumpTable:  
  856                     
  857  06:C855  0E C9       .word ExitPause                       ;fail safe
  858  06:C857  5D C8       .word UpdateLoadPauseScreen
  859  06:C859  79 C8       .word UpdatePauseScreen
  860  06:C85B  F2 C8       .word UpdateUnloadPauseScreen
  861                       
  862  06:C85D            UpdateLoadPauseScreen:
  863                       
  864  06:C85D  20 27 CE    JSR LoadPauseScreen
  865  06:C860  AD B9 00    LDA clueOffsetShift
  866  06:C863  C9 06       CMP #$06
  867  06:C865  D0 11       BNE .leave
  868                       
  869  06:C867            .changePauseState:
  870                     
  871  06:C867  A9 60       LDA #PAUSE_YES
  872  06:C869  A2 01       LDX #$01
  873  06:C86B  20 D0 C1    JSR SetSpriteXPosition  
  874  06:C86E  A9 01       LDA #$01
  875  06:C870  A2 01       LDX #$01
  876  06:C872  20 DB C1    JSR SetSpriteImage
  877                       
  878  06:C875  EE C6 00    INC pauseState
  879  06:C878            .leave:
  880  06:C878  60          RTS
  881                       
  882  06:C879            UpdatePauseScreen:
  883                       
  884  06:C879  AD 1A 00    LDA gamepadPressed
  885  06:C87C  C9 08       CMP #GAMEPAD_START
  886  06:C87E  F0 29       BEQ .unPause
  887  06:C880  C9 02       CMP #GAMEPAD_B
  888  06:C882  F0 25       BEQ .unPause
  889  06:C884  C9 01       CMP #GAMEPAD_A
  890  06:C886  F0 4A       BEQ .checkA
  891                       
  892                       ;;update pointer
  893                       
  894  06:C888  AD 1A 00    LDA gamepadPressed
  895  06:C88B  29 C0       AND #GAMEPAD_HORI
  896                       ;;binary system- left and right don't really matter, we'll just toggle the position
  897  06:C88D  F0 62       BEQ .leave
  898                       
  899  06:C88F  A9 03       LDA #SPRITE_XPOS
  900  06:C891  A2 01       LDX #$01
  901  06:C893  20 F2 C1    JSR GetSpriteData
  902                       
  903  06:C896  C9 60       CMP #PAUSE_YES
  904  06:C898  F0 05       BEQ .loadNo
  905                       
  906  06:C89A  A9 60       LDA #PAUSE_YES
  907  06:C89C  4C A1 C8    JMP .setPosition
  908                       
  909  06:C89F            .loadNo:
  910  06:C89F  A9 88       LDA #PAUSE_NO
  911                     
  912  06:C8A1            .setPosition
  913                       
  914  06:C8A1  A2 01       LDX #$01
  915  06:C8A3  20 D0 C1    JSR SetSpriteXPosition  
  916                     
  917  06:C8A6  4C F1 C8    JMP .leave 
  918                     
  919  06:C8A9            .unPause:
  920                     
  921  06:C8A9  A9 00       LDA #$00
  922  06:C8AB  8D B8 00    STA clueLineIndex
  923  06:C8AE  8D B9 00    STA clueOffsetShift
  924                       
  925  06:C8B1  A9 FF       LDA #$FF
  926  06:C8B3  A2 01       LDX #$01
  927  06:C8B5  20 DB C1    JSR SetSpriteImage
  928                     
  929                       MACROGetLabelPointer $610A, pause_address
                          
       06:C8B8  A9 61             LDA #HIGH($610A)
       06:C8BA  A2 0A             LDX #LOW($610A)
                                  
       06:C8BC  8E AD 00          STX pause_address
       06:C8BF  8D AE 00          STA pause_address+1
                                  
  930                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C8C2  A9 21             LDA #HIGH($210A)
       06:C8C4  A2 0A             LDX #LOW($210A)
                                  
       06:C8C6  8E B1 00          STX pause_draw_address
       06:C8C9  8D B2 00          STA pause_draw_address+1
                                  
  931                         
  932  06:C8CC  EE C6 00    INC pauseState
  933  06:C8CF  4C F1 C8    JMP .leave
  934                      
  935  06:C8D2            .checkA:
  936                       
  937  06:C8D2  A9 03       LDA #SPRITE_XPOS
  938  06:C8D4  A2 01       LDX #$01
  939  06:C8D6  20 F2 C1    JSR GetSpriteData
  940                       
  941  06:C8D9  C9 88       CMP #PAUSE_NO
  942  06:C8DB  F0 CC       BEQ .unPause
  943                        
  944  06:C8DD            .quit:
  945                     
  946  06:C8DD  A9 00       LDA #$00
  947  06:C8DF  8D C6 00    STA pauseState
  948  06:C8E2  A9 00       LDA #$00
  949  06:C8E4  8D 0A 00    STA time
  950  06:C8E7  A9 00       LDA #TITLE_IDX
  951  06:C8E9  8D CD 00    STA targetGameMode
  952  06:C8EC  A9 08       LDA #$08
  953  06:C8EE  8D 0F 00    STA mode_state
  954                       
  955  06:C8F1            .leave:
  956  06:C8F1  60          RTS
  957                       
  958  06:C8F2            UpdateUnloadPauseScreen:
  959                       
  960  06:C8F2  20 6E CE    JSR ClearPauseScreen
  961  06:C8F5  AD B9 00    LDA clueOffsetShift
  962  06:C8F8  C9 06       CMP #$06
  963  06:C8FA  D0 11       BNE .leave
  964  06:C8FC            .changePauseState:
  965                     
  966  06:C8FC  A9 02       LDA #$02
  967  06:C8FE  A2 00       LDX #$00
  968  06:C900  20 DB C1    JSR SetSpriteImage
  969                       
  970  06:C903  A9 03       LDA #GAMEPAD_AB
  971  06:C905  8D C7 00    STA pauseInputLock 
  972                       
  973  06:C908  A9 00       LDA #$00
  974  06:C90A  8D C6 00    STA pauseState
  975  06:C90D            .leave:
  976  06:C90D  60          RTS
  977                       
  978  06:C90E            ExitPause:
  979  06:C90E  60          RTS
  980                       
  981                     ;hori, vert
  982  06:C90F            MouseMinimums:
  983  06:C90F  6A 5A       .db $6A, $5A
  984  06:C911  6A 5A       .db $6A, $5A
  985  06:C913  6A 5A       .db $6A, $5A
  986  06:C915            MouseMaximums:
  987  06:C915  9A 8A       .db $9A, $8A
  988  06:C917  C2 B2       .db $C2, $B2
  989  06:C919  EA DA       .db $EA, $DA
  990                       
  991  06:C91B            PuzzleScrollHori:
  992  06:C91B  01 04 06    .db $01, $04, $06
  993  06:C91E            PuzzleScrollVert:
  994  06:C91E  01 03 05    .db $01, $03, $05
  995                       
  996  06:C921            PuzzleHeaderSkips:
  997                     
  998  06:C921  09 18 22    .db $09, $18, $22
  999                       
 1000           0060      PAUSE_YES = $60
 1001           0088      PAUSE_NO = $88
 1002                     
 1003                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   85                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C924            UpdateGameOver:
    2                     
    3  06:C924  AD 10 00    LDA NMI_locks
    4  06:C927  F0 01       BEQ .unlocked
    5                       
    6  06:C929  60          RTS
    7                       
    8  06:C92A            .unlocked:
    9                     
   10  06:C92A  20 2E C9    JSR DoUpdateGameOver 
   11  06:C92D  60          RTS
   12                       
   13  06:C92E            DoUpdateGameOver:
   14                     
   15  06:C92E  AD 0F 00    LDA mode_state
   16  06:C931  20 32 CA    JSR Dynamic_Jump
   17                         
   18  06:C934            UpdateGameOverJumpTable:
   19                     
   20  06:C934  3C C9       .word UpdateGameOverInit
   21  06:C936  43 C9       .word UpdateGameOverWaitInput
   22  06:C938  51 C9       .word UpdateGameOverFadeOut
   23  06:C93A  66 C9       .word UpdateGameOverExit
   24                       
   25  06:C93C            UpdateGameOverInit:
   26                     
   27  06:C93C  20 DB CB    JSR TurnOnSprites
   28  06:C93F  EE 0F 00    INC mode_state
   29  06:C942  60          RTS
   30                     
   31  06:C943            UpdateGameOverWaitInput:
   32                     
   33  06:C943  AD 1A 00    LDA gamepadPressed
   34  06:C946  F0 08       BEQ .leave
   35                     
   36  06:C948            .changeModeState:
   37                     
   38  06:C948  A9 00       LDA #$00
   39  06:C94A  8D 0A 00    STA time
   40  06:C94D  EE 0F 00    INC mode_state
   41  06:C950            .leave:
   42  06:C950  60          RTS
   43                     
   44  06:C951            UpdateGameOverFadeOut:
   45                     
   46  06:C951  AD 0A 00    LDA time
   47  06:C954  29 07       AND #$07
   48  06:C956  D0 0D       BNE .leave
   49                       ;;every 8 frames, decrement the palettes
   50  06:C958  20 10 CC    JSR FadeOutPalettes
   51  06:C95B  B0 08       BCS .leave
   52                     
   53  06:C95D            .changeModeState:
   54  06:C95D  A9 00       LDA #$00
   55  06:C95F  8D 0A 00    STA time
   56  06:C962  EE 0F 00    INC mode_state
   57  06:C965            .leave:
   58  06:C965  60          RTS
   59                     
   60  06:C966            UpdateGameOverExit:
   61                     
   62  06:C966  AD 0A 00    LDA time
   63  06:C969  29 0F       AND #$0F
   64  06:C96B  D0 07       BNE .leave
   65                     
   66  06:C96D  A9 00       LDA #TITLE_IDX
   67  06:C96F  A2 00       LDX #$00
   68  06:C971  20 75 C9    JSR ChangeGameMode
   69                       
   70  06:C974            .leave:
   71  06:C974  60          RTS
#[1]   Picross.asm
   86                       
   87                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   88                     ;;     Routines             ;;
   89                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   90                     
   91                     
#[2]   Routines/Common/GameModeRoutines.asm
   92                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C975            ChangeGameMode:
    2                       ;A - game mode index
    3                       ;X - high nibble: palette start flag, low nibble: screen index
    4  06:C975  8D 0E 00    STA game_mode
    5  06:C978  8E 0D 00    STX mode_loadFlags
    6  06:C97B  A9 00       LDA #$00
    7  06:C97D  8D 0F 00    STA mode_state
    8  06:C980  20 A7 CB    JSR ClearPPUString
    9  06:C983  20 87 C9    JSR LoadGameModeScreen
   10  06:C986  60          RTS
   11                       
   12  06:C987            LoadGameModeScreen:
   13                     
   14                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C987  AD 10 00    LDA NMI_locks
       06:C98A  09 01       ORA #BGLOAD_NMI_LOCK
       06:C98C  8D 10 00    STA NMI_locks
                                  
   15                       
   16  06:C98F  A9 00       LDA #$00
   17  06:C991  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   18                     
   19  06:C994  20 C2 C9    JSR LoadGameModeBackground
   20  06:C997  20 0F CA    JSR LoadGameModeSprites
   21                     
   22                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C99A  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C99C  49 FF       EOR #$FF
       06:C99E  2D 10 00    AND NMI_locks  
       06:C9A1  8D 10 00    STA NMI_locks
                          
   23                     
   24                       
   25                       ;; load the CHR bank for this mode
   26  06:C9A4  20 7A CC    JSR ResetMapper
   27                       ;;remember, we're loading the SECOND set in each chr bank
   28                       ;;so we'll take the index from the game mode chr table and add one mult 2
   29  06:C9A7  AE 0E 00    LDX game_mode
   30  06:C9AA  BD 2C CA    LDA gameModeInitCHRROMB, x
   31  06:C9AD  0A          ASL A
   32  06:C9AE  18          CLC 
   33  06:C9AF  69 01       ADC #$01
   34  06:C9B1  20 9F CC    JSR LoadCHRBankB
   35                       
   36  06:C9B4  20 7A CC    JSR ResetMapper
   37  06:C9B7  AE 0E 00    LDX game_mode
   38  06:C9BA  BD 2F CA    LDA gameModeInitCHRROMA, x
   39  06:C9BD  0A          ASL A
   40  06:C9BE  20 94 CC    JSR LoadCHRBankA
   41                       
   42                       
   43                       
   44  06:C9C1  60          RTS
   45                       
   46  06:C9C2            LoadGameModeBackground:
   47                             
   48                       MACROGetDoubleIndex game_mode
                          
       06:C9C2  AD 0E 00          LDA game_mode
       06:C9C5  0A                ASL A
       06:C9C6  A8                TAY
                                  
   49  06:C9C7  8C 00 00    STY temp1
   50                             
   51                       MACROGetLabelPointer Palettes, table_address
                          
       06:C9CA  A9 E0             LDA #HIGH(Palettes)
       06:C9CC  A2 00             LDX #LOW(Palettes)
                                  
       06:C9CE  8E 14 00          STX table_address
       06:C9D1  8D 15 00          STA table_address+1
                                  
   52  06:C9D4  20 58 CA    JSR GetTableAtIndex
   53                     
   54  06:C9D7  20 65 CA    JSR LoadFullPaletteFromTable
   55                             
   56  06:C9DA  AC 00 00    LDY temp1
   57                       MACROGetLabelPointer NameTables, table_address
                          
       06:C9DD  A9 E0             LDA #HIGH(NameTables)
       06:C9DF  A2 06             LDX #LOW(NameTables)
                                  
       06:C9E1  8E 14 00          STX table_address
       06:C9E4  8D 15 00          STA table_address+1
                                  
   58  06:C9E7  20 58 CA    JSR GetTableAtIndex
   59  06:C9EA  AD 0D 00    LDA mode_loadFlags
   60  06:C9ED  29 0F       AND #$0F
   61  06:C9EF  0A          ASL A
   62  06:C9F0  A8          TAY
   63  06:C9F1  20 58 CA    JSR GetTableAtIndex
   64                             
   65  06:C9F4  A9 00       LDA #$00
   66  06:C9F6  20 94 CA    JSR LoadFullBackgroundFromTable
   67                       
   68  06:C9F9  AC 00 00    LDY temp1
   69                       MACROGetLabelPointer NameTables2, table_address
                          
       06:C9FC  A9 E0             LDA #HIGH(NameTables2)
       06:C9FE  A2 0C             LDX #LOW(NameTables2)
                                  
       06:CA00  8E 14 00          STX table_address
       06:CA03  8D 15 00          STA table_address+1
                                  
   70  06:CA06  20 58 CA    JSR GetTableAtIndex
   71                       
   72  06:CA09  A9 01       LDA #$01
   73  06:CA0B  20 94 CA    JSR LoadFullBackgroundFromTable
   74                       
   75  06:CA0E  60          RTS
   76                       
   77  06:CA0F            LoadGameModeSprites:
   78                     
   79                       MACROGetDoubleIndex game_mode  
                          
       06:CA0F  AD 0E 00          LDA game_mode
       06:CA12  0A                ASL A
       06:CA13  A8                TAY
                                  
   80                       MACROGetLabelPointer Sprites, table_address
                          
       06:CA14  A9 FC             LDA #HIGH(Sprites)
       06:CA16  A2 CA             LDX #LOW(Sprites)
                                  
       06:CA18  8E 14 00          STX table_address
       06:CA1B  8D 15 00          STA table_address+1
                                  
   81  06:CA1E  20 58 CA    JSR GetTableAtIndex
   82  06:CA21  A0 00       LDY #$00
   83  06:CA23  B1 14       LDA [table_address],y
   84  06:CA25  EE 14 00    INC table_address
   85  06:CA28  20 7C CB    JSR LoadSprites_impl
   86                       
   87  06:CA2B  60          RTS
   88                       
   89  06:CA2C            gameModeInitCHRROMB:
   90  06:CA2C  00 02 02          .db $00, $02, $02
   91  06:CA2F            gameModeInitCHRROMA:
   92  06:CA2F  00 02 02          .db $00, $02, $02
   93                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   93                       .include "Routines/Utils/PointerUtils.asm"
    1  06:CA32            Dynamic_Jump:
    2                     
    3  06:CA32  0A          ASL A                                 ;; double the index passed into A
    4  06:CA33  8E 08 00    STX tempx
    5  06:CA36  8C 09 00    STY tempy
    6  06:CA39  A8          TAY
    7  06:CA3A  C8          INY  
    8  06:CA3B  68          PLA
    9  06:CA3C  8D 16 00    STA jump_address
   10  06:CA3F  68          PLA 
   11  06:CA40  8D 17 00    STA jump_address+1            
   12  06:CA43  B1 16       LDA [jump_address], y
   13  06:CA45  AA          TAX
   14  06:CA46  C8          INY
   15  06:CA47  B1 16       LDA [jump_address], y
   16  06:CA49  8E 16 00    STX jump_address
   17  06:CA4C  8D 17 00    STA jump_address+1
   18  06:CA4F  AE 08 00    LDX tempx
   19  06:CA52  AC 09 00    LDY tempy
   20  06:CA55  6C 16 00    JMP [jump_address]
   21                       
   22  06:CA58            GetTableAtIndex:
   23                     
   24  06:CA58  B1 14             LDA [table_address], y
   25  06:CA5A  AA                TAX
   26  06:CA5B  C8                INY
   27  06:CA5C  B1 14             LDA [table_address], y
   28                             
   29  06:CA5E            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:CA5E  8E 14 00          STX table_address
   33  06:CA61  8D 15 00          STA table_address+1
   34  06:CA64  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   94                       .include "Routines/Utils/PPUUtils.asm"
    1  06:CA65            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:CA65  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:CA68  A9 3F       LDA #HIGH($3F00)
       06:CA6A  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:CA6D  A9 00       LDA #LOW($3F00)
       06:CA6F  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:CA72  A0 00       LDY #$00              ; start out at 0
    5  06:CA74  A2 00       LDX #$00
    6  06:CA76            .loop:
    7  06:CA76  B1 14       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:CA78  9D 00 68    STA Palette_Copy, x
    9  06:CA7B  48          PHA 
   10  06:CA7C  AD 0D 00    LDA mode_loadFlags
   11  06:CA7F  29 10       AND #$10
   12  06:CA81  D0 04       BNE .setBlack
   13  06:CA83  68          PLA 
   14  06:CA84  4C 8A CA    JMP .setPPUData
   15  06:CA87            .setBlack:
   16                     
   17  06:CA87  68          PLA 
   18  06:CA88  A9 0F       LDA #$0F
   19                       
   20  06:CA8A            .setPPUData:
   21  06:CA8A  8D 07 20    STA PPU_DATA            ; write to PPU
   22  06:CA8D  C8          INY                   ; X = X + 1
   23  06:CA8E  E8          INX
   24  06:CA8F  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   25  06:CA91  D0 E3       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   26  06:CA93  60          RTS
   27                     
   28  06:CA94            LoadFullBackgroundFromTable:
   29                     
   30                         ;;use A as an index for which nametable to write to
   31  06:CA94  20 C7 CB          JSR SetNametableFromIndex
   32  06:CA97  8A                TXA
   33  06:CA98  4A                LSR A
   34  06:CA99  29 01             AND #$01
   35  06:CA9B  D0 0D             BNE .copyScreenB
   36                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:CA9D  A9 60             LDA #HIGH(Screen_Copy)
       06:CA9F  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:CAA1  8E 12 00          STX pointer_address
       06:CAA4  8D 13 00          STA pointer_address+1
                                  
   37  06:CAA7  4C B4 CA          JMP .setCounters
   38                             
   39  06:CAAA            .copyScreenB:
   40                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:CAAA  A9 64             LDA #HIGH(ScreenB_Copy)
       06:CAAC  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:CAAE  8E 12 00          STX pointer_address
       06:CAB1  8D 13 00          STA pointer_address+1
                                  
   41                             
   42                             ;;set pointer
   43                             ;; set counters
   44  06:CAB4            .setCounters:
   45  06:CAB4  A0 00             LDY #$00
   46  06:CAB6  A2 00             LDX #$00
   47                             
   48                             ;;start loop
   49                     
   50  06:CAB8            .outerloop:
   51                     
   52  06:CAB8            .innerloop:
   53                     
   54  06:CAB8  B1 14             LDA [table_address], y
   55  06:CABA  8D 07 20          STA PPU_DATA
   56  06:CABD  91 12             STA [pointer_address],y
   57  06:CABF  C8                INY
   58  06:CAC0  C0 00             CPY #$00
   59  06:CAC2  D0 F4             BNE .innerloop
   60                     
   61  06:CAC4  EE 13 00          INC pointer_address+1
   62  06:CAC7  EE 15 00          INC table_address+1
   63                             
   64  06:CACA  E8                INX
   65  06:CACB  E0 04             CPX #$04
   66  06:CACD  D0 E9             BNE .outerloop
   67  06:CACF  60                RTS
   68                             
   69                     
   70           0000      DATA_LEN = temp1
   71           0001      WRITE_SETTINGS = temp2
   72                             
   73  06:CAD0            ProcessPPUString:
   74                     
   75  06:CAD0  AD 21 00          LDA PPU_PendingWrite
   76  06:CAD3  D0 01             BNE .continueProcess
   77  06:CAD5  60                RTS
   78                             
   79  06:CAD6            .continueProcess:
   80  06:CAD6  A0 00             LDY #$00
   81                             
   82  06:CAD8  A9 23             LDA #LOW(PPU_String)
   83  06:CADA  8D 12 00          STA pointer_address
   84  06:CADD  A9 00             LDA #HIGH(PPU_String)
   85  06:CADF  8D 13 00          STA pointer_address + 1
   86                     
   87  06:CAE2            .outerloop:
   88  06:CAE2  AD 02 20          LDA PPU_STATUS
   89  06:CAE5  B1 12             LDA [pointer_address], y
   90  06:CAE7  F0 79             BEQ .finish
   91  06:CAE9  8D 06 20          STA PPU_ADDR
   92  06:CAEC  C8                INY
   93  06:CAED  B1 12             LDA [pointer_address], y
   94  06:CAEF  8D 06 20          STA PPU_ADDR
   95  06:CAF2  C8            INY 
   96  06:CAF3  B1 12             LDA [pointer_address], y
   97  06:CAF5  8D 01 00          STA WRITE_SETTINGS
   98  06:CAF8  C8                INY
   99                             
  100  06:CAF9  AD 00 20          LDA PPU_CTRL
  101  06:CAFC  29 FB             AND #$FB
  102  06:CAFE  8D 00 20          STA PPU_CTRL
  103                             
  104  06:CB01  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
  105  06:CB04  29 80             AND #%10000000
  106  06:CB06  F0 06             BEQ .checkRepeat
  107  06:CB08  0D 00 20          ORA PPU_CTRL 
  108  06:CB0B  8D 00 20          STA PPU_CTRL 
  109                             
  110                             
  111  06:CB0E            .checkRepeat:
  112  06:CB0E  AD 01 00    LDA WRITE_SETTINGS
  113  06:CB11  29 40       AND #%01000000
  114  06:CB13  F0 19       BEQ .checkTable
  115                       
  116  06:CB15  AD 01 00    LDA WRITE_SETTINGS
  117  06:CB18  29 3F       AND #$3F
  118  06:CB1A  8D 00 00    STA DATA_LEN
  119                       ;;the usual data length byte is now the repeatable byte
  120  06:CB1D  A2 00       LDX #$00
  121                       
  122  06:CB1F            .repeatLoop:
  123  06:CB1F  B1 12       LDA [pointer_address], y
  124  06:CB21  8D 07 20    STA PPU_DATA
  125  06:CB24  E8          INX 
  126  06:CB25  EC 00 00    CPX DATA_LEN
  127  06:CB28  D0 F5       BNE .repeatLoop
  128  06:CB2A  C8          INY
  129  06:CB2B  4C E2 CA    JMP .outerloop
  130                             
  131  06:CB2E            .checkTable:
  132  06:CB2E  AD 01 00          LDA WRITE_SETTINGS
  133  06:CB31  29 20             AND #%00100000
  134  06:CB33  F0 16             BEQ .rawData
  135                             
  136  06:CB35  B1 12             LDA [pointer_address], y
  137  06:CB37  8D 14 00          STA table_address
  138  06:CB3A  C8                INY 
  139  06:CB3B  B1 12             LDA [pointer_address], y
  140  06:CB3D  8D 15 00          STA table_address + 1
  141  06:CB40  C8                INY
  142  06:CB41  98                TYA 
  143  06:CB42  48                PHA
  144  06:CB43  20 66 CB          JSR WriteToPPUFromTable
  145  06:CB46  68                PLA
  146  06:CB47  A8                TAY
  147  06:CB48  4C E2 CA          JMP .outerloop
  148                             
  149  06:CB4B            .rawData:
  150                     
  151  06:CB4B  B1 12             LDA [pointer_address], y
  152  06:CB4D  C8                INY
  153  06:CB4E  8D 00 00          STA DATA_LEN
  154                     
  155  06:CB51  A2 00             LDX #$00
  156                     
  157  06:CB53            .innerloop:
  158                             
  159  06:CB53  B1 12             LDA [pointer_address], y
  160  06:CB55  8D 07 20          STA PPU_DATA
  161  06:CB58  C8                INY
  162  06:CB59  E8                INX
  163  06:CB5A  EC 00 00          CPX DATA_LEN
  164  06:CB5D  D0 F4             BNE .innerloop
  165  06:CB5F  4C E2 CA          JMP .outerloop
  166                             
  167  06:CB62            .finish:
  168  06:CB62  20 A7 CB          JSR ClearPPUString
  169  06:CB65            .leave:
  170  06:CB65  60                RTS
  171                             
  172  06:CB66            WriteToPPUFromTable:
  173  06:CB66  A0 00             LDY #$00
  174  06:CB68  B1 14             LDA [table_address], y
  175  06:CB6A  C8                INY
  176  06:CB6B  8D 00 00          STA DATA_LEN
  177  06:CB6E            .innerloop:
  178  06:CB6E  B1 14             LDA [table_address], y
  179  06:CB70  8D 07 20          STA PPU_DATA
  180  06:CB73  C8                INY
  181  06:CB74  CC 00 00          CPY DATA_LEN
  182  06:CB77  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  183  06:CB79  F0 F3             BEQ .innerloop
  184  06:CB7B  60                RTS
  185                       
  186  06:CB7C            LoadSprites_impl:
  187                       ;;A will be the amount of sprites to load
  188  06:CB7C  8D 00 00    STA DATA_LEN
  189  06:CB7F  0E 00 00    ASL DATA_LEN
  190  06:CB82  0E 00 00    ASL DATA_LEN
  191                       
  192  06:CB85  A0 00       LDY #$00              ; start at 0
  193                       
  194  06:CB87            .loop:
  195  06:CB87  B1 14       LDA [table_address], y; load data from address (sprites +  x)
  196  06:CB89  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  197  06:CB8C  C8          INY                   ; X = X + 1
  198  06:CB8D  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  199  06:CB90  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  200                                             ; if compare was equal to 16, keep going down   
  201  06:CB92  60          RTS
  202                     
  203                     
  204  06:CB93            WriteToPPUString:
  205                     
  206  06:CB93  AE 22 00          LDX PPU_StringIdx
  207  06:CB96  E0 4F             CPX #PPU_STRINGMAX
  208  06:CB98  F0 0C             BEQ .finish
  209                             
  210  06:CB9A  9D 23 00          STA PPU_String, x
  211  06:CB9D  EE 22 00          INC PPU_StringIdx
  212  06:CBA0  E8                INX
  213  06:CBA1  A9 00             LDA #$00
  214  06:CBA3  9D 23 00          STA PPU_String, x
  215                                     
  216  06:CBA6            .finish:
  217  06:CBA6  60                RTS
  218                     
  219  06:CBA7            ClearPPUString:
  220                             
  221  06:CBA7  A9 00             LDA #$00
  222  06:CBA9  8D 22 00          STA PPU_StringIdx
  223  06:CBAC  8D 23 00          STA PPU_String
  224  06:CBAF  8D 21 00          STA PPU_PendingWrite
  225  06:CBB2  60                RTS
  226                     
  227  06:CBB3            DetectSprite0:
  228  06:CBB3            WaitNotSprite0:
  229  06:CBB3  AD 02 20    lda PPU_STATUS
  230  06:CBB6  29 40       and #SPRITE_0_MASK
  231  06:CBB8  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  232                     
  233  06:CBBA            WaitSprite0:
  234  06:CBBA  AD 02 20    lda $2002
  235  06:CBBD  29 40       and #SPRITE_0_MASK
  236  06:CBBF  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  237                     
  238  06:CBC1  A2 05       ldx #$05                              ;do a scanline wait
  239  06:CBC3            WaitScanline:
  240  06:CBC3  CA          dex
  241  06:CBC4  D0 FD       bne WaitScanline
  242  06:CBC6  60          RTS
  243                     
  244                     
  245  06:CBC7            SetNametableFromIndex:
  246                     
  247  06:CBC7  48          PHA
  248  06:CBC8  AD 02 20    LDA PPU_STATUS
  249  06:CBCB  68          PLA
  250  06:CBCC  0A          ASL A
  251  06:CBCD  AA          TAX
  252  06:CBCE  BD 63 CC    LDA NameTableMemList+1, x
  253  06:CBD1  8D 06 20    STA PPU_ADDR
  254  06:CBD4  BD 62 CC    LDA NameTableMemList, x
  255  06:CBD7  8D 06 20    STA PPU_ADDR
  256  06:CBDA  60          RTS
  257                       
  258  06:CBDB            TurnOnSprites:
  259                      
  260  06:CBDB  AD 1C 00    LDA PPU_Mask
  261  06:CBDE  09 10       ORA #%00010000
  262  06:CBE0  8D 1C 00    STA PPU_Mask
  263  06:CBE3  60          RTS
  264                       
  265  06:CBE4            TurnOffSprites:
  266                       
  267  06:CBE4  AD 1C 00    LDA PPU_Mask
  268  06:CBE7  29 EF       AND #%11101111
  269  06:CBE9  8D 1C 00    STA PPU_Mask
  270  06:CBEC  60          RTS
  271                     
  272  06:CBED            UpdatePPUControl:
  273                     
  274  06:CBED  AD 1B 00    LDA PPU_Control
  275  06:CBF0  29 FC       AND #$FC
  276  06:CBF2  0D 20 00    ORA PPU_NT
  277  06:CBF5  8D 00 20    STA PPU_CTRL
  278  06:CBF8  AD 1C 00    LDA PPU_Mask
  279  06:CBFB  8D 01 20    STA PPU_MASK
  280  06:CBFE  60          RTS
  281                       
  282  06:CBFF            InitPPUControl:
  283                       
  284                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  285                       ; enable sprites, enable background, no clipping on left side
  286  06:CBFF  A9 90       LDA #%10010000
  287  06:CC01  8D 00 20    STA PPU_CTRL
  288  06:CC04  8D 1B 00    STA PPU_Control
  289  06:CC07  A9 1E       LDA #%00011110
  290  06:CC09  8D 01 20    STA PPU_MASK
  291  06:CC0C  8D 1C 00    STA PPU_Mask
  292  06:CC0F  60          RTS
  293                       
  294  06:CC10            FadeOutPalettes:
  295                     
  296                     ;;take the current values, and decrement the lower nibbles
  297                     ;;we can access from the palette copy 
  298                     ;;we'll make this fade out one level per call
  299                     ;;once all the palettes are blacked out we'll return true, so we'll keep the carry flag as a return result
  300                     
  301                     ;;go through the palette copy, decrement, make a raw data PPU string and add all the bytes into it
  302                     ;;for any palette color already in the 0x range, change it to 0f to get black
  303                     
  304                       MACROGetLabelPointer Palette_Copy, table_address
                          
       06:CC10  A9 68             LDA #HIGH(Palette_Copy)
       06:CC12  A2 00             LDX #LOW(Palette_Copy)
                                  
       06:CC14  8E 14 00          STX table_address
       06:CC17  8D 15 00          STA table_address+1
                                  
  305                     ;;palette copy address is now X accessable
  306                     
  307  06:CC1A  A0 00       LDY #$00
  308                       MACROAddPPUStringEntryRawData #$3F, #$00, #DRAW_HORIZONTAL, #$20  
                          
       06:CC1C  A9 01       LDA #$01
       06:CC1E  8D 21 00    STA PPU_PendingWrite
       06:CC21  A9 3F       LDA #$3F
       06:CC23  20 93 CB    JSR WriteToPPUString
       06:CC26  A9 00       LDA #$00
       06:CC28  20 93 CB    JSR WriteToPPUString
       06:CC2B  A9 00       LDA #DRAW_HORIZONTAL
       06:CC2D  20 93 CB    JSR WriteToPPUString
       06:CC30  A9 20       LDA #$20 
       06:CC32  20 93 CB    JSR WriteToPPUString
                            
  309                     
  310  06:CC35  A9 00       LDA #$00
  311  06:CC37  8D 00 00    STA temp1
  312                       
  313  06:CC3A            .loop:
  314                     
  315  06:CC3A  B1 14       LDA [table_address], y
  316  06:CC3C  C9 0F       CMP #$0F
  317  06:CC3E  F0 15       BEQ .addToString
  318  06:CC40  C9 10       CMP #$10
  319  06:CC42  90 0D       BCC .setBlack
  320                       
  321  06:CC44  A9 80       LDA #$80
  322  06:CC46  8D 00 00    STA temp1
  323                       
  324  06:CC49  B1 14       LDA [table_address], y
  325  06:CC4B  38          SEC
  326  06:CC4C  E9 10       SBC #$10
  327  06:CC4E  4C 53 CC    JMP .setColor
  328                     
  329  06:CC51            .setBlack:
  330                     
  331  06:CC51  A9 0F       LDA #$0F
  332                     
  333  06:CC53            .setColor:
  334  06:CC53  91 14       STA [table_address], y
  335                     
  336  06:CC55            .addToString:
  337                     
  338  06:CC55  20 93 CB    JSR WriteToPPUString
  339                     
  340  06:CC58            .incY:
  341                       
  342  06:CC58  C8          INY
  343  06:CC59  C0 20       CPY #$20
  344  06:CC5B  D0 DD       BNE .loop
  345                     
  346  06:CC5D  0E 00 00    ASL temp1     ;get carry out, if we have one
  347                     
  348  06:CC60  60          RTS
  349                       
  350  06:CC61            FadeInPalettes:
  351                     
  352                     ;;need to be able to store off a target palette first
  353                     ;;we can use the palette copy we make during the game mode change as the target
  354  06:CC61  60          RTS
  355                     
  356  06:CC62            NameTableMemList:
  357  06:CC62  00 20       .word $2000, $2400, $2800, $2C00
       06:CC64  00 24     
       06:CC66  00 28     
       06:CC68  00 2C     
  358  06:CC6A            PalettesMemList:
  359  06:CC6A  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:CC6C  04 3F     
       06:CC6E  08 3F     
       06:CC70  0C 3F     
  360  06:CC72  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:CC74  14 3F     
       06:CC76  18 3F     
       06:CC78  1C 3F     
  361                       
  362           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   95                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:CC7A            ResetMapper:
    7  06:CC7A  EE 7A CC    inc ResetMapper
    8  06:CC7D  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:CC7E            SetMapperControls:
   23                       ;;A = controls
   24  06:CC7E  AA          TAX
   25  06:CC7F  A9 80       LDA #MAPPERCONTROL
   26  06:CC81  8D A4 00    STA mapper_address+1
   27  06:CC84  8A          TXA
   28  06:CC85  20 AA CC    JSR SendMapperCommand
   29  06:CC88  60          RTS
   30                     
   31  06:CC89            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:CC89  AA                TAX
   35  06:CC8A  A9 E0             LDA #PRGBANK
   36  06:CC8C  8D A4 00          STA mapper_address+1
   37  06:CC8F  8A                TXA
   38  06:CC90  20 AA CC          JSR SendMapperCommand
   39  06:CC93  60                RTS
   40                             
   41  06:CC94            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:CC94  AA                TAX
   44  06:CC95  A9 A0             LDA #CHRBANK1
   45  06:CC97  8D A4 00          STA mapper_address+1
   46  06:CC9A  8A                TXA
   47  06:CC9B  20 AA CC          JSR SendMapperCommand
   48  06:CC9E  60                RTS
   49                             
   50  06:CC9F            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:CC9F  AA                TAX
   53  06:CCA0  A9 C0             LDA #CHRBANK2
   54  06:CCA2  8D A4 00          STA mapper_address+1
   55  06:CCA5  8A                TXA
   56  06:CCA6  20 AA CC          JSR SendMapperCommand
   57  06:CCA9  60                RTS
   58                             
   59  06:CCAA            SendMapperCommand:
   60                     
   61  06:CCAA  A0 00             LDY #$00
   62                             
   63  06:CCAC  91 A3             STA [mapper_address], y
   64  06:CCAE  4A                LSR A
   65  06:CCAF  91 A3             STA [mapper_address], y
   66  06:CCB1  4A                LSR A
   67  06:CCB2  91 A3             STA [mapper_address], y
   68  06:CCB4  4A                LSR A 
   69  06:CCB5  91 A3             STA [mapper_address], y
   70  06:CCB7  4A                LSR A
   71  06:CCB8  91 A3             STA [mapper_address], y
   72                             
   73  06:CCBA  60                RTS
   74                             
   75  06:CCBB            ResetBanks:
   76                     
   77  06:CCBB  20 7A CC          JSR ResetMapper
   78  06:CCBE  A9 00             LDA #$00
   79  06:CCC0  20 89 CC          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:CCC3  20 7A CC          JSR ResetMapper
   83  06:CCC6  A9 00             LDA #$00
   84  06:CCC8  20 94 CC          JSR LoadCHRBankA
   85  06:CCCB  A9 01             LDA #$01
   86  06:CCCD  20 9F CC          JSR LoadCHRBankB
   87  06:CCD0  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   96                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:CCD1            PopulateClues:
    2                       
    3  06:CCD1  A0 00       LDY #$00
    4  06:CCD3  B1 A9       LDA [puzzle_address], y
    5  06:CCD5  AA          TAX
    6  06:CCD6  BD 34 D0    LDA PuzzleSizes, x
    7  06:CCD9  8D 00 00    STA temp1
    8                       
    9  06:CCDC            .getByte:
   10  06:CCDC  AC B7 00    LDY clueTableIndex
   11  06:CCDF  B1 AB       LDA [clues_address], y
   12  06:CCE1  D0 07       BNE .checkNewLine
   13  06:CCE3  EE B7 00    INC clueTableIndex
   14  06:CCE6  A9 00       LDA #$00
   15  06:CCE8  F0 39       BEQ .drawClue
   16                       ;was 0, set up a draw
   17  06:CCEA            .checkNewLine
   18  06:CCEA  C9 FF       CMP #$FF
   19  06:CCEC  D0 18       BNE .getClue
   20                       
   21                       ;;was FF- need to inc stuff
   22  06:CCEE  EE B7 00    INC clueTableIndex
   23  06:CCF1  A9 00       LDA #$00
   24  06:CCF3  8D BE 00    STA clueParity
   25                       
   26  06:CCF6  EE B8 00    INC clueLineIndex
   27  06:CCF9  AD B8 00    LDA clueLineIndex
   28  06:CCFC  CD 00 00    CMP temp1
   29                       ;CMP #$01
   30  06:CCFF  F0 28       BEQ .leave    ;carry will be set
   31                       
   32  06:CD01  20 B2 CD    JSR CreateOffsetFromIndex
   33                      
   34  06:CD04  D0 D6       BNE .getByte
   35                       
   36  06:CD06            .getClue:
   37                       ;;clues go from high nibble to low nibble
   38  06:CD06  48          PHA 
   39  06:CD07  AD BE 00    LDA clueParity
   40  06:CD0A  D0 0A       BNE .getSecondClue
   41  06:CD0C  EE BE 00    INC clueParity
   42  06:CD0F  68          PLA
   43  06:CD10  4A          LSR A
   44  06:CD11  4A          LSR A
   45  06:CD12  4A          LSR A
   46  06:CD13  4A          LSR A         ;move clue over to lower nibble
   47  06:CD14  D0 0D       BNE .drawClue
   48                       
   49  06:CD16            .getSecondClue:
   50                     
   51  06:CD16  CE BE 00    DEC clueParity
   52  06:CD19  EE B7 00    INC clueTableIndex
   53  06:CD1C  68          PLA 
   54  06:CD1D  29 0F       AND #$0F
   55  06:CD1F  D0 02       BNE .drawClue
   56                       ;;if 0, skip
   57  06:CD21  F0 B9       BEQ .getByte
   58                      
   59  06:CD23            .drawClue:
   60                       
   61  06:CD23  09 40       ORA #$40
   62  06:CD25  20 2A CD    JSR WriteClueByteToPPUString
   63  06:CD28  18          CLC
   64                       
   65  06:CD29            .leave:
   66  06:CD29  60          RTS
   67                       
   68  06:CD2A            WriteClueByteToPPUString:
   69                     
   70  06:CD2A  8D 00 00    STA temp1 ;store off the tile value
   71                     
   72                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:CD2D  A9 01       LDA #$01
       06:CD2F  8D 21 00    STA PPU_PendingWrite
       06:CD32  AD B6 00    LDA clue_draw_address+1
       06:CD35  20 93 CB    JSR WriteToPPUString
       06:CD38  AD B5 00    LDA clue_draw_address
       06:CD3B  20 93 CB    JSR WriteToPPUString
       06:CD3E  A9 00       LDA #DRAW_HORIZONTAL
       06:CD40  20 93 CB    JSR WriteToPPUString
       06:CD43  A9 01       LDA #$01 
       06:CD45  20 93 CB    JSR WriteToPPUString
                            
   73  06:CD48  AD 00 00    LDA temp1
   74  06:CD4B  20 93 CB    JSR WriteToPPUString
   75                       
   76                       ;;also copy to ... copy
   77  06:CD4E  AD B5 00    LDA clue_draw_address
   78  06:CD51  8D AF 00    STA copy_address
   79  06:CD54  AD B6 00    LDA clue_draw_address+1
   80  06:CD57  29 0F       AND #$0F
   81  06:CD59  09 60       ORA #$60
   82  06:CD5B  8D B0 00    STA copy_address+1
   83  06:CD5E  AD 00 00    LDA temp1
   84  06:CD61  A0 00       LDY #$00
   85  06:CD63  91 AF       STA [copy_address],y
   86                       
   87  06:CD65  AD BA 00    LDA clueDrawAdd
   88  06:CD68  20 8F CD    JSR SubFromClueDrawAddress
   89                         
   90  06:CD6B  60          RTS
   91                       
   92  06:CD6C            ResetClueDrawAddress:
   93                     
   94                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:CD6C  AD B3 00          LDA clue_start_address
       06:CD6F  8D B5 00          STA clue_draw_address
       06:CD72  AD B4 00          LDA clue_start_address+1
       06:CD75  8D B6 00          STA clue_draw_address+1
                          
   95                       
   96  06:CD78  60          RTS
   97                       
   98  06:CD79            AddToClueDrawAddress:
   99                     
  100  06:CD79  8D 00 00    STA temp1
  101                       
  102  06:CD7C  AD B5 00    LDA clue_draw_address
  103  06:CD7F  18          CLC
  104  06:CD80  6D 00 00    ADC temp1
  105  06:CD83  8D B5 00    STA clue_draw_address
  106  06:CD86  AD B6 00    LDA clue_draw_address+1
  107  06:CD89  69 00       ADC #$00
  108  06:CD8B  8D B6 00    STA clue_draw_address+1
  109                       
  110  06:CD8E  60          RTS
  111                         
  112  06:CD8F            SubFromClueDrawAddress:
  113                     
  114  06:CD8F  8D 00 00    STA temp1
  115                       
  116  06:CD92  AD B5 00    LDA clue_draw_address
  117  06:CD95  38          SEC
  118  06:CD96  ED 00 00    SBC temp1
  119  06:CD99  8D B5 00    STA clue_draw_address
  120  06:CD9C  AD B6 00    LDA clue_draw_address+1
  121  06:CD9F  E9 00       SBC #$00
  122  06:CDA1  8D B6 00    STA clue_draw_address+1
  123                       
  124  06:CDA4  60          RTS
  125                       
  126  06:CDA5            AddToClueDrawAddressHi:
  127                     
  128  06:CDA5  8D 00 00    STA temp1
  129                       
  130  06:CDA8  AD B6 00    LDA clue_draw_address+1
  131  06:CDAB  6D 00 00    ADC temp1
  132  06:CDAE  8D B6 00    STA clue_draw_address+1
  133                       
  134  06:CDB1  60          RTS
  135                       
  136  06:CDB2            CreateOffsetFromIndex:
  137                     
  138                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  139  06:CDB2  AD B8 00    LDA clueLineIndex
  140  06:CDB5  8D BB 00    STA clueDrawOffset
  141  06:CDB8  A9 00       LDA #$00
  142  06:CDBA  8D BC 00    STA clueDrawOffset+1
  143                       
  144  06:CDBD  AD B9 00    LDA clueOffsetShift   
  145  06:CDC0  F0 0E       BEQ .addOffset
  146                       
  147  06:CDC2  A2 00       LDX #$00
  148                       
  149  06:CDC4            .loopShift:
  150  06:CDC4  0E BB 00    ASL clueDrawOffset
  151  06:CDC7  2E BC 00    ROL clueDrawOffset+1
  152  06:CDCA  E8          INX
  153  06:CDCB  EC B9 00    CPX clueOffsetShift
  154  06:CDCE  D0 F4       BNE .loopShift
  155                       
  156  06:CDD0            .addOffset:
  157                       
  158  06:CDD0  20 6C CD    JSR ResetClueDrawAddress
  159  06:CDD3  AD BB 00    LDA clueDrawOffset
  160  06:CDD6  20 79 CD    JSR AddToClueDrawAddress 
  161  06:CDD9  AD BC 00    LDA clueDrawOffset+1
  162  06:CDDC  20 A5 CD    JSR AddToClueDrawAddressHi
  163                       
  164  06:CDDF  60          RTS  
  165                       
  166  06:CDE0            ClearPuzzle:
  167                     
  168                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  169                      
  170                       MACROGetLabelPointer ClearLineDefs, table_address
                          
       06:CDE0  A9 D0             LDA #HIGH(ClearLineDefs)
       06:CDE2  A2 16             LDX #LOW(ClearLineDefs)
                                  
       06:CDE4  8E 14 00          STX table_address
       06:CDE7  8D 15 00          STA table_address+1
                                  
  171                     
  172  06:CDEA  AC B8 00    LDY clueLineIndex
  173  06:CDED  B1 14       LDA [table_address], y
  174  06:CDEF  8D 00 00    STA temp1
  175                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:CDF2  A9 01       LDA #$01
       06:CDF4  8D 21 00    STA PPU_PendingWrite
       06:CDF7  AD B6 00    LDA clue_draw_address+1
       06:CDFA  20 93 CB    JSR WriteToPPUString
       06:CDFD  AD B5 00    LDA clue_draw_address
       06:CE00  20 93 CB    JSR WriteToPPUString
       06:CE03  A9 40       LDA #$40
       06:CE05  09 00       ORA #DRAW_HORIZONTAL
       06:CE07  0D 00 00    ORA temp1
       06:CE0A  20 93 CB    JSR WriteToPPUString
       06:CE0D  A9 24       LDA #$24
       06:CE0F  20 93 CB    JSR WriteToPPUString
                            
  176                       ;;no need to load anything else
  177                       
  178  06:CE12  AD B5 00    LDA clue_draw_address
  179  06:CE15  18          CLC
  180  06:CE16  69 20       ADC #32
  181  06:CE18  8D B5 00    STA clue_draw_address
  182  06:CE1B  AD B6 00    LDA clue_draw_address+1
  183  06:CE1E  69 00       ADC #$00
  184  06:CE20  8D B6 00    STA clue_draw_address+1
  185                       
  186  06:CE23  EE B8 00    INC clueLineIndex
  187  06:CE26  60          RTS
  188                       
  189  06:CE27            LoadPauseScreen:
  190                     
  191                     ;;use clue indexes again
  192                     ;;we want to draw one line at a time
  193                     ;;we have control codes, but those don't matter since we have to build ou the strings before hand
  194                     
  195                     ;load pause table
  196                     ;there are 6 lines of 13 tiles
  197                     ;one byte for the 6 lines, one byte to keep track of our index
  198                       ;STA clueLineIndex 
  199                       ;STA clueOffsetShift
  200                     
  201                     ;;pause_address has the table we want
  202                     ;;pause_draw_address will be the draw location
  203                     
  204                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:CE27  A9 01       LDA #$01
       06:CE29  8D 21 00    STA PPU_PendingWrite
       06:CE2C  AD B2 00    LDA pause_draw_address+1
       06:CE2F  20 93 CB    JSR WriteToPPUString
       06:CE32  AD B1 00    LDA pause_draw_address
       06:CE35  20 93 CB    JSR WriteToPPUString
       06:CE38  A9 00       LDA #DRAW_HORIZONTAL
       06:CE3A  20 93 CB    JSR WriteToPPUString
       06:CE3D  A9 0D       LDA #13 
       06:CE3F  20 93 CB    JSR WriteToPPUString
                            
  205                     
  206  06:CE42  A2 00       LDX #$00
  207  06:CE44  AC B8 00    LDY clueLineIndex
  208  06:CE47            .loop:
  209                      
  210  06:CE47  8A          TXA
  211  06:CE48  48          PHA
  212  06:CE49  B1 AD       LDA [pause_address],y
  213  06:CE4B  20 93 CB    JSR WriteToPPUString
  214  06:CE4E  68          PLA
  215  06:CE4F  AA          TAX
  216  06:CE50  C8          INY
  217  06:CE51  E8          INX 
  218  06:CE52  E0 0D       CPX #13
  219  06:CE54  D0 F1       BNE .loop
  220                       
  221  06:CE56  8C B8 00    STY clueLineIndex
  222                       
  223  06:CE59  AD B1 00    LDA pause_draw_address
  224  06:CE5C  18          CLC
  225  06:CE5D  69 20       ADC #$20
  226  06:CE5F  8D B1 00    STA pause_draw_address
  227  06:CE62  AD B2 00    LDA pause_draw_address+1
  228  06:CE65  69 00       ADC #$00
  229  06:CE67  8D B2 00    STA pause_draw_address+1
  230                       
  231  06:CE6A  EE B9 00    INC clueOffsetShift
  232  06:CE6D  60          RTS
  233                       
  234                       
  235                     
  236                     
  237  06:CE6E            ClearPauseScreen:  
  238                     
  239                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:CE6E  A9 01       LDA #$01
       06:CE70  8D 21 00    STA PPU_PendingWrite
       06:CE73  AD B2 00    LDA pause_draw_address+1
       06:CE76  20 93 CB    JSR WriteToPPUString
       06:CE79  AD B1 00    LDA pause_draw_address
       06:CE7C  20 93 CB    JSR WriteToPPUString
       06:CE7F  A9 00       LDA #DRAW_HORIZONTAL
       06:CE81  20 93 CB    JSR WriteToPPUString
       06:CE84  A9 0D       LDA #13 
       06:CE86  20 93 CB    JSR WriteToPPUString
                            
  240                     
  241  06:CE89  A2 00       LDX #$00
  242  06:CE8B  A0 00       LDY #$00
  243  06:CE8D            .loop:
  244                      
  245  06:CE8D  8A          TXA
  246  06:CE8E  48          PHA
  247  06:CE8F  B1 AD       LDA [pause_address],y
  248  06:CE91  20 93 CB    JSR WriteToPPUString
  249  06:CE94  68          PLA
  250  06:CE95  AA          TAX
  251  06:CE96  C8          INY
  252  06:CE97  E8          INX 
  253  06:CE98  E0 0D       CPX #13
  254  06:CE9A  D0 F1       BNE .loop
  255                       
  256                       
  257  06:CE9C  AD B1 00    LDA pause_draw_address
  258  06:CE9F  18          CLC
  259  06:CEA0  69 20       ADC #$20
  260  06:CEA2  8D B1 00    STA pause_draw_address
  261  06:CEA5  AD B2 00    LDA pause_draw_address+1
  262  06:CEA8  69 00       ADC #$00
  263  06:CEAA  8D B2 00    STA pause_draw_address+1
  264                       
  265  06:CEAD  AD AD 00    LDA pause_address
  266  06:CEB0  18          CLC
  267  06:CEB1  69 20       ADC #$20
  268  06:CEB3  8D AD 00    STA pause_address
  269  06:CEB6  AD AE 00    LDA pause_address+1
  270  06:CEB9  69 00       ADC #$00
  271  06:CEBB  8D AE 00    STA pause_address+1
  272                       
  273  06:CEBE  EE B9 00    INC clueOffsetShift
  274  06:CEC1  60         RTS
  275  06:CEC2            DrawImage:
  276                     
  277                       ;;we have clueTableIndex, which should be at the image bytes now
  278                       ;;clue line index will keep track of our place in a byte
  279                        
  280  06:CEC2  A9 00       LDA #$00
  281  06:CEC4  8D 00 00    STA temp1
  282  06:CEC7  8D 01 00    STA temp2
  283  06:CECA  8D 02 00    STA temp3
  284  06:CECD  8D 03 00    STA temp4
  285  06:CED0  8D 05 00    STA temp6
  286                       
  287  06:CED3  A9 04       LDA #$04
  288  06:CED5  8D 04 00    STA temp5
  289                       
  290  06:CED8  A0 00       LDY #$00
  291  06:CEDA  B1 A9       LDA [puzzle_address], y
  292  06:CEDC  AA          TAX
  293  06:CEDD  BD 34 D0    LDA PuzzleSizes, x
  294  06:CEE0  8D 06 00    STA temp7
  295  06:CEE3  BD 37 D0    LDA PuzzleImageSizes, x
  296  06:CEE6  8D 07 00    STA temp8
  297  06:CEE9  4A          LSR A
  298  06:CEEA  4A          LSR A
  299  06:CEEB  8D 09 00    STA tempy
  300  06:CEEE  AD 07 00    LDA temp8
  301  06:CEF1  29 03       AND #$03
  302  06:CEF3  F0 03       BEQ .skipAdd1
  303  06:CEF5  EE 09 00    INC tempy  
  304  06:CEF8            .skipAdd1:
  305  06:CEF8  BD 3A D0    LDA ImageDrawWrapOffsets, x
  306  06:CEFB  8D 08 00    STA tempx
  307                       
  308  06:CEFE  AC B7 00    LDY clueTableIndex
  309  06:CF01  B1 AB       LDA [clues_address], y
  310                     
  311  06:CF03  0A          ASL A
  312  06:CF04  2E 00 00    ROL temp1
  313  06:CF07  0A          ASL A
  314  06:CF08  2E 00 00    ROL temp1
  315  06:CF0B  0A          ASL A
  316  06:CF0C  2E 01 00    ROL temp2
  317  06:CF0F  0A          ASL A
  318  06:CF10  2E 01 00    ROL temp2
  319  06:CF13  0A          ASL A
  320  06:CF14  2E 02 00    ROL temp3
  321  06:CF17  0A          ASL A
  322  06:CF18  2E 02 00    ROL temp3
  323  06:CF1B  0A          ASL A
  324  06:CF1C  2E 03 00    ROL temp4
  325  06:CF1F  0A          ASL A
  326  06:CF20  2E 03 00    ROL temp4
  327                       
  328                     
  329  06:CF23  A2 00       LDX #$00
  330  06:CF25            .moveUpTiles:
  331  06:CF25  BD 00 00    LDA temp1, x
  332  06:CF28  09 24       ORA #$24
  333  06:CF2A  9D 00 00    STA temp1, x
  334  06:CF2D  E8          INX
  335  06:CF2E  E0 04       CPX #$04
  336  06:CF30  D0 F3       BNE .moveUpTiles
  337                       
  338                       
  339  06:CF32  AD B9 00    LDA clueOffsetShift
  340  06:CF35  18          CLC
  341  06:CF36  69 04       ADC #$04
  342                     
  343  06:CF38  8D B9 00    STA clueOffsetShift
  344                       ;;clue offset shift + 4, check if we went over puzle row length
  345  06:CF3B  38          SEC
  346  06:CF3C  ED 06 00    SBC temp7 ;;subtract 15
  347  06:CF3F  90 12       BCC .makeStrings
  348  06:CF41  F0 10       BEQ .makeStrings
  349                       
  350  06:CF43  8D B9 00    STA clueOffsetShift ;loop offset over
  351  06:CF46  8D 05 00    STA temp6 ; length of second string
  352  06:CF49  AD 04 00    LDA temp5
  353  06:CF4C  38          SEC
  354  06:CF4D  ED 05 00    SBC temp6 
  355  06:CF50  8D 04 00    STA temp5 ;length of first string 
  356                       
  357  06:CF53            .makeStrings:
  358                       
  359  06:CF53  A2 00       LDX #$00
  360                       
  361  06:CF55  AD 04 00    LDA temp5
  362  06:CF58  F0 51       BEQ .makeSecondString
  363  06:CF5A  8A          TXA
  364  06:CF5B  48          PHA
  365                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp5
                          
       06:CF5C  A9 01       LDA #$01
       06:CF5E  8D 21 00    STA PPU_PendingWrite
       06:CF61  AD B6 00    LDA clue_draw_address+1
       06:CF64  20 93 CB    JSR WriteToPPUString
       06:CF67  AD B5 00    LDA clue_draw_address
       06:CF6A  20 93 CB    JSR WriteToPPUString
       06:CF6D  A9 00       LDA #DRAW_HORIZONTAL
       06:CF6F  20 93 CB    JSR WriteToPPUString
       06:CF72  AD 04 00    LDA temp5 
       06:CF75  20 93 CB    JSR WriteToPPUString
                            
  366  06:CF78  68          PLA
  367  06:CF79  AA          TAX
  368                       
  369  06:CF7A            .firstStringLoop:
  370                       
  371  06:CF7A  8A          TXA 
  372  06:CF7B  48          PHA
  373  06:CF7C  BD 00 00    LDA temp1, x
  374  06:CF7F  20 93 CB    JSR WriteToPPUString
  375                       
  376  06:CF82  EE B8 00    INC clueLineIndex
  377  06:CF85  AD B8 00    LDA clueLineIndex
  378  06:CF88  CD 07 00    CMP temp8
  379  06:CF8B  D0 04       BNE .continueLoop
  380  06:CF8D  68          PLA 
  381  06:CF8E  4C 12 D0    JMP .leave
  382                       
  383  06:CF91            .continueLoop:
  384  06:CF91  68          PLA
  385  06:CF92  AA          TAX
  386  06:CF93  E8          INX
  387  06:CF94  EC 04 00    CPX temp5
  388  06:CF97  D0 E1       BNE .firstStringLoop
  389                       
  390  06:CF99  AD B5 00    LDA clue_draw_address
  391  06:CF9C  18          CLC
  392  06:CF9D  6D 04 00    ADC temp5
  393  06:CFA0  8D B5 00    STA clue_draw_address
  394  06:CFA3  AD B6 00    LDA clue_draw_address+1
  395  06:CFA6  69 00       ADC #$00
  396  06:CFA8  8D B6 00    STA clue_draw_address+1
  397                       
  398  06:CFAB            .makeSecondString:
  399                     
  400  06:CFAB  AD 05 00    LDA temp6
  401  06:CFAE  F0 62       BEQ .leave
  402                       
  403                       ;;loop draw address to next line
  404  06:CFB0  AD B5 00    LDA clue_draw_address
  405  06:CFB3  18          CLC
  406  06:CFB4  6D 08 00    ADC tempx
  407  06:CFB7  8D B5 00    STA clue_draw_address
  408  06:CFBA  AD B6 00    LDA clue_draw_address+1
  409  06:CFBD  69 00       ADC #$00
  410  06:CFBF  8D B6 00    STA clue_draw_address+1
  411  06:CFC2  8A          TXA
  412  06:CFC3  48          PHA
  413                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp6
                          
       06:CFC4  A9 01       LDA #$01
       06:CFC6  8D 21 00    STA PPU_PendingWrite
       06:CFC9  AD B6 00    LDA clue_draw_address+1
       06:CFCC  20 93 CB    JSR WriteToPPUString
       06:CFCF  AD B5 00    LDA clue_draw_address
       06:CFD2  20 93 CB    JSR WriteToPPUString
       06:CFD5  A9 00       LDA #DRAW_HORIZONTAL
       06:CFD7  20 93 CB    JSR WriteToPPUString
       06:CFDA  AD 05 00    LDA temp6 
       06:CFDD  20 93 CB    JSR WriteToPPUString
                            
  414  06:CFE0  68          PLA 
  415  06:CFE1  AA          TAX
  416                       
  417  06:CFE2            .secondStringLoop:
  418                     
  419  06:CFE2  8A          TXA
  420  06:CFE3  48          PHA 
  421  06:CFE4  BD 00 00    LDA temp1, x
  422  06:CFE7  20 93 CB    JSR WriteToPPUString
  423                       
  424  06:CFEA  EE B8 00    INC clueLineIndex
  425  06:CFED  AD B8 00    LDA clueLineIndex
  426  06:CFF0  CD 07 00    CMP temp8
  427  06:CFF3  D0 04       BNE .continueSecondLoop
  428                       
  429  06:CFF5  68          PLA 
  430  06:CFF6  4C 12 D0    JMP .leave
  431                       
  432  06:CFF9            .continueSecondLoop:
  433  06:CFF9  68          PLA
  434  06:CFFA  AA          TAX
  435  06:CFFB  E8          INX
  436  06:CFFC  E0 04       CPX #$04
  437  06:CFFE  D0 E2       BNE .secondStringLoop
  438                       
  439  06:D000  AD B5 00    LDA clue_draw_address
  440  06:D003  18          CLC
  441  06:D004  6D 05 00    ADC temp6
  442  06:D007  8D B5 00    STA clue_draw_address
  443  06:D00A  AD B6 00    LDA clue_draw_address+1
  444  06:D00D  69 00       ADC #$00
  445  06:D00F  8D B6 00    STA clue_draw_address+1
  446                       
  447  06:D012            .leave:
  448  06:D012  EE B7 00    INC clueTableIndex
  449  06:D015  60          RTS
  450                     
  451  06:D016            ClearLineDefs:
  452                     
  453  06:D016  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:D019  20 20 20  
       06:D01C  20 20 20  
       06:D01F  20 20     
  454  06:D021  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:D024  0D 0D 0D  
       06:D027  0D 0D 0D  
       06:D02A  0D 0D 0D  
       06:D02D  0D 0D 0D  
       06:D030  0D 0D     
  455  06:D032  20 20       .db $20, $20
  456                       
  457  06:D034            PuzzleSizes:
  458                       
  459  06:D034  05 0A 0F    .db $05, $0A, $0F
  460                       
  461  06:D037            PuzzleImageSizes:
  462                     
  463                       ;.db $05, $0A, $0F
  464  06:D037  19 64 E1    .db $19, $64, $E1
  465                       
  466  06:D03A            ImageDrawWrapOffsets:
  467                     
  468  06:D03A  1B 16 11   .db $1B, $16, $11
#[1]   Picross.asm
   97                       
   98                       
   99                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  100                     ;;     NMI                  ;;
  101                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  102                     
#[2]   Routines/Common/NMI.asm
  103                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:D03D            NMI:
    3                     
    4  06:D03D  48          PHA                              ;protect the registers
    5  06:D03E  8A          TXA
    6  06:D03F  48          PHA
    7  06:D040  98          TYA
    8  06:D041  48          PHA
    9                       
   10  06:D042            nmi_started:
   11  06:D042  A9 00       LDA #$00
   12  06:D044  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:D047  A9 02       LDA #$02
   14  06:D049  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:D04C  AD 10 00    LDA NMI_locks
   17  06:D04F  F0 03       BEQ update_controllers
   18  06:D051  4C C0 D0    JMP WakeUp
   19                     
   20  06:D054            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:D054  8A            TXA
    3  06:D055  48                PHA
    4  06:D056  98                TYA
    5  06:D057  48                PHA
    6                     
    7  06:D058  A2 00             LDX #$00
    8                     
    9  06:D05A            GamePadCheck:
   10  06:D05A  A9 01             LDA #$01        ;load 1
   11  06:D05C  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:D05F  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:D060  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:D063  A9 80             LDA #$80
   18  06:D065  8D 18 00          STA gamepad
   19                     
   20  06:D068            ReadControllerABytesLoop:
   21  06:D068  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:D06B  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:D06D  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:D06F  6E 18 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:D072  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:D074  AD 19 00          LDA gamepadLast
   31  06:D077  49 FF             EOR #$FF
   32  06:D079  2D 18 00          AND gamepad
   33  06:D07C  8D 1A 00          STA gamepadPressed
   34                             
   35                             
   36  06:D07F  AD 18 00          LDA gamepad
   37  06:D082  8D 19 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:D085  68                PLA
   41  06:D086  A8                TAY
   42  06:D087  68                PLA
   43  06:D088  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:D089  20 D0 CA    JSR ProcessPPUString
   25                       
   26                       
   27  06:D08C  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:D08E  8D 05 20    STA PPU_SCROLL
   29  06:D091  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:D094  20 ED CB    JSR UpdatePPUControl
   34                     
   35  06:D097            NMIUpdate:
   36                     
   37  06:D097  20 B4 D0    JSR StateNMIUpdate
   38                       
   39  06:D09A  AD 1B 00    LDA PPU_Control
   40  06:D09D  29 FC       AND #$FC
   41  06:D09F  0D 1F 00    ORA PPU_ScrollNT
   42  06:D0A2  8D 00 20    STA PPU_CTRL
   43                       
   44  06:D0A5  AD 1D 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:D0A8  8D 05 20    STA PPU_SCROLL
   46  06:D0AB  AD 1E 00    LDA PPU_ScrollY
   47  06:D0AE  8D 05 20    STA PPU_SCROLL
   48                     
   49  06:D0B1  4C C0 D0    JMP WakeUp
   50                     
   51  06:D0B4            StateNMIUpdate:
   52                     
   53                       MACROCallDynamicJump game_mode
                          
       06:D0B4  AD 0E 00    LDA game_mode
       06:D0B7  20 32 CA    JSR Dynamic_Jump
                                  
   54                     
   55  06:D0BA            NMIJumpTable:
   56                     
   57  06:D0BA  CB D0       .word UpdateTitleNMI
   58  06:D0BC  CF D0       .word UpdateGameNMI
   59  06:D0BE  D0 D0       .word UpdateGameOverNMI
   60                     
   61  06:D0C0            WakeUp:
   62  06:D0C0  A9 00       LDA #$00
   63  06:D0C2  8D 0C 00    STA sleeping
   64                       
   65  06:D0C5  68          PLA             ;restore the registers
   66  06:D0C6  A8          TAY 
   67  06:D0C7  68          PLA
   68  06:D0C8  AA          TAX
   69  06:D0C9  68          PLA
   70                     
   71  06:D0CA  40          RTI             ; return from interrupt
   72                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   73                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:D0CB            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:D0CB  20 B3 CB    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:D0CE  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   74                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:D0CF            UpdateGameNMI:
    2  06:D0CF  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:D0D0            UpdateGameOverNMI:
    2  06:D0D0  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
  104                       
  105                     ;;**************************;;
  106                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  107                     ;;       PRG ROM DATA       ;;
  108                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  109                     ;;**************************;; 
  110                       
  111           0007        .bank 7
  112           E000        .org $E000
  113                     
#[2]   NameTables/Tables.asm
  114                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  1C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  3C E0     
       07:E004  5C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  12 E0       .word Title_Screens, Game_Screens, GameOver_Screens
       07:E008  14 E0     
       07:E00A  1A E0     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  7C E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  7C F8     
       07:E010  7C F8     
   12                       
   13  07:E012            Title_Screens:
   14                     
   15  07:E012  7C E0       .word Title_Screen
   16                       
   17  07:E014            Game_Screens:
   18                     
   19  07:E014  7C E8       .word Game_5, Game_10, Game_15
       07:E016  7C EC     
       07:E018  7C F0     
   20                       
   21  07:E01A            GameOver_Screens:
   22                     
   23  07:E01A  7C F4       .word GameOver_Screen
   24                     
   25  07:E01C            Title_Palette:
   26                     
   27  07:E01C              .incbin "NameTables/Title_PAL.pal"
   28  07:E02C              .incbin "NameTables/Title_PAL.pal"
   29                       
   30  07:E03C            Game_Palette:
   31                     
   32  07:E03C              .incbin "NameTables/Game_PAL.pal"
   33  07:E04C              .incbin "NameTables/Game_PAL.pal"
   34                       
   35  07:E05C            GameOver_Palette:
   36                     
   37  07:E05C              .incbin "NameTables/GameOver_PAL.pal"
   38  07:E06C              .incbin "NameTables/GameOver_PAL.pal"
   39                       
   40  07:E07C            Title_Screen:
   41                     
   42  07:E07C              .incbin "NameTables/Title_NT.nam"
   43                       
   44  07:E47C            Title_Second:
   45                     
   46  07:E47C              .incbin "NameTables/Title_PuzzMen_NT.nam"
   47                       
   48  07:E87C            Game_5: 
   49                     
   50  07:E87C              .incbin "NameTables/Game_NT_5.nam"
   51                       
   52  07:EC7C            Game_10:
   53  07:EC7C              .incbin "NameTables/Game_NT_10.nam"
   54                       
   55  07:F07C            Game_15:
   56  07:F07C              .incbin "NameTables/Game_NT.nam"
   57                       
   58  07:F47C            GameOver_Screen:
   59                     
   60  07:F47C              .incbin "NameTables/GameOver_NT.nam"
   61                       
   62  07:F87C            Blank_Screen:
   63                     
   64  07:F87C              .incbin "NameTables/Blank_NT.nam"
   65                     
   66  07:FC7C            Pause_Menu:
   67  07:FC7C  28 2A 2A    .db $28,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$29
       07:FC7F  2A 2A 2A  
       07:FC82  2A 2A 2A  
       07:FC85  2A 2A 2A  
       07:FC88  29        
   68  07:FC89  2B 24 1C    .db $2b,$24,$1c,$0a,$1f,$0e,$62,$0e,$21,$12,$1d,$24,$3b
       07:FC8C  0A 1F 0E  
       07:FC8F  62 0E 21  
       07:FC92  12 1D 24  
       07:FC95  3B        
   69  07:FC96  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FC99  24 24 24  
       07:FC9C  24 24 24  
       07:FC9F  24 24 24  
       07:FCA2  3B        
   70  07:FCA3  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FCA6  24 24 24  
       07:FCA9  24 24 24  
       07:FCAC  24 24 24  
       07:FCAF  3B        
   71  07:FCB0  2B 24 24    .db $2b,$24,$24,$22,$0e,$1c,$24,$24,$17,$18,$24,$24,$3b
       07:FCB3  22 0E 1C  
       07:FCB6  24 24 17  
       07:FCB9  18 24 24  
       07:FCBC  3B        
   72  07:FCBD  38 3A 3A    .db $38,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$39
       07:FCC0  3A 3A 3A  
       07:FCC3  3A 3A 3A  
       07:FCC6  3A 3A 3A  
       07:FCC9  39        
   73                     
   74                       
   75                     
   76                       
   77                      
   78                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  115                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:FCCA            Sprites:
   38  07:FCCA  D0 FC             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:FCCC  D9 FC     
       07:FCCE  E2 FC     
   39                     
   40  07:FCD0            Title_Sprites:
   41  07:FCD0  02            .db $02
   42  07:FCD1  85 00 00          .db $85,$00,$00,$E8
       07:FCD4  E8        
   43  07:FCD5  A0 01 00          .db $A0,$01,$00,$60
       07:FCD8  60        
   44  07:FCD9            Game_Sprites:
   45  07:FCD9  02            .db $02
   46  07:FCDA  62 02 03          .db $62,$02,$03,$72
       07:FCDD  72        
   47  07:FCDE  5F FF 00          .db $5F,$FF,$00,$60
       07:FCE1  60        
   48  07:FCE2            GameOver_Sprites:
   49  07:FCE2  01                .db $01
   50  07:FCE3  00 00 00          .db $00,$00,$00,$00
       07:FCE6  00        
#[1]   Picross.asm
  116                     
  117           FFFA        .org $FFFA     ;first of the three vectors starts here
  118  07:FFFA  3D D0       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  119                                        ;processor will jump to the label NMI:
  120  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  121                                        ;to the label RESET:
  122  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  123                       
  124                     ;;**************************;;
  125                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  126                     ;;      CHR ROM DATA        ;;
  127                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  128                     ;;**************************;; 
  129                       
  130           0008        .bank 8
  131           0000        .org $0000
  132  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  133                       
  134           0009        .bank 9
  135           0000        .org $0000
  136  09:0000              .incbin "CHRROM/Bank1.chr"
  137                       
  138           000A        .bank 10
  139           0000        .org $0000
  140  0A:0000              .incbin "CHRROM/Bank2.chr"
  141                       
  142           000B        .bank 11
  143           0000        .org $0000
  144  0B:0000              .incbin "CHRROM/Bank3.chr"
