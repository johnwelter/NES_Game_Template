#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      tempx                   .rs 1
    6           0005      tempy                   .rs 1
    7           0006      time                    .rs 1
    8           0007      sleeping                .rs 1
    9           0008      game_mode               .rs 1
   10           0009      mode_state              .rs 1
   11           000A      NMI_locks               .rs 1
   12           000B      game_locks              .rs 1
   13           000C      pointer_address .rs 2
   14           000E      table_address   .rs 2
   15           0010      jump_address    .rs 2
   16                     
   17                     ;game modes
   18           0000      TITLE_IDX = $00
   19           0001      GAME_IDX = $01
   20           0002      GAMEOVER_IDX = $02
   21                     
   22                     ;locks for input and rendering
   23           0001      BGLOAD_NMI_LOCK = %00000001
   24           0001      EFFECT_GAME_LOCK = %00000001
   25                     
   26                     
   27                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           0012      gamepad                 .rs 1
   19           0013      gamepadLast     .rs 1
   20           0014      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           0015      PPU_Control                     .rs 1
    2           0016      PPU_Mask                        .rs 1
    3           0017      PPU_ScrollX                     .rs 1
    4           0018      PPU_ScrollY                     .rs 1
    5           0019      PPU_ScrollNT            .rs 1   ;first two bits
    6           001A      PPU_NT                          .rs 1
    7                     
    8           001B      PPU_PendingWrite        .rs 1
    9           001C      PPU_StringIdx           .rs 1
   10           001D      PPU_String                      .rs 32
   11                     
   12           0020      PPU_STRINGMAX = $20 ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           003D      mapper_address  .rs 2
    2           003F      currentCHRBankA .rs 1
    3           0040      currentCHRBankB .rs 1
    4           0041      currentPRGBank  .rs 1
    5           0042      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1           0043      bank_index      .rs 1
    2           0044      puzzle_index .rs 1
    3                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           0045      puzzle_address          .rs 2
    2           0047      clues_address           .rs 2
    3           0049      clue_start_address      .rs 2
    4           004B      clue_draw_address       .rs 2
    5           004D      clueTableIndex          .rs 1
    6           004E      clueLineIndex           .rs 1
    7           004F      clueOffsetShift         .rs 1
    8           0050      clueDrawOffset          .rs 2
    9           0052      clueDrawAdd                     .rs 1
   10           0053      clueDrawDecSize         .rs 1
   11           0054      clueParity                      .rs 1
   12           0055      mouse_location          .rs 2
   13           0057      mouse_index                     .rs 2
   14           0059      currentPaintTile        .rs 1
   15           005A      solutionCount           .rs 1
   16           005B      nonSolutionCount        .rs 1
   17                     
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/SaveVariables.asm
   18                       .include "Defines/SaveVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/ScreenStateVariables.asm
   19                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   20                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                       
   40                     MACROAddPPUStringEntryTable .macro
   41                      
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       JSR WriteToPPUString
   51                       LDA #LOW(\4)
   52                       JSR WriteToPPUString
   53                       LDA #HIGH(\4)
   54                       JSR WriteToPPUString
   55                      
   56                       .endm
   57                     
   58                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1           0000        .bank 0
    2           8000        .org $8000
    3                       
#[3]   Puzzles/house.asm
    4                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  03 82 00    .db $03, $82, $00, $01
       00:8003  01        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $04, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 04  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  11 18 1E    .db $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1C 0E FF  
#[2]   Banks/Bank0.asm
    5                     
    6           0001        .bank 1
    7           A000        .org $A000
    8                       
    9  01:A000  00 80       .word house
   10                       
   11           BFFA        .org $BFFA     ;first of the three vectors starts here
   12  01:BFFA  80 C8       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   13                                        ;processor will jump to the label NMI:
   14  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   15                                        ;to the label RESET:
   16  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  03 62 00    .db $03, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $04, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 04  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  0F 1B 18    .db $0F, $1B, $18, $10, $FF
       02:80A7  10 FF     
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                     
    9  03:A000  00 80       .word frog
   10                     
   11           BFFA        .org $BFFA     ;first of the three vectors starts here
   12  03:BFFA  80 C8       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   13                                        ;processor will jump to the label NMI:
   14  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   15                                        ;to the label RESET:
   16  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  03 7E 00    .db $03, $7E, $00, $0A
       04:8003  0A        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $04, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 04  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  0C 0A 1D    .db $0C, $0A, $1D, $FF
       04:80A5  FF        
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8  05:A000  00 80       .word cat
    9                     
   10           BFFA        .org $BFFA     ;first of the three vectors starts here
   11  05:BFFA  80 C8       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   12                                        ;processor will jump to the label NMI:
   13  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   14                                        ;to the label RESET:
   15  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 3D C7    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 41 C7    JSR SetMapperControls
   34                       
   35  06:C040  20 7E C7    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  20 CD C4    JSR ChangeGameMode
   38  06:C04D  20 14 C7    JSR InitPPUControl
   39                       
   40                     
   41                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   42                     ;;     Main Program         ;;
   43                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   44                     
   45  06:C050            Forever:
   46                     
   47  06:C050  EE 07 00    INC sleeping
   48                     
   49  06:C053            .loop
   50  06:C053  AD 07 00    LDA sleeping
   51  06:C056  D0 FB       BNE .loop
   52                       
   53  06:C058  20 61 C0    JSR GameLoop
   54  06:C05B  EE 06 00    INC time
   55                     
   56  06:C05E  4C 50 C0    JMP Forever     ;jump back to Forever, infinite loop
   57                       
   58                     ;; dynamic jump table
   59                     
   60  06:C061            GameLoop:
   61                     
   62                       MACROCallDynamicJump game_mode
                          
       06:C061  AD 08 00    LDA game_mode
       06:C064  20 7D C5    JSR Dynamic_Jump
                                  
   63                       ;; we'll pop the return address here as the table index, so 
   64                       ;; the routine we pick will return us to whatever called Game Loop
   65                       ;; when it returns
   66                     
   67  06:C067            GameLoopJumpTable:
   68                     
   69  06:C067  6D C0       .word UpdateTitle
   70  06:C069  42 C2       .word UpdateGame
   71  06:C06B  BD C4       .word UpdateGameOver
   72                       
   73                     
   74                       ;;RTS is called in the subroutine
   75                     
   76                       
#[2]   Routines/Game_States/UpdateTitle.asm
   77                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C06D            UpdateTitle:
    2                     
    3  06:C06D  AD 0A 00    LDA NMI_locks
    4  06:C070  F0 01       BEQ .unlocked
    5                       
    6  06:C072  60          RTS
    7                       
    8  06:C073            .unlocked:
    9                     
   10  06:C073  20 77 C0    JSR DoUpdateTitle  
   11  06:C076  60          RTS
   12                       
   13  06:C077            DoUpdateTitle:
   14                     
   15  06:C077  AD 09 00    LDA mode_state
   16  06:C07A  20 7D C5    JSR Dynamic_Jump
   17                         
   18  06:C07D            UpdateTitleJumpTable:
   19                     
   20  06:C07D  89 C0       .word UpdateTitleInit
   21  06:C07F  97 C0       .word UpdateBankSelection
   22  06:C081  B0 C0       .word UpdateScroll
   23  06:C083  D2 C0       .word UpdatePuzzleSelection
   24  06:C085  0A C1       .word UpdateScrollBack
   25  06:C087  27 C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2, BANK3
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C089            UpdateTitleInit:
   35                     
   36  06:C089  A9 00       LDA #$00
   37  06:C08B  8D 57 00    STA mouse_index
   38  06:C08E  A9 00       LDA #$00
   39  06:C090  8D 58 00    STA mouse_index+1
   40                     
   41  06:C093            .changeModeState:
   42                     
   43  06:C093  EE 09 00    INC mode_state
   44  06:C096            .leave:
   45  06:C096  60          RTS
   46                       
   47  06:C097            UpdateBankSelection:
   48                     
   49  06:C097  20 9B C1    JSR UpdateBankPointer
   50                       
   51  06:C09A  AD 14 00    LDA gamepadPressed
   52  06:C09D  29 01       AND #GAMEPAD_A
   53  06:C09F  F0 0E       BEQ .leave
   54                       
   55  06:C0A1            .changeModeState:
   56                     
   57  06:C0A1  AD 57 00    LDA mouse_index
   58  06:C0A4  8D 43 00    STA bank_index
   59  06:C0A7  A9 FF       LDA #$FF
   60  06:C0A9  20 83 C1    JSR SetPointerSprite
   61                       
   62  06:C0AC  EE 09 00    INC mode_state
   63  06:C0AF            .leave:
   64  06:C0AF  60          RTS
   65                       
   66  06:C0B0            UpdateScroll:
   67  06:C0B0  EE 17 00    INC PPU_ScrollX
   68  06:C0B3  EE 17 00    INC PPU_ScrollX
   69  06:C0B6  EE 17 00    INC PPU_ScrollX
   70  06:C0B9  EE 17 00    INC PPU_ScrollX
   71  06:C0BC  D0 13       BNE .leave
   72  06:C0BE  AD 19 00    LDA PPU_ScrollNT
   73  06:C0C1  49 01       EOR #%00000001
   74  06:C0C3  8D 19 00    STA PPU_ScrollNT
   75                       
   76  06:C0C6            .changeModeState:
   77  06:C0C6  A9 01       LDA #$01
   78  06:C0C8  20 83 C1    JSR SetPointerSprite
   79  06:C0CB  20 49 C1    JSR InitPuzzlePointer
   80  06:C0CE  EE 09 00    INC mode_state
   81  06:C0D1            .leave:
   82  06:C0D1  60          RTS
   83                       
   84  06:C0D2            UpdatePuzzleSelection:
   85                     
   86  06:C0D2  20 D7 C1    JSR UpdatePuzzlePointer
   87                       
   88  06:C0D5  AD 14 00    LDA gamepadPressed
   89  06:C0D8  29 02       AND #GAMEPAD_B
   90  06:C0DA  D0 15       BNE .changeToScrollBack
   91  06:C0DC  AD 14 00    LDA gamepadPressed
   92  06:C0DF  29 09       AND #GAMEPAD_CONFIRM
   93  06:C0E1  F0 26       BEQ .leave
   94                       
   95                       ;on start, get the 2D mouse index into a 1D index- then store in puzzle_index
   96                       ;for now, we only have one puzzle each, just store 0
   97  06:C0E3  A9 00       LDA #$00
   98  06:C0E5  8D 44 00    STA puzzle_index
   99  06:C0E8  EE 09 00    INC mode_state
  100  06:C0EB  EE 09 00    INC mode_state
  101  06:C0EE  4C 09 C1    JMP .leave
  102                       
  103  06:C0F1            .changeToScrollBack:
  104                      
  105  06:C0F1  A9 FF       LDA #$FF
  106  06:C0F3  20 83 C1    JSR SetPointerSprite
  107  06:C0F6  20 41 C1    JSR InitBankPointer
  108                       
  109  06:C0F9  A9 FC       LDA #$FC
  110  06:C0FB  8D 17 00    STA PPU_ScrollX
  111  06:C0FE  AD 19 00    LDA PPU_ScrollNT
  112  06:C101  29 FE       AND #$FE
  113  06:C103  8D 19 00    STA PPU_ScrollNT
  114                       
  115  06:C106  EE 09 00    INC mode_state
  116  06:C109            .leave:
  117  06:C109  60          RTS
  118                       
  119  06:C10A            UpdateScrollBack:
  120                     
  121  06:C10A  CE 17 00    DEC PPU_ScrollX
  122  06:C10D  CE 17 00    DEC PPU_ScrollX
  123  06:C110  CE 17 00    DEC PPU_ScrollX
  124  06:C113  CE 17 00    DEC PPU_ScrollX
  125  06:C116  D0 0E       BNE .leave
  126                       
  127  06:C118            .changeModeState:
  128                     
  129  06:C118  A9 01       LDA #$01
  130  06:C11A  20 83 C1    JSR SetPointerSprite
  131  06:C11D  CE 09 00    DEC mode_state
  132  06:C120  CE 09 00    DEC mode_state
  133  06:C123  CE 09 00    DEC mode_state
  134                       
  135  06:C126            .leave:
  136  06:C126  60          RTS
  137                       
  138  06:C127            UpdateTitleExit:
  139                     
  140                       ;;reset screen scroll
  141  06:C127  A9 00       LDA #$00
  142  06:C129  8D 17 00    STA PPU_ScrollX
  143  06:C12C  8D 19 00    STA PPU_ScrollNT
  144                       
  145                       ;;load bank
  146                     
  147  06:C12F  20 3D C7    JSR ResetMapper
  148  06:C132  AD 43 00    LDA bank_index
  149  06:C135  8D 41 00    STA currentPRGBank
  150  06:C138  20 4C C7    JSR LoadPRGBank
  151                       
  152  06:C13B  A9 01       LDA #GAME_IDX
  153  06:C13D  20 CD C4    JSR ChangeGameMode
  154                       
  155  06:C140            .leave
  156  06:C140  60          RTS
  157                       
  158  06:C141            InitBankPointer:
  159                     
  160  06:C141  A2 A0       LDX #$A0
  161  06:C143  A9 60       LDA #$60
  162  06:C145  20 5C C1    JSR InitPointer
  163                       
  164  06:C148  60          RTS  
  165                       
  166  06:C149            InitPuzzlePointer:
  167                       
  168  06:C149  A2 AE       LDX #$AE
  169  06:C14B  A9 10       LDA #$10
  170  06:C14D  20 5C C1    JSR InitPointer
  171                       
  172  06:C150  60          RTS
  173                     
  174  06:C151            ResetMouseIndex:
  175                     
  176  06:C151  A9 00       LDA #$00
  177  06:C153  8D 57 00    STA mouse_index
  178  06:C156  A9 00       LDA #$00
  179  06:C158  8D 58 00    STA mouse_index+1
  180  06:C15B  60          RTS
  181                     
  182  06:C15C            InitPointer:
  183                     
  184  06:C15C  20 63 C1    JSR SetPointerPosition
  185  06:C15F  20 51 C1    JSR ResetMouseIndex
  186  06:C162  60          RTS  
  187                       
  188  06:C163            SetPointerPosition:
  189                     
  190  06:C163  48          PHA
  191  06:C164  8A          TXA
  192  06:C165  20 6D C1    JSR SetPointerYPosition
  193  06:C168  68          PLA
  194  06:C169  20 78 C1    JSR SetPointerXPosition
  195                      
  196  06:C16C  60          RTS
  197                       
  198  06:C16D            SetPointerYPosition:
  199                       
  200  06:C16D  48          PHA
  201  06:C16E  A9 00       LDA #SPRITE_YPOS
  202  06:C170  20 8E C1    JSR GetPointerDataIndexInX
  203  06:C173  68          PLA
  204  06:C174  9D 00 02    STA SPRITE_DATA, x
  205  06:C177  60          RTS
  206                       
  207  06:C178            SetPointerXPosition:  
  208                       
  209  06:C178  48          PHA
  210  06:C179  A9 03       LDA #SPRITE_XPOS
  211  06:C17B  20 8E C1    JSR GetPointerDataIndexInX
  212  06:C17E  68          PLA
  213  06:C17F  9D 00 02    STA SPRITE_DATA, x 
  214  06:C182  60          RTS
  215                     
  216  06:C183            SetPointerSprite:
  217                     
  218                     ;; A has aprite we want
  219  06:C183  48          PHA
  220  06:C184  A9 01       LDA #SPRITE_ID
  221  06:C186  20 8E C1    JSR GetPointerDataIndexInX
  222  06:C189  68          PLA
  223  06:C18A  9D 00 02    STA SPRITE_DATA, x
  224  06:C18D  60          RTS
  225                       
  226  06:C18E            GetPointerDataIndexInX:
  227                     
  228  06:C18E  8D 02 00    STA temp3
  229  06:C191  A9 01       LDA #$01
  230  06:C193  0A          ASL A
  231  06:C194  0A          ASL A
  232  06:C195  18          CLC
  233  06:C196  6D 02 00    ADC temp3
  234  06:C199  AA          TAX
  235                       
  236  06:C19A  60          RTS
  237                       
  238                       
  239  06:C19B            UpdateBankPointer:
  240                      
  241                       ;;bank pointer is 1D, will loop between 0->3
  242  06:C19B  AD 14 00    LDA gamepadPressed
  243  06:C19E  F0 36       BEQ .leave 
  244                       
  245  06:C1A0  A9 00       LDA #$00
  246  06:C1A2  8D 00 00    STA temp1
  247                       
  248  06:C1A5            .parseInputs:
  249  06:C1A5  AD 14 00    LDA gamepadPressed
  250  06:C1A8  29 30       AND #GAMEPAD_VERT
  251  06:C1AA  F0 2A       BEQ .leave
  252  06:C1AC  0A          ASL A
  253  06:C1AD  0A          ASL A
  254  06:C1AE            .checkDown:
  255  06:C1AE  0A          ASL A
  256  06:C1AF  90 03       BCC .checkUp
  257  06:C1B1  EE 00 00    INC temp1
  258  06:C1B4            .checkUp:
  259  06:C1B4  0A          ASL A
  260  06:C1B5  90 03       BCC .move
  261  06:C1B7  CE 00 00    DEC temp1
  262  06:C1BA            .move:
  263                       
  264  06:C1BA  AD 57 00    LDA mouse_index
  265  06:C1BD  18          CLC
  266  06:C1BE  6D 00 00    ADC temp1
  267  06:C1C1  C9 02       CMP #$02
  268  06:C1C3  F0 04       BEQ .skipMod
  269  06:C1C5  90 02       BCC .skipMod
  270  06:C1C7  A9 00       LDA #$00
  271  06:C1C9            .skipMod:
  272  06:C1C9  8D 57 00    STA mouse_index
  273                       ;; mult mouse_index by 16
  274  06:C1CC  0A          ASL A
  275  06:C1CD  0A          ASL A
  276  06:C1CE  0A          ASL A
  277  06:C1CF  0A          ASL A
  278  06:C1D0  18          CLC
  279  06:C1D1  69 A0       ADC #$A0
  280  06:C1D3  20 6D C1    JSR SetPointerYPosition
  281                     
  282  06:C1D6            .leave:
  283                       
  284  06:C1D6  60          RTS
  285                       
  286  06:C1D7            UpdatePuzzlePointer:
  287                     
  288                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  289  06:C1D7  AD 14 00    LDA gamepadPressed
  290  06:C1DA  F0 65       BEQ .leave 
  291                       
  292  06:C1DC  A9 00       LDA #$00
  293  06:C1DE  8D 00 00    STA temp1
  294  06:C1E1  8D 01 00    STA temp2
  295                       
  296  06:C1E4            .parseInputs:
  297  06:C1E4  AD 14 00    LDA gamepadPressed
  298  06:C1E7  29 F0       AND #GAMEPAD_MOVE
  299  06:C1E9  F0 56       BEQ .leave
  300  06:C1EB  0A          ASL A
  301  06:C1EC  90 03       BCC .checkLeft
  302  06:C1EE  EE 00 00    INC temp1
  303  06:C1F1            .checkLeft:
  304  06:C1F1  0A          ASL A
  305  06:C1F2  90 03       BCC .checkDown
  306  06:C1F4  CE 00 00    DEC temp1
  307  06:C1F7            .checkDown:
  308  06:C1F7  0A          ASL A
  309  06:C1F8  90 03       BCC .checkUp
  310  06:C1FA  EE 01 00    INC temp2
  311  06:C1FD            .checkUp:
  312  06:C1FD  0A          ASL A
  313  06:C1FE  90 03       BCC .move
  314  06:C200  CE 01 00    DEC temp2
  315                       
  316  06:C203            .move:
  317                     
  318  06:C203  AD 57 00    LDA mouse_index
  319  06:C206  18          CLC
  320  06:C207  6D 01 00    ADC temp2
  321  06:C20A  C9 02       CMP #$02
  322  06:C20C  F0 04       BEQ .skipYMod
  323  06:C20E  90 02       BCC .skipYMod
  324  06:C210  A9 00       LDA #$00
  325  06:C212            .skipYMod:
  326  06:C212  8D 57 00    STA mouse_index
  327                       ;; mult mouse_index by 16
  328  06:C215  0A          ASL A
  329  06:C216  0A          ASL A
  330  06:C217  0A          ASL A
  331  06:C218  0A          ASL A
  332  06:C219  18          CLC
  333  06:C21A  69 AE       ADC #$AE
  334  06:C21C  20 6D C1    JSR SetPointerYPosition
  335                       
  336  06:C21F  AD 58 00    LDA mouse_index+1
  337  06:C222  18          CLC
  338  06:C223  6D 00 00    ADC temp1
  339  06:C226  C9 08       CMP #$08
  340  06:C228  F0 04       BEQ .skipXMod
  341  06:C22A  90 02       BCC .skipXMod
  342  06:C22C  A9 00       LDA #$00
  343  06:C22E            .skipXMod:
  344  06:C22E  8D 58 00    STA mouse_index+1
  345                       ;; we need to move 3 tiles each- so index * 3 * 8,
  346  06:C231  18          CLC
  347  06:C232  6D 58 00    ADC mouse_index+1
  348  06:C235  6D 58 00    ADC mouse_index+1
  349  06:C238  0A          ASL A
  350  06:C239  0A          ASL A
  351  06:C23A  0A          ASL A
  352  06:C23B  18          CLC
  353  06:C23C  69 10       ADC #$10
  354  06:C23E  20 78 C1    JSR SetPointerXPosition
  355                       
  356  06:C241            .leave:
  357                       
  358  06:C241  60          RTS
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   78                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6                     
    7                     ;;this will change with puzzle sizes
    8           005A      VERT_MIN = $5A ;12 - 1
    9           00DA      VERT_MAX = $DA
   10           006A      HORI_MIN = $6A ;14 - 1
   11           00EA      HORI_MAX = $EA
   12                     
   13           618E      MOUSE_START = $618E
   14                     
   15  06:C242            UpdateGame:
   16                     
   17  06:C242  AD 0A 00    LDA NMI_locks
   18  06:C245  F0 01       BEQ .unlocked
   19                       
   20  06:C247  60          RTS
   21                       
   22  06:C248            .unlocked:
   23                     
   24  06:C248  20 4C C2    JSR DoUpdateGame
   25  06:C24B  60          RTS
   26                       
   27  06:C24C            DoUpdateGame:
   28                     
   29  06:C24C  AD 09 00    LDA mode_state
   30  06:C24F  20 7D C5    JSR Dynamic_Jump
   31                       
   32  06:C252            UpdateGameJumpTable:
   33                     
   34  06:C252  5C C2       .word UpdateGameInit
   35  06:C254  B7 C2       .word UpdateDrawVertClues
   36  06:C256  DF C2       .word UpdateDrawHoriClues
   37  06:C258  E8 C2       .word UpdateGamePlay
   38  06:C25A  22 C4       .word UpdateGameExit
   39                     
   40  06:C25C            UpdateGameInit:
   41                     
   42                       ;; get the puzzle table in the puzzle address
   43                       MACROGetLabelPointer $A000, table_address
                          
       06:C25C  A9 A0             LDA #HIGH($A000)
       06:C25E  A2 00             LDX #LOW($A000)
                                  
       06:C260  8E 0E 00          STX table_address
       06:C263  8D 0F 00          STA table_address+1
                                  
   44                       MACROGetDoubleIndex #$00
                          
       06:C266  A9 00             LDA #$00
       06:C268  0A                ASL A
       06:C269  A8                TAY
                                  
   45  06:C26A  20 A3 C5    JSR GetTableAtIndex
   46                       MACROGetPointer table_address, puzzle_address
                          
       06:C26D  AD 0E 00          LDA table_address
       06:C270  8D 45 00          STA puzzle_address
       06:C273  AD 0F 00          LDA table_address+1
       06:C276  8D 46 00          STA puzzle_address+1
                          
   47                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C279  A9 61             LDA #HIGH(MOUSE_START)
       06:C27B  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C27D  8E 55 00          STX mouse_location
       06:C280  8D 56 00          STA mouse_location+1
                                  
   48                       
   49                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   50  06:C283  AD 45 00    LDA puzzle_address
   51  06:C286  18          CLC
   52  06:C287  69 22       ADC #34
   53  06:C289  8D 47 00    STA clues_address
   54  06:C28C  A9 00       LDA #$00
   55  06:C28E  6D 46 00    ADC puzzle_address+1
   56  06:C291  8D 48 00    STA clues_address+1
   57                     
   58  06:C294  A9 00       LDA #$00
   59  06:C296  8D 4D 00    STA clueTableIndex
   60  06:C299  8D 4E 00    STA clueLineIndex
   61  06:C29C  8D 54 00    STA clueParity
   62  06:C29F  8D 4F 00    STA clueOffsetShift
   63                       
   64  06:C2A2  A9 20       LDA #$20
   65  06:C2A4  8D 52 00    STA clueDrawAdd
   66                        
   67                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C2A7  A9 21             LDA #HIGH(VERT_CLUES)
       06:C2A9  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C2AB  8E 49 00          STX clue_start_address
       06:C2AE  8D 4A 00          STA clue_start_address+1
                                  
   68  06:C2B1  20 0C C8    JSR ResetClueDrawAddress
   69                         
   70  06:C2B4  EE 09 00    INC mode_state
   71                     
   72  06:C2B7            UpdateDrawVertClues:
   73                       
   74  06:C2B7  20 94 C7    JSR PopulateClues
   75  06:C2BA  90 22       BCC .leave
   76                       
   77  06:C2BC            .changeModeState:
   78                     
   79  06:C2BC  A9 00       LDA #$00
   80  06:C2BE  8D 4E 00    STA clueLineIndex
   81  06:C2C1  8D 54 00    STA clueParity
   82                       
   83  06:C2C4  A9 05       LDA #$05
   84  06:C2C6  8D 4F 00    STA clueOffsetShift
   85                       
   86  06:C2C9  A9 01       LDA #$01
   87  06:C2CB  8D 52 00    STA clueDrawAdd
   88                        
   89                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C2CE  A9 21             LDA #HIGH(HORI_CLUES)
       06:C2D0  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C2D2  8E 49 00          STX clue_start_address
       06:C2D5  8D 4A 00          STA clue_start_address+1
                                  
   90  06:C2D8  20 0C C8    JSR ResetClueDrawAddress
   91                     
   92  06:C2DB  EE 09 00    INC mode_state
   93  06:C2DE            .leave:
   94  06:C2DE  60          RTS
   95                       
   96  06:C2DF            UpdateDrawHoriClues:
   97                     
   98  06:C2DF  20 94 C7    JSR PopulateClues
   99  06:C2E2  90 03       BCC .leave
  100                     
  101  06:C2E4            .changeModeState:
  102                     
  103  06:C2E4  EE 09 00    INC mode_state
  104  06:C2E7            .leave:
  105  06:C2E7  60          RTS
  106                       
  107  06:C2E8            UpdateGamePlay:
  108                         
  109  06:C2E8  A9 00       LDA #$00
  110  06:C2EA  8D 00 00    STA temp1
  111  06:C2ED  8D 01 00    STA temp2
  112  06:C2F0  8D 02 00    STA temp3
  113                     
  114                       
  115  06:C2F3  AD 14 00    LDA gamepadPressed
  116  06:C2F6  F0 6A       BEQ .updatePaint  
  117                       
  118  06:C2F8            .parseInputs:
  119                     
  120  06:C2F8  29 F0       AND #GAMEPAD_MOVE
  121  06:C2FA  F0 1E       BEQ .checkPaintPress
  122  06:C2FC  0A          ASL A
  123  06:C2FD  90 03       BCC .checkLeft
  124  06:C2FF  EE 00 00    INC temp1
  125  06:C302            .checkLeft:
  126  06:C302  0A          ASL A
  127  06:C303  90 03       BCC .checkDown
  128  06:C305  CE 00 00    DEC temp1
  129  06:C308            .checkDown:
  130  06:C308  0A          ASL A
  131  06:C309  90 03       BCC .checkUp
  132  06:C30B  EE 01 00    INC temp2
  133  06:C30E            .checkUp:
  134  06:C30E  0A          ASL A
  135  06:C30F  90 03       BCC .move
  136  06:C311  CE 01 00    DEC temp2
  137                       
  138  06:C314            .move:
  139                      
  140  06:C314  20 28 C4    JSR MoveMouse
  141  06:C317  20 69 C4    JSR UpdateMouseScreenPos
  142                       
  143  06:C31A            .checkPaintPress:
  144                     
  145  06:C31A  AD 14 00    LDA gamepadPressed
  146  06:C31D  29 03       AND #GAMEPAD_AB
  147  06:C31F  F0 41       BEQ .updatePaint
  148                       ;;A or B pressed, get current tile
  149                       
  150  06:C321  8D 00 00    STA temp1
  151                       
  152  06:C324  A0 00       LDY #$00
  153  06:C326  B1 55       LDA [mouse_location], y
  154  06:C328  8D 01 00    STA temp2
  155                       
  156                         ;;A treats X and Clear as clear
  157                             ;;B treats mark and clear as clear
  158                             ;;clear->mark->x
  159                             
  160                     
  161  06:C32B  C9 7C       CMP #$7C      ;check if this is a marked tile
  162  06:C32D  B0 0F       BCS .getClearTile
  163                       ;;cleared tile- store off marked tile to paint with instead
  164                       ;;not a clear tile- a mark or an x - check A or B  
  165  06:C32F  4E 00 00    LSR temp1
  166  06:C332  B0 05       BCS .getMarkTile
  167                       
  168  06:C334            .getXTile:
  169  06:C334  A9 80       LDA #$80
  170  06:C336  4C 5C C3    JMP .finishGetTile
  171                       
  172  06:C339            .getMarkTile:
  173  06:C339  A9 70       LDA #$70
  174  06:C33B  4C 5C C3    JMP .finishGetTile
  175                     
  176  06:C33E            .getClearTile:
  177                       
  178  06:C33E  4E 00 00    LSR temp1
  179  06:C341  90 0A       BCC .checkB
  180  06:C343  AD 01 00    LDA temp2
  181  06:C346  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  182  06:C348  90 0D       BCC .clearTile
  183  06:C34A  4C 39 C3    JMP .getMarkTile
  184                       
  185  06:C34D            .checkB:
  186                       
  187  06:C34D  AD 01 00   LDA temp2
  188  06:C350  C9 8C      CMP #$8C
  189  06:C352  B0 03      BCS .clearTile
  190  06:C354  4C 34 C3   JMP .getXTile
  191                       
  192  06:C357            .clearTile:
  193  06:C357  A9 60       LDA #$60
  194  06:C359  4C 5C C3    JMP .finishGetTile
  195                       
  196  06:C35C            .finishGetTile:
  197  06:C35C  8D 59 00    STA currentPaintTile
  198  06:C35F  4C 6A C3    JMP .setTile
  199                     
  200                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  201                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  202                     ;;we can load the nametable into memory as we draw it
  203                     
  204  06:C362            .updatePaint:
  205                     
  206  06:C362  AD 12 00    LDA gamepad
  207  06:C365  29 03       AND #GAMEPAD_AB
  208  06:C367  D0 01       BNE .setTile
  209  06:C369  60          RTS  
  210                       
  211  06:C36A            .setTile:
  212                     
  213                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  214  06:C36A  AD 58 00    LDA mouse_index+1
  215  06:C36D  0A          ASL A
  216  06:C36E  18          CLC
  217  06:C36F  69 04       ADC #$04 ;; add to get past header
  218  06:C371  8D 00 00    STA temp1
  219                       
  220                       ;;div X position by 8 to get the byte index
  221  06:C374  AD 57 00    LDA mouse_index
  222  06:C377  4A          LSR A
  223  06:C378  4A          LSR A
  224  06:C379  4A          LSR A
  225  06:C37A  F0 03       BEQ .getMask
  226                       
  227  06:C37C  EE 00 00    INC temp1
  228                       
  229  06:C37F            .getMask:
  230                       
  231  06:C37F  AD 57 00    LDA mouse_index
  232  06:C382  29 07       AND #$07
  233  06:C384  AA          TAX
  234  06:C385  A9 80       LDA #$80
  235  06:C387  E0 00       CPX #$00
  236  06:C389  F0 04       BEQ .storeMask
  237                     
  238  06:C38B            .maskLoop:
  239  06:C38B  4A          LSR A
  240  06:C38C  CA          DEX
  241  06:C38D  D0 FC       BNE .maskLoop
  242  06:C38F            .storeMask:
  243  06:C38F  8D 01 00    STA temp2
  244                     
  245  06:C392  AC 00 00    LDY temp1
  246  06:C395  B1 45       LDA [puzzle_address], y
  247  06:C397  2D 01 00    AND temp2
  248  06:C39A  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  249                     
  250  06:C39D  A0 00       LDY #$00
  251  06:C39F  B1 55       LDA [mouse_location], y
  252  06:C3A1  8D 02 00    STA temp3
  253  06:C3A4  29 F0       AND #$F0
  254  06:C3A6  CD 59 00    CMP currentPaintTile
  255  06:C3A9  F0 76       BEQ .leave
  256                       
  257                       ;;tiles are different- check if the current tile is marked as a solution tile
  258  06:C3AB  C9 70       CMP #$70
  259  06:C3AD  D0 0B       BNE .checkNewMark
  260                       ;;if erasing a mark, check if the tile was part of the solution
  261  06:C3AF  AD 00 00    LDA temp1
  262  06:C3B2  D0 18       BNE .antiMark
  263  06:C3B4  CE 5B 00    DEC nonSolutionCount
  264  06:C3B7  4C D5 C3    JMP .checkSolution
  265                       
  266  06:C3BA            .checkNewMark:
  267                     
  268  06:C3BA  AD 59 00    LDA currentPaintTile
  269  06:C3BD  C9 70       CMP #$70
  270  06:C3BF  D0 22       BNE .overwriteTile
  271                       
  272  06:C3C1  AD 00 00    LDA temp1
  273  06:C3C4  D0 0C       BNE .proMark
  274  06:C3C6  EE 5B 00    INC nonSolutionCount 
  275  06:C3C9  4C D5 C3    JMP .checkSolution  
  276                       
  277  06:C3CC            .antiMark:
  278  06:C3CC  CE 5A 00    DEC solutionCount
  279  06:C3CF  4C E3 C3    JMP .overwriteTile
  280  06:C3D2            .proMark:   
  281                       
  282  06:C3D2  EE 5A 00    INC solutionCount
  283                     
  284  06:C3D5            .checkSolution: 
  285                     
  286  06:C3D5  A0 01       LDY #$01
  287  06:C3D7  B1 45       LDA [puzzle_address], y
  288  06:C3D9  CD 5A 00    CMP solutionCount
  289  06:C3DC  D0 05       BNE .overwriteTile
  290  06:C3DE  AD 5B 00    LDA nonSolutionCount
  291  06:C3E1  F0 3B       BEQ .changeModeState
  292                       
  293  06:C3E3            .overwriteTile:
  294                       ;;overwrite tile
  295  06:C3E3  AD 02 00    LDA temp3
  296  06:C3E6  29 0F       AND #$0F
  297  06:C3E8  0D 59 00    ORA currentPaintTile
  298  06:C3EB  A0 00       LDY #$00
  299  06:C3ED  91 55       STA [mouse_location], y
  300  06:C3EF  8D 00 00    STA temp1
  301                       
  302  06:C3F2  AD 56 00    LDA mouse_location+1
  303  06:C3F5  29 3F       AND #$3F
  304  06:C3F7  8D 01 00    STA temp2
  305                         
  306                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C3FA  A9 01       LDA #$01
       06:C3FC  8D 1B 00    STA PPU_PendingWrite
       06:C3FF  AD 01 00    LDA temp2
       06:C402  20 AE C6    JSR WriteToPPUString
       06:C405  AD 55 00    LDA mouse_location
       06:C408  20 AE C6    JSR WriteToPPUString
       06:C40B  A9 00       LDA #DRAW_HORIZONTAL
       06:C40D  20 AE C6    JSR WriteToPPUString
       06:C410  A9 01       LDA #$01
       06:C412  20 AE C6    JSR WriteToPPUString
                            
  307  06:C415  AD 00 00    LDA temp1
  308  06:C418  20 AE C6    JSR WriteToPPUString
  309  06:C41B  4C 21 C4    JMP .leave
  310                       
  311                       ;;update the painting
  312  06:C41E            .changeModeState:
  313                     
  314  06:C41E  EE 09 00    INC mode_state
  315                     
  316  06:C421            .leave:
  317                      
  318  06:C421  60          RTS
  319                       
  320  06:C422            UpdateGameExit:
  321                     
  322  06:C422  A9 02       LDA #GAMEOVER_IDX
  323  06:C424  20 CD C4    JSR ChangeGameMode
  324  06:C427  60          RTS
  325                       
  326  06:C428            MoveMouse:
  327                     
  328  06:C428  AD 00 00    LDA temp1
  329  06:C42B  0E 00 00    ASL temp1
  330  06:C42E  0E 00 00    ASL temp1
  331  06:C431  0E 00 00    ASL temp1
  332                       
  333  06:C434  AD 01 00    LDA temp2
  334  06:C437  0E 01 00    ASL temp2 
  335  06:C43A  0E 01 00    ASL temp2
  336  06:C43D  0E 01 00    ASL temp2
  337                       
  338  06:C440  A2 03       LDX #SPRITE_XPOS
  339  06:C442  BD 00 02    LDA SPRITE_DATA, x
  340  06:C445  18          CLC
  341  06:C446  6D 00 00    ADC temp1
  342                       ;;check against borders
  343  06:C449  C9 6A       CMP #HORI_MIN
  344  06:C44B  F0 07       BEQ .moveVert
  345  06:C44D  C9 EA       CMP #HORI_MAX
  346  06:C44F  F0 03       BEQ .moveVert
  347  06:C451  9D 00 02    STA SPRITE_DATA, x
  348                     
  349  06:C454            .moveVert:
  350                     
  351  06:C454  A2 00       LDX #SPRITE_YPOS
  352  06:C456  BD 00 02    LDA SPRITE_DATA, x
  353  06:C459  18          CLC
  354  06:C45A  6D 01 00    ADC temp2
  355                       ;;check against borders
  356  06:C45D  C9 5A       CMP #VERT_MIN
  357  06:C45F  F0 07       BEQ .leave
  358  06:C461  C9 DA       CMP #VERT_MAX
  359  06:C463  F0 03       BEQ .leave
  360  06:C465  9D 00 02    STA SPRITE_DATA, x
  361                     
  362  06:C468            .leave:
  363  06:C468  60          RTS
  364                             
  365  06:C469            UpdateMouseScreenPos:
  366                     
  367  06:C469  A2 00       LDX #$00
  368  06:C46B  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  369  06:C46E  4A          LSR A                                         ;0yyy yy..
  370  06:C46F  4A          LSR A                                         ;00yy yyy.
  371  06:C470  4A          LSR A                                         ;000y yyyy
  372  06:C471  8D 00 00    STA temp1
  373  06:C474  8D 58 00    STA mouse_index+1
  374  06:C477  E8          INX
  375  06:C478  E8          INX
  376  06:C479  E8          INX   
  377  06:C47A  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  378  06:C47D  29 F8       AND #$F8                       ;              ;  xxxx x000
  379  06:C47F  8D 01 00    STA temp2                      ;      ;  
  380  06:C482  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  381  06:C485  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  382  06:C488  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  383  06:C48B  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  384  06:C48E  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  385  06:C491  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  386  06:C494  AD 01 00    LDA temp2
  387  06:C497  29 1F       AND #$1F
  388  06:C499  8D 57 00    STA mouse_index
  389                       
  390  06:C49C  AD 57 00    LDA mouse_index
  391  06:C49F  38          SEC 
  392  06:C4A0  E9 0E       SBC #$0E
  393  06:C4A2  8D 57 00    STA mouse_index
  394                       
  395  06:C4A5  AD 58 00    LDA mouse_index+1
  396  06:C4A8  38          SEC 
  397  06:C4A9  E9 0C       SBC #$0C
  398  06:C4AB  8D 58 00    STA mouse_index+1
  399                       
  400                       ;subtract starting offsets for mouse index
  401                       
  402  06:C4AE  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  403  06:C4B1  09 60       ORA #$60                       ;              ;  0110 00yy
  404                       
  405  06:C4B3  8D 56 00    STA mouse_location+1
  406  06:C4B6  AD 01 00    LDA temp2
  407  06:C4B9  8D 55 00    STA mouse_location
  408                       
  409  06:C4BC            .leave:
  410  06:C4BC  60          RTS
  411                     
  412                     ;;using the line index and a given count based on the direction, 
  413                       
  414                     ;;      JSR ResetMapper
  415                     ;;      INC currentCHRBank
  416                     ;;      LDA currentCHRBank
  417                     ;;      CMP #$03
  418                     ;;      BNE .dontModCHR
  419                             
  420                     ;;      LDA #$00
  421                     
  422                     ;;.dontModCHR:
  423                     ;;      STA currentCHRBank 
  424                     ;;      ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
  425                     ;;      ASL A
  426                     ;;      CLC 
  427                     ;;      ADC #$01
  428                     ;;      JSR LoadCHRBankB
  429                     ;;      
  430                     ;;      JSR ResetMapper
  431                     ;;      INC currentPRGBank
  432                     ;;      LDA currentPRGBank
  433                     ;;      CMP #$03
  434                     ;;      BNE .dontModPRG
  435                             
  436                     ;;      LDA #$00
  437                             
  438                     ;;.dontModPRG:
  439                     ;;       STA currentPRGBank
  440                     ;;       JSR LoadPRGBank
  441                      
  442                     ;;       JSR TestBankA
  443                     ;;       LDA mapperDebugVar
  444                     ;;       STA $6000
  445                     ;;       JMP .noInputDetected
  446                     
  447                     
  448                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   79                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C4BD            UpdateGameOver:
    2                     
    3  06:C4BD  AD 0A 00    LDA NMI_locks
    4  06:C4C0  D0 0A       BNE .noInputDetected
    5                     
    6  06:C4C2  AD 14 00    LDA gamepadPressed
    7  06:C4C5  F0 05       BEQ .noInputDetected
    8                       
    9  06:C4C7  A9 00         LDA #TITLE_IDX
   10  06:C4C9  20 CD C4          JSR ChangeGameMode
   11                      
   12  06:C4CC            .noInputDetected:
   13                      
   14  06:C4CC  60          RTS
#[1]   Picross.asm
   80                       
   81                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   82                     ;;     Routines             ;;
   83                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   84                     
   85                     
#[2]   Routines/Common/GameModeRoutines.asm
   86                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C4CD            ChangeGameMode:
    2  06:C4CD  8D 08 00    STA game_mode
    3  06:C4D0  A9 00       LDA #$00
    4  06:C4D2  8D 09 00    STA mode_state
    5  06:C4D5  20 BC C6    JSR ClearPPUString
    6  06:C4D8  20 DC C4    JSR LoadGameModeScreen
    7  06:C4DB  60          RTS
    8                       
    9  06:C4DC            LoadGameModeScreen:
   10                     
   11                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C4DC  AD 0A 00    LDA NMI_locks
       06:C4DF  09 01       ORA #BGLOAD_NMI_LOCK
       06:C4E1  8D 0A 00    STA NMI_locks
                                  
   12                       
   13  06:C4E4  A9 00       LDA #$00
   14  06:C4E6  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   15                     
   16  06:C4E9  20 17 C5    JSR LoadGameModeBackground
   17  06:C4EC  20 5A C5    JSR LoadGameModeSprites
   18                     
   19                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C4EF  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C4F1  49 FF       EOR #$FF
       06:C4F3  2D 0A 00    AND NMI_locks  
       06:C4F6  8D 0A 00    STA NMI_locks
                          
   20                     
   21                       
   22                       ;; load the CHR bank for this mode
   23  06:C4F9  20 3D C7    JSR ResetMapper
   24                       ;;remember, we're loading the SECOND set in each chr bank
   25                       ;;so we'll take the index from the game mode chr table and add one mult 2
   26  06:C4FC  AE 08 00    LDX game_mode
   27  06:C4FF  BD 77 C5    LDA gameModeInitCHRROMB, x
   28  06:C502  0A          ASL A
   29  06:C503  18          CLC 
   30  06:C504  69 01       ADC #$01
   31  06:C506  20 62 C7    JSR LoadCHRBankB
   32                       
   33  06:C509  20 3D C7    JSR ResetMapper
   34  06:C50C  AE 08 00    LDX game_mode
   35  06:C50F  BD 7A C5    LDA gameModeInitCHRROMA, x
   36  06:C512  0A          ASL A
   37  06:C513  20 57 C7    JSR LoadCHRBankA
   38                       
   39                       
   40                       
   41  06:C516  60          RTS
   42                       
   43  06:C517            LoadGameModeBackground:
   44                             
   45                       MACROGetDoubleIndex game_mode
                          
       06:C517  AD 08 00          LDA game_mode
       06:C51A  0A                ASL A
       06:C51B  A8                TAY
                                  
   46  06:C51C  8C 00 00    STY temp1
   47                             
   48                       MACROGetLabelPointer Palettes, table_address
                          
       06:C51F  A9 E0             LDA #HIGH(Palettes)
       06:C521  A2 00             LDX #LOW(Palettes)
                                  
       06:C523  8E 0E 00          STX table_address
       06:C526  8D 0F 00          STA table_address+1
                                  
   49  06:C529  20 A3 C5    JSR GetTableAtIndex
   50                     
   51  06:C52C  20 B0 C5    JSR LoadFullPaletteFromTable
   52                             
   53  06:C52F  AC 00 00    LDY temp1
   54                       MACROGetLabelPointer NameTables, table_address
                          
       06:C532  A9 E0             LDA #HIGH(NameTables)
       06:C534  A2 06             LDX #LOW(NameTables)
                                  
       06:C536  8E 0E 00          STX table_address
       06:C539  8D 0F 00          STA table_address+1
                                  
   55  06:C53C  20 A3 C5    JSR GetTableAtIndex
   56                             
   57  06:C53F  A9 00       LDA #$00
   58  06:C541  20 D0 C5    JSR LoadFullBackgroundFromTable
   59                       
   60  06:C544  AC 00 00    LDY temp1
   61                       MACROGetLabelPointer NameTables2, table_address
                          
       06:C547  A9 E0             LDA #HIGH(NameTables2)
       06:C549  A2 0C             LDX #LOW(NameTables2)
                                  
       06:C54B  8E 0E 00          STX table_address
       06:C54E  8D 0F 00          STA table_address+1
                                  
   62  06:C551  20 A3 C5    JSR GetTableAtIndex
   63                       
   64  06:C554  A9 01       LDA #$01
   65  06:C556  20 D0 C5    JSR LoadFullBackgroundFromTable
   66                       
   67  06:C559  60          RTS
   68                       
   69  06:C55A            LoadGameModeSprites:
   70                     
   71                       MACROGetDoubleIndex game_mode  
                          
       06:C55A  AD 08 00          LDA game_mode
       06:C55D  0A                ASL A
       06:C55E  A8                TAY
                                  
   72                       MACROGetLabelPointer Sprites, table_address
                          
       06:C55F  A9 F4             LDA #HIGH(Sprites)
       06:C561  A2 72             LDX #LOW(Sprites)
                                  
       06:C563  8E 0E 00          STX table_address
       06:C566  8D 0F 00          STA table_address+1
                                  
   73  06:C569  20 A3 C5    JSR GetTableAtIndex
   74  06:C56C  A0 00       LDY #$00
   75  06:C56E  B1 0E       LDA [table_address],y
   76  06:C570  EE 0E 00    INC table_address
   77  06:C573  20 97 C6    JSR LoadSprites_impl
   78                       
   79  06:C576  60          RTS
   80                       
   81  06:C577            gameModeInitCHRROMB:
   82  06:C577  00 02 02          .db $00, $02, $02
   83  06:C57A            gameModeInitCHRROMA:
   84  06:C57A  00 02 02          .db $00, $02, $02
   85                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   87                       .include "Routines/Utils/PointerUtils.asm"
    1  06:C57D            Dynamic_Jump:
    2                     
    3  06:C57D  0A          ASL A                                 ;; double the index passed into A
    4  06:C57E  8E 04 00    STX tempx
    5  06:C581  8C 05 00    STY tempy
    6  06:C584  A8          TAY
    7  06:C585  C8          INY  
    8  06:C586  68          PLA
    9  06:C587  8D 10 00    STA jump_address
   10  06:C58A  68          PLA 
   11  06:C58B  8D 11 00    STA jump_address+1            
   12  06:C58E  B1 10       LDA [jump_address], y
   13  06:C590  AA          TAX
   14  06:C591  C8          INY
   15  06:C592  B1 10       LDA [jump_address], y
   16  06:C594  8E 10 00    STX jump_address
   17  06:C597  8D 11 00    STA jump_address+1
   18  06:C59A  AE 04 00    LDX tempx
   19  06:C59D  AC 05 00    LDY tempy
   20  06:C5A0  6C 10 00    JMP [jump_address]
   21                       
   22  06:C5A3            GetTableAtIndex:
   23                     
   24  06:C5A3  B1 0E             LDA [table_address], y
   25  06:C5A5  AA                TAX
   26  06:C5A6  C8                INY
   27  06:C5A7  B1 0E             LDA [table_address], y
   28                             
   29  06:C5A9            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:C5A9  8E 0E 00          STX table_address
   33  06:C5AC  8D 0F 00          STA table_address+1
   34  06:C5AF  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   88                       .include "Routines/Utils/PPUUtils.asm"
    1  06:C5B0            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:C5B0  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C5B3  A9 3F       LDA #HIGH($3F00)
       06:C5B5  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C5B8  A9 00       LDA #LOW($3F00)
       06:C5BA  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:C5BD  A0 00       LDY #$00              ; start out at 0
    5  06:C5BF  A2 00       LDX #$00
    6  06:C5C1            .loop:
    7  06:C5C1  B1 0E       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:C5C3  8D 07 20    STA PPU_DATA            ; write to PPU
    9  06:C5C6  9D 00 68    STA Palette_Copy, x
   10  06:C5C9  C8          INY                   ; X = X + 1
   11  06:C5CA  E8          INX
   12  06:C5CB  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   13  06:C5CD  D0 F2       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   14  06:C5CF  60          RTS
   15                     
   16  06:C5D0            LoadFullBackgroundFromTable:
   17                     
   18                         ;;use A as an index for which nametable to write to
   19  06:C5D0  20 DC C6          JSR SetNametableFromIndex
   20  06:C5D3  8A                TXA
   21  06:C5D4  4A                LSR A
   22  06:C5D5  29 01             AND #$01
   23  06:C5D7  D0 0D             BNE .copyScreenB
   24                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:C5D9  A9 60             LDA #HIGH(Screen_Copy)
       06:C5DB  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:C5DD  8E 0C 00          STX pointer_address
       06:C5E0  8D 0D 00          STA pointer_address+1
                                  
   25  06:C5E3  4C F0 C5          JMP .setCounters
   26                             
   27  06:C5E6            .copyScreenB:
   28                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:C5E6  A9 64             LDA #HIGH(ScreenB_Copy)
       06:C5E8  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:C5EA  8E 0C 00          STX pointer_address
       06:C5ED  8D 0D 00          STA pointer_address+1
                                  
   29                             
   30                             ;;set pointer
   31                             ;; set counters
   32  06:C5F0            .setCounters:
   33  06:C5F0  A0 00             LDY #$00
   34  06:C5F2  A2 00             LDX #$00
   35                             
   36                             ;;start loop
   37                     
   38  06:C5F4            .outerloop:
   39                     
   40  06:C5F4            .innerloop:
   41                     
   42  06:C5F4  B1 0E             LDA [table_address], y
   43  06:C5F6  8D 07 20          STA PPU_DATA
   44  06:C5F9  91 0C             STA [pointer_address],y
   45  06:C5FB  C8                INY
   46  06:C5FC  C0 00             CPY #$00
   47  06:C5FE  D0 F4             BNE .innerloop
   48                     
   49  06:C600  EE 0D 00          INC pointer_address+1
   50  06:C603  EE 0F 00          INC table_address+1
   51                             
   52  06:C606  E8                INX
   53  06:C607  E0 04             CPX #$04
   54  06:C609  D0 E9             BNE .outerloop
   55  06:C60B  60                RTS
   56                             
   57                     
   58           0000      DATA_LEN = temp1
   59           0001      WRITE_SETTINGS = temp2
   60                             
   61  06:C60C            ProcessPPUString:
   62                     
   63  06:C60C  AD 1B 00          LDA PPU_PendingWrite
   64  06:C60F  F0 6F             BEQ .leave
   65  06:C611  A0 00             LDY #$00
   66                             
   67  06:C613  A9 1D             LDA #LOW(PPU_String)
   68  06:C615  8D 0C 00          STA pointer_address
   69  06:C618  A9 00             LDA #HIGH(PPU_String)
   70  06:C61A  8D 0D 00          STA pointer_address + 1
   71                     
   72  06:C61D            .outerloop:
   73  06:C61D  AD 02 20          LDA PPU_STATUS
   74  06:C620  B1 0C             LDA [pointer_address], y
   75  06:C622  F0 59             BEQ .finish
   76  06:C624  8D 06 20          STA PPU_ADDR
   77  06:C627  C8                INY
   78  06:C628  B1 0C             LDA [pointer_address], y
   79  06:C62A  8D 06 20          STA PPU_ADDR
   80  06:C62D  C8            INY 
   81  06:C62E  B1 0C             LDA [pointer_address], y
   82  06:C630  8D 01 00          STA WRITE_SETTINGS
   83  06:C633  C8                INY
   84                             
   85  06:C634  AD 00 20          LDA PPU_CTRL
   86  06:C637  29 FB             AND #$FB
   87  06:C639  8D 00 20          STA PPU_CTRL
   88                             
   89  06:C63C  AD 01 00          LDA WRITE_SETTINGS
   90  06:C63F  29 80             AND #%10000000
   91  06:C641  F0 06             BEQ .checkTable
   92  06:C643  0D 00 20          ORA PPU_CTRL 
   93  06:C646  8D 00 20          STA PPU_CTRL 
   94                             
   95  06:C649            .checkTable:
   96  06:C649  AD 01 00          LDA WRITE_SETTINGS
   97  06:C64C  29 40             AND #%01000000
   98  06:C64E  F0 16             BEQ .rawData
   99                             
  100  06:C650  B1 0C             LDA [pointer_address], y
  101  06:C652  8D 0E 00          STA table_address
  102  06:C655  C8                INY 
  103  06:C656  B1 0C             LDA [pointer_address], y
  104  06:C658  8D 0F 00          STA table_address + 1
  105  06:C65B  C8                INY
  106  06:C65C  98                TYA 
  107  06:C65D  48                PHA
  108  06:C65E  20 81 C6          JSR WriteToPPUFromTable
  109  06:C661  68                PLA
  110  06:C662  A8                TAY
  111  06:C663  4C 1D C6          JMP .outerloop
  112                     
  113  06:C666            .rawData:
  114                     
  115  06:C666  B1 0C             LDA [pointer_address], y
  116  06:C668  C8                INY
  117  06:C669  8D 00 00          STA DATA_LEN
  118                     
  119  06:C66C  A2 00             LDX #$00
  120                     
  121  06:C66E            .innerloop:
  122                             
  123  06:C66E  B1 0C             LDA [pointer_address], y
  124  06:C670  8D 07 20          STA PPU_DATA
  125  06:C673  C8                INY
  126  06:C674  E8                INX
  127  06:C675  EC 00 00          CPX DATA_LEN
  128  06:C678  D0 F4             BNE .innerloop
  129  06:C67A  4C 1D C6          JMP .outerloop
  130                             
  131  06:C67D            .finish:
  132  06:C67D  20 BC C6          JSR ClearPPUString
  133  06:C680            .leave:
  134  06:C680  60                RTS
  135                             
  136  06:C681            WriteToPPUFromTable:
  137  06:C681  A0 00             LDY #$00
  138  06:C683  B1 0E             LDA [table_address], y
  139  06:C685  C8                INY
  140  06:C686  8D 00 00          STA DATA_LEN
  141  06:C689            .innerloop:
  142  06:C689  B1 0E             LDA [table_address], y
  143  06:C68B  8D 07 20          STA PPU_DATA
  144  06:C68E  C8                INY
  145  06:C68F  CC 00 00          CPY DATA_LEN
  146  06:C692  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  147  06:C694  F0 F3             BEQ .innerloop
  148  06:C696  60                RTS
  149                       
  150  06:C697            LoadSprites_impl:
  151                       ;;A will be the amount of sprites to load
  152  06:C697  8D 00 00    STA DATA_LEN
  153  06:C69A  0E 00 00    ASL DATA_LEN
  154  06:C69D  0E 00 00    ASL DATA_LEN
  155                       
  156  06:C6A0  A0 00       LDY #$00              ; start at 0
  157                       
  158  06:C6A2            .loop:
  159  06:C6A2  B1 0E       LDA [table_address], y; load data from address (sprites +  x)
  160  06:C6A4  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  161  06:C6A7  C8          INY                   ; X = X + 1
  162  06:C6A8  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  163  06:C6AB  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  164                                             ; if compare was equal to 16, keep going down   
  165  06:C6AD  60          RTS
  166                     
  167                     
  168  06:C6AE            WriteToPPUString:
  169                     
  170  06:C6AE  AE 1C 00          LDX PPU_StringIdx
  171  06:C6B1  E0 20             CPX #PPU_STRINGMAX
  172  06:C6B3  F0 06             BEQ .finish
  173                             
  174  06:C6B5  9D 1D 00          STA PPU_String, x
  175  06:C6B8  EE 1C 00          INC PPU_StringIdx
  176                                     
  177  06:C6BB            .finish:
  178  06:C6BB  60                RTS
  179                     
  180  06:C6BC            ClearPPUString:
  181                             
  182  06:C6BC  A9 00             LDA #$00
  183  06:C6BE  8D 1C 00          STA PPU_StringIdx
  184  06:C6C1  8D 1D 00          STA PPU_String
  185  06:C6C4  8D 1B 00          STA PPU_PendingWrite
  186  06:C6C7  60                RTS
  187                     
  188  06:C6C8            DetectSprite0:
  189  06:C6C8            WaitNotSprite0:
  190  06:C6C8  AD 02 20    lda PPU_STATUS
  191  06:C6CB  29 40       and #SPRITE_0_MASK
  192  06:C6CD  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  193                     
  194  06:C6CF            WaitSprite0:
  195  06:C6CF  AD 02 20    lda $2002
  196  06:C6D2  29 40       and #SPRITE_0_MASK
  197  06:C6D4  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  198                     
  199  06:C6D6  A2 05       ldx #$05                              ;do a scanline wait
  200  06:C6D8            WaitScanline:
  201  06:C6D8  CA          dex
  202  06:C6D9  D0 FD       bne WaitScanline
  203  06:C6DB  60          RTS
  204                     
  205                     
  206  06:C6DC            SetNametableFromIndex:
  207                     
  208  06:C6DC  48          PHA
  209  06:C6DD  AD 02 20    LDA PPU_STATUS
  210  06:C6E0  68          PLA
  211  06:C6E1  0A          ASL A
  212  06:C6E2  AA          TAX
  213  06:C6E3  BD 26 C7    LDA NameTableMemList+1, x
  214  06:C6E6  8D 06 20    STA PPU_ADDR
  215  06:C6E9  BD 25 C7    LDA NameTableMemList, x
  216  06:C6EC  8D 06 20    STA PPU_ADDR
  217  06:C6EF  60          RTS
  218                       
  219  06:C6F0            TurnOnSprites:
  220                      
  221  06:C6F0  AD 16 00    LDA PPU_Mask
  222  06:C6F3  09 10       ORA #%00010000
  223  06:C6F5  8D 16 00    STA PPU_Mask
  224  06:C6F8  60          RTS
  225                       
  226  06:C6F9            TurnOffSprites:
  227                       
  228  06:C6F9  AD 16 00    LDA PPU_Mask
  229  06:C6FC  29 EF       AND #%11101111
  230  06:C6FE  8D 16 00    STA PPU_Mask
  231  06:C701  60          RTS
  232                     
  233  06:C702            UpdatePPUControl:
  234                     
  235  06:C702  AD 15 00    LDA PPU_Control
  236  06:C705  29 FC       AND #$FC
  237  06:C707  0D 1A 00    ORA PPU_NT
  238  06:C70A  8D 00 20    STA PPU_CTRL
  239  06:C70D  AD 16 00    LDA PPU_Mask
  240  06:C710  8D 01 20    STA PPU_MASK
  241  06:C713  60          RTS
  242                       
  243  06:C714            InitPPUControl:
  244                       
  245                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  246                       ; enable sprites, enable background, no clipping on left side
  247  06:C714  A9 90       LDA #%10010000
  248  06:C716  8D 00 20    STA PPU_CTRL
  249  06:C719  8D 15 00    STA PPU_Control
  250  06:C71C  A9 1E       LDA #%00011110
  251  06:C71E  8D 01 20    STA PPU_MASK
  252  06:C721  8D 16 00    STA PPU_Mask
  253  06:C724  60          RTS
  254                     
  255  06:C725            NameTableMemList:
  256  06:C725  00 20       .word $2000, $2400, $2800, $2C00
       06:C727  00 24     
       06:C729  00 28     
       06:C72B  00 2C     
  257  06:C72D            PalettesMemList:
  258  06:C72D  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:C72F  04 3F     
       06:C731  08 3F     
       06:C733  0C 3F     
  259  06:C735  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:C737  14 3F     
       06:C739  18 3F     
       06:C73B  1C 3F     
  260                       
  261           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   89                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:C73D            ResetMapper:
    7  06:C73D  EE 3D C7    inc ResetMapper
    8  06:C740  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:C741            SetMapperControls:
   23                       ;;A = controls
   24  06:C741  AA          TAX
   25  06:C742  A9 80       LDA #MAPPERCONTROL
   26  06:C744  8D 3E 00    STA mapper_address+1
   27  06:C747  8A          TXA
   28  06:C748  20 6D C7    JSR SendMapperCommand
   29  06:C74B  60          RTS
   30                     
   31  06:C74C            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:C74C  AA                TAX
   35  06:C74D  A9 E0             LDA #PRGBANK
   36  06:C74F  8D 3E 00          STA mapper_address+1
   37  06:C752  8A                TXA
   38  06:C753  20 6D C7          JSR SendMapperCommand
   39  06:C756  60                RTS
   40                             
   41  06:C757            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:C757  AA                TAX
   44  06:C758  A9 A0             LDA #CHRBANK1
   45  06:C75A  8D 3E 00          STA mapper_address+1
   46  06:C75D  8A                TXA
   47  06:C75E  20 6D C7          JSR SendMapperCommand
   48  06:C761  60                RTS
   49                             
   50  06:C762            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:C762  AA                TAX
   53  06:C763  A9 C0             LDA #CHRBANK2
   54  06:C765  8D 3E 00          STA mapper_address+1
   55  06:C768  8A                TXA
   56  06:C769  20 6D C7          JSR SendMapperCommand
   57  06:C76C  60                RTS
   58                             
   59  06:C76D            SendMapperCommand:
   60                     
   61  06:C76D  A0 00             LDY #$00
   62                             
   63  06:C76F  91 3D             STA [mapper_address], y
   64  06:C771  4A                LSR A
   65  06:C772  91 3D             STA [mapper_address], y
   66  06:C774  4A                LSR A
   67  06:C775  91 3D             STA [mapper_address], y
   68  06:C777  4A                LSR A 
   69  06:C778  91 3D             STA [mapper_address], y
   70  06:C77A  4A                LSR A
   71  06:C77B  91 3D             STA [mapper_address], y
   72                             
   73  06:C77D  60                RTS
   74                             
   75  06:C77E            ResetBanks:
   76                     
   77  06:C77E  20 3D C7          JSR ResetMapper
   78  06:C781  A9 00             LDA #$00
   79  06:C783  20 4C C7          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:C786  20 3D C7          JSR ResetMapper
   83  06:C789  A9 00             LDA #$00
   84  06:C78B  20 57 C7          JSR LoadCHRBankA
   85  06:C78E  A9 01             LDA #$01
   86  06:C790  20 62 C7          JSR LoadCHRBankB
   87  06:C793  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   90                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:C794            PopulateClues:
    2                     
    3  06:C794            .getByte:
    4  06:C794  AC 4D 00    LDY clueTableIndex
    5  06:C797  B1 47       LDA [clues_address], y
    6  06:C799  D0 07       BNE .checkNewLine
    7  06:C79B  EE 4D 00    INC clueTableIndex
    8  06:C79E  A9 00       LDA #$00
    9  06:C7A0  F0 38       BEQ .drawClue
   10                       ;was 0, set up a draw
   11  06:C7A2            .checkNewLine
   12  06:C7A2  C9 FF       CMP #$FF
   13  06:C7A4  D0 17       BNE .getClue
   14                       
   15                       ;;was FF- need to inc stuff
   16  06:C7A6  EE 4D 00    INC clueTableIndex
   17  06:C7A9  A9 00       LDA #$00
   18  06:C7AB  8D 54 00    STA clueParity
   19                       
   20  06:C7AE  EE 4E 00    INC clueLineIndex
   21  06:C7B1  AD 4E 00    LDA clueLineIndex
   22  06:C7B4  C9 0F       CMP #$0F
   23                       ;CMP #$01
   24  06:C7B6  F0 28       BEQ .leave    ;carry will be set
   25                       
   26  06:C7B8  20 52 C8    JSR CreateOffsetFromIndex
   27                      
   28  06:C7BB  D0 D7       BNE .getByte
   29                       
   30  06:C7BD            .getClue:
   31                       ;;clues go from high nibble to low nibble
   32  06:C7BD  48          PHA 
   33  06:C7BE  AD 54 00    LDA clueParity
   34  06:C7C1  D0 0A       BNE .getSecondClue
   35  06:C7C3  EE 54 00    INC clueParity
   36  06:C7C6  68          PLA
   37  06:C7C7  4A          LSR A
   38  06:C7C8  4A          LSR A
   39  06:C7C9  4A          LSR A
   40  06:C7CA  4A          LSR A         ;move clue over to lower nibble
   41  06:C7CB  D0 0D       BNE .drawClue
   42                       
   43  06:C7CD            .getSecondClue:
   44                     
   45  06:C7CD  CE 54 00    DEC clueParity
   46  06:C7D0  EE 4D 00    INC clueTableIndex
   47  06:C7D3  68          PLA 
   48  06:C7D4  29 0F       AND #$0F
   49  06:C7D6  D0 02       BNE .drawClue
   50                       ;;if 0, skip
   51  06:C7D8  F0 BA       BEQ .getByte
   52                      
   53  06:C7DA            .drawClue:
   54                       
   55  06:C7DA  09 40       ORA #$40
   56  06:C7DC  20 E1 C7    JSR WriteClueByteToPPUString
   57  06:C7DF  18          CLC
   58                       
   59  06:C7E0            .leave:
   60  06:C7E0  60          RTS
   61                       
   62  06:C7E1            WriteClueByteToPPUString:
   63                     
   64  06:C7E1  8D 00 00    STA temp1 ;store off the tile value
   65                     
   66                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:C7E4  A9 01       LDA #$01
       06:C7E6  8D 1B 00    STA PPU_PendingWrite
       06:C7E9  AD 4C 00    LDA clue_draw_address+1
       06:C7EC  20 AE C6    JSR WriteToPPUString
       06:C7EF  AD 4B 00    LDA clue_draw_address
       06:C7F2  20 AE C6    JSR WriteToPPUString
       06:C7F5  A9 00       LDA #DRAW_HORIZONTAL
       06:C7F7  20 AE C6    JSR WriteToPPUString
       06:C7FA  A9 01       LDA #$01
       06:C7FC  20 AE C6    JSR WriteToPPUString
                            
   67  06:C7FF  AD 00 00    LDA temp1
   68  06:C802  20 AE C6    JSR WriteToPPUString
   69                       
   70  06:C805  AD 52 00    LDA clueDrawAdd
   71  06:C808  20 2F C8    JSR SubFromClueDrawAddress
   72                         
   73  06:C80B  60          RTS
   74                       
   75  06:C80C            ResetClueDrawAddress:
   76                     
   77                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:C80C  AD 49 00          LDA clue_start_address
       06:C80F  8D 4B 00          STA clue_draw_address
       06:C812  AD 4A 00          LDA clue_start_address+1
       06:C815  8D 4C 00          STA clue_draw_address+1
                          
   78                       
   79  06:C818  60          RTS
   80                       
   81  06:C819            AddToClueDrawAddress:
   82                     
   83  06:C819  8D 00 00    STA temp1
   84                       
   85  06:C81C  AD 4B 00    LDA clue_draw_address
   86  06:C81F  18          CLC
   87  06:C820  6D 00 00    ADC temp1
   88  06:C823  8D 4B 00    STA clue_draw_address
   89  06:C826  AD 4C 00    LDA clue_draw_address+1
   90  06:C829  69 00       ADC #$00
   91  06:C82B  8D 4C 00    STA clue_draw_address+1
   92                       
   93  06:C82E  60          RTS
   94                         
   95  06:C82F            SubFromClueDrawAddress:
   96                     
   97  06:C82F  8D 00 00    STA temp1
   98                       
   99  06:C832  AD 4B 00    LDA clue_draw_address
  100  06:C835  38          SEC
  101  06:C836  ED 00 00    SBC temp1
  102  06:C839  8D 4B 00    STA clue_draw_address
  103  06:C83C  AD 4C 00    LDA clue_draw_address+1
  104  06:C83F  E9 00       SBC #$00
  105  06:C841  8D 4C 00    STA clue_draw_address+1
  106                       
  107  06:C844  60          RTS
  108                       
  109  06:C845            AddToClueDrawAddressHi:
  110                     
  111  06:C845  8D 00 00    STA temp1
  112                       
  113  06:C848  AD 4C 00    LDA clue_draw_address+1
  114  06:C84B  6D 00 00    ADC temp1
  115  06:C84E  8D 4C 00    STA clue_draw_address+1
  116                       
  117  06:C851  60          RTS
  118                       
  119  06:C852            CreateOffsetFromIndex:
  120                     
  121                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  122  06:C852  AD 4E 00    LDA clueLineIndex
  123  06:C855  8D 50 00    STA clueDrawOffset
  124  06:C858  A9 00       LDA #$00
  125  06:C85A  8D 51 00    STA clueDrawOffset+1
  126                       
  127  06:C85D  AD 4F 00    LDA clueOffsetShift   
  128  06:C860  F0 0E       BEQ .addOffset
  129                       
  130  06:C862  A2 00       LDX #$00
  131                       
  132  06:C864            .loopShift:
  133  06:C864  0E 50 00    ASL clueDrawOffset
  134  06:C867  2E 51 00    ROL clueDrawOffset+1
  135  06:C86A  E8          INX
  136  06:C86B  EC 4F 00    CPX clueOffsetShift
  137  06:C86E  D0 F4       BNE .loopShift
  138                       
  139  06:C870            .addOffset:
  140                       
  141  06:C870  20 0C C8    JSR ResetClueDrawAddress
  142  06:C873  AD 50 00    LDA clueDrawOffset
  143  06:C876  20 19 C8    JSR AddToClueDrawAddress 
  144  06:C879  AD 51 00    LDA clueDrawOffset+1
  145  06:C87C  20 45 C8    JSR AddToClueDrawAddressHi
  146                       
  147  06:C87F  60          RTS
#[1]   Picross.asm
   91                       
   92                       
   93                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   94                     ;;     NMI                  ;;
   95                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   96                     
#[2]   Routines/Common/NMI.asm
   97                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:C880            NMI:
    3                     
    4  06:C880  48          PHA                              ;protect the registers
    5  06:C881  8A          TXA
    6  06:C882  48          PHA
    7  06:C883  98          TYA
    8  06:C884  48          PHA
    9                       
   10  06:C885            nmi_started:
   11  06:C885  A9 00       LDA #$00
   12  06:C887  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:C88A  A9 02       LDA #$02
   14  06:C88C  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:C88F  AD 0A 00    LDA NMI_locks
   17  06:C892  F0 03       BEQ update_controllers
   18  06:C894  4C EC C8    JMP WakeUp
   19                     
   20  06:C897            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:C897  8A            TXA
    3  06:C898  48                PHA
    4  06:C899  98                TYA
    5  06:C89A  48                PHA
    6                     
    7  06:C89B  A2 00             LDX #$00
    8                     
    9  06:C89D            GamePadCheck:
   10  06:C89D  A9 01             LDA #$01        ;load 1
   11  06:C89F  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:C8A2  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:C8A3  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:C8A6  A9 80             LDA #$80
   18  06:C8A8  8D 12 00          STA gamepad
   19                     
   20  06:C8AB            ReadControllerABytesLoop:
   21  06:C8AB  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:C8AE  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:C8B0  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:C8B2  6E 12 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:C8B5  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:C8B7  AD 13 00          LDA gamepadLast
   31  06:C8BA  49 FF             EOR #$FF
   32  06:C8BC  2D 12 00          AND gamepad
   33  06:C8BF  8D 14 00          STA gamepadPressed
   34                             
   35                             
   36  06:C8C2  AD 12 00          LDA gamepad
   37  06:C8C5  8D 13 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:C8C8  68                PLA
   41  06:C8C9  A8                TAY
   42  06:C8CA  68                PLA
   43  06:C8CB  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:C8CC  20 0C C6    JSR ProcessPPUString
   25                       
   26                       
   27  06:C8CF  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:C8D1  8D 05 20    STA PPU_SCROLL
   29  06:C8D4  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:C8D7  20 02 C7    JSR UpdatePPUControl
   34                     
   35  06:C8DA            NMIUpdate:
   36                     
   37  06:C8DA  20 E0 C8    JSR StateNMIUpdate
   38  06:C8DD  4C EC C8    JMP WakeUp
   39                     
   40  06:C8E0            StateNMIUpdate:
   41                     
   42                       MACROCallDynamicJump game_mode
                          
       06:C8E0  AD 08 00    LDA game_mode
       06:C8E3  20 7D C5    JSR Dynamic_Jump
                                  
   43                     
   44  06:C8E6            NMIJumpTable:
   45                     
   46  06:C8E6  F7 C8       .word UpdateTitleNMI
   47  06:C8E8  11 C9       .word UpdateGameNMI
   48  06:C8EA  12 C9       .word UpdateGameOverNMI
   49                     
   50  06:C8EC            WakeUp:
   51  06:C8EC  A9 00       LDA #$00
   52  06:C8EE  8D 07 00    STA sleeping
   53                       
   54  06:C8F1  68          PLA             ;restore the registers
   55  06:C8F2  A8          TAY 
   56  06:C8F3  68          PLA
   57  06:C8F4  AA          TAX
   58  06:C8F5  68          PLA
   59                     
   60  06:C8F6  40          RTI             ; return from interrupt
   61                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   62                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:C8F7            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:C8F7  20 C8 C6    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15  06:C8FA  AD 15 00    LDA PPU_Control
   16  06:C8FD  29 FC       AND #$FC
   17  06:C8FF  0D 19 00    ORA PPU_ScrollNT
   18  06:C902  8D 00 20    STA PPU_CTRL
   19                       
   20  06:C905  AD 17 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   21  06:C908  8D 05 20    STA PPU_SCROLL
   22  06:C90B  A9 00       LDA #$00
   23  06:C90D  8D 05 20    STA PPU_SCROLL
   24                     
   25                        
   26  06:C910  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   63                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:C911            UpdateGameNMI:
    2  06:C911  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   64                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:C912            UpdateGameOverNMI:
    2  06:C912  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
   98                       
   99                     ;;**************************;;
  100                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  101                     ;;       PRG ROM DATA       ;;
  102                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  103                     ;;**************************;; 
  104                       
  105           0007        .bank 7
  106           E000        .org $E000
  107                     
#[2]   NameTables/Tables.asm
  108                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  12 E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  32 E0     
       07:E004  52 E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  72 E0       .word Title_Screen, Game_Screen, GameOver_Screen
       07:E008  72 E8     
       07:E00A  72 EC     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  72 E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  72 F0     
       07:E010  72 F0     
   12                     
   13  07:E012            Title_Palette:
   14                     
   15  07:E012              .incbin "NameTables/Title_PAL.pal"
   16  07:E022              .incbin "NameTables/Title_PAL.pal"
   17                       
   18  07:E032            Game_Palette:
   19                     
   20  07:E032              .incbin "NameTables/Game_PAL.pal"
   21  07:E042              .incbin "NameTables/Game_PAL.pal"
   22                       
   23  07:E052            GameOver_Palette:
   24                     
   25  07:E052              .incbin "NameTables/GameOver_PAL.pal"
   26  07:E062              .incbin "NameTables/GameOver_PAL.pal"
   27                       
   28  07:E072            Title_Screen:
   29                     
   30  07:E072              .incbin "NameTables/Title_NT.nam"
   31                       
   32  07:E472            Title_Second:
   33                     
   34  07:E472              .incbin "NameTables/Title_PuzzMen_NT.nam"
   35                       
   36  07:E872            Game_Screen: 
   37                     
   38  07:E872              .incbin "NameTables/Game_NT.nam"
   39                       
   40  07:EC72            GameOver_Screen:
   41                     
   42  07:EC72              .incbin "NameTables/GameOver_NT.nam"
   43                       
   44  07:F072            Blank_Screen:
   45                     
   46  07:F072              .incbin "NameTables/Blank_NT.nam"
   47                     
   48                       
   49                     
   50                       
   51                      
   52                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  109                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:F472            Sprites:
   38  07:F472  78 F4             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:F474  81 F4     
       07:F476  86 F4     
   39                     
   40  07:F478            Title_Sprites:
   41  07:F478  02            .db $02
   42  07:F479  85 00 00          .db $85,$00,$00,$E8
       07:F47C  E8        
   43  07:F47D  A0 01 00          .db $A0,$01,$00,$60
       07:F480  60        
   44  07:F481            Game_Sprites:
   45  07:F481  01            .db $01
   46  07:F482  62 00 03          .db $62,$00,$03,$72
       07:F485  72        
   47  07:F486            GameOver_Sprites:
   48  07:F486  01                .db $01
   49  07:F487  00 00 00          .db $00,$00,$00,$00
       07:F48A  00        
#[1]   Picross.asm
  110                     
  111           FFFA        .org $FFFA     ;first of the three vectors starts here
  112  07:FFFA  80 C8       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  113                                        ;processor will jump to the label NMI:
  114  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  115                                        ;to the label RESET:
  116  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  117                       
  118                     ;;**************************;;
  119                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  120                     ;;      CHR ROM DATA        ;;
  121                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122                     ;;**************************;; 
  123                       
  124           0008        .bank 8
  125           0000        .org $0000
  126  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  127                       
  128           0009        .bank 9
  129           0000        .org $0000
  130  09:0000              .incbin "CHRROM/Bank1.chr"
  131                       
  132           000A        .bank 10
  133           0000        .org $0000
  134  0A:0000              .incbin "CHRROM/Bank2.chr"
  135                       
  136           000B        .bank 11
  137           0000        .org $0000
  138  0B:0000              .incbin "CHRROM/Bank3.chr"
