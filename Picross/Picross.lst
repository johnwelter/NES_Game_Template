#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      tempx                   .rs 1
    6           0005      tempy                   .rs 1
    7           0006      time                    .rs 1
    8           0007      sleeping                .rs 1
    9           0008      game_mode               .rs 1
   10           0009      mode_state              .rs 1
   11           000A      NMI_locks               .rs 1
   12           000B      game_locks              .rs 1
   13           000C      pointer_address .rs 2
   14           000E      table_address   .rs 2
   15           0010      jump_address    .rs 2
   16                     
   17                     ;game modes
   18           0000      TITLE_IDX = $00
   19           0001      GAME_IDX = $01
   20           0002      GAMEOVER_IDX = $02
   21                     
   22                     ;locks for input and rendering
   23           0001      BGLOAD_NMI_LOCK = %00000001
   24           0001      EFFECT_GAME_LOCK = %00000001
   25                     
   26                     
   27                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           0012      gamepad                 .rs 1
   19           0013      gamepadLast     .rs 1
   20           0014      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           0015      PPU_Control                     .rs 1
    2           0016      PPU_Mask                        .rs 1
    3           0017      PPU_ScrollX                     .rs 1
    4           0018      PPU_ScrollY                     .rs 1
    5           0019      PPU_ScrollNT            .rs 1   ;first two bits
    6           001A      PPU_NT                          .rs 1
    7                     
    8           001B      PPU_PendingWrite        .rs 1
    9           001C      PPU_StringIdx           .rs 1
   10           001D      PPU_String                      .rs 32
   11                     
   12           0020      PPU_STRINGMAX = $20 ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           003D      mapper_address  .rs 2
    2           003F      currentCHRBankA .rs 1
    3           0040      currentCHRBankB .rs 1
    4           0041      currentPRGBank  .rs 1
    5           0042      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           0043      puzzle_address          .rs 2
    2           0045      clues_address           .rs 2
    3           0047      clue_start_address      .rs 2
    4           0049      clue_draw_address       .rs 2
    5           004B      clueTableIndex          .rs 1
    6           004C      clueLineIndex           .rs 1
    7           004D      clueOffsetShift         .rs 1
    8           004E      clueDrawOffset          .rs 2
    9           0050      clueDrawAdd                     .rs 1
   10           0051      clueDrawDecSize         .rs 1
   11           0052      clueParity                      .rs 1
   12           0053      mouse_location          .rs 2
   13           0055      mouse_index                     .rs 2
   14           0057      currentPaintTile        .rs 1
   15           0058      solutionCount           .rs 1
   16           0059      nonSolutionCount        .rs 1
   17           005A      holdTimer                       .rs 1
   18           005B      GameTime                        .rs 4   ;in order - second, ten second, minute, 10 minute - max out at 99 minutes
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/ScreenStateVariables.asm
   18                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   19           7000        .rsset $7000
#[3]   Defines/SaveVariables.asm
   20                       .include "Defines/SaveVariables.asm"
    1           7000      bank_index      .rs 1
    2           7001      puzzle_index .rs 1
    3                     
#[2]   Defines/Defines.asm
   21                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1           0000        .bank 0
    2           8000        .org $8000
    3                       
#[3]   Puzzles/house.asm
    4                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  03 82 00    .db $03, $82, $00, $01
       00:8003  01        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  11 18 1E    .db $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1C 0E FF  
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test.asm
    5                       .include "Puzzles/test.asm"
    1  00:80B6            test:
    2  00:80B6  03 01 00    .db $03, $01, $00, $00
       00:80B9  00        
    3  00:80BA  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:80BD  00 00 00  
       00:80C0  00 00 00  
       00:80C3  00 00 00  
       00:80C6  00 00 00  
       00:80C9  00 00 00  
       00:80CC  00 00 00  
       00:80CF  00 00 00  
       00:80D2  00 00 00  
       00:80D5  00 00 00  
    4  00:80D8  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80DB  FF 00 FF  
       00:80DE  00 FF 00  
       00:80E1  FF 00 FF  
       00:80E4  00 FF 00  
       00:80E7  FF 00 FF  
       00:80EA  00 FF 00  
       00:80ED  FF 00 FF  
       00:80F0  00 FF 00  
       00:80F3  FF 00 FF  
    5  00:80F6  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80F9  FF 00 FF  
       00:80FC  00 FF 00  
       00:80FF  FF 00 FF  
       00:8102  00 FF 00  
       00:8105  FF 00 FF  
       00:8108  00 FF 00  
       00:810B  FF 00 FF  
       00:810E  00 FF 00  
       00:8111  FF 00 FF  
    6  00:8114            testImage:
    7  00:8114  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8117  1B 1B 1B  
       00:811A  1B 1B 1B  
       00:811D  1B 1B 1B  
       00:8120  1B 1B 1B  
       00:8123  1B 1B 1B  
       00:8126  1B 1B 1B  
       00:8129  1B 1B 1B  
       00:812C  1B 1B 1B  
       00:812F  1B 1B 1B  
       00:8132  1B 1B 1B  
       00:8135  1B 1B 1B  
       00:8138  1B 1B 1B  
       00:813B  1B 1B 1B  
       00:813E  1B 1B 1B  
       00:8141  1B 1B 1B  
       00:8144  1B 1B 1B  
       00:8147  1B 1B 1B  
       00:814A  1B 1B 00  
       00:814D  FF        
    8  00:814E            testName:
    9  00:814E  1D 0E 1C    .db $1D, $0E, $1C, $1D, $FF
       00:8151  1D FF     
#[2]   Banks/Bank0.asm
    6                     
    7           0001        .bank 1
    8           A000        .org $A000
    9                       
   10  01:A000  00 80       .word house, test
       01:A002  B6 80     
   11                       
   12           BFFA        .org $BFFA     ;first of the three vectors starts here
   13  01:BFFA  DE CB       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   14                                        ;processor will jump to the label NMI:
   15  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   16                                        ;to the label RESET:
   17  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  03 62 00    .db $03, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  0F 1B 18    .db $0F, $1B, $18, $10, $FF
       02:80A7  10 FF     
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                     
    9  03:A000  00 80       .word frog
   10                     
   11           BFFA        .org $BFFA     ;first of the three vectors starts here
   12  03:BFFA  DE CB       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   13                                        ;processor will jump to the label NMI:
   14  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   15                                        ;to the label RESET:
   16  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  03 7E 00    .db $03, $7E, $00, $0A
       04:8003  0A        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  0C 0A 1D    .db $0C, $0A, $1D, $FF
       04:80A5  FF        
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8  05:A000  00 80       .word cat
    9                     
   10           BFFA        .org $BFFA     ;first of the three vectors starts here
   11  05:BFFA  DE CB       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   12                                        ;processor will jump to the label NMI:
   13  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   14                                        ;to the label RESET:
   15  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 A6 C9    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 AA C9    JSR SetMapperControls
   34                       
   35  06:C040  20 E7 C9    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  20 0F C7    JSR ChangeGameMode
   38  06:C04D  20 7D C9    JSR InitPPUControl
   39                       
   40                     
   41                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   42                     ;;     Main Program         ;;
   43                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   44                     
   45  06:C050            Forever:
   46                     
   47  06:C050  EE 07 00    INC sleeping
   48                     
   49  06:C053            .loop
   50  06:C053  AD 07 00    LDA sleeping
   51  06:C056  D0 FB       BNE .loop
   52                     
   53  06:C058  EE 06 00    INC time  
   54  06:C05B  20 61 C0    JSR GameLoop
   55                     
   56                     
   57  06:C05E  4C 50 C0    JMP Forever     ;jump back to Forever, infinite loop
   58                       
   59                     ;; dynamic jump table
   60                     
   61  06:C061            GameLoop:
   62                     
   63                       MACROCallDynamicJump game_mode
                          
       06:C061  AD 08 00    LDA game_mode
       06:C064  20 BF C7    JSR Dynamic_Jump
                                  
   64                       ;; we'll pop the return address here as the table index, so 
   65                       ;; the routine we pick will return us to whatever called Game Loop
   66                       ;; when it returns
   67                     
   68  06:C067            GameLoopJumpTable:
   69                     
   70  06:C067  6D C0       .word UpdateTitle
   71  06:C069  58 C2       .word UpdateGame
   72  06:C06B  FC C6       .word UpdateGameOver
   73                       
   74                     
   75                       ;;RTS is called in the subroutine
   76                     
   77                       
#[2]   Routines/Game_States/UpdateTitle.asm
   78                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C06D            UpdateTitle:
    2                     
    3  06:C06D  AD 0A 00    LDA NMI_locks
    4  06:C070  F0 01       BEQ .unlocked
    5                       
    6  06:C072  60          RTS
    7                       
    8  06:C073            .unlocked:
    9                     
   10  06:C073  20 77 C0    JSR DoUpdateTitle  
   11  06:C076  60          RTS
   12                       
   13  06:C077            DoUpdateTitle:
   14                     
   15  06:C077  AD 09 00    LDA mode_state
   16  06:C07A  20 BF C7    JSR Dynamic_Jump
   17                         
   18  06:C07D            UpdateTitleJumpTable:
   19                     
   20  06:C07D  89 C0       .word UpdateTitleInit
   21  06:C07F  9A C0       .word UpdateBankSelection
   22  06:C081  B3 C0       .word UpdateScroll
   23  06:C083  D5 C0       .word UpdatePuzzleSelection
   24  06:C085  0D C1       .word UpdateScrollBack
   25  06:C087  2A C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C089            UpdateTitleInit:
   35                     
   36  06:C089  20 59 C9    JSR TurnOnSprites
   37                       
   38  06:C08C  A9 00       LDA #$00
   39  06:C08E  8D 55 00    STA mouse_index
   40  06:C091  A9 00       LDA #$00
   41  06:C093  8D 56 00    STA mouse_index+1
   42                     
   43  06:C096            .changeModeState:
   44                     
   45  06:C096  EE 09 00    INC mode_state
   46  06:C099            .leave:
   47  06:C099  60          RTS
   48                       
   49  06:C09A            UpdateBankSelection:
   50                     
   51  06:C09A  20 B1 C1    JSR UpdateBankPointer
   52                       
   53  06:C09D  AD 14 00    LDA gamepadPressed
   54  06:C0A0  29 01       AND #GAMEPAD_A
   55  06:C0A2  F0 0E       BEQ .leave
   56                       
   57  06:C0A4            .changeModeState:
   58                     
   59  06:C0A4  AD 55 00    LDA mouse_index
   60  06:C0A7  8D 00 70    STA bank_index
   61  06:C0AA  A9 FF       LDA #$FF
   62  06:C0AC  20 99 C1    JSR SetPointerSprite
   63                       
   64  06:C0AF  EE 09 00    INC mode_state
   65  06:C0B2            .leave:
   66  06:C0B2  60          RTS
   67                       
   68  06:C0B3            UpdateScroll:
   69  06:C0B3  EE 17 00    INC PPU_ScrollX
   70  06:C0B6  EE 17 00    INC PPU_ScrollX
   71  06:C0B9  EE 17 00    INC PPU_ScrollX
   72  06:C0BC  EE 17 00    INC PPU_ScrollX
   73  06:C0BF  D0 13       BNE .leave
   74  06:C0C1  AD 19 00    LDA PPU_ScrollNT
   75  06:C0C4  49 01       EOR #%00000001
   76  06:C0C6  8D 19 00    STA PPU_ScrollNT
   77                       
   78  06:C0C9            .changeModeState:
   79  06:C0C9  A9 01       LDA #$01
   80  06:C0CB  20 99 C1    JSR SetPointerSprite
   81  06:C0CE  20 5F C1    JSR InitPuzzlePointer
   82  06:C0D1  EE 09 00    INC mode_state
   83  06:C0D4            .leave:
   84  06:C0D4  60          RTS
   85                       
   86  06:C0D5            UpdatePuzzleSelection:
   87                     
   88  06:C0D5  20 ED C1    JSR UpdatePuzzlePointer
   89                       
   90  06:C0D8  AD 14 00    LDA gamepadPressed
   91  06:C0DB  29 02       AND #GAMEPAD_B
   92  06:C0DD  D0 10       BNE .changeToScrollBack
   93  06:C0DF  AD 14 00    LDA gamepadPressed
   94  06:C0E2  29 09       AND #GAMEPAD_CONFIRM
   95  06:C0E4  F0 26       BEQ .leave
   96                       
   97  06:C0E6  EE 09 00    INC mode_state
   98  06:C0E9  EE 09 00    INC mode_state
   99  06:C0EC  4C 0C C1    JMP .leave
  100                       
  101  06:C0EF            .changeToScrollBack:
  102                      
  103  06:C0EF  A9 FF       LDA #$FF
  104  06:C0F1  20 99 C1    JSR SetPointerSprite
  105  06:C0F4  20 57 C1    JSR InitBankPointer
  106                       
  107  06:C0F7  A9 00       LDA #$00
  108  06:C0F9  8D 18 00    STA PPU_ScrollY
  109  06:C0FC  A9 FC       LDA #$FC
  110  06:C0FE  8D 17 00    STA PPU_ScrollX
  111  06:C101  AD 19 00    LDA PPU_ScrollNT
  112  06:C104  29 FE       AND #$FE
  113  06:C106  8D 19 00    STA PPU_ScrollNT
  114                       
  115  06:C109  EE 09 00    INC mode_state
  116  06:C10C            .leave:
  117  06:C10C  60          RTS
  118                       
  119  06:C10D            UpdateScrollBack:
  120                     
  121  06:C10D  CE 17 00    DEC PPU_ScrollX
  122  06:C110  CE 17 00    DEC PPU_ScrollX
  123  06:C113  CE 17 00    DEC PPU_ScrollX
  124  06:C116  CE 17 00    DEC PPU_ScrollX
  125  06:C119  D0 0E       BNE .leave
  126                       
  127  06:C11B            .changeModeState:
  128                     
  129  06:C11B  A9 01       LDA #$01
  130  06:C11D  20 99 C1    JSR SetPointerSprite
  131  06:C120  CE 09 00    DEC mode_state
  132  06:C123  CE 09 00    DEC mode_state
  133  06:C126  CE 09 00    DEC mode_state
  134                       
  135  06:C129            .leave:
  136  06:C129  60          RTS
  137                       
  138  06:C12A            UpdateTitleExit:
  139                     
  140                       ;;reset screen scroll
  141  06:C12A  A9 00       LDA #$00
  142  06:C12C  8D 17 00    STA PPU_ScrollX
  143  06:C12F  8D 19 00    STA PPU_ScrollNT
  144                       
  145                       ;;load bank
  146                     
  147  06:C132  20 A6 C9    JSR ResetMapper
  148  06:C135  AD 00 70    LDA bank_index
  149  06:C138  8D 41 00    STA currentPRGBank
  150  06:C13B  20 B5 C9    JSR LoadPRGBank
  151                     
  152                       ;; we can also pick out the puzzle index
  153                       ;; we have the mouse indexes - one vert, one hori
  154                       ;; take vert, mult by 9- alternatively, mult by 8, add index 
  155                       ;; IE - ind = 1, mult 8 = 8, add 1 = 9
  156                       ;; add X index
  157  06:C13E  AD 55 00    LDA mouse_index
  158  06:C141  0A          ASL A
  159  06:C142  0A          ASL A
  160  06:C143  0A          ASL A
  161  06:C144  18          CLC
  162  06:C145  6D 55 00    ADC mouse_index
  163  06:C148  6D 56 00    ADC mouse_index+1
  164  06:C14B  8D 01 70    STA puzzle_index
  165                     
  166  06:C14E  20 62 C9    JSR TurnOffSprites
  167                     
  168  06:C151  A9 01       LDA #GAME_IDX
  169  06:C153  20 0F C7    JSR ChangeGameMode
  170                       
  171  06:C156            .leave
  172  06:C156  60          RTS
  173                       
  174  06:C157            InitBankPointer:
  175                     
  176  06:C157  A2 A0       LDX #$A0
  177  06:C159  A9 60       LDA #$60
  178  06:C15B  20 72 C1    JSR InitPointer
  179                       
  180  06:C15E  60          RTS  
  181                       
  182  06:C15F            InitPuzzlePointer:
  183                       
  184  06:C15F  A2 AE       LDX #$AE
  185  06:C161  A9 10       LDA #$10
  186  06:C163  20 72 C1    JSR InitPointer
  187                       
  188  06:C166  60          RTS
  189                     
  190  06:C167            ResetMouseIndex:
  191                     
  192  06:C167  A9 00       LDA #$00
  193  06:C169  8D 55 00    STA mouse_index
  194  06:C16C  A9 00       LDA #$00
  195  06:C16E  8D 56 00    STA mouse_index+1
  196  06:C171  60          RTS
  197                     
  198  06:C172            InitPointer:
  199                     
  200  06:C172  20 79 C1    JSR SetPointerPosition
  201  06:C175  20 67 C1    JSR ResetMouseIndex
  202  06:C178  60          RTS  
  203                       
  204  06:C179            SetPointerPosition:
  205                     
  206  06:C179  48          PHA
  207  06:C17A  8A          TXA
  208  06:C17B  20 83 C1    JSR SetPointerYPosition
  209  06:C17E  68          PLA
  210  06:C17F  20 8E C1    JSR SetPointerXPosition
  211                      
  212  06:C182  60          RTS
  213                       
  214  06:C183            SetPointerYPosition:
  215                       
  216  06:C183  48          PHA
  217  06:C184  A9 00       LDA #SPRITE_YPOS
  218  06:C186  20 A4 C1    JSR GetPointerDataIndexInX
  219  06:C189  68          PLA
  220  06:C18A  9D 00 02    STA SPRITE_DATA, x
  221  06:C18D  60          RTS
  222                       
  223  06:C18E            SetPointerXPosition:  
  224                       
  225  06:C18E  48          PHA
  226  06:C18F  A9 03       LDA #SPRITE_XPOS
  227  06:C191  20 A4 C1    JSR GetPointerDataIndexInX
  228  06:C194  68          PLA
  229  06:C195  9D 00 02    STA SPRITE_DATA, x 
  230  06:C198  60          RTS
  231                     
  232  06:C199            SetPointerSprite:
  233                     
  234                     ;; A has aprite we want
  235  06:C199  48          PHA
  236  06:C19A  A9 01       LDA #SPRITE_ID
  237  06:C19C  20 A4 C1    JSR GetPointerDataIndexInX
  238  06:C19F  68          PLA
  239  06:C1A0  9D 00 02    STA SPRITE_DATA, x
  240  06:C1A3  60          RTS
  241                       
  242  06:C1A4            GetPointerDataIndexInX:
  243                     
  244  06:C1A4  8D 02 00    STA temp3
  245  06:C1A7  A9 01       LDA #$01
  246  06:C1A9  0A          ASL A
  247  06:C1AA  0A          ASL A
  248  06:C1AB  18          CLC
  249  06:C1AC  6D 02 00    ADC temp3
  250  06:C1AF  AA          TAX
  251                       
  252  06:C1B0  60          RTS
  253                       
  254                       
  255  06:C1B1            UpdateBankPointer:
  256                      
  257                       ;;bank pointer is 1D, will loop between 0->3
  258  06:C1B1  AD 14 00    LDA gamepadPressed
  259  06:C1B4  F0 36       BEQ .leave 
  260                       
  261  06:C1B6  A9 00       LDA #$00
  262  06:C1B8  8D 00 00    STA temp1
  263                       
  264  06:C1BB            .parseInputs:
  265  06:C1BB  AD 14 00    LDA gamepadPressed
  266  06:C1BE  29 30       AND #GAMEPAD_VERT
  267  06:C1C0  F0 2A       BEQ .leave
  268  06:C1C2  0A          ASL A
  269  06:C1C3  0A          ASL A
  270  06:C1C4            .checkDown:
  271  06:C1C4  0A          ASL A
  272  06:C1C5  90 03       BCC .checkUp
  273  06:C1C7  EE 00 00    INC temp1
  274  06:C1CA            .checkUp:
  275  06:C1CA  0A          ASL A
  276  06:C1CB  90 03       BCC .move
  277  06:C1CD  CE 00 00    DEC temp1
  278  06:C1D0            .move:
  279                       
  280  06:C1D0  AD 55 00    LDA mouse_index
  281  06:C1D3  18          CLC
  282  06:C1D4  6D 00 00    ADC temp1
  283  06:C1D7  C9 02       CMP #$02
  284  06:C1D9  F0 04       BEQ .skipMod
  285  06:C1DB  90 02       BCC .skipMod
  286  06:C1DD  A9 00       LDA #$00
  287  06:C1DF            .skipMod:
  288  06:C1DF  8D 55 00    STA mouse_index
  289                       ;; mult mouse_index by 16
  290  06:C1E2  0A          ASL A
  291  06:C1E3  0A          ASL A
  292  06:C1E4  0A          ASL A
  293  06:C1E5  0A          ASL A
  294  06:C1E6  18          CLC
  295  06:C1E7  69 A0       ADC #$A0
  296  06:C1E9  20 83 C1    JSR SetPointerYPosition
  297                     
  298  06:C1EC            .leave:
  299                       
  300  06:C1EC  60          RTS
  301                       
  302  06:C1ED            UpdatePuzzlePointer:
  303                     
  304                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  305  06:C1ED  AD 14 00    LDA gamepadPressed
  306  06:C1F0  F0 65       BEQ .leave 
  307                       
  308  06:C1F2  A9 00       LDA #$00
  309  06:C1F4  8D 00 00    STA temp1
  310  06:C1F7  8D 01 00    STA temp2
  311                       
  312  06:C1FA            .parseInputs:
  313  06:C1FA  AD 14 00    LDA gamepadPressed
  314  06:C1FD  29 F0       AND #GAMEPAD_MOVE
  315  06:C1FF  F0 56       BEQ .leave
  316  06:C201  0A          ASL A
  317  06:C202  90 03       BCC .checkLeft
  318  06:C204  EE 00 00    INC temp1
  319  06:C207            .checkLeft:
  320  06:C207  0A          ASL A
  321  06:C208  90 03       BCC .checkDown
  322  06:C20A  CE 00 00    DEC temp1
  323  06:C20D            .checkDown:
  324  06:C20D  0A          ASL A
  325  06:C20E  90 03       BCC .checkUp
  326  06:C210  EE 01 00    INC temp2
  327  06:C213            .checkUp:
  328  06:C213  0A          ASL A
  329  06:C214  90 03       BCC .move
  330  06:C216  CE 01 00    DEC temp2
  331                       
  332  06:C219            .move:
  333                     
  334  06:C219  AD 55 00    LDA mouse_index
  335  06:C21C  18          CLC
  336  06:C21D  6D 01 00    ADC temp2
  337  06:C220  C9 02       CMP #$02
  338  06:C222  F0 04       BEQ .skipYMod
  339  06:C224  90 02       BCC .skipYMod
  340  06:C226  A9 00       LDA #$00
  341  06:C228            .skipYMod:
  342  06:C228  8D 55 00    STA mouse_index
  343                       ;; mult mouse_index by 16
  344  06:C22B  0A          ASL A
  345  06:C22C  0A          ASL A
  346  06:C22D  0A          ASL A
  347  06:C22E  0A          ASL A
  348  06:C22F  18          CLC
  349  06:C230  69 AE       ADC #$AE
  350  06:C232  20 83 C1    JSR SetPointerYPosition
  351                       
  352  06:C235  AD 56 00    LDA mouse_index+1
  353  06:C238  18          CLC
  354  06:C239  6D 00 00    ADC temp1
  355  06:C23C  C9 08       CMP #$08
  356  06:C23E  F0 04       BEQ .skipXMod
  357  06:C240  90 02       BCC .skipXMod
  358  06:C242  A9 00       LDA #$00
  359  06:C244            .skipXMod:
  360  06:C244  8D 56 00    STA mouse_index+1
  361                       ;; we need to move 3 tiles each- so index * 3 * 8,
  362  06:C247  18          CLC
  363  06:C248  6D 56 00    ADC mouse_index+1
  364  06:C24B  6D 56 00    ADC mouse_index+1
  365  06:C24E  0A          ASL A
  366  06:C24F  0A          ASL A
  367  06:C250  0A          ASL A
  368  06:C251  18          CLC
  369  06:C252  69 10       ADC #$10
  370  06:C254  20 8E C1    JSR SetPointerXPosition
  371                       
  372  06:C257            .leave:
  373                       
  374  06:C257  60          RTS
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   79                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6           20A8      BANK_LEVEL = $20A8
    7           20E5      TIMER_LOC = $20E5
    8                     
    9                     ;;this will change with puzzle sizes
   10           005A      VERT_MIN = $5A ;12 - 1
   11           00DA      VERT_MAX = $DA
   12           006A      HORI_MIN = $6A ;14 - 1
   13           00EA      HORI_MAX = $EA
   14                     
   15           618E      MOUSE_START = $618E
   16                     
   17           0010      HOLD_TIME = $10
   18           0004      HOLD_FREQ = $04
   19                     
   20  06:C258            UpdateGame:
   21                     
   22  06:C258  AD 0A 00    LDA NMI_locks
   23  06:C25B  F0 01       BEQ .unlocked
   24                       
   25  06:C25D  60          RTS
   26                       
   27  06:C25E            .unlocked:
   28                     
   29  06:C25E  20 62 C2    JSR DoUpdateGame
   30  06:C261  60          RTS
   31                       
   32  06:C262            DoUpdateGame:
   33                     
   34  06:C262  AD 09 00    LDA mode_state
   35  06:C265  20 BF C7    JSR Dynamic_Jump
   36                       
   37  06:C268            UpdateGameJumpTable:
   38                     
   39  06:C268  7A C2       .word UpdateGameInit
   40  06:C26A  0E C3       .word UpdateDrawVertClues
   41  06:C26C  36 C3       .word UpdateDrawHoriClues
   42  06:C26E  79 C3       .word UpdateGamePlay
   43  06:C270  E8 C4       .word UpdateClearPuzzle
   44  06:C272  FB C4       .word UpdateMoveScreen
   45  06:C274  61 C5       .word UpdateDrawImage
   46  06:C276  CE C5       .word UpdateWaitInput
   47  06:C278  D7 C5       .word UpdateGameExit
   48                     
   49  06:C27A            UpdateGameInit:
   50                     
   51                       ;; get the puzzle table in the puzzle address
   52                       MACROGetLabelPointer $A000, table_address
                          
       06:C27A  A9 A0             LDA #HIGH($A000)
       06:C27C  A2 00             LDX #LOW($A000)
                                  
       06:C27E  8E 0E 00          STX table_address
       06:C281  8D 0F 00          STA table_address+1
                                  
   53                       MACROGetDoubleIndex puzzle_index
                          
       06:C284  AD 01 70          LDA puzzle_index
       06:C287  0A                ASL A
       06:C288  A8                TAY
                                  
   54  06:C289  20 E5 C7    JSR GetTableAtIndex
   55                       MACROGetPointer table_address, puzzle_address
                          
       06:C28C  AD 0E 00          LDA table_address
       06:C28F  8D 43 00          STA puzzle_address
       06:C292  AD 0F 00          LDA table_address+1
       06:C295  8D 44 00          STA puzzle_address+1
                          
   56                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C298  A9 61             LDA #HIGH(MOUSE_START)
       06:C29A  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C29C  8E 53 00          STX mouse_location
       06:C29F  8D 54 00          STA mouse_location+1
                                  
   57                       
   58                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   59  06:C2A2  AD 43 00    LDA puzzle_address
   60  06:C2A5  18          CLC
   61  06:C2A6  69 22       ADC #34
   62  06:C2A8  8D 45 00    STA clues_address
   63  06:C2AB  A9 00       LDA #$00
   64  06:C2AD  6D 44 00    ADC puzzle_address+1
   65  06:C2B0  8D 46 00    STA clues_address+1
   66                     
   67  06:C2B3  A9 00       LDA #$00
   68  06:C2B5  8D 4B 00    STA clueTableIndex
   69  06:C2B8  8D 4C 00    STA clueLineIndex
   70  06:C2BB  8D 52 00    STA clueParity
   71  06:C2BE  8D 4D 00    STA clueOffsetShift
   72  06:C2C1  8D 55 00    STA mouse_index
   73  06:C2C4  8D 56 00    STA mouse_index+1
   74  06:C2C7  8D 58 00    STA solutionCount
   75  06:C2CA  8D 59 00    STA nonSolutionCount
   76                         
   77  06:C2CD  A9 20       LDA #$20
   78  06:C2CF  8D 50 00    STA clueDrawAdd
   79                        
   80                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C2D2  A9 21             LDA #HIGH(VERT_CLUES)
       06:C2D4  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C2D6  8E 47 00          STX clue_start_address
       06:C2D9  8D 48 00          STA clue_start_address+1
                                  
   81  06:C2DC  20 75 CA    JSR ResetClueDrawAddress
   82                       
   83                       MACROAddPPUStringEntryRawData #HIGH(BANK_LEVEL), #LOW(BANK_LEVEL), #DRAW_HORIZONTAL, #$03
                          
       06:C2DF  A9 01       LDA #$01
       06:C2E1  8D 1B 00    STA PPU_PendingWrite
       06:C2E4  A9 20       LDA #HIGH(BANK_LEVEL)
       06:C2E6  20 11 C9    JSR WriteToPPUString
       06:C2E9  A9 A8       LDA #LOW(BANK_LEVEL)
       06:C2EB  20 11 C9    JSR WriteToPPUString
       06:C2EE  A9 00       LDA #DRAW_HORIZONTAL
       06:C2F0  20 11 C9    JSR WriteToPPUString
       06:C2F3  A9 03       LDA #$03 
       06:C2F5  20 11 C9    JSR WriteToPPUString
                            
   84  06:C2F8  AD 00 70    LDA bank_index
   85  06:C2FB  20 11 C9    JSR WriteToPPUString
   86  06:C2FE  A9 60       LDA #$60
   87  06:C300  20 11 C9    JSR WriteToPPUString
   88  06:C303  AE 01 70    LDX puzzle_index
   89  06:C306  E8          INX
   90  06:C307  8A          TXA 
   91  06:C308  20 11 C9    JSR WriteToPPUString
   92                       
   93  06:C30B  EE 09 00    INC mode_state
   94                     
   95  06:C30E            UpdateDrawVertClues:
   96                       
   97  06:C30E  20 FD C9    JSR PopulateClues
   98  06:C311  90 22       BCC .leave
   99                       
  100  06:C313            .changeModeState:
  101                     
  102  06:C313  A9 00       LDA #$00
  103  06:C315  8D 4C 00    STA clueLineIndex
  104  06:C318  8D 52 00    STA clueParity
  105                       
  106  06:C31B  A9 05       LDA #$05
  107  06:C31D  8D 4D 00    STA clueOffsetShift
  108                       
  109  06:C320  A9 01       LDA #$01
  110  06:C322  8D 50 00    STA clueDrawAdd
  111                        
  112                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C325  A9 21             LDA #HIGH(HORI_CLUES)
       06:C327  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C329  8E 47 00          STX clue_start_address
       06:C32C  8D 48 00          STA clue_start_address+1
                                  
  113  06:C32F  20 75 CA    JSR ResetClueDrawAddress
  114                     
  115  06:C332  EE 09 00    INC mode_state
  116  06:C335            .leave:
  117  06:C335  60          RTS
  118                       
  119  06:C336            UpdateDrawHoriClues:
  120                     
  121  06:C336  20 FD C9    JSR PopulateClues
  122  06:C339  90 3D       BCC .leave
  123                     
  124  06:C33B            .changeModeState:
  125  06:C33B  20 59 C9    JSR TurnOnSprites
  126                       
  127                       ;;set the timer to 00
  128                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C33E  A9 01       LDA #$01
       06:C340  8D 1B 00    STA PPU_PendingWrite
       06:C343  A9 20       LDA #HIGH(TIMER_LOC)
       06:C345  20 11 C9    JSR WriteToPPUString
       06:C348  A9 E5       LDA #LOW(TIMER_LOC)
       06:C34A  20 11 C9    JSR WriteToPPUString
       06:C34D  A9 00       LDA #DRAW_HORIZONTAL
       06:C34F  20 11 C9    JSR WriteToPPUString
       06:C352  A9 05       LDA #$05 
       06:C354  20 11 C9    JSR WriteToPPUString
                            
  129  06:C357  A9 00       LDA #$00
  130  06:C359  20 11 C9    JSR WriteToPPUString
  131  06:C35C  A9 00       LDA #$00
  132  06:C35E  20 11 C9    JSR WriteToPPUString
  133  06:C361  A9 61       LDA #$61
  134  06:C363  20 11 C9    JSR WriteToPPUString
  135  06:C366  A9 00       LDA #$00
  136  06:C368  20 11 C9    JSR WriteToPPUString
  137  06:C36B  A9 00       LDA #$00
  138  06:C36D  20 11 C9    JSR WriteToPPUString
  139                       
  140                       ;;reset time
  141  06:C370  A9 00       LDA #$00
  142  06:C372  8D 06 00    STA time
  143                       
  144  06:C375  EE 09 00    INC mode_state
  145  06:C378            .leave:
  146  06:C378  60          RTS
  147                       
  148  06:C379            UpdateGamePlay:
  149                         
  150  06:C379  20 7D C6    JSR UpdateTimeDisplay
  151                             
  152  06:C37C  A9 00       LDA #$00
  153  06:C37E  8D 00 00    STA temp1
  154  06:C381  8D 01 00    STA temp2
  155  06:C384  8D 02 00    STA temp3
  156                       
  157  06:C387            .checkPressed:  
  158                     
  159  06:C387  AD 14 00    LDA gamepadPressed
  160  06:C38A  29 F0       AND #GAMEPAD_MOVE
  161  06:C38C  F0 0B       BEQ .checkHeld
  162                       
  163  06:C38E  A9 10       LDA #HOLD_TIME
  164  06:C390  8D 5A 00    STA holdTimer 
  165  06:C393  AD 14 00    LDA gamepadPressed
  166  06:C396  4C AD C3    JMP .parseInputs
  167                       
  168  06:C399            .checkHeld:
  169                       
  170  06:C399  AD 12 00    LDA gamepad
  171  06:C39C  29 F0       AND #GAMEPAD_MOVE
  172  06:C39E  F0 2F       BEQ .checkPaintPress
  173                       
  174                       ;;decrement the hold timer
  175  06:C3A0  CE 5A 00    DEC holdTimer
  176  06:C3A3  D0 2A       BNE .checkPaintPress
  177  06:C3A5  A9 04       LDA #HOLD_FREQ
  178  06:C3A7  8D 5A 00    STA holdTimer
  179  06:C3AA  AD 12 00    LDA gamepad
  180                     
  181  06:C3AD            .parseInputs:
  182                     
  183  06:C3AD  29 F0       AND #GAMEPAD_MOVE
  184  06:C3AF  F0 1E       BEQ .checkPaintPress
  185  06:C3B1  0A          ASL A
  186  06:C3B2  90 03       BCC .checkLeft
  187  06:C3B4  EE 00 00    INC temp1
  188  06:C3B7            .checkLeft:
  189  06:C3B7  0A          ASL A
  190  06:C3B8  90 03       BCC .checkDown
  191  06:C3BA  CE 00 00    DEC temp1
  192  06:C3BD            .checkDown:
  193  06:C3BD  0A          ASL A
  194  06:C3BE  90 03       BCC .checkUp
  195  06:C3C0  EE 01 00    INC temp2
  196  06:C3C3            .checkUp:
  197  06:C3C3  0A          ASL A
  198  06:C3C4  90 03       BCC .move
  199  06:C3C6  CE 01 00    DEC temp2
  200                       
  201  06:C3C9            .move:
  202                      
  203  06:C3C9  20 E8 C5    JSR MoveMouse
  204  06:C3CC  20 29 C6    JSR UpdateMouseScreenPos
  205                       
  206  06:C3CF            .checkPaintPress:
  207                     
  208  06:C3CF  AD 14 00    LDA gamepadPressed
  209  06:C3D2  29 03       AND #GAMEPAD_AB
  210  06:C3D4  F0 41       BEQ .updatePaint
  211                       ;;A or B pressed, get current tile
  212                       
  213  06:C3D6  8D 00 00    STA temp1
  214                       
  215  06:C3D9  A0 00       LDY #$00
  216  06:C3DB  B1 53       LDA [mouse_location], y
  217  06:C3DD  8D 01 00    STA temp2
  218                       
  219                         ;;A treats X and Clear as clear
  220                             ;;B treats mark and clear as clear
  221                             ;;clear->mark->x
  222                             
  223                     
  224  06:C3E0  C9 7C       CMP #$7C      ;check if this is a marked tile
  225  06:C3E2  B0 0F       BCS .getClearTile
  226                       ;;cleared tile- store off marked tile to paint with instead
  227                       ;;not a clear tile- a mark or an x - check A or B  
  228  06:C3E4  4E 00 00    LSR temp1
  229  06:C3E7  B0 05       BCS .getMarkTile
  230                       
  231  06:C3E9            .getXTile:
  232  06:C3E9  A9 80       LDA #$80
  233  06:C3EB  4C 11 C4    JMP .finishGetTile
  234                       
  235  06:C3EE            .getMarkTile:
  236  06:C3EE  A9 70       LDA #$70
  237  06:C3F0  4C 11 C4    JMP .finishGetTile
  238                     
  239  06:C3F3            .getClearTile:
  240                       
  241  06:C3F3  4E 00 00    LSR temp1
  242  06:C3F6  90 0A       BCC .checkB
  243  06:C3F8  AD 01 00    LDA temp2
  244  06:C3FB  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  245  06:C3FD  90 0D       BCC .clearTile
  246  06:C3FF  4C EE C3    JMP .getMarkTile
  247                       
  248  06:C402            .checkB:
  249                       
  250  06:C402  AD 01 00   LDA temp2
  251  06:C405  C9 8C      CMP #$8C
  252  06:C407  B0 03      BCS .clearTile
  253  06:C409  4C E9 C3   JMP .getXTile
  254                       
  255  06:C40C            .clearTile:
  256  06:C40C  A9 60       LDA #$60
  257  06:C40E  4C 11 C4    JMP .finishGetTile
  258                       
  259  06:C411            .finishGetTile:
  260  06:C411  8D 57 00    STA currentPaintTile
  261  06:C414  4C 1F C4    JMP .setTile
  262                     
  263                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  264                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  265                     ;;we can load the nametable into memory as we draw it
  266                     
  267  06:C417            .updatePaint:
  268                     
  269  06:C417  AD 12 00    LDA gamepad
  270  06:C41A  29 03       AND #GAMEPAD_AB
  271  06:C41C  D0 01       BNE .setTile
  272  06:C41E  60          RTS  
  273                       
  274  06:C41F            .setTile:
  275                     
  276                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  277  06:C41F  AD 56 00    LDA mouse_index+1
  278  06:C422  0A          ASL A
  279  06:C423  18          CLC
  280  06:C424  69 04       ADC #$04 ;; add to get past header
  281  06:C426  8D 00 00    STA temp1
  282                       
  283                       ;;div X position by 8 to get the byte index
  284  06:C429  AD 55 00    LDA mouse_index
  285  06:C42C  4A          LSR A
  286  06:C42D  4A          LSR A
  287  06:C42E  4A          LSR A
  288  06:C42F  F0 03       BEQ .getMask
  289                       
  290  06:C431  EE 00 00    INC temp1
  291                       
  292  06:C434            .getMask:
  293                       
  294  06:C434  AD 55 00    LDA mouse_index
  295  06:C437  29 07       AND #$07
  296  06:C439  AA          TAX
  297  06:C43A  A9 80       LDA #$80
  298  06:C43C  E0 00       CPX #$00
  299  06:C43E  F0 04       BEQ .storeMask
  300                     
  301  06:C440            .maskLoop:
  302  06:C440  4A          LSR A
  303  06:C441  CA          DEX
  304  06:C442  D0 FC       BNE .maskLoop
  305  06:C444            .storeMask:
  306  06:C444  8D 01 00    STA temp2
  307                     
  308  06:C447  AC 00 00    LDY temp1
  309  06:C44A  B1 43       LDA [puzzle_address], y
  310  06:C44C  2D 01 00    AND temp2
  311  06:C44F  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  312                     
  313  06:C452  A0 00       LDY #$00
  314  06:C454  B1 53       LDA [mouse_location], y
  315  06:C456  8D 02 00    STA temp3
  316  06:C459  29 F0       AND #$F0
  317  06:C45B  CD 57 00    CMP currentPaintTile
  318  06:C45E  D0 01       BNE .diffTiles
  319  06:C460  60          RTS
  320                       
  321  06:C461            .diffTiles:
  322                       ;;tiles are different- check if the current tile is marked as a solution tile
  323  06:C461  C9 70       CMP #$70
  324  06:C463  D0 0B       BNE .checkNewMark
  325                       ;;if erasing a mark, check if the tile was part of the solution
  326  06:C465  AD 00 00    LDA temp1
  327  06:C468  D0 18       BNE .antiMark
  328  06:C46A  CE 59 00    DEC nonSolutionCount
  329  06:C46D  4C 8B C4    JMP .overwriteTile
  330                       
  331  06:C470            .checkNewMark:
  332                     
  333  06:C470  AD 57 00    LDA currentPaintTile
  334  06:C473  C9 70       CMP #$70
  335  06:C475  D0 14       BNE .overwriteTile
  336                       
  337  06:C477  AD 00 00    LDA temp1
  338  06:C47A  D0 0C       BNE .proMark
  339  06:C47C  EE 59 00    INC nonSolutionCount 
  340  06:C47F  4C 8B C4    JMP .overwriteTile  
  341                       
  342  06:C482            .antiMark:
  343  06:C482  CE 58 00    DEC solutionCount
  344  06:C485  4C 8B C4    JMP .overwriteTile
  345  06:C488            .proMark:   
  346                       
  347  06:C488  EE 58 00    INC solutionCount
  348                       
  349  06:C48B            .overwriteTile:
  350                       ;;overwrite tile
  351  06:C48B  AD 02 00    LDA temp3
  352  06:C48E  29 0F       AND #$0F
  353  06:C490  0D 57 00    ORA currentPaintTile
  354  06:C493  A0 00       LDY #$00
  355  06:C495  91 53       STA [mouse_location], y
  356  06:C497  8D 00 00    STA temp1
  357                       
  358  06:C49A  AD 54 00    LDA mouse_location+1
  359  06:C49D  29 3F       AND #$3F
  360  06:C49F  8D 01 00    STA temp2
  361                         
  362                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C4A2  A9 01       LDA #$01
       06:C4A4  8D 1B 00    STA PPU_PendingWrite
       06:C4A7  AD 01 00    LDA temp2
       06:C4AA  20 11 C9    JSR WriteToPPUString
       06:C4AD  AD 53 00    LDA mouse_location
       06:C4B0  20 11 C9    JSR WriteToPPUString
       06:C4B3  A9 00       LDA #DRAW_HORIZONTAL
       06:C4B5  20 11 C9    JSR WriteToPPUString
       06:C4B8  A9 01       LDA #$01 
       06:C4BA  20 11 C9    JSR WriteToPPUString
                            
  363  06:C4BD  AD 00 00    LDA temp1
  364  06:C4C0  20 11 C9    JSR WriteToPPUString
  365                       
  366  06:C4C3            .checkSolution: 
  367                     
  368  06:C4C3  A0 01       LDY #$01
  369  06:C4C5  B1 43       LDA [puzzle_address], y
  370  06:C4C7  CD 58 00    CMP solutionCount
  371  06:C4CA  D0 1B       BNE .leave
  372  06:C4CC  AD 59 00    LDA nonSolutionCount
  373  06:C4CF  F0 03       BEQ .changeModeState
  374                       
  375  06:C4D1  4C E7 C4    JMP .leave
  376                       
  377                       ;;update the painting
  378  06:C4D4            .changeModeState:
  379                      
  380  06:C4D4  20 62 C9    JSR TurnOffSprites
  381                        
  382  06:C4D7  A9 00       LDA #$00
  383  06:C4D9  8D 49 00    STA clue_draw_address
  384  06:C4DC  8D 4C 00    STA clueLineIndex
  385  06:C4DF  A9 20       LDA #$20
  386  06:C4E1  8D 4A 00    STA clue_draw_address+1
  387                       
  388  06:C4E4  EE 09 00    INC mode_state
  389                     
  390  06:C4E7            .leave:
  391                      
  392  06:C4E7  60          RTS
  393                       
  394  06:C4E8            UpdateClearPuzzle:
  395                     
  396  06:C4E8  20 E9 CA    JSR ClearPuzzle
  397  06:C4EB  AD 4C 00    LDA clueLineIndex
  398  06:C4EE  C9 1E       CMP #30
  399  06:C4F0  D0 08       BNE .leave
  400                       
  401  06:C4F2            .changeModeState:
  402                     
  403  06:C4F2  A9 00       LDA #$00
  404  06:C4F4  8D 4C 00    STA clueLineIndex ;using this as a scroller
  405  06:C4F7  EE 09 00    INC mode_state
  406                     
  407  06:C4FA            .leave:
  408                      
  409  06:C4FA  60          RTS
  410  06:C4FB            UpdateMoveScreen:
  411                       
  412                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  413                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  414                       
  415  06:C4FB  AD 4C 00    LDA clueLineIndex
  416  06:C4FE  29 10       AND #$10
  417  06:C500  D0 1D       BNE .scrollY
  418                       
  419                       ;;scroll X over
  420  06:C502  AD 4C 00    LDA clueLineIndex
  421  06:C505  29 0F       AND #$0F
  422  06:C507  0A          ASL A
  423  06:C508  0A          ASL A
  424  06:C509  0A          ASL A ;mult by 8
  425  06:C50A  8D 17 00    STA PPU_ScrollX
  426                       
  427  06:C50D  EE 4C 00    INC clueLineIndex
  428  06:C510  AD 4C 00    LDA clueLineIndex
  429  06:C513  C9 06       CMP #$06
  430  06:C515  D0 49       BNE .leave
  431  06:C517  A9 10       LDA #$10
  432  06:C519  8D 4C 00    STA clueLineIndex
  433  06:C51C  4C 60 C5    JMP .leave
  434                       
  435  06:C51F            .scrollY:
  436                     
  437  06:C51F  AD 4C 00    LDA clueLineIndex
  438  06:C522  29 0F       AND #$0F
  439  06:C524  0A          ASL A
  440  06:C525  0A          ASL A
  441  06:C526  0A          ASL A ;mult by 8
  442  06:C527  8D 18 00    STA PPU_ScrollY
  443                     
  444  06:C52A  EE 4C 00    INC clueLineIndex
  445  06:C52D  AD 4C 00    LDA clueLineIndex
  446  06:C530  29 0F       AND #$0F
  447  06:C532  C9 05       CMP #$05
  448  06:C534  D0 2A       BNE .leave
  449                       
  450  06:C536            .changeModeState:
  451                     
  452  06:C536  A9 8E       LDA #$8E
  453  06:C538  8D 49 00    STA clue_draw_address
  454  06:C53B  A9 21       LDA #$21
  455  06:C53D  8D 4A 00    STA clue_draw_address+1
  456                       
  457  06:C540  AD 45 00    LDA clues_address
  458  06:C543  18          CLC
  459  06:C544  6D 4B 00    ADC clueTableIndex
  460  06:C547  8D 45 00    STA clues_address
  461  06:C54A  AD 46 00    LDA clues_address+1
  462  06:C54D  69 00       ADC #$00
  463  06:C54F  8D 46 00    STA clues_address+1
  464                       
  465  06:C552  A9 00       LDA #$00
  466  06:C554  8D 4B 00    STA clueTableIndex
  467  06:C557  8D 4C 00    STA clueLineIndex
  468  06:C55A  8D 4D 00    STA clueOffsetShift
  469                     
  470  06:C55D  EE 09 00    INC mode_state
  471                     
  472  06:C560            .leave:
  473                      
  474  06:C560  60          RTS
  475  06:C561            UpdateDrawImage:
  476  06:C561  20 35 CB    JSR DrawImage
  477  06:C564  AD 4C 00    LDA clueLineIndex
  478  06:C567  C9 E1       CMP #225
  479  06:C569  D0 62       BNE .leave
  480                       
  481  06:C56B            .changeModeState:
  482                     
  483                       ;;do a palette draw
  484                       ;;puzzle address + 03 has the desired palette offset
  485                     
  486  06:C56B  A0 03       LDY #$03
  487  06:C56D  B1 43       LDA [puzzle_address],y
  488  06:C56F  29 0F       AND #$0F
  489  06:C571  AA          TAX
  490                       
  491  06:C572  B1 43       LDA [puzzle_address],y
  492  06:C574  29 10       AND #$10
  493  06:C576  D0 15       BNE .storeBottomVals
  494                       
  495  06:C578  8A          TXA
  496  06:C579  09 10       ORA #$10
  497  06:C57B  8D 00 00    STA temp1
  498  06:C57E  8A          TXA
  499  06:C57F  09 20       ORA #$20
  500  06:C581  8D 01 00    STA temp2
  501  06:C584  8A          TXA
  502  06:C585  09 30       ORA #$30
  503  06:C587  8D 02 00    STA temp3
  504                     
  505  06:C58A  4C 9F C5    JMP .loadPalToPPUStr
  506                       
  507  06:C58D            .storeBottomVals:
  508                     
  509  06:C58D  8A          TXA
  510  06:C58E  09 00       ORA #$00
  511  06:C590  8D 00 00    STA temp1
  512  06:C593  8A          TXA
  513  06:C594  09 10       ORA #$10
  514  06:C596  8D 01 00    STA temp2
  515  06:C599  8A          TXA
  516  06:C59A  09 20       ORA #$20
  517  06:C59C  8D 02 00    STA temp3
  518                       
  519  06:C59F            .loadPalToPPUStr:
  520                       
  521                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C59F  A9 01       LDA #$01
       06:C5A1  8D 1B 00    STA PPU_PendingWrite
       06:C5A4  A9 3F       LDA #$3F
       06:C5A6  20 11 C9    JSR WriteToPPUString
       06:C5A9  A9 01       LDA #$01
       06:C5AB  20 11 C9    JSR WriteToPPUString
       06:C5AE  A9 00       LDA #DRAW_HORIZONTAL
       06:C5B0  20 11 C9    JSR WriteToPPUString
       06:C5B3  A9 03       LDA #03 
       06:C5B5  20 11 C9    JSR WriteToPPUString
                            
  522  06:C5B8  AD 00 00    LDA temp1
  523  06:C5BB  20 11 C9    JSR WriteToPPUString
  524  06:C5BE  AD 01 00    LDA temp2
  525  06:C5C1  20 11 C9    JSR WriteToPPUString
  526  06:C5C4  AD 02 00    LDA temp3
  527  06:C5C7  20 11 C9    JSR WriteToPPUString
  528                       
  529  06:C5CA  EE 09 00    INC mode_state
  530                     
  531  06:C5CD            .leave:
  532                      
  533  06:C5CD  60          RTS
  534  06:C5CE            UpdateWaitInput:
  535                     
  536  06:C5CE  AD 14 00    LDA gamepadPressed
  537  06:C5D1  F0 03       BEQ .leave
  538                       
  539  06:C5D3            .changeModeState:
  540                     
  541  06:C5D3  EE 09 00    INC mode_state
  542                     
  543  06:C5D6            .leave:
  544                      
  545  06:C5D6  60          RTS
  546                       
  547  06:C5D7            UpdateGameExit:
  548                     
  549  06:C5D7  A9 00       LDA #$00
  550  06:C5D9  8D 17 00    STA PPU_ScrollX
  551  06:C5DC  8D 18 00    STA PPU_ScrollY
  552  06:C5DF  8D 19 00    STA PPU_ScrollNT
  553                       
  554  06:C5E2  A9 02       LDA #GAMEOVER_IDX
  555  06:C5E4  20 0F C7    JSR ChangeGameMode
  556  06:C5E7  60          RTS
  557                       
  558  06:C5E8            MoveMouse:
  559                     
  560  06:C5E8  AD 00 00    LDA temp1
  561  06:C5EB  0E 00 00    ASL temp1
  562  06:C5EE  0E 00 00    ASL temp1
  563  06:C5F1  0E 00 00    ASL temp1
  564                       
  565  06:C5F4  AD 01 00    LDA temp2
  566  06:C5F7  0E 01 00    ASL temp2 
  567  06:C5FA  0E 01 00    ASL temp2
  568  06:C5FD  0E 01 00    ASL temp2
  569                       
  570  06:C600  A2 03       LDX #SPRITE_XPOS
  571  06:C602  BD 00 02    LDA SPRITE_DATA, x
  572  06:C605  18          CLC
  573  06:C606  6D 00 00    ADC temp1
  574                       ;;check against borders
  575  06:C609  C9 6A       CMP #HORI_MIN
  576  06:C60B  F0 07       BEQ .moveVert
  577  06:C60D  C9 EA       CMP #HORI_MAX
  578  06:C60F  F0 03       BEQ .moveVert
  579  06:C611  9D 00 02    STA SPRITE_DATA, x
  580                     
  581  06:C614            .moveVert:
  582                     
  583  06:C614  A2 00       LDX #SPRITE_YPOS
  584  06:C616  BD 00 02    LDA SPRITE_DATA, x
  585  06:C619  18          CLC
  586  06:C61A  6D 01 00    ADC temp2
  587                       ;;check against borders
  588  06:C61D  C9 5A       CMP #VERT_MIN
  589  06:C61F  F0 07       BEQ .leave
  590  06:C621  C9 DA       CMP #VERT_MAX
  591  06:C623  F0 03       BEQ .leave
  592  06:C625  9D 00 02    STA SPRITE_DATA, x
  593                     
  594  06:C628            .leave:
  595  06:C628  60          RTS
  596                             
  597  06:C629            UpdateMouseScreenPos:
  598                     
  599  06:C629  A2 00       LDX #$00
  600  06:C62B  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  601  06:C62E  4A          LSR A                                         ;0yyy yy..
  602  06:C62F  4A          LSR A                                         ;00yy yyy.
  603  06:C630  4A          LSR A                                         ;000y yyyy
  604  06:C631  8D 00 00    STA temp1
  605  06:C634  8D 56 00    STA mouse_index+1
  606  06:C637  E8          INX
  607  06:C638  E8          INX
  608  06:C639  E8          INX   
  609  06:C63A  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  610  06:C63D  29 F8       AND #$F8                       ;              ;  xxxx x000
  611  06:C63F  8D 01 00    STA temp2                      ;      ;  
  612  06:C642  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  613  06:C645  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  614  06:C648  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  615  06:C64B  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  616  06:C64E  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  617  06:C651  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  618  06:C654  AD 01 00    LDA temp2
  619  06:C657  29 1F       AND #$1F
  620  06:C659  8D 55 00    STA mouse_index
  621                       
  622  06:C65C  AD 55 00    LDA mouse_index
  623  06:C65F  38          SEC 
  624  06:C660  E9 0E       SBC #$0E
  625  06:C662  8D 55 00    STA mouse_index
  626                       
  627  06:C665  AD 56 00    LDA mouse_index+1
  628  06:C668  38          SEC 
  629  06:C669  E9 0C       SBC #$0C
  630  06:C66B  8D 56 00    STA mouse_index+1
  631                       
  632                       ;subtract starting offsets for mouse index
  633                       
  634  06:C66E  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  635  06:C671  09 60       ORA #$60                       ;              ;  0110 00yy
  636                       
  637  06:C673  8D 54 00    STA mouse_location+1
  638  06:C676  AD 01 00    LDA temp2
  639  06:C679  8D 53 00    STA mouse_location
  640                       
  641  06:C67C            .leave:
  642  06:C67C  60          RTS
  643                       
  644  06:C67D            UpdateTimeDisplay:
  645                     
  646  06:C67D  AD 06 00    LDA time
  647  06:C680  C9 3C       CMP #60
  648  06:C682  D0 77       BNE .leave
  649                       
  650  06:C684  A9 00       LDA #$00
  651  06:C686  8D 06 00    STA time
  652                       
  653  06:C689  EE 5B 00    INC GameTime
  654  06:C68C  AD 5B 00    LDA GameTime
  655  06:C68F  C9 0A       CMP #10
  656  06:C691  D0 32       BNE .printTime
  657                       
  658  06:C693  A9 00       LDA #$00
  659  06:C695  8D 5B 00    STA GameTime
  660  06:C698  EE 5C 00    INC GameTime+1
  661  06:C69B  AD 5C 00    LDA GameTime+1
  662  06:C69E  C9 06       CMP #6
  663  06:C6A0  D0 23       BNE .printTime
  664                       
  665  06:C6A2  A9 00       LDA #$00
  666  06:C6A4  8D 5C 00    STA GameTime+1
  667  06:C6A7  EE 5D 00    INC GameTime+2
  668  06:C6AA  AD 5D 00    LDA GameTime+2
  669  06:C6AD  C9 0A       CMP #10
  670  06:C6AF  D0 14       BNE .printTime
  671                       
  672  06:C6B1  A9 00       LDA #$00
  673  06:C6B3  8D 5D 00    STA GameTime+2
  674  06:C6B6  EE 5E 00    INC GameTime+3
  675  06:C6B9  AD 5E 00    LDA GameTime+3
  676  06:C6BC  C9 0A       CMP #10
  677  06:C6BE  D0 05       BNE .printTime
  678                       
  679  06:C6C0  A9 00       LDA #$00
  680  06:C6C2  8D 5E 00    STA GameTime+3
  681                       
  682  06:C6C5            .printTime:
  683                     
  684                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C6C5  A9 01       LDA #$01
       06:C6C7  8D 1B 00    STA PPU_PendingWrite
       06:C6CA  A9 20       LDA #HIGH(TIMER_LOC)
       06:C6CC  20 11 C9    JSR WriteToPPUString
       06:C6CF  A9 E5       LDA #LOW(TIMER_LOC)
       06:C6D1  20 11 C9    JSR WriteToPPUString
       06:C6D4  A9 00       LDA #DRAW_HORIZONTAL
       06:C6D6  20 11 C9    JSR WriteToPPUString
       06:C6D9  A9 05       LDA #$05 
       06:C6DB  20 11 C9    JSR WriteToPPUString
                            
  685  06:C6DE  AD 5E 00    LDA GameTime+3
  686  06:C6E1  20 11 C9    JSR WriteToPPUString
  687  06:C6E4  AD 5D 00    LDA GameTime+2
  688  06:C6E7  20 11 C9    JSR WriteToPPUString
  689  06:C6EA  A9 61       LDA #$61
  690  06:C6EC  20 11 C9    JSR WriteToPPUString
  691  06:C6EF  AD 5C 00    LDA GameTime+1
  692  06:C6F2  20 11 C9    JSR WriteToPPUString
  693  06:C6F5  AD 5B 00    LDA GameTime
  694  06:C6F8  20 11 C9    JSR WriteToPPUString
  695                       
  696                       
  697                       
  698  06:C6FB            .leave: 
  699  06:C6FB  60          RTS  
  700                     
  701                     ;;using the line index and a given count based on the direction, 
  702                       
  703                     ;;      JSR ResetMapper
  704                     ;;      INC currentCHRBank
  705                     ;;      LDA currentCHRBank
  706                     ;;      CMP #$03
  707                     ;;      BNE .dontModCHR
  708                             
  709                     ;;      LDA #$00
  710                     
  711                     ;;.dontModCHR:
  712                     ;;      STA currentCHRBank 
  713                     ;;      ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
  714                     ;;      ASL A
  715                     ;;      CLC 
  716                     ;;      ADC #$01
  717                     ;;      JSR LoadCHRBankB
  718                     ;;      
  719                     ;;      JSR ResetMapper
  720                     ;;      INC currentPRGBank
  721                     ;;      LDA currentPRGBank
  722                     ;;      CMP #$03
  723                     ;;      BNE .dontModPRG
  724                             
  725                     ;;      LDA #$00
  726                             
  727                     ;;.dontModPRG:
  728                     ;;       STA currentPRGBank
  729                     ;;       JSR LoadPRGBank
  730                      
  731                     ;;       JSR TestBankA
  732                     ;;       LDA mapperDebugVar
  733                     ;;       STA $6000
  734                     ;;       JMP .noInputDetected
  735                     
  736                     
  737                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   80                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C6FC            UpdateGameOver:
    2                     
    3  06:C6FC  20 59 C9    JSR TurnOnSprites
    4                       
    5  06:C6FF  AD 0A 00    LDA NMI_locks
    6  06:C702  D0 0A       BNE .noInputDetected
    7                     
    8  06:C704  AD 14 00    LDA gamepadPressed
    9  06:C707  F0 05       BEQ .noInputDetected
   10                       
   11  06:C709  A9 00         LDA #TITLE_IDX
   12  06:C70B  20 0F C7          JSR ChangeGameMode
   13                      
   14  06:C70E            .noInputDetected:
   15                      
   16  06:C70E  60          RTS
#[1]   Picross.asm
   81                       
   82                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   83                     ;;     Routines             ;;
   84                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   85                     
   86                     
#[2]   Routines/Common/GameModeRoutines.asm
   87                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C70F            ChangeGameMode:
    2  06:C70F  8D 08 00    STA game_mode
    3  06:C712  A9 00       LDA #$00
    4  06:C714  8D 09 00    STA mode_state
    5  06:C717  20 25 C9    JSR ClearPPUString
    6  06:C71A  20 1E C7    JSR LoadGameModeScreen
    7  06:C71D  60          RTS
    8                       
    9  06:C71E            LoadGameModeScreen:
   10                     
   11                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C71E  AD 0A 00    LDA NMI_locks
       06:C721  09 01       ORA #BGLOAD_NMI_LOCK
       06:C723  8D 0A 00    STA NMI_locks
                                  
   12                       
   13  06:C726  A9 00       LDA #$00
   14  06:C728  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   15                     
   16  06:C72B  20 59 C7    JSR LoadGameModeBackground
   17  06:C72E  20 9C C7    JSR LoadGameModeSprites
   18                     
   19                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C731  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C733  49 FF       EOR #$FF
       06:C735  2D 0A 00    AND NMI_locks  
       06:C738  8D 0A 00    STA NMI_locks
                          
   20                     
   21                       
   22                       ;; load the CHR bank for this mode
   23  06:C73B  20 A6 C9    JSR ResetMapper
   24                       ;;remember, we're loading the SECOND set in each chr bank
   25                       ;;so we'll take the index from the game mode chr table and add one mult 2
   26  06:C73E  AE 08 00    LDX game_mode
   27  06:C741  BD B9 C7    LDA gameModeInitCHRROMB, x
   28  06:C744  0A          ASL A
   29  06:C745  18          CLC 
   30  06:C746  69 01       ADC #$01
   31  06:C748  20 CB C9    JSR LoadCHRBankB
   32                       
   33  06:C74B  20 A6 C9    JSR ResetMapper
   34  06:C74E  AE 08 00    LDX game_mode
   35  06:C751  BD BC C7    LDA gameModeInitCHRROMA, x
   36  06:C754  0A          ASL A
   37  06:C755  20 C0 C9    JSR LoadCHRBankA
   38                       
   39                       
   40                       
   41  06:C758  60          RTS
   42                       
   43  06:C759            LoadGameModeBackground:
   44                             
   45                       MACROGetDoubleIndex game_mode
                          
       06:C759  AD 08 00          LDA game_mode
       06:C75C  0A                ASL A
       06:C75D  A8                TAY
                                  
   46  06:C75E  8C 00 00    STY temp1
   47                             
   48                       MACROGetLabelPointer Palettes, table_address
                          
       06:C761  A9 E0             LDA #HIGH(Palettes)
       06:C763  A2 00             LDX #LOW(Palettes)
                                  
       06:C765  8E 0E 00          STX table_address
       06:C768  8D 0F 00          STA table_address+1
                                  
   49  06:C76B  20 E5 C7    JSR GetTableAtIndex
   50                     
   51  06:C76E  20 F2 C7    JSR LoadFullPaletteFromTable
   52                             
   53  06:C771  AC 00 00    LDY temp1
   54                       MACROGetLabelPointer NameTables, table_address
                          
       06:C774  A9 E0             LDA #HIGH(NameTables)
       06:C776  A2 06             LDX #LOW(NameTables)
                                  
       06:C778  8E 0E 00          STX table_address
       06:C77B  8D 0F 00          STA table_address+1
                                  
   55  06:C77E  20 E5 C7    JSR GetTableAtIndex
   56                             
   57  06:C781  A9 00       LDA #$00
   58  06:C783  20 12 C8    JSR LoadFullBackgroundFromTable
   59                       
   60  06:C786  AC 00 00    LDY temp1
   61                       MACROGetLabelPointer NameTables2, table_address
                          
       06:C789  A9 E0             LDA #HIGH(NameTables2)
       06:C78B  A2 0C             LDX #LOW(NameTables2)
                                  
       06:C78D  8E 0E 00          STX table_address
       06:C790  8D 0F 00          STA table_address+1
                                  
   62  06:C793  20 E5 C7    JSR GetTableAtIndex
   63                       
   64  06:C796  A9 01       LDA #$01
   65  06:C798  20 12 C8    JSR LoadFullBackgroundFromTable
   66                       
   67  06:C79B  60          RTS
   68                       
   69  06:C79C            LoadGameModeSprites:
   70                     
   71                       MACROGetDoubleIndex game_mode  
                          
       06:C79C  AD 08 00          LDA game_mode
       06:C79F  0A                ASL A
       06:C7A0  A8                TAY
                                  
   72                       MACROGetLabelPointer Sprites, table_address
                          
       06:C7A1  A9 F4             LDA #HIGH(Sprites)
       06:C7A3  A2 72             LDX #LOW(Sprites)
                                  
       06:C7A5  8E 0E 00          STX table_address
       06:C7A8  8D 0F 00          STA table_address+1
                                  
   73  06:C7AB  20 E5 C7    JSR GetTableAtIndex
   74  06:C7AE  A0 00       LDY #$00
   75  06:C7B0  B1 0E       LDA [table_address],y
   76  06:C7B2  EE 0E 00    INC table_address
   77  06:C7B5  20 FA C8    JSR LoadSprites_impl
   78                       
   79  06:C7B8  60          RTS
   80                       
   81  06:C7B9            gameModeInitCHRROMB:
   82  06:C7B9  00 02 02          .db $00, $02, $02
   83  06:C7BC            gameModeInitCHRROMA:
   84  06:C7BC  00 02 02          .db $00, $02, $02
   85                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   88                       .include "Routines/Utils/PointerUtils.asm"
    1  06:C7BF            Dynamic_Jump:
    2                     
    3  06:C7BF  0A          ASL A                                 ;; double the index passed into A
    4  06:C7C0  8E 04 00    STX tempx
    5  06:C7C3  8C 05 00    STY tempy
    6  06:C7C6  A8          TAY
    7  06:C7C7  C8          INY  
    8  06:C7C8  68          PLA
    9  06:C7C9  8D 10 00    STA jump_address
   10  06:C7CC  68          PLA 
   11  06:C7CD  8D 11 00    STA jump_address+1            
   12  06:C7D0  B1 10       LDA [jump_address], y
   13  06:C7D2  AA          TAX
   14  06:C7D3  C8          INY
   15  06:C7D4  B1 10       LDA [jump_address], y
   16  06:C7D6  8E 10 00    STX jump_address
   17  06:C7D9  8D 11 00    STA jump_address+1
   18  06:C7DC  AE 04 00    LDX tempx
   19  06:C7DF  AC 05 00    LDY tempy
   20  06:C7E2  6C 10 00    JMP [jump_address]
   21                       
   22  06:C7E5            GetTableAtIndex:
   23                     
   24  06:C7E5  B1 0E             LDA [table_address], y
   25  06:C7E7  AA                TAX
   26  06:C7E8  C8                INY
   27  06:C7E9  B1 0E             LDA [table_address], y
   28                             
   29  06:C7EB            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:C7EB  8E 0E 00          STX table_address
   33  06:C7EE  8D 0F 00          STA table_address+1
   34  06:C7F1  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   89                       .include "Routines/Utils/PPUUtils.asm"
    1  06:C7F2            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:C7F2  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C7F5  A9 3F       LDA #HIGH($3F00)
       06:C7F7  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C7FA  A9 00       LDA #LOW($3F00)
       06:C7FC  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:C7FF  A0 00       LDY #$00              ; start out at 0
    5  06:C801  A2 00       LDX #$00
    6  06:C803            .loop:
    7  06:C803  B1 0E       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:C805  8D 07 20    STA PPU_DATA            ; write to PPU
    9  06:C808  9D 00 68    STA Palette_Copy, x
   10  06:C80B  C8          INY                   ; X = X + 1
   11  06:C80C  E8          INX
   12  06:C80D  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   13  06:C80F  D0 F2       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   14  06:C811  60          RTS
   15                     
   16  06:C812            LoadFullBackgroundFromTable:
   17                     
   18                         ;;use A as an index for which nametable to write to
   19  06:C812  20 45 C9          JSR SetNametableFromIndex
   20  06:C815  8A                TXA
   21  06:C816  4A                LSR A
   22  06:C817  29 01             AND #$01
   23  06:C819  D0 0D             BNE .copyScreenB
   24                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:C81B  A9 60             LDA #HIGH(Screen_Copy)
       06:C81D  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:C81F  8E 0C 00          STX pointer_address
       06:C822  8D 0D 00          STA pointer_address+1
                                  
   25  06:C825  4C 32 C8          JMP .setCounters
   26                             
   27  06:C828            .copyScreenB:
   28                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:C828  A9 64             LDA #HIGH(ScreenB_Copy)
       06:C82A  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:C82C  8E 0C 00          STX pointer_address
       06:C82F  8D 0D 00          STA pointer_address+1
                                  
   29                             
   30                             ;;set pointer
   31                             ;; set counters
   32  06:C832            .setCounters:
   33  06:C832  A0 00             LDY #$00
   34  06:C834  A2 00             LDX #$00
   35                             
   36                             ;;start loop
   37                     
   38  06:C836            .outerloop:
   39                     
   40  06:C836            .innerloop:
   41                     
   42  06:C836  B1 0E             LDA [table_address], y
   43  06:C838  8D 07 20          STA PPU_DATA
   44  06:C83B  91 0C             STA [pointer_address],y
   45  06:C83D  C8                INY
   46  06:C83E  C0 00             CPY #$00
   47  06:C840  D0 F4             BNE .innerloop
   48                     
   49  06:C842  EE 0D 00          INC pointer_address+1
   50  06:C845  EE 0F 00          INC table_address+1
   51                             
   52  06:C848  E8                INX
   53  06:C849  E0 04             CPX #$04
   54  06:C84B  D0 E9             BNE .outerloop
   55  06:C84D  60                RTS
   56                             
   57                     
   58           0000      DATA_LEN = temp1
   59           0001      WRITE_SETTINGS = temp2
   60                             
   61  06:C84E            ProcessPPUString:
   62                     
   63  06:C84E  AD 1B 00          LDA PPU_PendingWrite
   64  06:C851  D0 01             BNE .continueProcess
   65  06:C853  60                RTS
   66                             
   67  06:C854            .continueProcess:
   68  06:C854  A0 00             LDY #$00
   69                             
   70  06:C856  A9 1D             LDA #LOW(PPU_String)
   71  06:C858  8D 0C 00          STA pointer_address
   72  06:C85B  A9 00             LDA #HIGH(PPU_String)
   73  06:C85D  8D 0D 00          STA pointer_address + 1
   74                     
   75  06:C860            .outerloop:
   76  06:C860  AD 02 20          LDA PPU_STATUS
   77  06:C863  B1 0C             LDA [pointer_address], y
   78  06:C865  F0 79             BEQ .finish
   79  06:C867  8D 06 20          STA PPU_ADDR
   80  06:C86A  C8                INY
   81  06:C86B  B1 0C             LDA [pointer_address], y
   82  06:C86D  8D 06 20          STA PPU_ADDR
   83  06:C870  C8            INY 
   84  06:C871  B1 0C             LDA [pointer_address], y
   85  06:C873  8D 01 00          STA WRITE_SETTINGS
   86  06:C876  C8                INY
   87                             
   88  06:C877  AD 00 20          LDA PPU_CTRL
   89  06:C87A  29 FB             AND #$FB
   90  06:C87C  8D 00 20          STA PPU_CTRL
   91                             
   92  06:C87F  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
   93  06:C882  29 80             AND #%10000000
   94  06:C884  F0 06             BEQ .checkRepeat
   95  06:C886  0D 00 20          ORA PPU_CTRL 
   96  06:C889  8D 00 20          STA PPU_CTRL 
   97                             
   98                             
   99  06:C88C            .checkRepeat:
  100  06:C88C  AD 01 00    LDA WRITE_SETTINGS
  101  06:C88F  29 40       AND #%01000000
  102  06:C891  F0 19       BEQ .checkTable
  103                       
  104  06:C893  AD 01 00    LDA WRITE_SETTINGS
  105  06:C896  29 3F       AND #$3F
  106  06:C898  8D 00 00    STA DATA_LEN
  107                       ;;the usual data length byte is now the repeatable byte
  108  06:C89B  A2 00       LDX #$00
  109                       
  110  06:C89D            .repeatLoop:
  111  06:C89D  B1 0C       LDA [pointer_address], y
  112  06:C89F  8D 07 20    STA PPU_DATA
  113  06:C8A2  E8          INX 
  114  06:C8A3  EC 00 00    CPX DATA_LEN
  115  06:C8A6  D0 F5       BNE .repeatLoop
  116  06:C8A8  C8          INY
  117  06:C8A9  4C 60 C8    JMP .outerloop
  118                             
  119  06:C8AC            .checkTable:
  120  06:C8AC  AD 01 00          LDA WRITE_SETTINGS
  121  06:C8AF  29 20             AND #%00100000
  122  06:C8B1  F0 16             BEQ .rawData
  123                             
  124  06:C8B3  B1 0C             LDA [pointer_address], y
  125  06:C8B5  8D 0E 00          STA table_address
  126  06:C8B8  C8                INY 
  127  06:C8B9  B1 0C             LDA [pointer_address], y
  128  06:C8BB  8D 0F 00          STA table_address + 1
  129  06:C8BE  C8                INY
  130  06:C8BF  98                TYA 
  131  06:C8C0  48                PHA
  132  06:C8C1  20 E4 C8          JSR WriteToPPUFromTable
  133  06:C8C4  68                PLA
  134  06:C8C5  A8                TAY
  135  06:C8C6  4C 60 C8          JMP .outerloop
  136                             
  137  06:C8C9            .rawData:
  138                     
  139  06:C8C9  B1 0C             LDA [pointer_address], y
  140  06:C8CB  C8                INY
  141  06:C8CC  8D 00 00          STA DATA_LEN
  142                     
  143  06:C8CF  A2 00             LDX #$00
  144                     
  145  06:C8D1            .innerloop:
  146                             
  147  06:C8D1  B1 0C             LDA [pointer_address], y
  148  06:C8D3  8D 07 20          STA PPU_DATA
  149  06:C8D6  C8                INY
  150  06:C8D7  E8                INX
  151  06:C8D8  EC 00 00          CPX DATA_LEN
  152  06:C8DB  D0 F4             BNE .innerloop
  153  06:C8DD  4C 60 C8          JMP .outerloop
  154                             
  155  06:C8E0            .finish:
  156  06:C8E0  20 25 C9          JSR ClearPPUString
  157  06:C8E3            .leave:
  158  06:C8E3  60                RTS
  159                             
  160  06:C8E4            WriteToPPUFromTable:
  161  06:C8E4  A0 00             LDY #$00
  162  06:C8E6  B1 0E             LDA [table_address], y
  163  06:C8E8  C8                INY
  164  06:C8E9  8D 00 00          STA DATA_LEN
  165  06:C8EC            .innerloop:
  166  06:C8EC  B1 0E             LDA [table_address], y
  167  06:C8EE  8D 07 20          STA PPU_DATA
  168  06:C8F1  C8                INY
  169  06:C8F2  CC 00 00          CPY DATA_LEN
  170  06:C8F5  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  171  06:C8F7  F0 F3             BEQ .innerloop
  172  06:C8F9  60                RTS
  173                       
  174  06:C8FA            LoadSprites_impl:
  175                       ;;A will be the amount of sprites to load
  176  06:C8FA  8D 00 00    STA DATA_LEN
  177  06:C8FD  0E 00 00    ASL DATA_LEN
  178  06:C900  0E 00 00    ASL DATA_LEN
  179                       
  180  06:C903  A0 00       LDY #$00              ; start at 0
  181                       
  182  06:C905            .loop:
  183  06:C905  B1 0E       LDA [table_address], y; load data from address (sprites +  x)
  184  06:C907  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  185  06:C90A  C8          INY                   ; X = X + 1
  186  06:C90B  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  187  06:C90E  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  188                                             ; if compare was equal to 16, keep going down   
  189  06:C910  60          RTS
  190                     
  191                     
  192  06:C911            WriteToPPUString:
  193                     
  194  06:C911  AE 1C 00          LDX PPU_StringIdx
  195  06:C914  E0 20             CPX #PPU_STRINGMAX
  196  06:C916  F0 0C             BEQ .finish
  197                             
  198  06:C918  9D 1D 00          STA PPU_String, x
  199  06:C91B  EE 1C 00          INC PPU_StringIdx
  200  06:C91E  E8                INX
  201  06:C91F  A9 00             LDA #$00
  202  06:C921  9D 1D 00          STA PPU_String, x
  203                                     
  204  06:C924            .finish:
  205  06:C924  60                RTS
  206                     
  207  06:C925            ClearPPUString:
  208                             
  209  06:C925  A9 00             LDA #$00
  210  06:C927  8D 1C 00          STA PPU_StringIdx
  211  06:C92A  8D 1D 00          STA PPU_String
  212  06:C92D  8D 1B 00          STA PPU_PendingWrite
  213  06:C930  60                RTS
  214                     
  215  06:C931            DetectSprite0:
  216  06:C931            WaitNotSprite0:
  217  06:C931  AD 02 20    lda PPU_STATUS
  218  06:C934  29 40       and #SPRITE_0_MASK
  219  06:C936  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  220                     
  221  06:C938            WaitSprite0:
  222  06:C938  AD 02 20    lda $2002
  223  06:C93B  29 40       and #SPRITE_0_MASK
  224  06:C93D  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  225                     
  226  06:C93F  A2 05       ldx #$05                              ;do a scanline wait
  227  06:C941            WaitScanline:
  228  06:C941  CA          dex
  229  06:C942  D0 FD       bne WaitScanline
  230  06:C944  60          RTS
  231                     
  232                     
  233  06:C945            SetNametableFromIndex:
  234                     
  235  06:C945  48          PHA
  236  06:C946  AD 02 20    LDA PPU_STATUS
  237  06:C949  68          PLA
  238  06:C94A  0A          ASL A
  239  06:C94B  AA          TAX
  240  06:C94C  BD 8F C9    LDA NameTableMemList+1, x
  241  06:C94F  8D 06 20    STA PPU_ADDR
  242  06:C952  BD 8E C9    LDA NameTableMemList, x
  243  06:C955  8D 06 20    STA PPU_ADDR
  244  06:C958  60          RTS
  245                       
  246  06:C959            TurnOnSprites:
  247                      
  248  06:C959  AD 16 00    LDA PPU_Mask
  249  06:C95C  09 10       ORA #%00010000
  250  06:C95E  8D 16 00    STA PPU_Mask
  251  06:C961  60          RTS
  252                       
  253  06:C962            TurnOffSprites:
  254                       
  255  06:C962  AD 16 00    LDA PPU_Mask
  256  06:C965  29 EF       AND #%11101111
  257  06:C967  8D 16 00    STA PPU_Mask
  258  06:C96A  60          RTS
  259                     
  260  06:C96B            UpdatePPUControl:
  261                     
  262  06:C96B  AD 15 00    LDA PPU_Control
  263  06:C96E  29 FC       AND #$FC
  264  06:C970  0D 1A 00    ORA PPU_NT
  265  06:C973  8D 00 20    STA PPU_CTRL
  266  06:C976  AD 16 00    LDA PPU_Mask
  267  06:C979  8D 01 20    STA PPU_MASK
  268  06:C97C  60          RTS
  269                       
  270  06:C97D            InitPPUControl:
  271                       
  272                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  273                       ; enable sprites, enable background, no clipping on left side
  274  06:C97D  A9 90       LDA #%10010000
  275  06:C97F  8D 00 20    STA PPU_CTRL
  276  06:C982  8D 15 00    STA PPU_Control
  277  06:C985  A9 1E       LDA #%00011110
  278  06:C987  8D 01 20    STA PPU_MASK
  279  06:C98A  8D 16 00    STA PPU_Mask
  280  06:C98D  60          RTS
  281                     
  282  06:C98E            NameTableMemList:
  283  06:C98E  00 20       .word $2000, $2400, $2800, $2C00
       06:C990  00 24     
       06:C992  00 28     
       06:C994  00 2C     
  284  06:C996            PalettesMemList:
  285  06:C996  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:C998  04 3F     
       06:C99A  08 3F     
       06:C99C  0C 3F     
  286  06:C99E  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:C9A0  14 3F     
       06:C9A2  18 3F     
       06:C9A4  1C 3F     
  287                       
  288           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   90                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:C9A6            ResetMapper:
    7  06:C9A6  EE A6 C9    inc ResetMapper
    8  06:C9A9  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:C9AA            SetMapperControls:
   23                       ;;A = controls
   24  06:C9AA  AA          TAX
   25  06:C9AB  A9 80       LDA #MAPPERCONTROL
   26  06:C9AD  8D 3E 00    STA mapper_address+1
   27  06:C9B0  8A          TXA
   28  06:C9B1  20 D6 C9    JSR SendMapperCommand
   29  06:C9B4  60          RTS
   30                     
   31  06:C9B5            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:C9B5  AA                TAX
   35  06:C9B6  A9 E0             LDA #PRGBANK
   36  06:C9B8  8D 3E 00          STA mapper_address+1
   37  06:C9BB  8A                TXA
   38  06:C9BC  20 D6 C9          JSR SendMapperCommand
   39  06:C9BF  60                RTS
   40                             
   41  06:C9C0            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:C9C0  AA                TAX
   44  06:C9C1  A9 A0             LDA #CHRBANK1
   45  06:C9C3  8D 3E 00          STA mapper_address+1
   46  06:C9C6  8A                TXA
   47  06:C9C7  20 D6 C9          JSR SendMapperCommand
   48  06:C9CA  60                RTS
   49                             
   50  06:C9CB            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:C9CB  AA                TAX
   53  06:C9CC  A9 C0             LDA #CHRBANK2
   54  06:C9CE  8D 3E 00          STA mapper_address+1
   55  06:C9D1  8A                TXA
   56  06:C9D2  20 D6 C9          JSR SendMapperCommand
   57  06:C9D5  60                RTS
   58                             
   59  06:C9D6            SendMapperCommand:
   60                     
   61  06:C9D6  A0 00             LDY #$00
   62                             
   63  06:C9D8  91 3D             STA [mapper_address], y
   64  06:C9DA  4A                LSR A
   65  06:C9DB  91 3D             STA [mapper_address], y
   66  06:C9DD  4A                LSR A
   67  06:C9DE  91 3D             STA [mapper_address], y
   68  06:C9E0  4A                LSR A 
   69  06:C9E1  91 3D             STA [mapper_address], y
   70  06:C9E3  4A                LSR A
   71  06:C9E4  91 3D             STA [mapper_address], y
   72                             
   73  06:C9E6  60                RTS
   74                             
   75  06:C9E7            ResetBanks:
   76                     
   77  06:C9E7  20 A6 C9          JSR ResetMapper
   78  06:C9EA  A9 00             LDA #$00
   79  06:C9EC  20 B5 C9          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:C9EF  20 A6 C9          JSR ResetMapper
   83  06:C9F2  A9 00             LDA #$00
   84  06:C9F4  20 C0 C9          JSR LoadCHRBankA
   85  06:C9F7  A9 01             LDA #$01
   86  06:C9F9  20 CB C9          JSR LoadCHRBankB
   87  06:C9FC  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   91                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:C9FD            PopulateClues:
    2                     
    3  06:C9FD            .getByte:
    4  06:C9FD  AC 4B 00    LDY clueTableIndex
    5  06:CA00  B1 45       LDA [clues_address], y
    6  06:CA02  D0 07       BNE .checkNewLine
    7  06:CA04  EE 4B 00    INC clueTableIndex
    8  06:CA07  A9 00       LDA #$00
    9  06:CA09  F0 38       BEQ .drawClue
   10                       ;was 0, set up a draw
   11  06:CA0B            .checkNewLine
   12  06:CA0B  C9 FF       CMP #$FF
   13  06:CA0D  D0 17       BNE .getClue
   14                       
   15                       ;;was FF- need to inc stuff
   16  06:CA0F  EE 4B 00    INC clueTableIndex
   17  06:CA12  A9 00       LDA #$00
   18  06:CA14  8D 52 00    STA clueParity
   19                       
   20  06:CA17  EE 4C 00    INC clueLineIndex
   21  06:CA1A  AD 4C 00    LDA clueLineIndex
   22  06:CA1D  C9 0F       CMP #$0F
   23                       ;CMP #$01
   24  06:CA1F  F0 28       BEQ .leave    ;carry will be set
   25                       
   26  06:CA21  20 BB CA    JSR CreateOffsetFromIndex
   27                      
   28  06:CA24  D0 D7       BNE .getByte
   29                       
   30  06:CA26            .getClue:
   31                       ;;clues go from high nibble to low nibble
   32  06:CA26  48          PHA 
   33  06:CA27  AD 52 00    LDA clueParity
   34  06:CA2A  D0 0A       BNE .getSecondClue
   35  06:CA2C  EE 52 00    INC clueParity
   36  06:CA2F  68          PLA
   37  06:CA30  4A          LSR A
   38  06:CA31  4A          LSR A
   39  06:CA32  4A          LSR A
   40  06:CA33  4A          LSR A         ;move clue over to lower nibble
   41  06:CA34  D0 0D       BNE .drawClue
   42                       
   43  06:CA36            .getSecondClue:
   44                     
   45  06:CA36  CE 52 00    DEC clueParity
   46  06:CA39  EE 4B 00    INC clueTableIndex
   47  06:CA3C  68          PLA 
   48  06:CA3D  29 0F       AND #$0F
   49  06:CA3F  D0 02       BNE .drawClue
   50                       ;;if 0, skip
   51  06:CA41  F0 BA       BEQ .getByte
   52                      
   53  06:CA43            .drawClue:
   54                       
   55  06:CA43  09 40       ORA #$40
   56  06:CA45  20 4A CA    JSR WriteClueByteToPPUString
   57  06:CA48  18          CLC
   58                       
   59  06:CA49            .leave:
   60  06:CA49  60          RTS
   61                       
   62  06:CA4A            WriteClueByteToPPUString:
   63                     
   64  06:CA4A  8D 00 00    STA temp1 ;store off the tile value
   65                     
   66                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:CA4D  A9 01       LDA #$01
       06:CA4F  8D 1B 00    STA PPU_PendingWrite
       06:CA52  AD 4A 00    LDA clue_draw_address+1
       06:CA55  20 11 C9    JSR WriteToPPUString
       06:CA58  AD 49 00    LDA clue_draw_address
       06:CA5B  20 11 C9    JSR WriteToPPUString
       06:CA5E  A9 00       LDA #DRAW_HORIZONTAL
       06:CA60  20 11 C9    JSR WriteToPPUString
       06:CA63  A9 01       LDA #$01 
       06:CA65  20 11 C9    JSR WriteToPPUString
                            
   67  06:CA68  AD 00 00    LDA temp1
   68  06:CA6B  20 11 C9    JSR WriteToPPUString
   69                       
   70  06:CA6E  AD 50 00    LDA clueDrawAdd
   71  06:CA71  20 98 CA    JSR SubFromClueDrawAddress
   72                         
   73  06:CA74  60          RTS
   74                       
   75  06:CA75            ResetClueDrawAddress:
   76                     
   77                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:CA75  AD 47 00          LDA clue_start_address
       06:CA78  8D 49 00          STA clue_draw_address
       06:CA7B  AD 48 00          LDA clue_start_address+1
       06:CA7E  8D 4A 00          STA clue_draw_address+1
                          
   78                       
   79  06:CA81  60          RTS
   80                       
   81  06:CA82            AddToClueDrawAddress:
   82                     
   83  06:CA82  8D 00 00    STA temp1
   84                       
   85  06:CA85  AD 49 00    LDA clue_draw_address
   86  06:CA88  18          CLC
   87  06:CA89  6D 00 00    ADC temp1
   88  06:CA8C  8D 49 00    STA clue_draw_address
   89  06:CA8F  AD 4A 00    LDA clue_draw_address+1
   90  06:CA92  69 00       ADC #$00
   91  06:CA94  8D 4A 00    STA clue_draw_address+1
   92                       
   93  06:CA97  60          RTS
   94                         
   95  06:CA98            SubFromClueDrawAddress:
   96                     
   97  06:CA98  8D 00 00    STA temp1
   98                       
   99  06:CA9B  AD 49 00    LDA clue_draw_address
  100  06:CA9E  38          SEC
  101  06:CA9F  ED 00 00    SBC temp1
  102  06:CAA2  8D 49 00    STA clue_draw_address
  103  06:CAA5  AD 4A 00    LDA clue_draw_address+1
  104  06:CAA8  E9 00       SBC #$00
  105  06:CAAA  8D 4A 00    STA clue_draw_address+1
  106                       
  107  06:CAAD  60          RTS
  108                       
  109  06:CAAE            AddToClueDrawAddressHi:
  110                     
  111  06:CAAE  8D 00 00    STA temp1
  112                       
  113  06:CAB1  AD 4A 00    LDA clue_draw_address+1
  114  06:CAB4  6D 00 00    ADC temp1
  115  06:CAB7  8D 4A 00    STA clue_draw_address+1
  116                       
  117  06:CABA  60          RTS
  118                       
  119  06:CABB            CreateOffsetFromIndex:
  120                     
  121                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  122  06:CABB  AD 4C 00    LDA clueLineIndex
  123  06:CABE  8D 4E 00    STA clueDrawOffset
  124  06:CAC1  A9 00       LDA #$00
  125  06:CAC3  8D 4F 00    STA clueDrawOffset+1
  126                       
  127  06:CAC6  AD 4D 00    LDA clueOffsetShift   
  128  06:CAC9  F0 0E       BEQ .addOffset
  129                       
  130  06:CACB  A2 00       LDX #$00
  131                       
  132  06:CACD            .loopShift:
  133  06:CACD  0E 4E 00    ASL clueDrawOffset
  134  06:CAD0  2E 4F 00    ROL clueDrawOffset+1
  135  06:CAD3  E8          INX
  136  06:CAD4  EC 4D 00    CPX clueOffsetShift
  137  06:CAD7  D0 F4       BNE .loopShift
  138                       
  139  06:CAD9            .addOffset:
  140                       
  141  06:CAD9  20 75 CA    JSR ResetClueDrawAddress
  142  06:CADC  AD 4E 00    LDA clueDrawOffset
  143  06:CADF  20 82 CA    JSR AddToClueDrawAddress 
  144  06:CAE2  AD 4F 00    LDA clueDrawOffset+1
  145  06:CAE5  20 AE CA    JSR AddToClueDrawAddressHi
  146                       
  147  06:CAE8  60          RTS  
  148                       
  149  06:CAE9            ClearPuzzle:
  150                     
  151                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  152                      
  153                       MACROGetLabelPointer ClearLineDefTables, table_address
                          
       06:CAE9  A9 CB             LDA #HIGH(ClearLineDefTables)
       06:CAEB  A2 BE             LDX #LOW(ClearLineDefTables)
                                  
       06:CAED  8E 0E 00          STX table_address
       06:CAF0  8D 0F 00          STA table_address+1
                                  
  154  06:CAF3  A0 00       LDY #$00
  155  06:CAF5  20 E5 C7    JSR GetTableAtIndex
  156                       
  157                       
  158  06:CAF8  AC 4C 00    LDY clueLineIndex
  159  06:CAFB  B1 0E       LDA [table_address], y
  160  06:CAFD  8D 00 00    STA temp1
  161                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:CB00  A9 01       LDA #$01
       06:CB02  8D 1B 00    STA PPU_PendingWrite
       06:CB05  AD 4A 00    LDA clue_draw_address+1
       06:CB08  20 11 C9    JSR WriteToPPUString
       06:CB0B  AD 49 00    LDA clue_draw_address
       06:CB0E  20 11 C9    JSR WriteToPPUString
       06:CB11  A9 40       LDA #$40
       06:CB13  09 00       ORA #DRAW_HORIZONTAL
       06:CB15  0D 00 00    ORA temp1
       06:CB18  20 11 C9    JSR WriteToPPUString
       06:CB1B  A9 24       LDA #$24
       06:CB1D  20 11 C9    JSR WriteToPPUString
                            
  162                       ;;no need to load anything else
  163                       
  164  06:CB20  AD 49 00    LDA clue_draw_address
  165  06:CB23  18          CLC
  166  06:CB24  69 20       ADC #32
  167  06:CB26  8D 49 00    STA clue_draw_address
  168  06:CB29  AD 4A 00    LDA clue_draw_address+1
  169  06:CB2C  69 00       ADC #$00
  170  06:CB2E  8D 4A 00    STA clue_draw_address+1
  171                       
  172  06:CB31  EE 4C 00    INC clueLineIndex
  173  06:CB34  60          RTS
  174                       
  175  06:CB35            DrawImage:
  176                     
  177                       ;;we have clueTableIndex, which should be at the image bytes now
  178                       ;;clue line index will keep track of our place in a byte
  179                        
  180  06:CB35  A9 00       LDA #$00
  181  06:CB37  8D 00 00    STA temp1
  182                       
  183  06:CB3A  AD 4C 00    LDA clueLineIndex
  184  06:CB3D  29 03       AND #$03
  185  06:CB3F  8D 01 00    STA temp2
  186                     
  187  06:CB42  AC 4B 00    LDY clueTableIndex
  188  06:CB45  B1 45       LDA [clues_address], y
  189                     
  190  06:CB47  A2 00       LDX #$00
  191  06:CB49            .loop:
  192  06:CB49  0A          ASL A
  193  06:CB4A  2E 00 00    ROL temp1
  194  06:CB4D  0A          ASL A
  195  06:CB4E  2E 00 00    ROL temp1
  196  06:CB51  E8          INX
  197  06:CB52  EC 01 00    CPX temp2
  198  06:CB55  90 F2       BCC .loop
  199  06:CB57  F0 F0       BEQ .loop
  200                       
  201  06:CB59  AD 00 00    LDA temp1
  202  06:CB5C  29 03       AND #$03
  203  06:CB5E  18          CLC
  204  06:CB5F  69 24       ADC #$24
  205  06:CB61  8D 00 00    STA temp1
  206                       
  207                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:CB64  A9 01       LDA #$01
       06:CB66  8D 1B 00    STA PPU_PendingWrite
       06:CB69  AD 4A 00    LDA clue_draw_address+1
       06:CB6C  20 11 C9    JSR WriteToPPUString
       06:CB6F  AD 49 00    LDA clue_draw_address
       06:CB72  20 11 C9    JSR WriteToPPUString
       06:CB75  A9 00       LDA #DRAW_HORIZONTAL
       06:CB77  20 11 C9    JSR WriteToPPUString
       06:CB7A  A9 01       LDA #$01 
       06:CB7C  20 11 C9    JSR WriteToPPUString
                            
  208  06:CB7F  AD 00 00    LDA temp1
  209  06:CB82  20 11 C9    JSR WriteToPPUString
  210                       
  211  06:CB85  EE 4D 00    INC clueOffsetShift
  212  06:CB88  EE 4C 00    INC clueLineIndex
  213  06:CB8B  AD 4C 00    LDA clueLineIndex
  214  06:CB8E  29 03       AND #$03
  215  06:CB90  D0 03       BNE .incDrawIndex
  216  06:CB92  EE 4B 00    INC clueTableIndex
  217                       
  218                       
  219  06:CB95            .incDrawIndex:  
  220  06:CB95  AD 4D 00    LDA clueOffsetShift
  221  06:CB98  C9 0F       CMP #$0F
  222  06:CB9A  D0 19       BNE .incOnly
  223                       ;;add 32-15 = 17 to the draw address
  224  06:CB9C  AD 49 00    LDA clue_draw_address
  225  06:CB9F  18          CLC
  226  06:CBA0  69 12       ADC #18
  227  06:CBA2  8D 49 00    STA clue_draw_address
  228  06:CBA5  AD 4A 00    LDA clue_draw_address+1
  229  06:CBA8  69 00       ADC #$00
  230  06:CBAA  8D 4A 00    STA clue_draw_address+1
  231                       
  232  06:CBAD  A9 00       LDA #$00
  233  06:CBAF  8D 4D 00    STA clueOffsetShift
  234                       
  235  06:CBB2  4C BD CB    JMP .leave
  236                       
  237  06:CBB5            .incOnly:
  238                     
  239  06:CBB5  EE 49 00    INC clue_draw_address
  240  06:CBB8  D0 03       BNE .leave
  241  06:CBBA  EE 4A 00    INC clue_draw_address+1
  242                       
  243  06:CBBD            .leave:
  244  06:CBBD  60          RTS
  245                     
  246  06:CBBE            ClearLineDefTables:
  247                     
  248  06:CBBE  C0 CB       .word Clear15x15LineDefs
  249                     
  250  06:CBC0            Clear15x15LineDefs:
  251  06:CBC0  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:CBC3  20 20 20  
       06:CBC6  20 20 20  
       06:CBC9  20 20     
  252  06:CBCB  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:CBCE  0D 0D 0D  
       06:CBD1  0D 0D 0D  
       06:CBD4  0D 0D 0D  
       06:CBD7  0D 0D 0D  
       06:CBDA  0D 0D     
  253  06:CBDC  20 20       .db $20, $20
#[1]   Picross.asm
   92                       
   93                       
   94                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   95                     ;;     NMI                  ;;
   96                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   97                     
#[2]   Routines/Common/NMI.asm
   98                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:CBDE            NMI:
    3                     
    4  06:CBDE  48          PHA                              ;protect the registers
    5  06:CBDF  8A          TXA
    6  06:CBE0  48          PHA
    7  06:CBE1  98          TYA
    8  06:CBE2  48          PHA
    9                       
   10  06:CBE3            nmi_started:
   11  06:CBE3  A9 00       LDA #$00
   12  06:CBE5  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:CBE8  A9 02       LDA #$02
   14  06:CBEA  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:CBED  AD 0A 00    LDA NMI_locks
   17  06:CBF0  F0 03       BEQ update_controllers
   18  06:CBF2  4C 61 CC    JMP WakeUp
   19                     
   20  06:CBF5            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:CBF5  8A            TXA
    3  06:CBF6  48                PHA
    4  06:CBF7  98                TYA
    5  06:CBF8  48                PHA
    6                     
    7  06:CBF9  A2 00             LDX #$00
    8                     
    9  06:CBFB            GamePadCheck:
   10  06:CBFB  A9 01             LDA #$01        ;load 1
   11  06:CBFD  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:CC00  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:CC01  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:CC04  A9 80             LDA #$80
   18  06:CC06  8D 12 00          STA gamepad
   19                     
   20  06:CC09            ReadControllerABytesLoop:
   21  06:CC09  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:CC0C  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:CC0E  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:CC10  6E 12 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:CC13  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:CC15  AD 13 00          LDA gamepadLast
   31  06:CC18  49 FF             EOR #$FF
   32  06:CC1A  2D 12 00          AND gamepad
   33  06:CC1D  8D 14 00          STA gamepadPressed
   34                             
   35                             
   36  06:CC20  AD 12 00          LDA gamepad
   37  06:CC23  8D 13 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:CC26  68                PLA
   41  06:CC27  A8                TAY
   42  06:CC28  68                PLA
   43  06:CC29  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:CC2A  20 4E C8    JSR ProcessPPUString
   25                       
   26                       
   27  06:CC2D  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:CC2F  8D 05 20    STA PPU_SCROLL
   29  06:CC32  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:CC35  20 6B C9    JSR UpdatePPUControl
   34                     
   35  06:CC38            NMIUpdate:
   36                     
   37  06:CC38  20 55 CC    JSR StateNMIUpdate
   38                       
   39  06:CC3B  AD 15 00    LDA PPU_Control
   40  06:CC3E  29 FC       AND #$FC
   41  06:CC40  0D 19 00    ORA PPU_ScrollNT
   42  06:CC43  8D 00 20    STA PPU_CTRL
   43                       
   44  06:CC46  AD 17 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:CC49  8D 05 20    STA PPU_SCROLL
   46  06:CC4C  AD 18 00    LDA PPU_ScrollY
   47  06:CC4F  8D 05 20    STA PPU_SCROLL
   48                     
   49  06:CC52  4C 61 CC    JMP WakeUp
   50                     
   51  06:CC55            StateNMIUpdate:
   52                     
   53                       MACROCallDynamicJump game_mode
                          
       06:CC55  AD 08 00    LDA game_mode
       06:CC58  20 BF C7    JSR Dynamic_Jump
                                  
   54                     
   55  06:CC5B            NMIJumpTable:
   56                     
   57  06:CC5B  6C CC       .word UpdateTitleNMI
   58  06:CC5D  70 CC       .word UpdateGameNMI
   59  06:CC5F  71 CC       .word UpdateGameOverNMI
   60                     
   61  06:CC61            WakeUp:
   62  06:CC61  A9 00       LDA #$00
   63  06:CC63  8D 07 00    STA sleeping
   64                       
   65  06:CC66  68          PLA             ;restore the registers
   66  06:CC67  A8          TAY 
   67  06:CC68  68          PLA
   68  06:CC69  AA          TAX
   69  06:CC6A  68          PLA
   70                     
   71  06:CC6B  40          RTI             ; return from interrupt
   72                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   73                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:CC6C            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:CC6C  20 31 C9    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:CC6F  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   74                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:CC70            UpdateGameNMI:
    2  06:CC70  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:CC71            UpdateGameOverNMI:
    2  06:CC71  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
   99                       
  100                     ;;**************************;;
  101                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  102                     ;;       PRG ROM DATA       ;;
  103                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  104                     ;;**************************;; 
  105                       
  106           0007        .bank 7
  107           E000        .org $E000
  108                     
#[2]   NameTables/Tables.asm
  109                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  12 E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  32 E0     
       07:E004  52 E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  72 E0       .word Title_Screen, Game_Screen, GameOver_Screen
       07:E008  72 E8     
       07:E00A  72 EC     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  72 E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  72 F0     
       07:E010  72 F0     
   12                     
   13  07:E012            Title_Palette:
   14                     
   15  07:E012              .incbin "NameTables/Title_PAL.pal"
   16  07:E022              .incbin "NameTables/Title_PAL.pal"
   17                       
   18  07:E032            Game_Palette:
   19                     
   20  07:E032              .incbin "NameTables/Game_PAL.pal"
   21  07:E042              .incbin "NameTables/Game_PAL.pal"
   22                       
   23  07:E052            GameOver_Palette:
   24                     
   25  07:E052              .incbin "NameTables/GameOver_PAL.pal"
   26  07:E062              .incbin "NameTables/GameOver_PAL.pal"
   27                       
   28  07:E072            Title_Screen:
   29                     
   30  07:E072              .incbin "NameTables/Title_NT.nam"
   31                       
   32  07:E472            Title_Second:
   33                     
   34  07:E472              .incbin "NameTables/Title_PuzzMen_NT.nam"
   35                       
   36  07:E872            Game_Screen: 
   37                     
   38  07:E872              .incbin "NameTables/Game_NT.nam"
   39                       
   40  07:EC72            GameOver_Screen:
   41                     
   42  07:EC72              .incbin "NameTables/GameOver_NT.nam"
   43                       
   44  07:F072            Blank_Screen:
   45                     
   46  07:F072              .incbin "NameTables/Blank_NT.nam"
   47                     
   48                       
   49                     
   50                       
   51                      
   52                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  110                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:F472            Sprites:
   38  07:F472  78 F4             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:F474  81 F4     
       07:F476  86 F4     
   39                     
   40  07:F478            Title_Sprites:
   41  07:F478  02            .db $02
   42  07:F479  85 00 00          .db $85,$00,$00,$E8
       07:F47C  E8        
   43  07:F47D  A0 01 00          .db $A0,$01,$00,$60
       07:F480  60        
   44  07:F481            Game_Sprites:
   45  07:F481  01            .db $01
   46  07:F482  62 00 03          .db $62,$00,$03,$72
       07:F485  72        
   47  07:F486            GameOver_Sprites:
   48  07:F486  01                .db $01
   49  07:F487  00 00 00          .db $00,$00,$00,$00
       07:F48A  00        
#[1]   Picross.asm
  111                     
  112           FFFA        .org $FFFA     ;first of the three vectors starts here
  113  07:FFFA  DE CB       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  114                                        ;processor will jump to the label NMI:
  115  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  116                                        ;to the label RESET:
  117  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  118                       
  119                     ;;**************************;;
  120                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  121                     ;;      CHR ROM DATA        ;;
  122                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  123                     ;;**************************;; 
  124                       
  125           0008        .bank 8
  126           0000        .org $0000
  127  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  128                       
  129           0009        .bank 9
  130           0000        .org $0000
  131  09:0000              .incbin "CHRROM/Bank1.chr"
  132                       
  133           000A        .bank 10
  134           0000        .org $0000
  135  0A:0000              .incbin "CHRROM/Bank2.chr"
  136                       
  137           000B        .bank 11
  138           0000        .org $0000
  139  0B:0000              .incbin "CHRROM/Bank3.chr"
