#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      temp5                   .rs 1
    6           0005      temp6                   .rs 1
    7           0006      temp7                   .rs 1
    8           0007      temp8                   .rs 1
    9           0008      tempx                   .rs 1
   10           0009      tempy                   .rs 1
   11           000A      time                    .rs 1
   12           000B      scaledTime              .rs 1
   13           000C      sleeping                .rs 1
   14           000D      mode_loadFlags  .rs 1
   15                     ;;0rcb xxxx
   16                     ;;r = read from save copy 
   17                     ;;c = write to save copy
   18           000E      game_mode               .rs 1
   19           000F      mode_state              .rs 1
   20           0010      NMI_locks               .rs 1
   21           0011      game_locks              .rs 1
   22           0012      pointer_address .rs 2
   23           0014      pointerB_address .rs 2
   24           0016      table_address   .rs 2
   25           0018      jump_address    .rs 2
   26                     
   27                     ;game modes
   28           0000      TITLE_IDX = $00
   29           0001      GAME_IDX = $01
   30           0002      GAMEOVER_IDX = $02
   31                     
   32                     ;locks for input and rendering
   33           0001      BGLOAD_NMI_LOCK = %00000001
   34           0001      EFFECT_GAME_LOCK = %00000001
   35                     
   36                     
   37                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           001A      gamepad                 .rs 1
   19           001B      gamepadLast     .rs 1
   20           001C      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           001D      PPU_Control                     .rs 1
    2           001E      PPU_Mask                        .rs 1
    3           001F      PPU_ScrollX                     .rs 1
    4           0020      PPU_ScrollY                     .rs 1
    5           0021      PPU_ScrollNT            .rs 1   ;first two bits
    6           0022      PPU_NT                          .rs 1
    7                     
    8           0023      PPU_PendingWrite        .rs 1
    9           0024      PPU_StringIdx           .rs 1
   10           0025      PPU_String                      .rs 128
   11                     
   12           004F      PPU_STRINGMAX = $4F ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           00A5      mapper_address  .rs 2
    2           00A7      currentCHRBankA .rs 1
    3           00A8      currentCHRBankB .rs 1
    4           00A9      currentPRGBank  .rs 1
    5           00AA      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           A000      PUZZLE_TABLE = $A000
    2           A01B      NAMES_TABLE = $A01B
    3           A036      SPRITES_TABLE = $A036
    4                     
    5           00AB      tempBank                        .rs 1
    6           00AC      puzzle_address          .rs 2
    7           00AE      clues_address           .rs 2
    8           00B0      pause_address           .rs 2
    9           00B2      copy_address        .rs 2
   10           00B4      pause_draw_address  .rs 2
   11           00B6      clue_start_address      .rs 2
   12           00B8      clue_draw_address       .rs 2
   13           00BA      clueTableIndex          .rs 1
   14           00BB      clueLineIndex           .rs 1
   15           00BC      clueOffsetShift         .rs 1
   16           00BD      clueDrawAdd                     .rs 1
   17           00BE      clueDrawOffset          .rs 2
   18           00C0      clueDrawDecSize         .rs 1
   19           00C1      clueParity                      .rs 1
   20           00C2      mouse_location          .rs 2
   21           00C4      mouse_index                     .rs 2
   22           00C6      currentPaintTile        .rs 1
   23           00C7      pauseState                      .rs 1
   24           00C8      pauseInputLock          .rs 1
   25           00C9      holdTimer                       .rs 1
   26           00CA      targetGameMode          .rs 1
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/ScreenStateVariables.asm
   18                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      SaveScreen_Copy .rs 1024
    4           6C00      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   19           7000        .rsset $7000
#[3]   Defines/SaveVariables.asm
   20                       .include "Defines/SaveVariables.asm"
    1           7000      hasContinue .rs 1
    2           7001      solutionCount           .rs 1
    3           7002      nonSolutionCount        .rs 1
    4           7003      GameTime                        .rs 4   ;in order - second, ten second, minute, 10 minute - max out at 99 minutes
    5           7007      bank_index      .rs 1
    6           7008      puzzle_index .rs 1
    7                     ;we can save these for the continue
    8                     ;on a continue- we just need to load the back ground as it was
    9                     ;we'll save out data for the puzzles- just need to know if it's 1) complete and 2) the time
   10                     ;we can do that in 4 bytes each, so 324 bytes
   11           7009      puzzle_clear_bank0 .rs 108
   12           7075      puzzle_clear_bank1 .rs 108
   13           70E1      puzzle_clear_bank2 .rs 108
   14                     
#[2]   Defines/Defines.asm
   21                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1                     
    2                     
    3           0000        .bank 0
    4           8000        .org $8000
    5                       
#[3]   Puzzles/house.asm
    6                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  02 82 00    .db $02, $82, $00, $21
       00:8003  21        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  05 11 18    .db $05, $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1E 1C 0E  
       00:80B6  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test.asm
    7                       .include "Puzzles/test.asm"
    1  00:80B7            test:
    2  00:80B7  02 01 00    .db $02, $01, $00, $00
       00:80BA  00        
    3  00:80BB  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:80BE  00 00 00  
       00:80C1  00 00 00  
       00:80C4  00 00 00  
       00:80C7  00 00 00  
       00:80CA  00 00 00  
       00:80CD  00 00 00  
       00:80D0  00 00 00  
       00:80D3  00 00 00  
       00:80D6  00 00 00  
    4  00:80D9  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80DC  FF 00 FF  
       00:80DF  00 FF 00  
       00:80E2  FF 00 FF  
       00:80E5  00 FF 00  
       00:80E8  FF 00 FF  
       00:80EB  00 FF 00  
       00:80EE  FF 00 FF  
       00:80F1  00 FF 00  
       00:80F4  FF 00 FF  
    5  00:80F7  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80FA  FF 00 FF  
       00:80FD  00 FF 00  
       00:8100  FF 00 FF  
       00:8103  00 FF 00  
       00:8106  FF 00 FF  
       00:8109  00 FF 00  
       00:810C  FF 00 FF  
       00:810F  00 FF 00  
       00:8112  FF 00 FF  
    6  00:8115            testImage:
    7  00:8115  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8118  1B 1B 1B  
       00:811B  1B 1B 1B  
       00:811E  1B 1B 1B  
       00:8121  1B 1B 1B  
       00:8124  1B 1B 1B  
       00:8127  1B 1B 1B  
       00:812A  1B 1B 1B  
       00:812D  1B 1B 1B  
       00:8130  1B 1B 1B  
       00:8133  1B 1B 1B  
       00:8136  1B 1B 1B  
       00:8139  1B 1B 1B  
       00:813C  1B 1B 1B  
       00:813F  1B 1B 1B  
       00:8142  1B 1B 1B  
       00:8145  1B 1B 1B  
       00:8148  1B 1B 1B  
       00:814B  1B 1B 00  
       00:814E  FF        
    8  00:814F            testName:
    9  00:814F  04 1D 0E    .db $04, $1D, $0E, $1C, $1D, $FF
       00:8152  1C 1D FF  
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test5.asm
    8                       .include "Puzzles/test5.asm"
    1  00:8155            test5:
    2  00:8155  00 01 00    .db $00, $01, $00, $32
       00:8158  32        
    3  00:8159  80 00 00    .db $80, $00, $00, $00, $00
       00:815C  00 00     
    4  00:815E  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:8161  FF 00 FF  
       00:8164  00 FF 00  
       00:8167  FF        
    5  00:8168  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:816B  FF 00 FF  
       00:816E  00 FF 00  
       00:8171  FF        
    6  00:8172            test5Image:
    7  00:8172  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8175  1B 1B 1B  
       00:8178  00 FF     
    8  00:817A            test5Name:
    9  00:817A  05 1D 0E    .db $05, $1D, $0E, $1C, $1D, $05, $FF
       00:817D  1C 1D 05  
       00:8180  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test10.asm
    9                       .include "Puzzles/test10.asm"
    1  00:8181            test10:
    2  00:8181  01 01 00    .db $01, $01, $00, $16
       00:8184  16        
    3  00:8185  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:8188  00 00 00  
       00:818B  00 00 00  
       00:818E  00 00 00  
       00:8191  00 00 00  
       00:8194  00 00 00  
       00:8197  00 00     
    4  00:8199  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:819C  FF 00 FF  
       00:819F  00 FF 00  
       00:81A2  FF 00 FF  
       00:81A5  00 FF 00  
       00:81A8  FF 00 FF  
       00:81AB  00 FF     
    5  00:81AD  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:81B0  FF 00 FF  
       00:81B3  00 FF 00  
       00:81B6  FF 00 FF  
       00:81B9  00 FF 00  
       00:81BC  FF 00 FF  
       00:81BF  00 FF     
    6  00:81C1            test10Image:
    7  00:81C1  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $FF
       00:81C4  1B 1B 1B  
       00:81C7  1B 1B 1B  
       00:81CA  1B 1B 1B  
       00:81CD  1B 1B 1B  
       00:81D0  1B 1B 1B  
       00:81D3  1B 1B 1B  
       00:81D6  1B 1B 1B  
       00:81D9  1B FF     
    8  00:81DB            test10Name:
    9  00:81DB  06 1D 0E    .db $06, $1D, $0E, $1C, $1D, $01, $00, $FF
       00:81DE  1C 1D 01  
       00:81E1  00 FF     
#[2]   Banks/Bank0.asm
   10                     
   11           0001        .bank 1
   12           A000        .org $A000
   13                     ;puzzles
   14  01:A000  55 81       .word test5, test10, test, test, test, test, test, test, test
       01:A002  81 81     
       01:A004  B7 80     
       01:A006  B7 80     
       01:A008  B7 80     
       01:A00A  B7 80     
       01:A00C  B7 80     
       01:A00E  B7 80     
       01:A010  B7 80     
   15  01:A012  00 80       .word house, test, test, test, test, test, test, test, test
       01:A014  B7 80     
       01:A016  B7 80     
       01:A018  B7 80     
       01:A01A  B7 80     
       01:A01C  B7 80     
       01:A01E  B7 80     
       01:A020  B7 80     
       01:A022  B7 80     
   16  01:A024  00 80       .word house, test, test, test, test, test, test, test, test
       01:A026  B7 80     
       01:A028  B7 80     
       01:A02A  B7 80     
       01:A02C  B7 80     
       01:A02E  B7 80     
       01:A030  B7 80     
       01:A032  B7 80     
       01:A034  B7 80     
   17                     ;puzzle names
   18  01:A036  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A038  4F 81     
       01:A03A  4F 81     
       01:A03C  4F 81     
       01:A03E  4F 81     
       01:A040  4F 81     
       01:A042  4F 81     
       01:A044  4F 81     
       01:A046  4F 81     
   19  01:A048  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A04A  4F 81     
       01:A04C  4F 81     
       01:A04E  4F 81     
       01:A050  4F 81     
       01:A052  4F 81     
       01:A054  4F 81     
       01:A056  4F 81     
       01:A058  4F 81     
   20  01:A05A  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A05C  4F 81     
       01:A05E  4F 81     
       01:A060  4F 81     
       01:A062  4F 81     
       01:A064  4F 81     
       01:A066  4F 81     
       01:A068  4F 81     
       01:A06A  4F 81     
   21                     ;puzzle sprites
   22  01:A06C  00 00 00    .db $00, $00, $00, $00
       01:A06F  00        
   23  01:A070  00 00 00    .db $00, $00, $00, $00
       01:A073  00        
   24  01:A074  00 00 00    .db $00, $00, $00, $00
       01:A077  00        
   25  01:A078  00 00 00    .db $00, $00, $00, $00
       01:A07B  00        
   26  01:A07C  00 00 00    .db $00, $00, $00, $00
       01:A07F  00        
   27  01:A080  00 00 00    .db $00, $00, $00, $00
       01:A083  00        
   28  01:A084  00 00 00    .db $00, $00, $00, $00
       01:A087  00        
   29  01:A088  00 00 00    .db $00, $00, $00, $00
       01:A08B  00        
   30  01:A08C  00 00 00    .db $00, $00, $00, $00
       01:A08F  00        
   31  01:A090  00 00 00    .db $00, $00, $00, $00
       01:A093  00        
   32  01:A094  00 00 00    .db $00, $00, $00, $00
       01:A097  00        
   33  01:A098  00 00 00    .db $00, $00, $00, $00
       01:A09B  00        
   34  01:A09C  00 00 00    .db $00, $00, $00, $00
       01:A09F  00        
   35  01:A0A0  00 00 00    .db $00, $00, $00, $00
       01:A0A3  00        
   36  01:A0A4  00 00 00    .db $00, $00, $00, $00
       01:A0A7  00        
   37  01:A0A8  00 00 00    .db $00, $00, $00, $00
       01:A0AB  00        
   38  01:A0AC  00 00 00    .db $00, $00, $00, $00
       01:A0AF  00        
   39  01:A0B0  00 00 00    .db $00, $00, $00, $00
       01:A0B3  00        
   40  01:A0B4  00 00 00    .db $00, $00, $00, $00
       01:A0B7  00        
   41  01:A0B8  00 00 00    .db $00, $00, $00, $00
       01:A0BB  00        
   42  01:A0BC  00 00 00    .db $00, $00, $00, $00
       01:A0BF  00        
   43  01:A0C0  00 00 00    .db $00, $00, $00, $00
       01:A0C3  00        
   44  01:A0C4  00 00 00    .db $00, $00, $00, $00
       01:A0C7  00        
   45  01:A0C8  00 00 00    .db $00, $00, $00, $00
       01:A0CB  00        
   46  01:A0CC  00 00 00    .db $00, $00, $00, $00
       01:A0CF  00        
   47  01:A0D0  00 00 00    .db $00, $00, $00, $00
       01:A0D3  00        
   48  01:A0D4  00 00 00    .db $00, $00, $00, $00
       01:A0D7  00        
   49                       
   50                       
   51           BFFA        .org $BFFA     ;first of the three vectors starts here
   52  01:BFFA  36 D1       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   53                                        ;processor will jump to the label NMI:
   54  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   55                                        ;to the label RESET:
   56  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  02 62 00    .db $02, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  04 0F 1B    .db $04, $0F, $1B, $18, $10, $FF
       02:80A7  18 10 FF  
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                      
    9                     ;puzzles
   10  03:A000  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A002  00 80     
       03:A004  00 80     
       03:A006  00 80     
       03:A008  00 80     
       03:A00A  00 80     
       03:A00C  00 80     
       03:A00E  00 80     
       03:A010  00 80     
   11  03:A012  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A014  00 80     
       03:A016  00 80     
       03:A018  00 80     
       03:A01A  00 80     
       03:A01C  00 80     
       03:A01E  00 80     
       03:A020  00 80     
       03:A022  00 80     
   12  03:A024  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A026  00 80     
       03:A028  00 80     
       03:A02A  00 80     
       03:A02C  00 80     
       03:A02E  00 80     
       03:A030  00 80     
       03:A032  00 80     
       03:A034  00 80     
   13                     ;puzzle names
   14  03:A036  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A038  A4 80     
       03:A03A  A4 80     
       03:A03C  A4 80     
       03:A03E  A4 80     
       03:A040  A4 80     
       03:A042  A4 80     
       03:A044  A4 80     
       03:A046  A4 80     
   15  03:A048  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A04A  A4 80     
       03:A04C  A4 80     
       03:A04E  A4 80     
       03:A050  A4 80     
       03:A052  A4 80     
       03:A054  A4 80     
       03:A056  A4 80     
       03:A058  A4 80     
   16  03:A05A  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A05C  A4 80     
       03:A05E  A4 80     
       03:A060  A4 80     
       03:A062  A4 80     
       03:A064  A4 80     
       03:A066  A4 80     
       03:A068  A4 80     
       03:A06A  A4 80     
   17                     ;puzzle sprites
   18  03:A06C  00 00 00    .db $00, $00, $00, $00
       03:A06F  00        
   19  03:A070  00 00 00    .db $00, $00, $00, $00
       03:A073  00        
   20  03:A074  00 00 00    .db $00, $00, $00, $00
       03:A077  00        
   21  03:A078  00 00 00    .db $00, $00, $00, $00
       03:A07B  00        
   22  03:A07C  00 00 00    .db $00, $00, $00, $00
       03:A07F  00        
   23  03:A080  00 00 00    .db $00, $00, $00, $00
       03:A083  00        
   24  03:A084  00 00 00    .db $00, $00, $00, $00
       03:A087  00        
   25  03:A088  00 00 00    .db $00, $00, $00, $00
       03:A08B  00        
   26  03:A08C  00 00 00    .db $00, $00, $00, $00
       03:A08F  00        
   27  03:A090  00 00 00    .db $00, $00, $00, $00
       03:A093  00        
   28  03:A094  00 00 00    .db $00, $00, $00, $00
       03:A097  00        
   29  03:A098  00 00 00    .db $00, $00, $00, $00
       03:A09B  00        
   30  03:A09C  00 00 00    .db $00, $00, $00, $00
       03:A09F  00        
   31  03:A0A0  00 00 00    .db $00, $00, $00, $00
       03:A0A3  00        
   32  03:A0A4  00 00 00    .db $00, $00, $00, $00
       03:A0A7  00        
   33  03:A0A8  00 00 00    .db $00, $00, $00, $00
       03:A0AB  00        
   34  03:A0AC  00 00 00    .db $00, $00, $00, $00
       03:A0AF  00        
   35  03:A0B0  00 00 00    .db $00, $00, $00, $00
       03:A0B3  00        
   36  03:A0B4  00 00 00    .db $00, $00, $00, $00
       03:A0B7  00        
   37  03:A0B8  00 00 00    .db $00, $00, $00, $00
       03:A0BB  00        
   38  03:A0BC  00 00 00    .db $00, $00, $00, $00
       03:A0BF  00        
   39  03:A0C0  00 00 00    .db $00, $00, $00, $00
       03:A0C3  00        
   40  03:A0C4  00 00 00    .db $00, $00, $00, $00
       03:A0C7  00        
   41  03:A0C8  00 00 00    .db $00, $00, $00, $00
       03:A0CB  00        
   42  03:A0CC  00 00 00    .db $00, $00, $00, $00
       03:A0CF  00        
   43  03:A0D0  00 00 00    .db $00, $00, $00, $00
       03:A0D3  00        
   44  03:A0D4  00 00 00    .db $00, $00, $00, $00
       03:A0D7  00        
   45                       
   46                       
   47           BFFA        .org $BFFA     ;first of the three vectors starts here
   48  03:BFFA  36 D1       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   49                                        ;processor will jump to the label NMI:
   50  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   51                                        ;to the label RESET:
   52  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  02 7E 00    .db $02, $7E, $00, $2B
       04:8003  2B        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  03 0C 0A    .db $03, $0C, $0A, $1D, $FF
       04:80A5  1D FF     
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8                       
    9                     ;puzzles
   10  05:A000  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A002  00 80     
       05:A004  00 80     
       05:A006  00 80     
       05:A008  00 80     
       05:A00A  00 80     
       05:A00C  00 80     
       05:A00E  00 80     
       05:A010  00 80     
   11  05:A012  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A014  00 80     
       05:A016  00 80     
       05:A018  00 80     
       05:A01A  00 80     
       05:A01C  00 80     
       05:A01E  00 80     
       05:A020  00 80     
       05:A022  00 80     
   12  05:A024  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat
       05:A026  00 80     
       05:A028  00 80     
       05:A02A  00 80     
       05:A02C  00 80     
       05:A02E  00 80     
       05:A030  00 80     
       05:A032  00 80     
       05:A034  00 80     
   13                     ;puzzle names
   14  05:A036  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A038  A2 80     
       05:A03A  A2 80     
       05:A03C  A2 80     
       05:A03E  A2 80     
       05:A040  A2 80     
       05:A042  A2 80     
       05:A044  A2 80     
       05:A046  A2 80     
   15  05:A048  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A04A  A2 80     
       05:A04C  A2 80     
       05:A04E  A2 80     
       05:A050  A2 80     
       05:A052  A2 80     
       05:A054  A2 80     
       05:A056  A2 80     
       05:A058  A2 80     
   16  05:A05A  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName
       05:A05C  A2 80     
       05:A05E  A2 80     
       05:A060  A2 80     
       05:A062  A2 80     
       05:A064  A2 80     
       05:A066  A2 80     
       05:A068  A2 80     
       05:A06A  A2 80     
   17                     ;puzzle sprites
   18  05:A06C  00 00 00    .db $00, $00, $00, $00
       05:A06F  00        
   19  05:A070  00 00 00    .db $00, $00, $00, $00
       05:A073  00        
   20  05:A074  00 00 00    .db $00, $00, $00, $00
       05:A077  00        
   21  05:A078  00 00 00    .db $00, $00, $00, $00
       05:A07B  00        
   22  05:A07C  00 00 00    .db $00, $00, $00, $00
       05:A07F  00        
   23  05:A080  00 00 00    .db $00, $00, $00, $00
       05:A083  00        
   24  05:A084  00 00 00    .db $00, $00, $00, $00
       05:A087  00        
   25  05:A088  00 00 00    .db $00, $00, $00, $00
       05:A08B  00        
   26  05:A08C  00 00 00    .db $00, $00, $00, $00
       05:A08F  00        
   27  05:A090  00 00 00    .db $00, $00, $00, $00
       05:A093  00        
   28  05:A094  00 00 00    .db $00, $00, $00, $00
       05:A097  00        
   29  05:A098  00 00 00    .db $00, $00, $00, $00
       05:A09B  00        
   30  05:A09C  00 00 00    .db $00, $00, $00, $00
       05:A09F  00        
   31  05:A0A0  00 00 00    .db $00, $00, $00, $00
       05:A0A3  00        
   32  05:A0A4  00 00 00    .db $00, $00, $00, $00
       05:A0A7  00        
   33  05:A0A8  00 00 00    .db $00, $00, $00, $00
       05:A0AB  00        
   34  05:A0AC  00 00 00    .db $00, $00, $00, $00
       05:A0AF  00        
   35  05:A0B0  00 00 00    .db $00, $00, $00, $00
       05:A0B3  00        
   36  05:A0B4  00 00 00    .db $00, $00, $00, $00
       05:A0B7  00        
   37  05:A0B8  00 00 00    .db $00, $00, $00, $00
       05:A0BB  00        
   38  05:A0BC  00 00 00    .db $00, $00, $00, $00
       05:A0BF  00        
   39  05:A0C0  00 00 00    .db $00, $00, $00, $00
       05:A0C3  00        
   40  05:A0C4  00 00 00    .db $00, $00, $00, $00
       05:A0C7  00        
   41  05:A0C8  00 00 00    .db $00, $00, $00, $00
       05:A0CB  00        
   42  05:A0CC  00 00 00    .db $00, $00, $00, $00
       05:A0CF  00        
   43  05:A0D0  00 00 00    .db $00, $00, $00, $00
       05:A0D3  00        
   44  05:A0D4  00 00 00    .db $00, $00, $00, $00
       05:A0D7  00        
   45                     
   46           BFFA        .org $BFFA     ;first of the three vectors starts here
   47  05:BFFA  36 D1       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   48                                        ;processor will jump to the label NMI:
   49  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   50                                        ;to the label RESET:
   51  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 73 CD    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 77 CD    JSR SetMapperControls
   34                       
   35  06:C040  20 B4 CD    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  A2 00       LDX #$00
   38  06:C04C  20 39 CA    JSR ChangeGameMode
   39  06:C04F  20 F8 CC    JSR InitPPUControl
   40                       
   41                     
   42                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   43                     ;;     Main Program         ;;
   44                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   45                     
   46  06:C052            Forever:
   47                     
   48  06:C052  EE 0C 00    INC sleeping
   49                     
   50  06:C055            .loop
   51  06:C055  AD 0C 00    LDA sleeping
   52  06:C058  D0 FB       BNE .loop
   53                     
   54  06:C05A  EE 0A 00    INC time  
   55  06:C05D  AD C7 00    LDA pauseState
   56  06:C060  D0 03       BNE .skipScaleUpdate
   57  06:C062  EE 0B 00    INC scaledTime
   58  06:C065            .skipScaleUpdate:
   59  06:C065  20 6B C0    JSR GameLoop
   60                     
   61                     
   62  06:C068  4C 52 C0    JMP Forever     ;jump back to Forever, infinite loop
   63                       
   64                     ;; dynamic jump table
   65                     
   66  06:C06B            GameLoop:
   67                     
   68                       MACROCallDynamicJump game_mode
                          
       06:C06B  AD 0E 00    LDA game_mode
       06:C06E  20 0A CB    JSR Dynamic_Jump
                                  
   69                       ;; we'll pop the return address here as the table index, so 
   70                       ;; the routine we pick will return us to whatever called Game Loop
   71                       ;; when it returns
   72                     
   73  06:C071            GameLoopJumpTable:
   74                     
   75  06:C071  77 C0       .word UpdateTitle
   76  06:C073  1C C3       .word UpdateGame
   77  06:C075  E8 C9       .word UpdateGameOver
   78                       
   79                     
   80                       ;;RTS is called in the subroutine
   81                     
   82                       
#[2]   Routines/Game_States/UpdateTitle.asm
   83                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C077            UpdateTitle:
    2                     
    3  06:C077  AD 10 00    LDA NMI_locks
    4  06:C07A  F0 01       BEQ .unlocked
    5                       
    6  06:C07C  60          RTS
    7                       
    8  06:C07D            .unlocked:
    9                     
   10  06:C07D  20 81 C0    JSR DoUpdateTitle  
   11  06:C080  60          RTS
   12                       
   13  06:C081            DoUpdateTitle:
   14                     
   15  06:C081  AD 0F 00    LDA mode_state
   16  06:C084  20 0A CB    JSR Dynamic_Jump
   17                         
   18  06:C087            UpdateTitleJumpTable:
   19                     
   20  06:C087  93 C0       .word UpdateTitleInit
   21  06:C089  C9 C0       .word UpdateBankSelection
   22  06:C08B  FA C0       .word UpdateScroll
   23  06:C08D  1E C1       .word UpdatePuzzleSelection
   24  06:C08F  61 C1       .word UpdateScrollBack
   25  06:C091  80 C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C093            UpdateTitleInit:
   35                     
   36  06:C093  20 D4 CC    JSR TurnOnSprites
   37                       
   38  06:C096  AD 00 70    LDA hasContinue
   39  06:C099  F0 20       BEQ .skipContinueText
   40                       MACROAddPPUStringEntryTable #$2B, #$4D, #DRAW_HORIZONTAL, ContinueText
                           
       06:C09B  A9 01       LDA #$01
       06:C09D  8D 23 00    STA PPU_PendingWrite
       06:C0A0  A9 2B       LDA #$2B
       06:C0A2  20 8C CC    JSR WriteToPPUString
       06:C0A5  A9 4D       LDA #$4D
       06:C0A7  20 8C CC    JSR WriteToPPUString
       06:C0AA  A9 20       LDA #$20
       06:C0AC  09 00       ORA #DRAW_HORIZONTAL
       06:C0AE  20 8C CC    JSR WriteToPPUString
       06:C0B1  A9 13       LDA #LOW(ContinueText)
       06:C0B3  20 8C CC    JSR WriteToPPUString
       06:C0B6  A9 C3       LDA #HIGH(ContinueText)
       06:C0B8  20 8C CC    JSR WriteToPPUString
                           
   41                       
   42  06:C0BB            .skipContinueText:
   43                       
   44  06:C0BB  A9 00       LDA #$00
   45  06:C0BD  8D C4 00    STA mouse_index
   46  06:C0C0  A9 00       LDA #$00
   47  06:C0C2  8D C5 00    STA mouse_index+1
   48                     
   49  06:C0C5            .changeModeState:
   50                     
   51  06:C0C5  EE 0F 00    INC mode_state
   52  06:C0C8            .leave:
   53  06:C0C8  60          RTS
   54                       
   55  06:C0C9            UpdateBankSelection:
   56                     
   57  06:C0C9  20 48 C2    JSR UpdateBankPointer
   58                       
   59  06:C0CC  AD 1C 00    LDA gamepadPressed
   60  06:C0CF  29 01       AND #GAMEPAD_A
   61  06:C0D1  F0 26       BEQ .leave
   62                       
   63  06:C0D3            .changeModeState:
   64                       
   65  06:C0D3  AD C4 00    LDA mouse_index
   66  06:C0D6  C9 03       CMP #$03
   67  06:C0D8  D0 0F       BNE .setBank
   68                       
   69  06:C0DA  EE 0F 00    INC mode_state
   70  06:C0DD  EE 0F 00    INC mode_state
   71  06:C0E0  EE 0F 00    INC mode_state
   72                       
   73                       ;;load bank
   74  06:C0E3  20 06 C3    JSR LoadBank
   75                       
   76  06:C0E6  4C F3 C0    JMP .goToNext
   77                       
   78  06:C0E9            .setBank:
   79  06:C0E9  8D AB 00    STA tempBank
   80  06:C0EC  A9 FF       LDA #$FF
   81  06:C0EE  A2 01       LDX #$01
   82  06:C0F0  20 2A C2    JSR SetSpriteImage
   83                     
   84  06:C0F3            .goToNext:
   85  06:C0F3  EE 0F 00    INC mode_state
   86  06:C0F6  4C F9 C0    JMP .leave
   87                     
   88                     
   89  06:C0F9            .leave:
   90  06:C0F9  60          RTS
   91                       
   92  06:C0FA            UpdateScroll:
   93  06:C0FA  EE 1F 00    INC PPU_ScrollX
   94  06:C0FD  EE 1F 00    INC PPU_ScrollX
   95  06:C100  EE 1F 00    INC PPU_ScrollX
   96  06:C103  EE 1F 00    INC PPU_ScrollX
   97  06:C106  D0 15       BNE .leave
   98  06:C108  AD 21 00    LDA PPU_ScrollNT
   99  06:C10B  49 01       EOR #%00000001
  100  06:C10D  8D 21 00    STA PPU_ScrollNT
  101                       
  102  06:C110            .changeModeState:
  103  06:C110  A9 01       LDA #$01
  104  06:C112  A2 01       LDX #$01
  105  06:C114  20 2A C2    JSR SetSpriteImage
  106  06:C117  20 EC C1    JSR InitPuzzlePointer
  107  06:C11A  EE 0F 00    INC mode_state
  108  06:C11D            .leave:
  109  06:C11D  60          RTS
  110                       
  111  06:C11E            UpdatePuzzleSelection:
  112                     
  113  06:C11E  20 97 C2    JSR UpdatePuzzlePointer
  114                       
  115  06:C121  AD 1C 00    LDA gamepadPressed
  116  06:C124  29 02       AND #GAMEPAD_B
  117  06:C126  D0 10       BNE .changeToScrollBack
  118  06:C128  AD 1C 00    LDA gamepadPressed
  119  06:C12B  29 09       AND #GAMEPAD_CONFIRM
  120  06:C12D  F0 31       BEQ .leave
  121                       
  122  06:C12F  EE 0F 00    INC mode_state
  123  06:C132  EE 0F 00    INC mode_state
  124  06:C135  4C 60 C1    JMP .leave
  125                       
  126  06:C138            .changeToScrollBack:
  127                      
  128  06:C138  A9 FF       LDA #$FF
  129  06:C13A  A2 01       LDX #$01
  130  06:C13C  20 2A C2    JSR SetSpriteImage
  131  06:C13F  20 E4 C1    JSR InitBankPointer
  132  06:C142  AD 07 70    LDA bank_index
  133  06:C145  8D C4 00    STA mouse_index
  134  06:C148  20 8A C2    JSR SetBankPointerFromIndex
  135                       
  136  06:C14B  A9 00       LDA #$00
  137  06:C14D  8D 20 00    STA PPU_ScrollY
  138  06:C150  A9 FC       LDA #$FC
  139  06:C152  8D 1F 00    STA PPU_ScrollX
  140  06:C155  AD 21 00    LDA PPU_ScrollNT
  141  06:C158  29 FE       AND #$FE
  142  06:C15A  8D 21 00    STA PPU_ScrollNT
  143                       
  144  06:C15D  EE 0F 00    INC mode_state
  145  06:C160            .leave:
  146  06:C160  60          RTS
  147                       
  148  06:C161            UpdateScrollBack:
  149                     
  150  06:C161  CE 1F 00    DEC PPU_ScrollX
  151  06:C164  CE 1F 00    DEC PPU_ScrollX
  152  06:C167  CE 1F 00    DEC PPU_ScrollX
  153  06:C16A  CE 1F 00    DEC PPU_ScrollX
  154  06:C16D  D0 10       BNE .leave
  155                       
  156  06:C16F            .changeModeState:
  157                     
  158  06:C16F  A9 01       LDA #$01
  159  06:C171  A2 01       LDX #$01
  160  06:C173  20 2A C2    JSR SetSpriteImage
  161  06:C176  CE 0F 00    DEC mode_state
  162  06:C179  CE 0F 00    DEC mode_state
  163  06:C17C  CE 0F 00    DEC mode_state
  164                       
  165  06:C17F            .leave:
  166  06:C17F  60          RTS
  167                       
  168  06:C180            UpdateTitleExit:
  169                     
  170                       ;;reset screen scroll
  171  06:C180  A9 00       LDA #$00
  172  06:C182  8D 1F 00    STA PPU_ScrollX
  173  06:C185  8D 21 00    STA PPU_ScrollNT
  174                       
  175  06:C188  A9 20       LDA #%00100000
  176  06:C18A  8D 00 00    STA temp1
  177                       
  178  06:C18D  AD C4 00    LDA mouse_index
  179  06:C190  C9 03       CMP #$03
  180  06:C192  D0 06       BNE .loadPuzzle
  181                       
  182  06:C194  0E 00 00    ASL temp1
  183  06:C197  4C B8 C1    JMP .setupPuzzle
  184                       
  185  06:C19A            .loadPuzzle:
  186                       ;; we can also pick out the puzzle index
  187                       ;; we have the mouse indexes - one vert, one hori
  188                       ;; take vert, mult by 9- alternatively, mult by 8, add index 
  189                       ;; IE - ind = 1, mult 8 = 8, add 1 = 9
  190                       ;; add X index
  191  06:C19A  AD AB 00    LDA tempBank
  192  06:C19D  8D 07 70    STA bank_index
  193  06:C1A0  20 06 C3    JSR LoadBank
  194                       
  195  06:C1A3  AD C4 00    LDA mouse_index
  196  06:C1A6  0A          ASL A
  197  06:C1A7  0A          ASL A
  198  06:C1A8  0A          ASL A
  199  06:C1A9  18          CLC
  200  06:C1AA  6D C4 00    ADC mouse_index
  201  06:C1AD  6D C5 00    ADC mouse_index+1
  202  06:C1B0  8D 08 70    STA puzzle_index
  203  06:C1B3  A9 00       LDA #$00
  204  06:C1B5  8D 00 70    STA hasContinue
  205                     
  206                     
  207  06:C1B8            .setupPuzzle:
  208                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C1B8  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C1BA  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C1BC  8E 16 00          STX table_address
       06:C1BF  8D 17 00          STA table_address+1
                                  
  209                       MACROGetDoubleIndex puzzle_index
                          
       06:C1C2  AD 08 70          LDA puzzle_index
       06:C1C5  0A                ASL A
       06:C1C6  A8                TAY
                                  
  210  06:C1C7  20 30 CB    JSR GetTableAtIndex
  211                       MACROGetPointer table_address, puzzle_address
                          
       06:C1CA  AD 16 00          LDA table_address
       06:C1CD  8D AC 00          STA puzzle_address
       06:C1D0  AD 17 00          LDA table_address+1
       06:C1D3  8D AD 00          STA puzzle_address+1
                          
  212                     
  213  06:C1D6  A0 00       LDY #$00
  214  06:C1D8  B1 AC       LDA [puzzle_address], y
  215  06:C1DA  0D 00 00    ORA temp1
  216                       
  217  06:C1DD  AA          TAX
  218                       
  219                     
  220  06:C1DE  A9 01       LDA #GAME_IDX
  221  06:C1E0  20 39 CA    JSR ChangeGameMode
  222                       
  223  06:C1E3            .leave
  224  06:C1E3  60          RTS
  225                       
  226  06:C1E4            InitBankPointer:
  227                     
  228  06:C1E4  A2 A0       LDX #$A0
  229  06:C1E6  A9 60       LDA #$60
  230  06:C1E8  20 FF C1    JSR InitPointer
  231                       
  232  06:C1EB  60          RTS  
  233                       
  234  06:C1EC            InitPuzzlePointer:
  235                       
  236  06:C1EC  A2 AE       LDX #$AE
  237  06:C1EE  A9 10       LDA #$10
  238  06:C1F0  20 FF C1    JSR InitPointer
  239                       
  240  06:C1F3  60          RTS
  241                     
  242  06:C1F4            ResetMouseIndex:
  243                     
  244  06:C1F4  A9 00       LDA #$00
  245  06:C1F6  8D C4 00    STA mouse_index
  246  06:C1F9  A9 00       LDA #$00
  247  06:C1FB  8D C5 00    STA mouse_index+1
  248  06:C1FE  60          RTS
  249                     
  250  06:C1FF            InitPointer:
  251                     
  252  06:C1FF  20 06 C2    JSR SetPointerPosition
  253  06:C202  20 F4 C1    JSR ResetMouseIndex
  254  06:C205  60          RTS  
  255                       
  256  06:C206            SetPointerPosition:
  257                     
  258  06:C206  48          PHA
  259  06:C207  8A          TXA
  260  06:C208  A2 01       LDX #$01
  261  06:C20A  20 14 C2    JSR SetSpriteYPosition
  262  06:C20D  68          PLA
  263  06:C20E  A2 01       LDX #$01
  264  06:C210  20 1F C2    JSR SetSpriteXPosition
  265                      
  266  06:C213  60          RTS
  267                       
  268  06:C214            SetSpriteYPosition:
  269                       
  270  06:C214  48          PHA
  271  06:C215  A9 00       LDA #SPRITE_YPOS
  272  06:C217  20 35 C2    JSR GetSpriteDataIndexInX
  273  06:C21A  68          PLA
  274  06:C21B  9D 00 02    STA SPRITE_DATA, x
  275  06:C21E  60          RTS
  276                       
  277  06:C21F            SetSpriteXPosition:  
  278                       
  279  06:C21F  48          PHA
  280  06:C220  A9 03       LDA #SPRITE_XPOS
  281  06:C222  20 35 C2    JSR GetSpriteDataIndexInX
  282  06:C225  68          PLA
  283  06:C226  9D 00 02    STA SPRITE_DATA, x 
  284  06:C229  60          RTS
  285                     
  286  06:C22A            SetSpriteImage:
  287                     
  288                     ;; A has sprite image index we want
  289                     ;; X has the sprite index
  290  06:C22A  48          PHA
  291  06:C22B  A9 01       LDA #SPRITE_ID
  292  06:C22D  20 35 C2    JSR GetSpriteDataIndexInX
  293  06:C230  68          PLA
  294  06:C231  9D 00 02    STA SPRITE_DATA, x
  295  06:C234  60          RTS
  296                       
  297  06:C235            GetSpriteDataIndexInX:
  298                     
  299                       ;; A has data index we want to get
  300                       ;; X has sprite index
  301  06:C235  8D 02 00    STA temp3
  302  06:C238  8A          TXA
  303  06:C239  0A          ASL A
  304  06:C23A  0A          ASL A
  305  06:C23B  18          CLC
  306  06:C23C  6D 02 00    ADC temp3
  307  06:C23F  AA          TAX
  308                       
  309  06:C240  60          RTS  
  310  06:C241            GetSpriteData:
  311                     
  312                       ;;A is data we want
  313                       ;;X is Sprite
  314  06:C241  20 35 C2    JSR GetSpriteDataIndexInX
  315  06:C244  BD 00 02    LDA SPRITE_DATA, x
  316  06:C247  60          RTS
  317                       
  318  06:C248            UpdateBankPointer:
  319                      
  320                       ;;bank pointer is 1D, will loop between 0->3
  321  06:C248  AD 1C 00    LDA gamepadPressed
  322  06:C24B  D0 01       BNE .continue
  323  06:C24D            .leaveEarly:
  324  06:C24D  60          RTS
  325                       
  326  06:C24E            .continue:
  327  06:C24E  A9 00       LDA #$00
  328  06:C250  8D 00 00    STA temp1
  329                       
  330  06:C253  A9 02       LDA #$02
  331  06:C255  8D 01 00    STA temp2
  332                       
  333  06:C258  AD 00 70    LDA hasContinue
  334  06:C25B  F0 05       BEQ .parseInputs
  335  06:C25D  A9 03       LDA #$03
  336  06:C25F  8D 01 00    STA temp2
  337                       
  338  06:C262            .parseInputs:
  339  06:C262  AD 1C 00    LDA gamepadPressed
  340  06:C265  29 30       AND #GAMEPAD_VERT
  341  06:C267  F0 E4       BEQ .leaveEarly
  342  06:C269  0A          ASL A
  343  06:C26A  0A          ASL A
  344  06:C26B            .checkDown:
  345  06:C26B  0A          ASL A
  346  06:C26C  90 03       BCC .checkUp
  347  06:C26E  EE 00 00    INC temp1
  348  06:C271            .checkUp:
  349  06:C271  0A          ASL A
  350  06:C272  90 03       BCC .move
  351  06:C274  CE 00 00    DEC temp1
  352  06:C277            .move:
  353                       
  354  06:C277  AD C4 00    LDA mouse_index
  355  06:C27A  18          CLC
  356  06:C27B  6D 00 00    ADC temp1
  357  06:C27E  CD 01 00    CMP temp2
  358  06:C281  F0 04       BEQ .skipMod
  359  06:C283  90 02       BCC .skipMod
  360  06:C285  A9 00       LDA #$00
  361  06:C287            .skipMod:
  362  06:C287  8D C4 00    STA mouse_index
  363                       ;; mult mouse_index by 16
  364  06:C28A            SetBankPointerFromIndex:
  365                     
  366  06:C28A  0A          ASL A
  367  06:C28B  0A          ASL A
  368  06:C28C  0A          ASL A
  369  06:C28D  0A          ASL A
  370  06:C28E  18          CLC
  371  06:C28F  69 A0       ADC #$A0
  372  06:C291  A2 01       LDX #$01
  373  06:C293  20 14 C2    JSR SetSpriteYPosition
  374                     
  375  06:C296            .leave:
  376                       
  377  06:C296  60          RTS
  378                       
  379  06:C297            UpdatePuzzlePointer:
  380                     
  381                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  382  06:C297  AD 1C 00    LDA gamepadPressed
  383  06:C29A  F0 69       BEQ .leave 
  384                       
  385  06:C29C  A9 00       LDA #$00
  386  06:C29E  8D 00 00    STA temp1
  387  06:C2A1  8D 01 00    STA temp2
  388                       
  389  06:C2A4            .parseInputs:
  390  06:C2A4  AD 1C 00    LDA gamepadPressed
  391  06:C2A7  29 F0       AND #GAMEPAD_MOVE
  392  06:C2A9  F0 5A       BEQ .leave
  393  06:C2AB  0A          ASL A
  394  06:C2AC  90 03       BCC .checkLeft
  395  06:C2AE  EE 00 00    INC temp1
  396  06:C2B1            .checkLeft:
  397  06:C2B1  0A          ASL A
  398  06:C2B2  90 03       BCC .checkDown
  399  06:C2B4  CE 00 00    DEC temp1
  400  06:C2B7            .checkDown:
  401  06:C2B7  0A          ASL A
  402  06:C2B8  90 03       BCC .checkUp
  403  06:C2BA  EE 01 00    INC temp2
  404  06:C2BD            .checkUp:
  405  06:C2BD  0A          ASL A
  406  06:C2BE  90 03       BCC .move
  407  06:C2C0  CE 01 00    DEC temp2
  408                       
  409  06:C2C3            .move:
  410                     
  411  06:C2C3  AD C4 00    LDA mouse_index
  412  06:C2C6  18          CLC
  413  06:C2C7  6D 01 00    ADC temp2
  414  06:C2CA  C9 02       CMP #$02
  415  06:C2CC  F0 04       BEQ .skipYMod
  416  06:C2CE  90 02       BCC .skipYMod
  417  06:C2D0  A9 00       LDA #$00
  418  06:C2D2            .skipYMod:
  419  06:C2D2  8D C4 00    STA mouse_index
  420                       ;; mult mouse_index by 16
  421  06:C2D5  0A          ASL A
  422  06:C2D6  0A          ASL A
  423  06:C2D7  0A          ASL A
  424  06:C2D8  0A          ASL A
  425  06:C2D9  18          CLC
  426  06:C2DA  69 AE       ADC #$AE
  427  06:C2DC  A2 01       LDX #$01
  428  06:C2DE  20 14 C2    JSR SetSpriteYPosition
  429                       
  430  06:C2E1  AD C5 00    LDA mouse_index+1
  431  06:C2E4  18          CLC
  432  06:C2E5  6D 00 00    ADC temp1
  433  06:C2E8  C9 08       CMP #$08
  434  06:C2EA  F0 04       BEQ .skipXMod
  435  06:C2EC  90 02       BCC .skipXMod
  436  06:C2EE  A9 00       LDA #$00
  437  06:C2F0            .skipXMod:
  438  06:C2F0  8D C5 00    STA mouse_index+1
  439                       ;; we need to move 3 tiles each- so index * 3 * 8,
  440  06:C2F3  18          CLC
  441  06:C2F4  6D C5 00    ADC mouse_index+1
  442  06:C2F7  6D C5 00    ADC mouse_index+1
  443  06:C2FA  0A          ASL A
  444  06:C2FB  0A          ASL A
  445  06:C2FC  0A          ASL A
  446  06:C2FD  18          CLC
  447  06:C2FE  69 10       ADC #$10
  448  06:C300  A2 01       LDX #$01
  449  06:C302  20 1F C2    JSR SetSpriteXPosition
  450                       
  451  06:C305            .leave:
  452                       
  453  06:C305  60          RTS
  454                     
  455  06:C306            LoadBank:
  456                     
  457                       ;;load bank
  458  06:C306  20 73 CD    JSR ResetMapper
  459  06:C309  AD 07 70    LDA bank_index
  460  06:C30C  8D A9 00    STA currentPRGBank
  461  06:C30F  20 82 CD    JSR LoadPRGBank
  462  06:C312  60          RTS
  463                       
  464  06:C313            ContinueText:
  465                     
  466  06:C313  08 0C 18    .db $08, $0C, $18, $17, $1D, $12, $17, $1E, $0E
       06:C316  17 1D 12  
       06:C319  17 1E 0E  
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   84                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6           20A8      BANK_LEVEL = $20A8
    7           20E5      TIMER_LOC = $20E5
    8                     
    9           618E      MOUSE_START = $618E
   10                     
   11           0010      HOLD_TIME = $10
   12           0004      HOLD_FREQ = $04
   13                     
   14  06:C31C            UpdateGame:
   15                     
   16  06:C31C  AD 10 00    LDA NMI_locks
   17  06:C31F  F0 01       BEQ .unlocked
   18                       
   19  06:C321  60          RTS
   20                       
   21  06:C322            .unlocked:
   22                     
   23  06:C322  20 26 C3    JSR DoUpdateGame
   24  06:C325  60          RTS
   25                       
   26  06:C326            DoUpdateGame:
   27                     
   28  06:C326  AD 0F 00    LDA mode_state
   29  06:C329  20 0A CB    JSR Dynamic_Jump
   30                       
   31  06:C32C            UpdateGameJumpTable:
   32                     
   33  06:C32C  40 C3       .word UpdateGameInit
   34  06:C32E  F8 C3       .word UpdateDrawVertClues
   35  06:C330  20 C4       .word UpdateDrawHoriClues
   36  06:C332  6A C4       .word UpdateGamePlay
   37  06:C334  75 C6       .word UpdateClearPuzzle
   38  06:C336  88 C6       .word UpdateMoveScreen
   39  06:C338  01 C7       .word UpdateDrawImage
   40  06:C33A  87 C7       .word UpdateWaitInput
   41  06:C33C  9D C7       .word UpdateGameFadeOut
   42  06:C33E  B2 C7       .word UpdateGameExit
   43                     
   44  06:C340            UpdateGameInit:
   45                     
   46                       ;; get the puzzle table in the puzzle address
   47                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C340  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C342  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C344  8E 16 00          STX table_address
       06:C347  8D 17 00          STA table_address+1
                                  
   48                       MACROGetDoubleIndex puzzle_index
                          
       06:C34A  AD 08 70          LDA puzzle_index
       06:C34D  0A                ASL A
       06:C34E  A8                TAY
                                  
   49  06:C34F  20 30 CB    JSR GetTableAtIndex
   50                       MACROGetPointer table_address, puzzle_address
                          
       06:C352  AD 16 00          LDA table_address
       06:C355  8D AC 00          STA puzzle_address
       06:C358  AD 17 00          LDA table_address+1
       06:C35B  8D AD 00          STA puzzle_address+1
                          
   51                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C35E  A9 61             LDA #HIGH(MOUSE_START)
       06:C360  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C362  8E C2 00          STX mouse_location
       06:C365  8D C3 00          STA mouse_location+1
                                  
   52                     
   53                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   54  06:C368  A0 00       LDY #$00
   55  06:C36A  B1 AC       LDA [puzzle_address], y
   56  06:C36C  AA          TAX
   57  06:C36D  BD DF C9    LDA PuzzleHeaderSkips, x
   58  06:C370  8D 00 00    STA temp1
   59                       
   60  06:C373  AD AC 00    LDA puzzle_address
   61  06:C376  18          CLC
   62  06:C377  6D 00 00    ADC temp1
   63  06:C37A  8D AE 00    STA clues_address
   64  06:C37D  A9 00       LDA #$00
   65  06:C37F  6D AD 00    ADC puzzle_address+1
   66  06:C382  8D AF 00    STA clues_address+1
   67                     
   68  06:C385  A9 00       LDA #$00
   69  06:C387  8D BA 00    STA clueTableIndex
   70  06:C38A  8D BB 00    STA clueLineIndex
   71  06:C38D  8D C1 00    STA clueParity
   72  06:C390  8D BC 00    STA clueOffsetShift
   73  06:C393  8D C4 00    STA mouse_index
   74  06:C396  8D C5 00    STA mouse_index+1
   75                     
   76  06:C399  AD 00 70    LDA hasContinue
   77  06:C39C  D0 14       BNE .skipSolutionReset
   78                       
   79  06:C39E  A9 00       LDA #$00
   80  06:C3A0  8D 01 70    STA solutionCount
   81  06:C3A3  8D 02 70    STA nonSolutionCount
   82  06:C3A6  8D 03 70    STA GameTime
   83  06:C3A9  8D 04 70    STA GameTime+1
   84  06:C3AC  8D 05 70    STA GameTime+2
   85  06:C3AF  8D 06 70    STA GameTime+3
   86                       
   87  06:C3B2            .skipSolutionReset:     
   88                       
   89  06:C3B2  A9 20       LDA #$20
   90  06:C3B4  8D BD 00    STA clueDrawAdd
   91                     
   92  06:C3B7  A9 00       LDA #$00
   93  06:C3B9  8D 00 70    STA hasContinue  
   94                       
   95                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C3BC  A9 21             LDA #HIGH(VERT_CLUES)
       06:C3BE  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C3C0  8E B6 00          STX clue_start_address
       06:C3C3  8D B7 00          STA clue_start_address+1
                                  
   96  06:C3C6  20 65 CE    JSR ResetClueDrawAddress
   97                       
   98                       MACROAddPPUStringEntryRawData #HIGH(BANK_LEVEL), #LOW(BANK_LEVEL), #DRAW_HORIZONTAL, #$03
                          
       06:C3C9  A9 01       LDA #$01
       06:C3CB  8D 23 00    STA PPU_PendingWrite
       06:C3CE  A9 20       LDA #HIGH(BANK_LEVEL)
       06:C3D0  20 8C CC    JSR WriteToPPUString
       06:C3D3  A9 A8       LDA #LOW(BANK_LEVEL)
       06:C3D5  20 8C CC    JSR WriteToPPUString
       06:C3D8  A9 00       LDA #DRAW_HORIZONTAL
       06:C3DA  20 8C CC    JSR WriteToPPUString
       06:C3DD  A9 03       LDA #$03 
       06:C3DF  20 8C CC    JSR WriteToPPUString
                            
   99  06:C3E2  AD 07 70    LDA bank_index
  100  06:C3E5  20 8C CC    JSR WriteToPPUString
  101  06:C3E8  A9 60       LDA #$60
  102  06:C3EA  20 8C CC    JSR WriteToPPUString
  103  06:C3ED  AE 08 70    LDX puzzle_index
  104  06:C3F0  E8          INX
  105  06:C3F1  8A          TXA 
  106  06:C3F2  20 8C CC    JSR WriteToPPUString
  107                       
  108  06:C3F5  EE 0F 00    INC mode_state
  109                     
  110  06:C3F8            UpdateDrawVertClues:
  111                       
  112  06:C3F8  20 CA CD    JSR PopulateClues
  113  06:C3FB  90 22       BCC .leave
  114                       
  115  06:C3FD            .changeModeState:
  116                     
  117  06:C3FD  A9 00       LDA #$00
  118  06:C3FF  8D BB 00    STA clueLineIndex
  119  06:C402  8D C1 00    STA clueParity
  120                       
  121  06:C405  A9 05       LDA #$05
  122  06:C407  8D BC 00    STA clueOffsetShift
  123                       
  124  06:C40A  A9 01       LDA #$01
  125  06:C40C  8D BD 00    STA clueDrawAdd
  126                        
  127                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C40F  A9 21             LDA #HIGH(HORI_CLUES)
       06:C411  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C413  8E B6 00          STX clue_start_address
       06:C416  8D B7 00          STA clue_start_address+1
                                  
  128  06:C419  20 65 CE    JSR ResetClueDrawAddress
  129                     
  130  06:C41C  EE 0F 00    INC mode_state
  131  06:C41F            .leave:
  132  06:C41F  60          RTS
  133                       
  134  06:C420            UpdateDrawHoriClues:
  135                     
  136  06:C420  20 CA CD    JSR PopulateClues
  137  06:C423  90 44       BCC .leave
  138                     
  139  06:C425            .changeModeState:
  140  06:C425  20 D4 CC    JSR TurnOnSprites
  141                       
  142                       ;;set the timer to 00
  143                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C428  A9 01       LDA #$01
       06:C42A  8D 23 00    STA PPU_PendingWrite
       06:C42D  A9 20       LDA #HIGH(TIMER_LOC)
       06:C42F  20 8C CC    JSR WriteToPPUString
       06:C432  A9 E5       LDA #LOW(TIMER_LOC)
       06:C434  20 8C CC    JSR WriteToPPUString
       06:C437  A9 00       LDA #DRAW_HORIZONTAL
       06:C439  20 8C CC    JSR WriteToPPUString
       06:C43C  A9 05       LDA #$05 
       06:C43E  20 8C CC    JSR WriteToPPUString
                            
  144  06:C441  AD 06 70    LDA GameTime+3
  145  06:C444  20 8C CC    JSR WriteToPPUString
  146  06:C447  AD 05 70    LDA GameTime+2
  147  06:C44A  20 8C CC    JSR WriteToPPUString
  148  06:C44D  A9 61       LDA #$61
  149  06:C44F  20 8C CC    JSR WriteToPPUString
  150  06:C452  AD 04 70    LDA GameTime+1
  151  06:C455  20 8C CC    JSR WriteToPPUString
  152  06:C458  AD 03 70    LDA GameTime
  153  06:C45B  20 8C CC    JSR WriteToPPUString
  154                       
  155                       ;;reset time
  156  06:C45E  A9 00       LDA #$00
  157  06:C460  8D 0A 00    STA time
  158  06:C463  8D 0B 00    STA scaledTime
  159                       
  160  06:C466  EE 0F 00    INC mode_state
  161  06:C469            .leave:
  162  06:C469  60          RTS
  163                       
  164  06:C46A            UpdateGamePlay:
  165                         
  166  06:C46A  AD C7 00    LDA pauseState
  167  06:C46D  F0 04       BEQ .checkPause
  168  06:C46F  20 08 C9    JSR UpdatePause
  169  06:C472  60          RTS
  170                       
  171  06:C473            .checkPause:
  172                       
  173  06:C473  AD 1C 00    LDA gamepadPressed
  174  06:C476  29 08       AND #GAMEPAD_START
  175  06:C478  F0 29       BEQ .updatePlay
  176  06:C47A  A9 01       LDA #$01
  177  06:C47C  8D C7 00    STA pauseState
  178  06:C47F  A9 00       LDA #$00
  179  06:C481  8D BB 00    STA clueLineIndex 
  180  06:C484  8D BC 00    STA clueOffsetShift   
  181                     
  182  06:C487  A9 FF       LDA #$FF
  183  06:C489  A2 00       LDX #$00
  184  06:C48B  20 2A C2    JSR SetSpriteImage
  185                     
  186                       ;;we need the pause screen table loaded
  187                       MACROGetLabelPointer Pause_Menu, pause_address
                          
       06:C48E  A9 FC             LDA #HIGH(Pause_Menu)
       06:C490  A2 7C             LDX #LOW(Pause_Menu)
                                  
       06:C492  8E B0 00          STX pause_address
       06:C495  8D B1 00          STA pause_address+1
                                  
  188                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C498  A9 21             LDA #HIGH($210A)
       06:C49A  A2 0A             LDX #LOW($210A)
                                  
       06:C49C  8E B4 00          STX pause_draw_address
       06:C49F  8D B5 00          STA pause_draw_address+1
                                  
  189                       
  190                       
  191  06:C4A2  60          RTS
  192                     
  193  06:C4A3            .updatePlay:
  194                     
  195  06:C4A3  20 89 C8    JSR UpdateTimeDisplay
  196                             
  197  06:C4A6  A9 00       LDA #$00
  198  06:C4A8  8D 00 00    STA temp1
  199  06:C4AB  8D 01 00    STA temp2
  200  06:C4AE  8D 02 00    STA temp3
  201                       
  202  06:C4B1            .checkPressed:  
  203                     
  204  06:C4B1  AD 1C 00    LDA gamepadPressed
  205  06:C4B4  29 F0       AND #GAMEPAD_MOVE
  206  06:C4B6  F0 0B       BEQ .checkHeld
  207                       
  208  06:C4B8  A9 10       LDA #HOLD_TIME
  209  06:C4BA  8D C9 00    STA holdTimer 
  210  06:C4BD  AD 1C 00    LDA gamepadPressed
  211  06:C4C0  4C D7 C4    JMP .parseInputs
  212                       
  213  06:C4C3            .checkHeld:
  214                       
  215  06:C4C3  AD 1A 00    LDA gamepad
  216  06:C4C6  29 F0       AND #GAMEPAD_MOVE
  217  06:C4C8  F0 2F       BEQ .checkPaintPress
  218                       
  219                       ;;decrement the hold timer
  220  06:C4CA  CE C9 00    DEC holdTimer
  221  06:C4CD  D0 2A       BNE .checkPaintPress
  222  06:C4CF  A9 04       LDA #HOLD_FREQ
  223  06:C4D1  8D C9 00    STA holdTimer
  224  06:C4D4  AD 1A 00    LDA gamepad
  225                     
  226  06:C4D7            .parseInputs:
  227                     
  228  06:C4D7  29 F0       AND #GAMEPAD_MOVE
  229  06:C4D9  F0 1E       BEQ .checkPaintPress
  230  06:C4DB  0A          ASL A
  231  06:C4DC  90 03       BCC .checkLeft
  232  06:C4DE  EE 00 00    INC temp1
  233  06:C4E1            .checkLeft:
  234  06:C4E1  0A          ASL A
  235  06:C4E2  90 03       BCC .checkDown
  236  06:C4E4  CE 00 00    DEC temp1
  237  06:C4E7            .checkDown:
  238  06:C4E7  0A          ASL A
  239  06:C4E8  90 03       BCC .checkUp
  240  06:C4EA  EE 01 00    INC temp2
  241  06:C4ED            .checkUp:
  242  06:C4ED  0A          ASL A
  243  06:C4EE  90 03       BCC .move
  244  06:C4F0  CE 01 00    DEC temp2
  245                       
  246  06:C4F3            .move:
  247                      
  248  06:C4F3  20 CD C7    JSR MoveMouse
  249  06:C4F6  20 35 C8    JSR UpdateMouseScreenPos
  250                       
  251  06:C4F9            .checkPaintPress:
  252                     
  253  06:C4F9  AD 1C 00    LDA gamepadPressed
  254  06:C4FC  29 03       AND #GAMEPAD_AB
  255  06:C4FE  F0 41       BEQ .updatePaint
  256                       ;;A or B pressed, get current tile
  257                       
  258  06:C500  8D 00 00    STA temp1
  259                       
  260  06:C503  A0 00       LDY #$00
  261  06:C505  B1 C2       LDA [mouse_location], y
  262  06:C507  8D 01 00    STA temp2
  263                       
  264                         ;;A treats X and Clear as clear
  265                             ;;B treats mark and clear as clear
  266                             ;;clear->mark->x
  267                             
  268                     
  269  06:C50A  C9 7C       CMP #$7C      ;check if this is a marked tile
  270  06:C50C  B0 0F       BCS .getClearTile
  271                       ;;cleared tile- store off marked tile to paint with instead
  272                       ;;not a clear tile- a mark or an x - check A or B  
  273  06:C50E  4E 00 00    LSR temp1
  274  06:C511  B0 05       BCS .getMarkTile
  275                       
  276  06:C513            .getXTile:
  277  06:C513  A9 80       LDA #$80
  278  06:C515  4C 3B C5    JMP .finishGetTile
  279                       
  280  06:C518            .getMarkTile:
  281  06:C518  A9 70       LDA #$70
  282  06:C51A  4C 3B C5    JMP .finishGetTile
  283                     
  284  06:C51D            .getClearTile:
  285                       
  286  06:C51D  4E 00 00    LSR temp1
  287  06:C520  90 0A       BCC .checkB
  288  06:C522  AD 01 00    LDA temp2
  289  06:C525  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  290  06:C527  90 0D       BCC .clearTile
  291  06:C529  4C 18 C5    JMP .getMarkTile
  292                       
  293  06:C52C            .checkB:
  294                       
  295  06:C52C  AD 01 00   LDA temp2
  296  06:C52F  C9 8C      CMP #$8C
  297  06:C531  B0 03      BCS .clearTile
  298  06:C533  4C 13 C5   JMP .getXTile
  299                       
  300  06:C536            .clearTile:
  301  06:C536  A9 60       LDA #$60
  302  06:C538  4C 3B C5    JMP .finishGetTile
  303                       
  304  06:C53B            .finishGetTile:
  305  06:C53B  8D C6 00    STA currentPaintTile
  306  06:C53E  4C 53 C5    JMP .setTile
  307                     
  308                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  309                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  310                     ;;we can load the nametable into memory as we draw it
  311                     
  312  06:C541            .updatePaint:
  313                     
  314  06:C541  AD 1A 00    LDA gamepad
  315  06:C544  29 03       AND #GAMEPAD_AB
  316  06:C546  D0 06       BNE .checkInputLock
  317                       
  318  06:C548  A9 00       LDA #$00
  319  06:C54A  8D C8 00    STA pauseInputLock
  320                       
  321  06:C54D            .leaveEarly:
  322  06:C54D  60          RTS  
  323                     
  324  06:C54E            .checkInputLock:
  325                     
  326                       ;;check if the input lock is on
  327  06:C54E  2D C8 00    AND pauseInputLock
  328  06:C551  D0 FA       BNE .leaveEarly
  329                       
  330  06:C553            .setTile:
  331                       
  332                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  333  06:C553  AD C5 00    LDA mouse_index+1
  334                     ;;if the puzzle is a 5x5, we only have one byte per row, so no need to double this
  335  06:C556  8D 00 00    STA temp1
  336  06:C559  A0 00       LDY #$00
  337  06:C55B  B1 AC       LDA [puzzle_address], y
  338  06:C55D  F0 03       BEQ .skipDouble
  339  06:C55F  0E 00 00    ASL temp1
  340  06:C562            .skipDouble:
  341  06:C562  AD 00 00    LDA temp1
  342  06:C565  18          CLC
  343  06:C566  69 04       ADC #$04 ;; add to get past header
  344  06:C568  8D 00 00    STA temp1
  345                       
  346                       ;;div X position by 8 to get the byte index
  347  06:C56B  AD C4 00    LDA mouse_index
  348  06:C56E  4A          LSR A
  349  06:C56F  4A          LSR A
  350  06:C570  4A          LSR A
  351  06:C571  F0 03       BEQ .getMask
  352                       
  353  06:C573  EE 00 00    INC temp1
  354                       
  355  06:C576            .getMask:
  356                       
  357  06:C576  AD C4 00    LDA mouse_index
  358  06:C579  29 07       AND #$07
  359  06:C57B  AA          TAX
  360  06:C57C  A9 80       LDA #$80
  361  06:C57E  E0 00       CPX #$00
  362  06:C580  F0 04       BEQ .storeMask
  363                     
  364  06:C582            .maskLoop:
  365  06:C582  4A          LSR A
  366  06:C583  CA          DEX
  367  06:C584  D0 FC       BNE .maskLoop
  368  06:C586            .storeMask:
  369  06:C586  8D 01 00    STA temp2
  370                     
  371  06:C589  AC 00 00    LDY temp1
  372  06:C58C  B1 AC       LDA [puzzle_address], y
  373  06:C58E  2D 01 00    AND temp2
  374  06:C591  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  375                     
  376  06:C594  A0 00       LDY #$00
  377  06:C596  B1 C2       LDA [mouse_location], y
  378  06:C598  8D 02 00    STA temp3
  379  06:C59B  29 F0       AND #$F0
  380  06:C59D  CD C6 00    CMP currentPaintTile
  381  06:C5A0  D0 01       BNE .diffTiles
  382  06:C5A2  60          RTS
  383                       
  384  06:C5A3            .diffTiles:
  385                       ;;tiles are different- check if the current tile is marked as a solution tile
  386  06:C5A3  C9 70       CMP #$70
  387  06:C5A5  D0 0B       BNE .checkNewMark
  388                       ;;if erasing a mark, check if the tile was part of the solution
  389  06:C5A7  AD 00 00    LDA temp1
  390  06:C5AA  D0 18       BNE .antiMark
  391  06:C5AC  CE 02 70    DEC nonSolutionCount
  392  06:C5AF  4C CD C5    JMP .overwriteTile
  393                       
  394  06:C5B2            .checkNewMark:
  395                     
  396  06:C5B2  AD C6 00    LDA currentPaintTile
  397  06:C5B5  C9 70       CMP #$70
  398  06:C5B7  D0 14       BNE .overwriteTile
  399                       
  400  06:C5B9  AD 00 00    LDA temp1
  401  06:C5BC  D0 0C       BNE .proMark
  402  06:C5BE  EE 02 70    INC nonSolutionCount 
  403  06:C5C1  4C CD C5    JMP .overwriteTile  
  404                       
  405  06:C5C4            .antiMark:
  406  06:C5C4  CE 01 70    DEC solutionCount
  407  06:C5C7  4C CD C5    JMP .overwriteTile
  408  06:C5CA            .proMark:   
  409                       
  410  06:C5CA  EE 01 70    INC solutionCount
  411                       
  412  06:C5CD            .overwriteTile:
  413                       ;;overwrite tile
  414  06:C5CD  AD 02 00    LDA temp3
  415  06:C5D0  29 0F       AND #$0F
  416  06:C5D2  0D C6 00    ORA currentPaintTile
  417  06:C5D5  A0 00       LDY #$00
  418  06:C5D7  91 C2       STA [mouse_location], y
  419  06:C5D9  8D 00 00    STA temp1
  420                       
  421  06:C5DC  AD C3 00    LDA mouse_location+1
  422  06:C5DF  29 3F       AND #$3F
  423  06:C5E1  8D 01 00    STA temp2
  424                         
  425                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C5E4  A9 01       LDA #$01
       06:C5E6  8D 23 00    STA PPU_PendingWrite
       06:C5E9  AD 01 00    LDA temp2
       06:C5EC  20 8C CC    JSR WriteToPPUString
       06:C5EF  AD C2 00    LDA mouse_location
       06:C5F2  20 8C CC    JSR WriteToPPUString
       06:C5F5  A9 00       LDA #DRAW_HORIZONTAL
       06:C5F7  20 8C CC    JSR WriteToPPUString
       06:C5FA  A9 01       LDA #$01 
       06:C5FC  20 8C CC    JSR WriteToPPUString
                            
  426  06:C5FF  AD 00 00    LDA temp1
  427  06:C602  20 8C CC    JSR WriteToPPUString
  428                       
  429                       ;;also copy to save copy
  430  06:C605  AD C2 00    LDA mouse_location
  431  06:C608  8D B2 00    STA copy_address
  432  06:C60B  AD C3 00    LDA mouse_location+1
  433  06:C60E  29 0F       AND #$0F
  434  06:C610  09 60       ORA #$60
  435  06:C612  18          CLC
  436  06:C613  69 08       ADC #$08
  437  06:C615  8D B3 00    STA copy_address+1
  438                       
  439  06:C618  AD 00 00    LDA temp1
  440  06:C61B  A0 00       LDY #$00
  441  06:C61D  91 B2       STA [copy_address],y
  442                       
  443  06:C61F            .checkSolution: 
  444                     
  445  06:C61F  A0 01       LDY #$01
  446  06:C621  B1 AC       LDA [puzzle_address], y
  447  06:C623  CD 01 70    CMP solutionCount
  448  06:C626  D0 4C       BNE .leave
  449  06:C628  AD 02 70    LDA nonSolutionCount
  450  06:C62B  F0 03       BEQ .changeModeState
  451                       
  452  06:C62D  4C 74 C6    JMP .leave
  453                       
  454                       ;;update the painting
  455  06:C630            .changeModeState:
  456                      
  457  06:C630  20 DD CC    JSR TurnOffSprites
  458                        
  459  06:C633  A9 00       LDA #$00
  460  06:C635  8D B8 00    STA clue_draw_address
  461  06:C638  8D BB 00    STA clueLineIndex
  462  06:C63B  A9 20       LDA #$20
  463  06:C63D  8D B9 00    STA clue_draw_address+1
  464                       
  465  06:C640  EE 0F 00    INC mode_state
  466                       
  467                       ;;the puzzle is solved, store the time and solved bit in memory
  468                       ;;if the puzzle was solved before, only update the time
  469                       
  470                       MACROGetLabelPointer PuzzleSaveLocations, table_address
                          
       06:C643  A9 C9             LDA #HIGH(PuzzleSaveLocations)
       06:C645  A2 E2             LDX #LOW(PuzzleSaveLocations)
                                  
       06:C647  8E 16 00          STX table_address
       06:C64A  8D 17 00          STA table_address+1
                                  
  471  06:C64D  AD 07 70    LDA bank_index
  472  06:C650  0A          ASL A
  473  06:C651  A8          TAY
  474  06:C652  20 30 CB    JSR GetTableAtIndex
  475                       
  476  06:C655  AD 08 70    LDA puzzle_index
  477  06:C658  0A          ASL A
  478  06:C659  0A          ASL A
  479  06:C65A  A8          TAY
  480  06:C65B  AD 03 70    LDA GameTime
  481  06:C65E  09 80       ORA #$80
  482  06:C660  91 16       STA [table_address], y
  483  06:C662  C8          INY
  484  06:C663  AD 04 70    LDA GameTime+1
  485  06:C666  91 16       STA [table_address], y
  486  06:C668  C8          INY
  487  06:C669  AD 05 70    LDA GameTime+2
  488  06:C66C  91 16       STA [table_address], y
  489  06:C66E  C8          INY
  490  06:C66F  AD 06 70    LDA GameTime+3
  491  06:C672  91 16       STA [table_address],y
  492                     
  493                       
  494  06:C674            .leave:
  495                      
  496  06:C674  60          RTS
  497                       
  498  06:C675            UpdateClearPuzzle:
  499                     
  500  06:C675  20 D9 CE    JSR ClearPuzzle
  501  06:C678  AD BB 00    LDA clueLineIndex
  502  06:C67B  C9 1E       CMP #30
  503  06:C67D  D0 08       BNE .leave
  504                       
  505  06:C67F            .changeModeState:
  506                     
  507  06:C67F  A9 00       LDA #$00
  508  06:C681  8D BB 00    STA clueLineIndex ;using this as a scroller
  509  06:C684  EE 0F 00    INC mode_state
  510                     
  511  06:C687            .leave:
  512                      
  513  06:C687  60          RTS
  514  06:C688            UpdateMoveScreen:
  515                       
  516                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  517                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  518                       
  519  06:C688  A0 00       LDY #$00
  520  06:C68A  B1 AC       LDA [puzzle_address], y
  521  06:C68C  AA          TAX
  522  06:C68D  BD D9 C9    LDA PuzzleScrollHori, x
  523  06:C690  8D 00 00    STA temp1
  524  06:C693  BD DC C9    LDA PuzzleScrollVert, x
  525  06:C696  8D 01 00    STA temp2
  526                       
  527  06:C699  AD BB 00    LDA clueLineIndex
  528  06:C69C  29 10       AND #$10
  529  06:C69E  D0 1E       BNE .scrollY
  530                       
  531                       ;;scroll X over
  532  06:C6A0  AD BB 00    LDA clueLineIndex
  533  06:C6A3  29 0F       AND #$0F
  534  06:C6A5  0A          ASL A
  535  06:C6A6  0A          ASL A
  536  06:C6A7  0A          ASL A ;mult by 8
  537  06:C6A8  8D 1F 00    STA PPU_ScrollX
  538                       
  539  06:C6AB  EE BB 00    INC clueLineIndex
  540  06:C6AE  AD BB 00    LDA clueLineIndex
  541  06:C6B1  CD 00 00    CMP temp1
  542  06:C6B4  D0 4A       BNE .leave
  543  06:C6B6  A9 10       LDA #$10
  544  06:C6B8  8D BB 00    STA clueLineIndex
  545  06:C6BB  4C 00 C7    JMP .leave
  546                       
  547  06:C6BE            .scrollY:
  548                     
  549  06:C6BE  AD BB 00    LDA clueLineIndex
  550  06:C6C1  29 0F       AND #$0F
  551  06:C6C3  0A          ASL A
  552  06:C6C4  0A          ASL A
  553  06:C6C5  0A          ASL A ;mult by 8
  554  06:C6C6  8D 20 00    STA PPU_ScrollY
  555                     
  556  06:C6C9  EE BB 00    INC clueLineIndex
  557  06:C6CC  AD BB 00    LDA clueLineIndex
  558  06:C6CF  29 0F       AND #$0F
  559  06:C6D1  CD 01 00    CMP temp2
  560  06:C6D4  D0 2A       BNE .leave
  561                       
  562  06:C6D6            .changeModeState:
  563                     
  564  06:C6D6  A9 8E       LDA #$8E
  565  06:C6D8  8D B8 00    STA clue_draw_address
  566  06:C6DB  A9 21       LDA #$21
  567  06:C6DD  8D B9 00    STA clue_draw_address+1
  568                       
  569  06:C6E0  AD AE 00    LDA clues_address
  570  06:C6E3  18          CLC
  571  06:C6E4  6D BA 00    ADC clueTableIndex
  572  06:C6E7  8D AE 00    STA clues_address
  573  06:C6EA  AD AF 00    LDA clues_address+1
  574  06:C6ED  69 00       ADC #$00
  575  06:C6EF  8D AF 00    STA clues_address+1
  576                       
  577  06:C6F2  A9 00       LDA #$00
  578  06:C6F4  8D BA 00    STA clueTableIndex
  579  06:C6F7  8D BB 00    STA clueLineIndex
  580  06:C6FA  8D BC 00    STA clueOffsetShift
  581                     
  582  06:C6FD  EE 0F 00    INC mode_state
  583                     
  584  06:C700            .leave:
  585                      
  586  06:C700  60          RTS
  587  06:C701            UpdateDrawImage:
  588                     
  589                       ;run it twice for a faster draw
  590  06:C701  20 BB CF    JSR DrawImage
  591  06:C704  AD BA 00    LDA clueTableIndex
  592  06:C707  CD 09 00    CMP tempy
  593                       ;BEQ .changeModeState
  594                       
  595                       ;JSR DrawImage
  596                       ;LDA clueTableIndex
  597                       ;CMP tempy
  598  06:C70A  D0 7A       BNE .leave
  599                       
  600  06:C70C            .changeModeState:
  601                     
  602                       ;;do a palette draw
  603                       ;;puzzle address + 03 has the desired palette offset
  604                     
  605  06:C70C  A0 03       LDY #$03
  606  06:C70E  B1 AC       LDA [puzzle_address],y
  607  06:C710  29 0F       AND #$0F
  608  06:C712  AA          TAX
  609                       
  610  06:C713  B1 AC       LDA [puzzle_address],y
  611  06:C715  29 10       AND #$10
  612  06:C717  F0 15       BEQ .storeBottomVals
  613                       
  614  06:C719  8A          TXA
  615  06:C71A  09 10       ORA #$10
  616  06:C71C  8D 01 00    STA temp2
  617  06:C71F  8A          TXA
  618  06:C720  09 20       ORA #$20
  619  06:C722  8D 02 00    STA temp3
  620  06:C725  8A          TXA
  621  06:C726  09 30       ORA #$30
  622  06:C728  8D 03 00    STA temp4
  623                     
  624  06:C72B  4C 40 C7    JMP .checkKeepWhite
  625                       
  626  06:C72E            .storeBottomVals:
  627                     
  628  06:C72E  8A          TXA
  629  06:C72F  09 00       ORA #$00
  630  06:C731  8D 01 00    STA temp2
  631  06:C734  8A          TXA
  632  06:C735  09 10       ORA #$10
  633  06:C737  8D 02 00    STA temp3
  634  06:C73A  8A          TXA
  635  06:C73B  09 20       ORA #$20
  636  06:C73D  8D 03 00    STA temp4
  637                       
  638  06:C740            .checkKeepWhite:
  639                       
  640  06:C740  B1 AC       LDA [puzzle_address],y
  641  06:C742  29 20       AND #$20
  642  06:C744  F0 05       BEQ .loadPalToPPUStr
  643                       
  644  06:C746  A9 30       LDA #$30
  645  06:C748  8D 03 00    STA temp4
  646                       
  647                       
  648  06:C74B            .loadPalToPPUStr:
  649                       
  650                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C74B  A9 01       LDA #$01
       06:C74D  8D 23 00    STA PPU_PendingWrite
       06:C750  A9 3F       LDA #$3F
       06:C752  20 8C CC    JSR WriteToPPUString
       06:C755  A9 01       LDA #$01
       06:C757  20 8C CC    JSR WriteToPPUString
       06:C75A  A9 00       LDA #DRAW_HORIZONTAL
       06:C75C  20 8C CC    JSR WriteToPPUString
       06:C75F  A9 03       LDA #03 
       06:C761  20 8C CC    JSR WriteToPPUString
                            
  651  06:C764  AD 01 00    LDA temp2
  652  06:C767  20 8C CC    JSR WriteToPPUString
  653  06:C76A  AD 02 00    LDA temp3
  654  06:C76D  20 8C CC    JSR WriteToPPUString
  655  06:C770  AD 03 00    LDA temp4
  656  06:C773  20 8C CC    JSR WriteToPPUString
  657                       
  658  06:C776  A2 01       LDX #$01
  659  06:C778            .copyLoop:
  660                       ;;also store in the copy 
  661  06:C778  BD 00 00    LDA temp1, x
  662  06:C77B  9D 00 6C    STA Palette_Copy, x
  663  06:C77E  E8          INX
  664  06:C77F  E0 04       CPX #$04
  665  06:C781  D0 F5       BNE .copyLoop
  666                       
  667                       
  668  06:C783  EE 0F 00    INC mode_state
  669                     
  670  06:C786            .leave:
  671                      
  672  06:C786  60          RTS
  673                       
  674  06:C787            UpdateWaitInput:
  675                     
  676  06:C787  AD 1C 00    LDA gamepadPressed
  677  06:C78A  F0 10       BEQ .leave
  678                       
  679  06:C78C            .changeModeState:
  680  06:C78C  A9 00       LDA #$00
  681  06:C78E  8D 0A 00    STA time
  682  06:C791  8D 0B 00    STA scaledTime
  683  06:C794  A9 02       LDA #GAMEOVER_IDX
  684  06:C796  8D CA 00    STA targetGameMode
  685  06:C799  EE 0F 00    INC mode_state
  686                     
  687  06:C79C            .leave:
  688                      
  689  06:C79C  60          RTS
  690                       
  691  06:C79D            UpdateGameFadeOut:
  692                     
  693  06:C79D  AD 0A 00    LDA time
  694  06:C7A0  29 07       AND #$07
  695  06:C7A2  D0 0D       BNE .leave
  696                       ;;every 8 frames, decrement the palettes
  697  06:C7A4  20 09 CD    JSR FadeOutPalettes
  698  06:C7A7  B0 08       BCS .leave
  699                     
  700  06:C7A9            .changeModeState:
  701  06:C7A9  A9 00       LDA #$00
  702  06:C7AB  8D 0A 00    STA time
  703  06:C7AE  EE 0F 00    INC mode_state
  704  06:C7B1            .leave:
  705  06:C7B1  60          RTS  
  706                     
  707  06:C7B2            UpdateGameExit:
  708                     
  709  06:C7B2  AD 0A 00    LDA time
  710  06:C7B5  29 0F       AND #$0F
  711  06:C7B7  D0 13       BNE .leave
  712                     
  713  06:C7B9  A9 00       LDA #$00
  714  06:C7BB  8D 1F 00    STA PPU_ScrollX
  715  06:C7BE  8D 20 00    STA PPU_ScrollY
  716  06:C7C1  8D 21 00    STA PPU_ScrollNT
  717                       
  718  06:C7C4  AD CA 00    LDA targetGameMode
  719  06:C7C7  A2 00       LDX #$00
  720  06:C7C9  20 39 CA    JSR ChangeGameMode
  721  06:C7CC            .leave:
  722  06:C7CC  60          RTS
  723                       
  724  06:C7CD            MoveMouse:
  725                     
  726  06:C7CD  AD 00 00    LDA temp1
  727  06:C7D0  0E 00 00    ASL temp1
  728  06:C7D3  0E 00 00    ASL temp1
  729  06:C7D6  0E 00 00    ASL temp1
  730                       
  731  06:C7D9  AD 01 00    LDA temp2
  732  06:C7DC  0E 01 00    ASL temp2 
  733  06:C7DF  0E 01 00    ASL temp2
  734  06:C7E2  0E 01 00    ASL temp2
  735                       
  736  06:C7E5  A0 00       LDY #$00
  737  06:C7E7  B1 AC       LDA [puzzle_address], y ;puzzle size 0 = 5, 1 = 10, 2 = 15  
  738  06:C7E9  0A          ASL A
  739  06:C7EA  AA          TAX
  740  06:C7EB  BD CD C9    LDA MouseMinimums, x
  741  06:C7EE  8D 02 00    STA temp3
  742  06:C7F1  BD D3 C9    LDA MouseMaximums, x
  743  06:C7F4  8D 03 00    STA temp4
  744  06:C7F7  8A          TXA
  745  06:C7F8  48          PHA
  746                       
  747  06:C7F9  A2 03       LDX #SPRITE_XPOS
  748  06:C7FB  BD 00 02    LDA SPRITE_DATA, x
  749  06:C7FE  18          CLC
  750  06:C7FF  6D 00 00    ADC temp1
  751                       ;;check against borders
  752  06:C802  CD 02 00    CMP temp3
  753  06:C805  F0 08       BEQ .moveVert 
  754  06:C807  CD 03 00    CMP temp4
  755  06:C80A  F0 03       BEQ .moveVert
  756  06:C80C  9D 00 02    STA SPRITE_DATA, x
  757                     
  758  06:C80F            .moveVert:
  759                     
  760  06:C80F  68          PLA
  761  06:C810  AA          TAX
  762  06:C811  E8          INX
  763  06:C812  BD CD C9    LDA MouseMinimums, x
  764  06:C815  8D 02 00    STA temp3
  765  06:C818  BD D3 C9    LDA MouseMaximums, x
  766  06:C81B  8D 03 00    STA temp4
  767                     
  768  06:C81E  A2 00       LDX #SPRITE_YPOS
  769  06:C820  BD 00 02    LDA SPRITE_DATA, x
  770  06:C823  18          CLC
  771  06:C824  6D 01 00    ADC temp2
  772                       ;;check against borders
  773  06:C827  CD 02 00    CMP temp3
  774  06:C82A  F0 08       BEQ .leave
  775  06:C82C  CD 03 00    CMP temp4
  776  06:C82F  F0 03       BEQ .leave
  777  06:C831  9D 00 02    STA SPRITE_DATA, x
  778                     
  779  06:C834            .leave:
  780  06:C834  60          RTS
  781                             
  782  06:C835            UpdateMouseScreenPos:
  783                     
  784  06:C835  A2 00       LDX #$00
  785  06:C837  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  786  06:C83A  4A          LSR A                                         ;0yyy yy..
  787  06:C83B  4A          LSR A                                         ;00yy yyy.
  788  06:C83C  4A          LSR A                                         ;000y yyyy
  789  06:C83D  8D 00 00    STA temp1
  790  06:C840  8D C5 00    STA mouse_index+1
  791  06:C843  E8          INX
  792  06:C844  E8          INX
  793  06:C845  E8          INX   
  794  06:C846  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  795  06:C849  29 F8       AND #$F8                       ;              ;  xxxx x000
  796  06:C84B  8D 01 00    STA temp2                      ;      ;  
  797  06:C84E  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  798  06:C851  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  799  06:C854  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  800  06:C857  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  801  06:C85A  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  802  06:C85D  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  803  06:C860  AD 01 00    LDA temp2
  804  06:C863  29 1F       AND #$1F
  805  06:C865  8D C4 00    STA mouse_index
  806                       
  807  06:C868  AD C4 00    LDA mouse_index
  808  06:C86B  38          SEC 
  809  06:C86C  E9 0E       SBC #$0E
  810  06:C86E  8D C4 00    STA mouse_index
  811                       
  812  06:C871  AD C5 00    LDA mouse_index+1
  813  06:C874  38          SEC 
  814  06:C875  E9 0C       SBC #$0C
  815  06:C877  8D C5 00    STA mouse_index+1
  816                       
  817                       ;subtract starting offsets for mouse index
  818                       
  819  06:C87A  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  820  06:C87D  09 60       ORA #$60                       ;              ;  0110 00yy
  821                       
  822  06:C87F  8D C3 00    STA mouse_location+1
  823  06:C882  AD 01 00    LDA temp2
  824  06:C885  8D C2 00    STA mouse_location
  825                       
  826  06:C888            .leave:
  827  06:C888  60          RTS
  828                       
  829  06:C889            UpdateTimeDisplay:
  830                     
  831  06:C889  AD 0B 00    LDA scaledTime
  832  06:C88C  C9 3C       CMP #60
  833  06:C88E  D0 77       BNE .leave
  834                       
  835  06:C890  A9 00       LDA #$00
  836  06:C892  8D 0B 00    STA scaledTime
  837                       
  838  06:C895  EE 03 70    INC GameTime
  839  06:C898  AD 03 70    LDA GameTime
  840  06:C89B  C9 0A       CMP #10
  841  06:C89D  D0 32       BNE .printTime
  842                       
  843  06:C89F  A9 00       LDA #$00
  844  06:C8A1  8D 03 70    STA GameTime
  845  06:C8A4  EE 04 70    INC GameTime+1
  846  06:C8A7  AD 04 70    LDA GameTime+1
  847  06:C8AA  C9 06       CMP #6
  848  06:C8AC  D0 23       BNE .printTime
  849                       
  850  06:C8AE  A9 00       LDA #$00
  851  06:C8B0  8D 04 70    STA GameTime+1
  852  06:C8B3  EE 05 70    INC GameTime+2
  853  06:C8B6  AD 05 70    LDA GameTime+2
  854  06:C8B9  C9 0A       CMP #10
  855  06:C8BB  D0 14       BNE .printTime
  856                       
  857  06:C8BD  A9 00       LDA #$00
  858  06:C8BF  8D 05 70    STA GameTime+2
  859  06:C8C2  EE 06 70    INC GameTime+3
  860  06:C8C5  AD 06 70    LDA GameTime+3
  861  06:C8C8  C9 0A       CMP #10
  862  06:C8CA  D0 05       BNE .printTime
  863                       
  864  06:C8CC  A9 00       LDA #$00
  865  06:C8CE  8D 06 70    STA GameTime+3
  866                       
  867  06:C8D1            .printTime:
  868                     
  869                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C8D1  A9 01       LDA #$01
       06:C8D3  8D 23 00    STA PPU_PendingWrite
       06:C8D6  A9 20       LDA #HIGH(TIMER_LOC)
       06:C8D8  20 8C CC    JSR WriteToPPUString
       06:C8DB  A9 E5       LDA #LOW(TIMER_LOC)
       06:C8DD  20 8C CC    JSR WriteToPPUString
       06:C8E0  A9 00       LDA #DRAW_HORIZONTAL
       06:C8E2  20 8C CC    JSR WriteToPPUString
       06:C8E5  A9 05       LDA #$05 
       06:C8E7  20 8C CC    JSR WriteToPPUString
                            
  870  06:C8EA  AD 06 70    LDA GameTime+3
  871  06:C8ED  20 8C CC    JSR WriteToPPUString
  872  06:C8F0  AD 05 70    LDA GameTime+2
  873  06:C8F3  20 8C CC    JSR WriteToPPUString
  874  06:C8F6  A9 61       LDA #$61
  875  06:C8F8  20 8C CC    JSR WriteToPPUString
  876  06:C8FB  AD 04 70    LDA GameTime+1
  877  06:C8FE  20 8C CC    JSR WriteToPPUString
  878  06:C901  AD 03 70    LDA GameTime
  879  06:C904  20 8C CC    JSR WriteToPPUString
  880                       
  881                       
  882                       
  883  06:C907            .leave: 
  884  06:C907  60          RTS  
  885                       
  886  06:C908            UpdatePause:
  887                     
  888                     ;;load screen
  889                     ;;update selection
  890                     ;; close - remove screen, then upause
  891                     ;; quit - jump to fade out
  892  06:C908  AD C7 00    LDA pauseState
  893  06:C90B  20 0A CB    JSR Dynamic_Jump
  894                     
  895  06:C90E            UpdatePauseJumpTable:  
  896                     
  897  06:C90E  CC C9       .word ExitPause                       ;fail safe
  898  06:C910  16 C9       .word UpdateLoadPauseScreen
  899  06:C912  32 C9       .word UpdatePauseScreen
  900  06:C914  B0 C9       .word UpdateUnloadPauseScreen
  901                       
  902  06:C916            UpdateLoadPauseScreen:
  903                       
  904  06:C916  20 20 CF    JSR LoadPauseScreen
  905  06:C919  AD BC 00    LDA clueOffsetShift
  906  06:C91C  C9 06       CMP #$06
  907  06:C91E  D0 11       BNE .leave
  908                       
  909  06:C920            .changePauseState:
  910                     
  911  06:C920  A9 60       LDA #PAUSE_YES
  912  06:C922  A2 01       LDX #$01
  913  06:C924  20 1F C2    JSR SetSpriteXPosition  
  914  06:C927  A9 01       LDA #$01
  915  06:C929  A2 01       LDX #$01
  916  06:C92B  20 2A C2    JSR SetSpriteImage
  917                       
  918  06:C92E  EE C7 00    INC pauseState
  919  06:C931            .leave:
  920  06:C931  60          RTS
  921                       
  922  06:C932            UpdatePauseScreen:
  923                       
  924  06:C932  AD 1C 00    LDA gamepadPressed
  925  06:C935  C9 08       CMP #GAMEPAD_START
  926  06:C937  F0 29       BEQ .unPause
  927  06:C939  C9 02       CMP #GAMEPAD_B
  928  06:C93B  F0 25       BEQ .unPause
  929  06:C93D  C9 01       CMP #GAMEPAD_A
  930  06:C93F  F0 4A       BEQ .checkA
  931                       
  932                       ;;update pointer
  933                       
  934  06:C941  AD 1C 00    LDA gamepadPressed
  935  06:C944  29 C0       AND #GAMEPAD_HORI
  936                       ;;binary system- left and right don't really matter, we'll just toggle the position
  937  06:C946  F0 67       BEQ .leave
  938                       
  939  06:C948  A9 03       LDA #SPRITE_XPOS
  940  06:C94A  A2 01       LDX #$01
  941  06:C94C  20 41 C2    JSR GetSpriteData
  942                       
  943  06:C94F  C9 60       CMP #PAUSE_YES
  944  06:C951  F0 05       BEQ .loadNo
  945                       
  946  06:C953  A9 60       LDA #PAUSE_YES
  947  06:C955  4C 5A C9    JMP .setPosition
  948                       
  949  06:C958            .loadNo:
  950  06:C958  A9 88       LDA #PAUSE_NO
  951                     
  952  06:C95A            .setPosition
  953                       
  954  06:C95A  A2 01       LDX #$01
  955  06:C95C  20 1F C2    JSR SetSpriteXPosition  
  956                     
  957  06:C95F  4C AF C9    JMP .leave 
  958                     
  959  06:C962            .unPause:
  960                     
  961  06:C962  A9 00       LDA #$00
  962  06:C964  8D BB 00    STA clueLineIndex
  963  06:C967  8D BC 00    STA clueOffsetShift
  964                       
  965  06:C96A  A9 FF       LDA #$FF
  966  06:C96C  A2 01       LDX #$01
  967  06:C96E  20 2A C2    JSR SetSpriteImage
  968                     
  969                       MACROGetLabelPointer $610A, pause_address
                          
       06:C971  A9 61             LDA #HIGH($610A)
       06:C973  A2 0A             LDX #LOW($610A)
                                  
       06:C975  8E B0 00          STX pause_address
       06:C978  8D B1 00          STA pause_address+1
                                  
  970                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C97B  A9 21             LDA #HIGH($210A)
       06:C97D  A2 0A             LDX #LOW($210A)
                                  
       06:C97F  8E B4 00          STX pause_draw_address
       06:C982  8D B5 00          STA pause_draw_address+1
                                  
  971                         
  972  06:C985  EE C7 00    INC pauseState
  973  06:C988  4C AF C9    JMP .leave
  974                      
  975  06:C98B            .checkA:
  976                       
  977  06:C98B  A9 03       LDA #SPRITE_XPOS
  978  06:C98D  A2 01       LDX #$01
  979  06:C98F  20 41 C2    JSR GetSpriteData
  980                       
  981  06:C992  C9 88       CMP #PAUSE_NO
  982  06:C994  F0 CC       BEQ .unPause
  983                        
  984  06:C996            .quit:
  985                     
  986  06:C996  A9 01       LDA #$01
  987  06:C998  8D 00 70    STA hasContinue
  988  06:C99B  A9 00       LDA #$00
  989  06:C99D  8D C7 00    STA pauseState
  990  06:C9A0  A9 00       LDA #$00
  991  06:C9A2  8D 0A 00    STA time
  992  06:C9A5  A9 00       LDA #TITLE_IDX
  993  06:C9A7  8D CA 00    STA targetGameMode
  994  06:C9AA  A9 08       LDA #$08
  995  06:C9AC  8D 0F 00    STA mode_state
  996                       
  997  06:C9AF            .leave:
  998  06:C9AF  60          RTS
  999                       
 1000  06:C9B0            UpdateUnloadPauseScreen:
 1001                       
 1002  06:C9B0  20 67 CF    JSR ClearPauseScreen
 1003  06:C9B3  AD BC 00    LDA clueOffsetShift
 1004  06:C9B6  C9 06       CMP #$06
 1005  06:C9B8  D0 11       BNE .leave
 1006  06:C9BA            .changePauseState:
 1007                     
 1008  06:C9BA  A9 02       LDA #$02
 1009  06:C9BC  A2 00       LDX #$00
 1010  06:C9BE  20 2A C2    JSR SetSpriteImage
 1011                       
 1012  06:C9C1  A9 03       LDA #GAMEPAD_AB
 1013  06:C9C3  8D C8 00    STA pauseInputLock 
 1014                       
 1015  06:C9C6  A9 00       LDA #$00
 1016  06:C9C8  8D C7 00    STA pauseState
 1017  06:C9CB            .leave:
 1018  06:C9CB  60          RTS
 1019                       
 1020  06:C9CC            ExitPause:
 1021  06:C9CC  60          RTS
 1022                       
 1023                     ;hori, vert
 1024  06:C9CD            MouseMinimums:
 1025  06:C9CD  6A 5A       .db $6A, $5A
 1026  06:C9CF  6A 5A       .db $6A, $5A
 1027  06:C9D1  6A 5A       .db $6A, $5A
 1028  06:C9D3            MouseMaximums:
 1029  06:C9D3  9A 8A       .db $9A, $8A
 1030  06:C9D5  C2 B2       .db $C2, $B2
 1031  06:C9D7  EA DA       .db $EA, $DA
 1032                       
 1033  06:C9D9            PuzzleScrollHori:
 1034  06:C9D9  01 04 06    .db $01, $04, $06
 1035  06:C9DC            PuzzleScrollVert:
 1036  06:C9DC  01 03 05    .db $01, $03, $05
 1037                       
 1038  06:C9DF            PuzzleHeaderSkips:
 1039                     
 1040  06:C9DF  09 18 22    .db $09, $18, $22
 1041                       
 1042  06:C9E2            PuzzleSaveLocations:
 1043  06:C9E2  09 70       .word puzzle_clear_bank0, puzzle_clear_bank1, puzzle_clear_bank2
       06:C9E4  75 70     
       06:C9E6  E1 70     
 1044                     
 1045                       
 1046           0060      PAUSE_YES = $60
 1047           0088      PAUSE_NO = $88
 1048                     
 1049                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   85                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C9E8            UpdateGameOver:
    2                     
    3  06:C9E8  AD 10 00    LDA NMI_locks
    4  06:C9EB  F0 01       BEQ .unlocked
    5                       
    6  06:C9ED  60          RTS
    7                       
    8  06:C9EE            .unlocked:
    9                     
   10  06:C9EE  20 F2 C9    JSR DoUpdateGameOver 
   11  06:C9F1  60          RTS
   12                       
   13  06:C9F2            DoUpdateGameOver:
   14                     
   15  06:C9F2  AD 0F 00    LDA mode_state
   16  06:C9F5  20 0A CB    JSR Dynamic_Jump
   17                         
   18  06:C9F8            UpdateGameOverJumpTable:
   19                     
   20  06:C9F8  00 CA       .word UpdateGameOverInit
   21  06:C9FA  07 CA       .word UpdateGameOverWaitInput
   22  06:C9FC  15 CA       .word UpdateGameOverFadeOut
   23  06:C9FE  2A CA       .word UpdateGameOverExit
   24                       
   25  06:CA00            UpdateGameOverInit:
   26                     
   27  06:CA00  20 D4 CC    JSR TurnOnSprites
   28  06:CA03  EE 0F 00    INC mode_state
   29  06:CA06  60          RTS
   30                     
   31  06:CA07            UpdateGameOverWaitInput:
   32                     
   33  06:CA07  AD 1C 00    LDA gamepadPressed
   34  06:CA0A  F0 08       BEQ .leave
   35                     
   36  06:CA0C            .changeModeState:
   37                     
   38  06:CA0C  A9 00       LDA #$00
   39  06:CA0E  8D 0A 00    STA time
   40  06:CA11  EE 0F 00    INC mode_state
   41  06:CA14            .leave:
   42  06:CA14  60          RTS
   43                     
   44  06:CA15            UpdateGameOverFadeOut:
   45                     
   46  06:CA15  AD 0A 00    LDA time
   47  06:CA18  29 07       AND #$07
   48  06:CA1A  D0 0D       BNE .leave
   49                       ;;every 8 frames, decrement the palettes
   50  06:CA1C  20 09 CD    JSR FadeOutPalettes
   51  06:CA1F  B0 08       BCS .leave
   52                     
   53  06:CA21            .changeModeState:
   54  06:CA21  A9 00       LDA #$00
   55  06:CA23  8D 0A 00    STA time
   56  06:CA26  EE 0F 00    INC mode_state
   57  06:CA29            .leave:
   58  06:CA29  60          RTS
   59                     
   60  06:CA2A            UpdateGameOverExit:
   61                     
   62  06:CA2A  AD 0A 00    LDA time
   63  06:CA2D  29 0F       AND #$0F
   64  06:CA2F  D0 07       BNE .leave
   65                     
   66  06:CA31  A9 00       LDA #TITLE_IDX
   67  06:CA33  A2 00       LDX #$00
   68  06:CA35  20 39 CA    JSR ChangeGameMode
   69                       
   70  06:CA38            .leave:
   71  06:CA38  60          RTS
#[1]   Picross.asm
   86                       
   87                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   88                     ;;     Routines             ;;
   89                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   90                     
   91                     
#[2]   Routines/Common/GameModeRoutines.asm
   92                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:CA39            ChangeGameMode:
    2                       ;A - game mode index
    3                       ;X - high nibble: palette start flag, low nibble: screen index
    4  06:CA39  8D 0E 00    STA game_mode
    5  06:CA3C  8E 0D 00    STX mode_loadFlags
    6  06:CA3F  A9 00       LDA #$00
    7  06:CA41  8D 0F 00    STA mode_state
    8  06:CA44  20 A0 CC    JSR ClearPPUString
    9  06:CA47  20 4B CA    JSR LoadGameModeScreen
   10  06:CA4A  60          RTS
   11                       
   12  06:CA4B            LoadGameModeScreen:
   13                     
   14                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:CA4B  AD 10 00    LDA NMI_locks
       06:CA4E  09 01       ORA #BGLOAD_NMI_LOCK
       06:CA50  8D 10 00    STA NMI_locks
                                  
   15                       
   16  06:CA53  A9 00       LDA #$00
   17  06:CA55  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   18                     
   19  06:CA58  20 86 CA    JSR LoadGameModeBackground
   20  06:CA5B  20 E7 CA    JSR LoadGameModeSprites
   21                     
   22                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:CA5E  A9 01       LDA #BGLOAD_NMI_LOCK
       06:CA60  49 FF       EOR #$FF
       06:CA62  2D 10 00    AND NMI_locks  
       06:CA65  8D 10 00    STA NMI_locks
                          
   23                     
   24                       
   25                       ;; load the CHR bank for this mode
   26  06:CA68  20 73 CD    JSR ResetMapper
   27                       ;;remember, we're loading the SECOND set in each chr bank
   28                       ;;so we'll take the index from the game mode chr table and add one mult 2
   29  06:CA6B  AE 0E 00    LDX game_mode
   30  06:CA6E  BD 04 CB    LDA gameModeInitCHRROMB, x
   31  06:CA71  0A          ASL A
   32  06:CA72  18          CLC 
   33  06:CA73  69 01       ADC #$01
   34  06:CA75  20 98 CD    JSR LoadCHRBankB
   35                       
   36  06:CA78  20 73 CD    JSR ResetMapper
   37  06:CA7B  AE 0E 00    LDX game_mode
   38  06:CA7E  BD 07 CB    LDA gameModeInitCHRROMA, x
   39  06:CA81  0A          ASL A
   40  06:CA82  20 8D CD    JSR LoadCHRBankA
   41                       
   42                       
   43                       
   44  06:CA85  60          RTS
   45                       
   46  06:CA86            LoadGameModeBackground:
   47                             
   48                       MACROGetDoubleIndex game_mode
                          
       06:CA86  AD 0E 00          LDA game_mode
       06:CA89  0A                ASL A
       06:CA8A  A8                TAY
                                  
   49  06:CA8B  8C 00 00    STY temp1
   50                             
   51                       MACROGetLabelPointer Palettes, table_address
                          
       06:CA8E  A9 E0             LDA #HIGH(Palettes)
       06:CA90  A2 00             LDX #LOW(Palettes)
                                  
       06:CA92  8E 16 00          STX table_address
       06:CA95  8D 17 00          STA table_address+1
                                  
   52  06:CA98  20 30 CB    JSR GetTableAtIndex
   53                     
   54  06:CA9B  20 3D CB    JSR LoadFullPaletteFromTable
   55                             
   56  06:CA9E  AC 00 00    LDY temp1
   57  06:CAA1  AD 0D 00    LDA mode_loadFlags
   58  06:CAA4  29 40       AND #%01000000 ; copy from saved screen
   59  06:CAA6  F0 0D       BEQ .dontUseSaveCopy
   60                       MACROGetLabelPointer SaveScreen_Copy, table_address
                          
       06:CAA8  A9 68             LDA #HIGH(SaveScreen_Copy)
       06:CAAA  A2 00             LDX #LOW(SaveScreen_Copy)
                                  
       06:CAAC  8E 16 00          STX table_address
       06:CAAF  8D 17 00          STA table_address+1
                                  
   61  06:CAB2  4C CC CA    JMP .loadTable
   62                       
   63  06:CAB5            .dontUseSaveCopy:
   64                       MACROGetLabelPointer NameTables, table_address
                          
       06:CAB5  A9 E0             LDA #HIGH(NameTables)
       06:CAB7  A2 06             LDX #LOW(NameTables)
                                  
       06:CAB9  8E 16 00          STX table_address
       06:CABC  8D 17 00          STA table_address+1
                                  
   65  06:CABF  20 30 CB    JSR GetTableAtIndex
   66  06:CAC2  AD 0D 00    LDA mode_loadFlags
   67  06:CAC5  29 0F       AND #$0F
   68  06:CAC7  0A          ASL A
   69  06:CAC8  A8          TAY
   70  06:CAC9  20 30 CB    JSR GetTableAtIndex
   71                             
   72  06:CACC            .loadTable:
   73  06:CACC  A9 00       LDA #$00
   74  06:CACE  20 6C CB    JSR LoadFullBackgroundFromTable
   75                       
   76  06:CAD1  AC 00 00    LDY temp1
   77                       MACROGetLabelPointer NameTables2, table_address
                          
       06:CAD4  A9 E0             LDA #HIGH(NameTables2)
       06:CAD6  A2 0C             LDX #LOW(NameTables2)
                                  
       06:CAD8  8E 16 00          STX table_address
       06:CADB  8D 17 00          STA table_address+1
                                  
   78  06:CADE  20 30 CB    JSR GetTableAtIndex
   79                       
   80  06:CAE1  A9 01       LDA #$01
   81  06:CAE3  20 6C CB    JSR LoadFullBackgroundFromTable
   82                       
   83  06:CAE6  60          RTS
   84                       
   85  06:CAE7            LoadGameModeSprites:
   86                     
   87                       MACROGetDoubleIndex game_mode  
                          
       06:CAE7  AD 0E 00          LDA game_mode
       06:CAEA  0A                ASL A
       06:CAEB  A8                TAY
                                  
   88                       MACROGetLabelPointer Sprites, table_address
                          
       06:CAEC  A9 FC             LDA #HIGH(Sprites)
       06:CAEE  A2 CA             LDX #LOW(Sprites)
                                  
       06:CAF0  8E 16 00          STX table_address
       06:CAF3  8D 17 00          STA table_address+1
                                  
   89  06:CAF6  20 30 CB    JSR GetTableAtIndex
   90  06:CAF9  A0 00       LDY #$00
   91  06:CAFB  B1 16       LDA [table_address],y
   92  06:CAFD  EE 16 00    INC table_address
   93  06:CB00  20 75 CC    JSR LoadSprites_impl
   94                       
   95  06:CB03  60          RTS
   96                       
   97  06:CB04            gameModeInitCHRROMB:
   98  06:CB04  00 02 02          .db $00, $02, $02
   99  06:CB07            gameModeInitCHRROMA:
  100  06:CB07  00 02 02          .db $00, $02, $02
  101                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   93                       .include "Routines/Utils/PointerUtils.asm"
    1  06:CB0A            Dynamic_Jump:
    2                     
    3  06:CB0A  0A          ASL A                                 ;; double the index passed into A
    4  06:CB0B  8E 08 00    STX tempx
    5  06:CB0E  8C 09 00    STY tempy
    6  06:CB11  A8          TAY
    7  06:CB12  C8          INY  
    8  06:CB13  68          PLA
    9  06:CB14  8D 18 00    STA jump_address
   10  06:CB17  68          PLA 
   11  06:CB18  8D 19 00    STA jump_address+1            
   12  06:CB1B  B1 18       LDA [jump_address], y
   13  06:CB1D  AA          TAX
   14  06:CB1E  C8          INY
   15  06:CB1F  B1 18       LDA [jump_address], y
   16  06:CB21  8E 18 00    STX jump_address
   17  06:CB24  8D 19 00    STA jump_address+1
   18  06:CB27  AE 08 00    LDX tempx
   19  06:CB2A  AC 09 00    LDY tempy
   20  06:CB2D  6C 18 00    JMP [jump_address]
   21                       
   22  06:CB30            GetTableAtIndex:
   23                     
   24  06:CB30  B1 16             LDA [table_address], y
   25  06:CB32  AA                TAX
   26  06:CB33  C8                INY
   27  06:CB34  B1 16             LDA [table_address], y
   28                             
   29  06:CB36            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:CB36  8E 16 00          STX table_address
   33  06:CB39  8D 17 00          STA table_address+1
   34  06:CB3C  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   94                       .include "Routines/Utils/PPUUtils.asm"
    1  06:CB3D            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:CB3D  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:CB40  A9 3F       LDA #HIGH($3F00)
       06:CB42  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:CB45  A9 00       LDA #LOW($3F00)
       06:CB47  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:CB4A  A0 00       LDY #$00              ; start out at 0
    5  06:CB4C  A2 00       LDX #$00
    6  06:CB4E            .loop:
    7  06:CB4E  B1 16       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:CB50  9D 00 6C    STA Palette_Copy, x
    9  06:CB53  48          PHA 
   10  06:CB54  AD 0D 00    LDA mode_loadFlags
   11  06:CB57  29 10       AND #$10
   12  06:CB59  D0 04       BNE .setBlack
   13  06:CB5B  68          PLA 
   14  06:CB5C  4C 62 CB    JMP .setPPUData
   15  06:CB5F            .setBlack:
   16                     
   17  06:CB5F  68          PLA 
   18  06:CB60  A9 0F       LDA #$0F
   19                       
   20  06:CB62            .setPPUData:
   21  06:CB62  8D 07 20    STA PPU_DATA            ; write to PPU
   22  06:CB65  C8          INY                   ; X = X + 1
   23  06:CB66  E8          INX
   24  06:CB67  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   25  06:CB69  D0 E3       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   26  06:CB6B  60          RTS
   27                     
   28  06:CB6C            LoadFullBackgroundFromTable:
   29                     
   30                         ;;use A as an index for which nametable to write to
   31  06:CB6C  20 C0 CC          JSR SetNametableFromIndex
   32  06:CB6F  8A                TXA
   33  06:CB70  4A                LSR A
   34  06:CB71  29 01             AND #$01
   35  06:CB73  D0 17             BNE .copyScreenB
   36                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:CB75  A9 60             LDA #HIGH(Screen_Copy)
       06:CB77  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:CB79  8E 12 00          STX pointer_address
       06:CB7C  8D 13 00          STA pointer_address+1
                                  
   37                             MACROGetLabelPointer SaveScreen_Copy, pointerB_address
                          
       06:CB7F  A9 68             LDA #HIGH(SaveScreen_Copy)
       06:CB81  A2 00             LDX #LOW(SaveScreen_Copy)
                                  
       06:CB83  8E 14 00          STX pointerB_address
       06:CB86  8D 15 00          STA pointerB_address+1
                                  
   38  06:CB89  4C 9F CB          JMP .setCounters
   39                             
   40  06:CB8C            .copyScreenB:
   41                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:CB8C  A9 64             LDA #HIGH(ScreenB_Copy)
       06:CB8E  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:CB90  8E 12 00          STX pointer_address
       06:CB93  8D 13 00          STA pointer_address+1
                                  
   42  06:CB96  AD 0D 00          LDA mode_loadFlags
   43  06:CB99  2D 00 00          AND $%11011111
   44  06:CB9C  8D 0D 00          STA mode_loadFlags ;kill the copy flag, just in case
   45                             
   46                             ;;set pointer
   47                             ;; set counters
   48  06:CB9F            .setCounters:
   49  06:CB9F  A0 00             LDY #$00
   50  06:CBA1  A2 00             LDX #$00
   51                             
   52                             ;;start loop
   53                     
   54  06:CBA3            .outerloop:
   55                     
   56  06:CBA3            .innerloop:
   57                     
   58  06:CBA3  B1 16             LDA [table_address], y
   59  06:CBA5  8D 07 20          STA PPU_DATA
   60  06:CBA8  91 12             STA [pointer_address],y
   61  06:CBAA  AD 0D 00      LDA mode_loadFlags
   62  06:CBAD  29 20         AND #%00100000      ;check copy flag
   63  06:CBAF  F0 04             BEQ .skipSaveCopy
   64  06:CBB1  B1 16         LDA [table_address], y
   65  06:CBB3  91 14             STA [pointerB_address],y
   66                     
   67  06:CBB5            .skipSaveCopy:
   68  06:CBB5  C8                INY
   69  06:CBB6  C0 00             CPY #$00
   70  06:CBB8  D0 E9             BNE .innerloop
   71                     
   72  06:CBBA  EE 13 00          INC pointer_address+1
   73  06:CBBD  EE 17 00          INC table_address+1
   74  06:CBC0  EE 15 00          INC pointerB_address+1
   75                             
   76  06:CBC3  E8                INX
   77  06:CBC4  E0 04             CPX #$04
   78  06:CBC6  D0 DB             BNE .outerloop
   79  06:CBC8  60                RTS
   80                             
   81                     
   82           0000      DATA_LEN = temp1
   83           0001      WRITE_SETTINGS = temp2
   84                             
   85  06:CBC9            ProcessPPUString:
   86                     
   87  06:CBC9  AD 23 00          LDA PPU_PendingWrite
   88  06:CBCC  D0 01             BNE .continueProcess
   89  06:CBCE  60                RTS
   90                             
   91  06:CBCF            .continueProcess:
   92  06:CBCF  A0 00             LDY #$00
   93                             
   94  06:CBD1  A9 25             LDA #LOW(PPU_String)
   95  06:CBD3  8D 12 00          STA pointer_address
   96  06:CBD6  A9 00             LDA #HIGH(PPU_String)
   97  06:CBD8  8D 13 00          STA pointer_address + 1
   98                     
   99  06:CBDB            .outerloop:
  100  06:CBDB  AD 02 20          LDA PPU_STATUS
  101  06:CBDE  B1 12             LDA [pointer_address], y
  102  06:CBE0  F0 79             BEQ .finish
  103  06:CBE2  8D 06 20          STA PPU_ADDR
  104  06:CBE5  C8                INY
  105  06:CBE6  B1 12             LDA [pointer_address], y
  106  06:CBE8  8D 06 20          STA PPU_ADDR
  107  06:CBEB  C8            INY 
  108  06:CBEC  B1 12             LDA [pointer_address], y
  109  06:CBEE  8D 01 00          STA WRITE_SETTINGS
  110  06:CBF1  C8                INY
  111                             
  112  06:CBF2  AD 00 20          LDA PPU_CTRL
  113  06:CBF5  29 FB             AND #$FB
  114  06:CBF7  8D 00 20          STA PPU_CTRL
  115                             
  116  06:CBFA  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
  117  06:CBFD  29 80             AND #%10000000
  118  06:CBFF  F0 06             BEQ .checkRepeat
  119  06:CC01  0D 00 20          ORA PPU_CTRL 
  120  06:CC04  8D 00 20          STA PPU_CTRL 
  121                             
  122                             
  123  06:CC07            .checkRepeat:
  124  06:CC07  AD 01 00    LDA WRITE_SETTINGS
  125  06:CC0A  29 40       AND #%01000000
  126  06:CC0C  F0 19       BEQ .checkTable
  127                       
  128  06:CC0E  AD 01 00    LDA WRITE_SETTINGS
  129  06:CC11  29 3F       AND #$3F
  130  06:CC13  8D 00 00    STA DATA_LEN
  131                       ;;the usual data length byte is now the repeatable byte
  132  06:CC16  A2 00       LDX #$00
  133                       
  134  06:CC18            .repeatLoop:
  135  06:CC18  B1 12       LDA [pointer_address], y
  136  06:CC1A  8D 07 20    STA PPU_DATA
  137  06:CC1D  E8          INX 
  138  06:CC1E  EC 00 00    CPX DATA_LEN
  139  06:CC21  D0 F5       BNE .repeatLoop
  140  06:CC23  C8          INY
  141  06:CC24  4C DB CB    JMP .outerloop
  142                             
  143  06:CC27            .checkTable:
  144  06:CC27  AD 01 00          LDA WRITE_SETTINGS
  145  06:CC2A  29 20             AND #%00100000
  146  06:CC2C  F0 16             BEQ .rawData
  147                             
  148  06:CC2E  B1 12             LDA [pointer_address], y
  149  06:CC30  8D 16 00          STA table_address
  150  06:CC33  C8                INY 
  151  06:CC34  B1 12             LDA [pointer_address], y
  152  06:CC36  8D 17 00          STA table_address + 1
  153  06:CC39  C8                INY
  154  06:CC3A  98                TYA 
  155  06:CC3B  48                PHA
  156  06:CC3C  20 5F CC          JSR WriteToPPUFromTable
  157  06:CC3F  68                PLA
  158  06:CC40  A8                TAY
  159  06:CC41  4C DB CB          JMP .outerloop
  160                             
  161  06:CC44            .rawData:
  162                     
  163  06:CC44  B1 12             LDA [pointer_address], y
  164  06:CC46  C8                INY
  165  06:CC47  8D 00 00          STA DATA_LEN
  166                     
  167  06:CC4A  A2 00             LDX #$00
  168                     
  169  06:CC4C            .innerloop:
  170                             
  171  06:CC4C  B1 12             LDA [pointer_address], y
  172  06:CC4E  8D 07 20          STA PPU_DATA
  173  06:CC51  C8                INY
  174  06:CC52  E8                INX
  175  06:CC53  EC 00 00          CPX DATA_LEN
  176  06:CC56  D0 F4             BNE .innerloop
  177  06:CC58  4C DB CB          JMP .outerloop
  178                             
  179  06:CC5B            .finish:
  180  06:CC5B  20 A0 CC          JSR ClearPPUString
  181  06:CC5E            .leave:
  182  06:CC5E  60                RTS
  183                             
  184  06:CC5F            WriteToPPUFromTable:
  185  06:CC5F  A0 00             LDY #$00
  186  06:CC61  B1 16             LDA [table_address], y
  187  06:CC63  C8                INY
  188  06:CC64  8D 00 00          STA DATA_LEN
  189  06:CC67            .innerloop:
  190  06:CC67  B1 16             LDA [table_address], y
  191  06:CC69  8D 07 20          STA PPU_DATA
  192  06:CC6C  C8                INY
  193  06:CC6D  CC 00 00          CPY DATA_LEN
  194  06:CC70  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  195  06:CC72  F0 F3             BEQ .innerloop
  196  06:CC74  60                RTS
  197                       
  198  06:CC75            LoadSprites_impl:
  199                       ;;A will be the amount of sprites to load
  200  06:CC75  8D 00 00    STA DATA_LEN
  201  06:CC78  0E 00 00    ASL DATA_LEN
  202  06:CC7B  0E 00 00    ASL DATA_LEN
  203                       
  204  06:CC7E  A0 00       LDY #$00              ; start at 0
  205                       
  206  06:CC80            .loop:
  207  06:CC80  B1 16       LDA [table_address], y; load data from address (sprites +  x)
  208  06:CC82  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  209  06:CC85  C8          INY                   ; X = X + 1
  210  06:CC86  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  211  06:CC89  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  212                                             ; if compare was equal to 16, keep going down   
  213  06:CC8B  60          RTS
  214                     
  215                     
  216  06:CC8C            WriteToPPUString:
  217                     
  218  06:CC8C  AE 24 00          LDX PPU_StringIdx
  219  06:CC8F  E0 4F             CPX #PPU_STRINGMAX
  220  06:CC91  F0 0C             BEQ .finish
  221                             
  222  06:CC93  9D 25 00          STA PPU_String, x
  223  06:CC96  EE 24 00          INC PPU_StringIdx
  224  06:CC99  E8                INX
  225  06:CC9A  A9 00             LDA #$00
  226  06:CC9C  9D 25 00          STA PPU_String, x
  227                                     
  228  06:CC9F            .finish:
  229  06:CC9F  60                RTS
  230                     
  231  06:CCA0            ClearPPUString:
  232                             
  233  06:CCA0  A9 00             LDA #$00
  234  06:CCA2  8D 24 00          STA PPU_StringIdx
  235  06:CCA5  8D 25 00          STA PPU_String
  236  06:CCA8  8D 23 00          STA PPU_PendingWrite
  237  06:CCAB  60                RTS
  238                     
  239  06:CCAC            DetectSprite0:
  240  06:CCAC            WaitNotSprite0:
  241  06:CCAC  AD 02 20    lda PPU_STATUS
  242  06:CCAF  29 40       and #SPRITE_0_MASK
  243  06:CCB1  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  244                     
  245  06:CCB3            WaitSprite0:
  246  06:CCB3  AD 02 20    lda $2002
  247  06:CCB6  29 40       and #SPRITE_0_MASK
  248  06:CCB8  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  249                     
  250  06:CCBA  A2 05       ldx #$05                              ;do a scanline wait
  251  06:CCBC            WaitScanline:
  252  06:CCBC  CA          dex
  253  06:CCBD  D0 FD       bne WaitScanline
  254  06:CCBF  60          RTS
  255                     
  256                     
  257  06:CCC0            SetNametableFromIndex:
  258                     
  259  06:CCC0  48          PHA
  260  06:CCC1  AD 02 20    LDA PPU_STATUS
  261  06:CCC4  68          PLA
  262  06:CCC5  0A          ASL A
  263  06:CCC6  AA          TAX
  264  06:CCC7  BD 5C CD    LDA NameTableMemList+1, x
  265  06:CCCA  8D 06 20    STA PPU_ADDR
  266  06:CCCD  BD 5B CD    LDA NameTableMemList, x
  267  06:CCD0  8D 06 20    STA PPU_ADDR
  268  06:CCD3  60          RTS
  269                       
  270  06:CCD4            TurnOnSprites:
  271                      
  272  06:CCD4  AD 1E 00    LDA PPU_Mask
  273  06:CCD7  09 10       ORA #%00010000
  274  06:CCD9  8D 1E 00    STA PPU_Mask
  275  06:CCDC  60          RTS
  276                       
  277  06:CCDD            TurnOffSprites:
  278                       
  279  06:CCDD  AD 1E 00    LDA PPU_Mask
  280  06:CCE0  29 EF       AND #%11101111
  281  06:CCE2  8D 1E 00    STA PPU_Mask
  282  06:CCE5  60          RTS
  283                     
  284  06:CCE6            UpdatePPUControl:
  285                     
  286  06:CCE6  AD 1D 00    LDA PPU_Control
  287  06:CCE9  29 FC       AND #$FC
  288  06:CCEB  0D 22 00    ORA PPU_NT
  289  06:CCEE  8D 00 20    STA PPU_CTRL
  290  06:CCF1  AD 1E 00    LDA PPU_Mask
  291  06:CCF4  8D 01 20    STA PPU_MASK
  292  06:CCF7  60          RTS
  293                       
  294  06:CCF8            InitPPUControl:
  295                       
  296                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  297                       ; enable sprites, enable background, no clipping on left side
  298  06:CCF8  A9 90       LDA #%10010000
  299  06:CCFA  8D 00 20    STA PPU_CTRL
  300  06:CCFD  8D 1D 00    STA PPU_Control
  301  06:CD00  A9 1E       LDA #%00011110
  302  06:CD02  8D 01 20    STA PPU_MASK
  303  06:CD05  8D 1E 00    STA PPU_Mask
  304  06:CD08  60          RTS
  305                       
  306  06:CD09            FadeOutPalettes:
  307                     
  308                     ;;take the current values, and decrement the lower nibbles
  309                     ;;we can access from the palette copy 
  310                     ;;we'll make this fade out one level per call
  311                     ;;once all the palettes are blacked out we'll return true, so we'll keep the carry flag as a return result
  312                     
  313                     ;;go through the palette copy, decrement, make a raw data PPU string and add all the bytes into it
  314                     ;;for any palette color already in the 0x range, change it to 0f to get black
  315                     
  316                       MACROGetLabelPointer Palette_Copy, table_address
                          
       06:CD09  A9 6C             LDA #HIGH(Palette_Copy)
       06:CD0B  A2 00             LDX #LOW(Palette_Copy)
                                  
       06:CD0D  8E 16 00          STX table_address
       06:CD10  8D 17 00          STA table_address+1
                                  
  317                     ;;palette copy address is now X accessable
  318                     
  319  06:CD13  A0 00       LDY #$00
  320                       MACROAddPPUStringEntryRawData #$3F, #$00, #DRAW_HORIZONTAL, #$20  
                          
       06:CD15  A9 01       LDA #$01
       06:CD17  8D 23 00    STA PPU_PendingWrite
       06:CD1A  A9 3F       LDA #$3F
       06:CD1C  20 8C CC    JSR WriteToPPUString
       06:CD1F  A9 00       LDA #$00
       06:CD21  20 8C CC    JSR WriteToPPUString
       06:CD24  A9 00       LDA #DRAW_HORIZONTAL
       06:CD26  20 8C CC    JSR WriteToPPUString
       06:CD29  A9 20       LDA #$20 
       06:CD2B  20 8C CC    JSR WriteToPPUString
                            
  321                     
  322  06:CD2E  A9 00       LDA #$00
  323  06:CD30  8D 00 00    STA temp1
  324                       
  325  06:CD33            .loop:
  326                     
  327  06:CD33  B1 16       LDA [table_address], y
  328  06:CD35  C9 0F       CMP #$0F
  329  06:CD37  F0 15       BEQ .addToString
  330  06:CD39  C9 10       CMP #$10
  331  06:CD3B  90 0D       BCC .setBlack
  332                       
  333  06:CD3D  A9 80       LDA #$80
  334  06:CD3F  8D 00 00    STA temp1
  335                       
  336  06:CD42  B1 16       LDA [table_address], y
  337  06:CD44  38          SEC
  338  06:CD45  E9 10       SBC #$10
  339  06:CD47  4C 4C CD    JMP .setColor
  340                     
  341  06:CD4A            .setBlack:
  342                     
  343  06:CD4A  A9 0F       LDA #$0F
  344                     
  345  06:CD4C            .setColor:
  346  06:CD4C  91 16       STA [table_address], y
  347                     
  348  06:CD4E            .addToString:
  349                     
  350  06:CD4E  20 8C CC    JSR WriteToPPUString
  351                     
  352  06:CD51            .incY:
  353                       
  354  06:CD51  C8          INY
  355  06:CD52  C0 20       CPY #$20
  356  06:CD54  D0 DD       BNE .loop
  357                     
  358  06:CD56  0E 00 00    ASL temp1     ;get carry out, if we have one
  359                     
  360  06:CD59  60          RTS
  361                       
  362  06:CD5A            FadeInPalettes:
  363                     
  364                     ;;need to be able to store off a target palette first
  365                     ;;we can use the palette copy we make during the game mode change as the target
  366  06:CD5A  60          RTS
  367                     
  368  06:CD5B            NameTableMemList:
  369  06:CD5B  00 20       .word $2000, $2400, $2800, $2C00
       06:CD5D  00 24     
       06:CD5F  00 28     
       06:CD61  00 2C     
  370  06:CD63            PalettesMemList:
  371  06:CD63  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:CD65  04 3F     
       06:CD67  08 3F     
       06:CD69  0C 3F     
  372  06:CD6B  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:CD6D  14 3F     
       06:CD6F  18 3F     
       06:CD71  1C 3F     
  373                       
  374           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   95                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:CD73            ResetMapper:
    7  06:CD73  EE 73 CD    inc ResetMapper
    8  06:CD76  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:CD77            SetMapperControls:
   23                       ;;A = controls
   24  06:CD77  AA          TAX
   25  06:CD78  A9 80       LDA #MAPPERCONTROL
   26  06:CD7A  8D A6 00    STA mapper_address+1
   27  06:CD7D  8A          TXA
   28  06:CD7E  20 A3 CD    JSR SendMapperCommand
   29  06:CD81  60          RTS
   30                     
   31  06:CD82            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:CD82  AA                TAX
   35  06:CD83  A9 E0             LDA #PRGBANK
   36  06:CD85  8D A6 00          STA mapper_address+1
   37  06:CD88  8A                TXA
   38  06:CD89  20 A3 CD          JSR SendMapperCommand
   39  06:CD8C  60                RTS
   40                             
   41  06:CD8D            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:CD8D  AA                TAX
   44  06:CD8E  A9 A0             LDA #CHRBANK1
   45  06:CD90  8D A6 00          STA mapper_address+1
   46  06:CD93  8A                TXA
   47  06:CD94  20 A3 CD          JSR SendMapperCommand
   48  06:CD97  60                RTS
   49                             
   50  06:CD98            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:CD98  AA                TAX
   53  06:CD99  A9 C0             LDA #CHRBANK2
   54  06:CD9B  8D A6 00          STA mapper_address+1
   55  06:CD9E  8A                TXA
   56  06:CD9F  20 A3 CD          JSR SendMapperCommand
   57  06:CDA2  60                RTS
   58                             
   59  06:CDA3            SendMapperCommand:
   60                     
   61  06:CDA3  A0 00             LDY #$00
   62                             
   63  06:CDA5  91 A5             STA [mapper_address], y
   64  06:CDA7  4A                LSR A
   65  06:CDA8  91 A5             STA [mapper_address], y
   66  06:CDAA  4A                LSR A
   67  06:CDAB  91 A5             STA [mapper_address], y
   68  06:CDAD  4A                LSR A 
   69  06:CDAE  91 A5             STA [mapper_address], y
   70  06:CDB0  4A                LSR A
   71  06:CDB1  91 A5             STA [mapper_address], y
   72                             
   73  06:CDB3  60                RTS
   74                             
   75  06:CDB4            ResetBanks:
   76                     
   77  06:CDB4  20 73 CD          JSR ResetMapper
   78  06:CDB7  A9 00             LDA #$00
   79  06:CDB9  20 82 CD          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:CDBC  20 73 CD          JSR ResetMapper
   83  06:CDBF  A9 00             LDA #$00
   84  06:CDC1  20 8D CD          JSR LoadCHRBankA
   85  06:CDC4  A9 01             LDA #$01
   86  06:CDC6  20 98 CD          JSR LoadCHRBankB
   87  06:CDC9  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   96                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:CDCA            PopulateClues:
    2                       
    3  06:CDCA  A0 00       LDY #$00
    4  06:CDCC  B1 AC       LDA [puzzle_address], y
    5  06:CDCE  AA          TAX
    6  06:CDCF  BD 2D D1    LDA PuzzleSizes, x
    7  06:CDD2  8D 00 00    STA temp1
    8                       
    9  06:CDD5            .getByte:
   10  06:CDD5  AC BA 00    LDY clueTableIndex
   11  06:CDD8  B1 AE       LDA [clues_address], y
   12  06:CDDA  D0 07       BNE .checkNewLine
   13  06:CDDC  EE BA 00    INC clueTableIndex
   14  06:CDDF  A9 00       LDA #$00
   15  06:CDE1  F0 39       BEQ .drawClue
   16                       ;was 0, set up a draw
   17  06:CDE3            .checkNewLine
   18  06:CDE3  C9 FF       CMP #$FF
   19  06:CDE5  D0 18       BNE .getClue
   20                       
   21                       ;;was FF- need to inc stuff
   22  06:CDE7  EE BA 00    INC clueTableIndex
   23  06:CDEA  A9 00       LDA #$00
   24  06:CDEC  8D C1 00    STA clueParity
   25                       
   26  06:CDEF  EE BB 00    INC clueLineIndex
   27  06:CDF2  AD BB 00    LDA clueLineIndex
   28  06:CDF5  CD 00 00    CMP temp1
   29                       ;CMP #$01
   30  06:CDF8  F0 28       BEQ .leave    ;carry will be set
   31                       
   32  06:CDFA  20 AB CE    JSR CreateOffsetFromIndex
   33                      
   34  06:CDFD  D0 D6       BNE .getByte
   35                       
   36  06:CDFF            .getClue:
   37                       ;;clues go from high nibble to low nibble
   38  06:CDFF  48          PHA 
   39  06:CE00  AD C1 00    LDA clueParity
   40  06:CE03  D0 0A       BNE .getSecondClue
   41  06:CE05  EE C1 00    INC clueParity
   42  06:CE08  68          PLA
   43  06:CE09  4A          LSR A
   44  06:CE0A  4A          LSR A
   45  06:CE0B  4A          LSR A
   46  06:CE0C  4A          LSR A         ;move clue over to lower nibble
   47  06:CE0D  D0 0D       BNE .drawClue
   48                       
   49  06:CE0F            .getSecondClue:
   50                     
   51  06:CE0F  CE C1 00    DEC clueParity
   52  06:CE12  EE BA 00    INC clueTableIndex
   53  06:CE15  68          PLA 
   54  06:CE16  29 0F       AND #$0F
   55  06:CE18  D0 02       BNE .drawClue
   56                       ;;if 0, skip
   57  06:CE1A  F0 B9       BEQ .getByte
   58                      
   59  06:CE1C            .drawClue:
   60                       
   61  06:CE1C  09 40       ORA #$40
   62  06:CE1E  20 23 CE    JSR WriteClueByteToPPUString
   63  06:CE21  18          CLC
   64                       
   65  06:CE22            .leave:
   66  06:CE22  60          RTS
   67                       
   68  06:CE23            WriteClueByteToPPUString:
   69                     
   70  06:CE23  8D 00 00    STA temp1 ;store off the tile value
   71                     
   72                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:CE26  A9 01       LDA #$01
       06:CE28  8D 23 00    STA PPU_PendingWrite
       06:CE2B  AD B9 00    LDA clue_draw_address+1
       06:CE2E  20 8C CC    JSR WriteToPPUString
       06:CE31  AD B8 00    LDA clue_draw_address
       06:CE34  20 8C CC    JSR WriteToPPUString
       06:CE37  A9 00       LDA #DRAW_HORIZONTAL
       06:CE39  20 8C CC    JSR WriteToPPUString
       06:CE3C  A9 01       LDA #$01 
       06:CE3E  20 8C CC    JSR WriteToPPUString
                            
   73  06:CE41  AD 00 00    LDA temp1
   74  06:CE44  20 8C CC    JSR WriteToPPUString
   75                       
   76                       ;;also copy to ... copy
   77  06:CE47  AD B8 00    LDA clue_draw_address
   78  06:CE4A  8D B2 00    STA copy_address
   79  06:CE4D  AD B9 00    LDA clue_draw_address+1
   80  06:CE50  29 0F       AND #$0F
   81  06:CE52  09 60       ORA #$60
   82  06:CE54  8D B3 00    STA copy_address+1
   83  06:CE57  AD 00 00    LDA temp1
   84  06:CE5A  A0 00       LDY #$00
   85  06:CE5C  91 B2       STA [copy_address],y
   86                       
   87  06:CE5E  AD BD 00    LDA clueDrawAdd
   88  06:CE61  20 88 CE    JSR SubFromClueDrawAddress
   89                         
   90  06:CE64  60          RTS
   91                       
   92  06:CE65            ResetClueDrawAddress:
   93                     
   94                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:CE65  AD B6 00          LDA clue_start_address
       06:CE68  8D B8 00          STA clue_draw_address
       06:CE6B  AD B7 00          LDA clue_start_address+1
       06:CE6E  8D B9 00          STA clue_draw_address+1
                          
   95                       
   96  06:CE71  60          RTS
   97                       
   98  06:CE72            AddToClueDrawAddress:
   99                     
  100  06:CE72  8D 00 00    STA temp1
  101                       
  102  06:CE75  AD B8 00    LDA clue_draw_address
  103  06:CE78  18          CLC
  104  06:CE79  6D 00 00    ADC temp1
  105  06:CE7C  8D B8 00    STA clue_draw_address
  106  06:CE7F  AD B9 00    LDA clue_draw_address+1
  107  06:CE82  69 00       ADC #$00
  108  06:CE84  8D B9 00    STA clue_draw_address+1
  109                       
  110  06:CE87  60          RTS
  111                         
  112  06:CE88            SubFromClueDrawAddress:
  113                     
  114  06:CE88  8D 00 00    STA temp1
  115                       
  116  06:CE8B  AD B8 00    LDA clue_draw_address
  117  06:CE8E  38          SEC
  118  06:CE8F  ED 00 00    SBC temp1
  119  06:CE92  8D B8 00    STA clue_draw_address
  120  06:CE95  AD B9 00    LDA clue_draw_address+1
  121  06:CE98  E9 00       SBC #$00
  122  06:CE9A  8D B9 00    STA clue_draw_address+1
  123                       
  124  06:CE9D  60          RTS
  125                       
  126  06:CE9E            AddToClueDrawAddressHi:
  127                     
  128  06:CE9E  8D 00 00    STA temp1
  129                       
  130  06:CEA1  AD B9 00    LDA clue_draw_address+1
  131  06:CEA4  6D 00 00    ADC temp1
  132  06:CEA7  8D B9 00    STA clue_draw_address+1
  133                       
  134  06:CEAA  60          RTS
  135                       
  136  06:CEAB            CreateOffsetFromIndex:
  137                     
  138                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  139  06:CEAB  AD BB 00    LDA clueLineIndex
  140  06:CEAE  8D BE 00    STA clueDrawOffset
  141  06:CEB1  A9 00       LDA #$00
  142  06:CEB3  8D BF 00    STA clueDrawOffset+1
  143                       
  144  06:CEB6  AD BC 00    LDA clueOffsetShift   
  145  06:CEB9  F0 0E       BEQ .addOffset
  146                       
  147  06:CEBB  A2 00       LDX #$00
  148                       
  149  06:CEBD            .loopShift:
  150  06:CEBD  0E BE 00    ASL clueDrawOffset
  151  06:CEC0  2E BF 00    ROL clueDrawOffset+1
  152  06:CEC3  E8          INX
  153  06:CEC4  EC BC 00    CPX clueOffsetShift
  154  06:CEC7  D0 F4       BNE .loopShift
  155                       
  156  06:CEC9            .addOffset:
  157                       
  158  06:CEC9  20 65 CE    JSR ResetClueDrawAddress
  159  06:CECC  AD BE 00    LDA clueDrawOffset
  160  06:CECF  20 72 CE    JSR AddToClueDrawAddress 
  161  06:CED2  AD BF 00    LDA clueDrawOffset+1
  162  06:CED5  20 9E CE    JSR AddToClueDrawAddressHi
  163                       
  164  06:CED8  60          RTS  
  165                       
  166  06:CED9            ClearPuzzle:
  167                     
  168                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  169                      
  170                       MACROGetLabelPointer ClearLineDefs, table_address
                          
       06:CED9  A9 D1             LDA #HIGH(ClearLineDefs)
       06:CEDB  A2 0F             LDX #LOW(ClearLineDefs)
                                  
       06:CEDD  8E 16 00          STX table_address
       06:CEE0  8D 17 00          STA table_address+1
                                  
  171                     
  172  06:CEE3  AC BB 00    LDY clueLineIndex
  173  06:CEE6  B1 16       LDA [table_address], y
  174  06:CEE8  8D 00 00    STA temp1
  175                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:CEEB  A9 01       LDA #$01
       06:CEED  8D 23 00    STA PPU_PendingWrite
       06:CEF0  AD B9 00    LDA clue_draw_address+1
       06:CEF3  20 8C CC    JSR WriteToPPUString
       06:CEF6  AD B8 00    LDA clue_draw_address
       06:CEF9  20 8C CC    JSR WriteToPPUString
       06:CEFC  A9 40       LDA #$40
       06:CEFE  09 00       ORA #DRAW_HORIZONTAL
       06:CF00  0D 00 00    ORA temp1
       06:CF03  20 8C CC    JSR WriteToPPUString
       06:CF06  A9 24       LDA #$24
       06:CF08  20 8C CC    JSR WriteToPPUString
                            
  176                       ;;no need to load anything else
  177                       
  178  06:CF0B  AD B8 00    LDA clue_draw_address
  179  06:CF0E  18          CLC
  180  06:CF0F  69 20       ADC #32
  181  06:CF11  8D B8 00    STA clue_draw_address
  182  06:CF14  AD B9 00    LDA clue_draw_address+1
  183  06:CF17  69 00       ADC #$00
  184  06:CF19  8D B9 00    STA clue_draw_address+1
  185                       
  186  06:CF1C  EE BB 00    INC clueLineIndex
  187  06:CF1F  60          RTS
  188                       
  189  06:CF20            LoadPauseScreen:
  190                     
  191                     ;;use clue indexes again
  192                     ;;we want to draw one line at a time
  193                     ;;we have control codes, but those don't matter since we have to build ou the strings before hand
  194                     
  195                     ;load pause table
  196                     ;there are 6 lines of 13 tiles
  197                     ;one byte for the 6 lines, one byte to keep track of our index
  198                       ;STA clueLineIndex 
  199                       ;STA clueOffsetShift
  200                     
  201                     ;;pause_address has the table we want
  202                     ;;pause_draw_address will be the draw location
  203                     
  204                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:CF20  A9 01       LDA #$01
       06:CF22  8D 23 00    STA PPU_PendingWrite
       06:CF25  AD B5 00    LDA pause_draw_address+1
       06:CF28  20 8C CC    JSR WriteToPPUString
       06:CF2B  AD B4 00    LDA pause_draw_address
       06:CF2E  20 8C CC    JSR WriteToPPUString
       06:CF31  A9 00       LDA #DRAW_HORIZONTAL
       06:CF33  20 8C CC    JSR WriteToPPUString
       06:CF36  A9 0D       LDA #13 
       06:CF38  20 8C CC    JSR WriteToPPUString
                            
  205                     
  206  06:CF3B  A2 00       LDX #$00
  207  06:CF3D  AC BB 00    LDY clueLineIndex
  208  06:CF40            .loop:
  209                      
  210  06:CF40  8A          TXA
  211  06:CF41  48          PHA
  212  06:CF42  B1 B0       LDA [pause_address],y
  213  06:CF44  20 8C CC    JSR WriteToPPUString
  214  06:CF47  68          PLA
  215  06:CF48  AA          TAX
  216  06:CF49  C8          INY
  217  06:CF4A  E8          INX 
  218  06:CF4B  E0 0D       CPX #13
  219  06:CF4D  D0 F1       BNE .loop
  220                       
  221  06:CF4F  8C BB 00    STY clueLineIndex
  222                       
  223  06:CF52  AD B4 00    LDA pause_draw_address
  224  06:CF55  18          CLC
  225  06:CF56  69 20       ADC #$20
  226  06:CF58  8D B4 00    STA pause_draw_address
  227  06:CF5B  AD B5 00    LDA pause_draw_address+1
  228  06:CF5E  69 00       ADC #$00
  229  06:CF60  8D B5 00    STA pause_draw_address+1
  230                       
  231  06:CF63  EE BC 00    INC clueOffsetShift
  232  06:CF66  60          RTS
  233                       
  234                       
  235                     
  236                     
  237  06:CF67            ClearPauseScreen:  
  238                     
  239                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:CF67  A9 01       LDA #$01
       06:CF69  8D 23 00    STA PPU_PendingWrite
       06:CF6C  AD B5 00    LDA pause_draw_address+1
       06:CF6F  20 8C CC    JSR WriteToPPUString
       06:CF72  AD B4 00    LDA pause_draw_address
       06:CF75  20 8C CC    JSR WriteToPPUString
       06:CF78  A9 00       LDA #DRAW_HORIZONTAL
       06:CF7A  20 8C CC    JSR WriteToPPUString
       06:CF7D  A9 0D       LDA #13 
       06:CF7F  20 8C CC    JSR WriteToPPUString
                            
  240                     
  241  06:CF82  A2 00       LDX #$00
  242  06:CF84  A0 00       LDY #$00
  243  06:CF86            .loop:
  244                      
  245  06:CF86  8A          TXA
  246  06:CF87  48          PHA
  247  06:CF88  B1 B0       LDA [pause_address],y
  248  06:CF8A  20 8C CC    JSR WriteToPPUString
  249  06:CF8D  68          PLA
  250  06:CF8E  AA          TAX
  251  06:CF8F  C8          INY
  252  06:CF90  E8          INX 
  253  06:CF91  E0 0D       CPX #13
  254  06:CF93  D0 F1       BNE .loop
  255                       
  256                       
  257  06:CF95  AD B4 00    LDA pause_draw_address
  258  06:CF98  18          CLC
  259  06:CF99  69 20       ADC #$20
  260  06:CF9B  8D B4 00    STA pause_draw_address
  261  06:CF9E  AD B5 00    LDA pause_draw_address+1
  262  06:CFA1  69 00       ADC #$00
  263  06:CFA3  8D B5 00    STA pause_draw_address+1
  264                       
  265  06:CFA6  AD B0 00    LDA pause_address
  266  06:CFA9  18          CLC
  267  06:CFAA  69 20       ADC #$20
  268  06:CFAC  8D B0 00    STA pause_address
  269  06:CFAF  AD B1 00    LDA pause_address+1
  270  06:CFB2  69 00       ADC #$00
  271  06:CFB4  8D B1 00    STA pause_address+1
  272                       
  273  06:CFB7  EE BC 00    INC clueOffsetShift
  274  06:CFBA  60         RTS
  275  06:CFBB            DrawImage:
  276                     
  277                       ;;we have clueTableIndex, which should be at the image bytes now
  278                       ;;clue line index will keep track of our place in a byte
  279                        
  280  06:CFBB  A9 00       LDA #$00
  281  06:CFBD  8D 00 00    STA temp1
  282  06:CFC0  8D 01 00    STA temp2
  283  06:CFC3  8D 02 00    STA temp3
  284  06:CFC6  8D 03 00    STA temp4
  285  06:CFC9  8D 05 00    STA temp6
  286                       
  287  06:CFCC  A9 04       LDA #$04
  288  06:CFCE  8D 04 00    STA temp5
  289                       
  290  06:CFD1  A0 00       LDY #$00
  291  06:CFD3  B1 AC       LDA [puzzle_address], y
  292  06:CFD5  AA          TAX
  293  06:CFD6  BD 2D D1    LDA PuzzleSizes, x
  294  06:CFD9  8D 06 00    STA temp7
  295  06:CFDC  BD 30 D1    LDA PuzzleImageSizes, x
  296  06:CFDF  8D 07 00    STA temp8
  297  06:CFE2  4A          LSR A
  298  06:CFE3  4A          LSR A
  299  06:CFE4  8D 09 00    STA tempy
  300  06:CFE7  AD 07 00    LDA temp8
  301  06:CFEA  29 03       AND #$03
  302  06:CFEC  F0 03       BEQ .skipAdd1
  303  06:CFEE  EE 09 00    INC tempy  
  304  06:CFF1            .skipAdd1:
  305  06:CFF1  BD 33 D1    LDA ImageDrawWrapOffsets, x
  306  06:CFF4  8D 08 00    STA tempx
  307                       
  308  06:CFF7  AC BA 00    LDY clueTableIndex
  309  06:CFFA  B1 AE       LDA [clues_address], y
  310                     
  311  06:CFFC  0A          ASL A
  312  06:CFFD  2E 00 00    ROL temp1
  313  06:D000  0A          ASL A
  314  06:D001  2E 00 00    ROL temp1
  315  06:D004  0A          ASL A
  316  06:D005  2E 01 00    ROL temp2
  317  06:D008  0A          ASL A
  318  06:D009  2E 01 00    ROL temp2
  319  06:D00C  0A          ASL A
  320  06:D00D  2E 02 00    ROL temp3
  321  06:D010  0A          ASL A
  322  06:D011  2E 02 00    ROL temp3
  323  06:D014  0A          ASL A
  324  06:D015  2E 03 00    ROL temp4
  325  06:D018  0A          ASL A
  326  06:D019  2E 03 00    ROL temp4
  327                       
  328                     
  329  06:D01C  A2 00       LDX #$00
  330  06:D01E            .moveUpTiles:
  331  06:D01E  BD 00 00    LDA temp1, x
  332  06:D021  09 24       ORA #$24
  333  06:D023  9D 00 00    STA temp1, x
  334  06:D026  E8          INX
  335  06:D027  E0 04       CPX #$04
  336  06:D029  D0 F3       BNE .moveUpTiles
  337                       
  338                       
  339  06:D02B  AD BC 00    LDA clueOffsetShift
  340  06:D02E  18          CLC
  341  06:D02F  69 04       ADC #$04
  342                     
  343  06:D031  8D BC 00    STA clueOffsetShift
  344                       ;;clue offset shift + 4, check if we went over puzle row length
  345  06:D034  38          SEC
  346  06:D035  ED 06 00    SBC temp7 ;;subtract 15
  347  06:D038  90 12       BCC .makeStrings
  348  06:D03A  F0 10       BEQ .makeStrings
  349                       
  350  06:D03C  8D BC 00    STA clueOffsetShift ;loop offset over
  351  06:D03F  8D 05 00    STA temp6 ; length of second string
  352  06:D042  AD 04 00    LDA temp5
  353  06:D045  38          SEC
  354  06:D046  ED 05 00    SBC temp6 
  355  06:D049  8D 04 00    STA temp5 ;length of first string 
  356                       
  357  06:D04C            .makeStrings:
  358                       
  359  06:D04C  A2 00       LDX #$00
  360                       
  361  06:D04E  AD 04 00    LDA temp5
  362  06:D051  F0 51       BEQ .makeSecondString
  363  06:D053  8A          TXA
  364  06:D054  48          PHA
  365                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp5
                          
       06:D055  A9 01       LDA #$01
       06:D057  8D 23 00    STA PPU_PendingWrite
       06:D05A  AD B9 00    LDA clue_draw_address+1
       06:D05D  20 8C CC    JSR WriteToPPUString
       06:D060  AD B8 00    LDA clue_draw_address
       06:D063  20 8C CC    JSR WriteToPPUString
       06:D066  A9 00       LDA #DRAW_HORIZONTAL
       06:D068  20 8C CC    JSR WriteToPPUString
       06:D06B  AD 04 00    LDA temp5 
       06:D06E  20 8C CC    JSR WriteToPPUString
                            
  366  06:D071  68          PLA
  367  06:D072  AA          TAX
  368                       
  369  06:D073            .firstStringLoop:
  370                       
  371  06:D073  8A          TXA 
  372  06:D074  48          PHA
  373  06:D075  BD 00 00    LDA temp1, x
  374  06:D078  20 8C CC    JSR WriteToPPUString
  375                       
  376  06:D07B  EE BB 00    INC clueLineIndex
  377  06:D07E  AD BB 00    LDA clueLineIndex
  378  06:D081  CD 07 00    CMP temp8
  379  06:D084  D0 04       BNE .continueLoop
  380  06:D086  68          PLA 
  381  06:D087  4C 0B D1    JMP .leave
  382                       
  383  06:D08A            .continueLoop:
  384  06:D08A  68          PLA
  385  06:D08B  AA          TAX
  386  06:D08C  E8          INX
  387  06:D08D  EC 04 00    CPX temp5
  388  06:D090  D0 E1       BNE .firstStringLoop
  389                       
  390  06:D092  AD B8 00    LDA clue_draw_address
  391  06:D095  18          CLC
  392  06:D096  6D 04 00    ADC temp5
  393  06:D099  8D B8 00    STA clue_draw_address
  394  06:D09C  AD B9 00    LDA clue_draw_address+1
  395  06:D09F  69 00       ADC #$00
  396  06:D0A1  8D B9 00    STA clue_draw_address+1
  397                       
  398  06:D0A4            .makeSecondString:
  399                     
  400  06:D0A4  AD 05 00    LDA temp6
  401  06:D0A7  F0 62       BEQ .leave
  402                       
  403                       ;;loop draw address to next line
  404  06:D0A9  AD B8 00    LDA clue_draw_address
  405  06:D0AC  18          CLC
  406  06:D0AD  6D 08 00    ADC tempx
  407  06:D0B0  8D B8 00    STA clue_draw_address
  408  06:D0B3  AD B9 00    LDA clue_draw_address+1
  409  06:D0B6  69 00       ADC #$00
  410  06:D0B8  8D B9 00    STA clue_draw_address+1
  411  06:D0BB  8A          TXA
  412  06:D0BC  48          PHA
  413                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp6
                          
       06:D0BD  A9 01       LDA #$01
       06:D0BF  8D 23 00    STA PPU_PendingWrite
       06:D0C2  AD B9 00    LDA clue_draw_address+1
       06:D0C5  20 8C CC    JSR WriteToPPUString
       06:D0C8  AD B8 00    LDA clue_draw_address
       06:D0CB  20 8C CC    JSR WriteToPPUString
       06:D0CE  A9 00       LDA #DRAW_HORIZONTAL
       06:D0D0  20 8C CC    JSR WriteToPPUString
       06:D0D3  AD 05 00    LDA temp6 
       06:D0D6  20 8C CC    JSR WriteToPPUString
                            
  414  06:D0D9  68          PLA 
  415  06:D0DA  AA          TAX
  416                       
  417  06:D0DB            .secondStringLoop:
  418                     
  419  06:D0DB  8A          TXA
  420  06:D0DC  48          PHA 
  421  06:D0DD  BD 00 00    LDA temp1, x
  422  06:D0E0  20 8C CC    JSR WriteToPPUString
  423                       
  424  06:D0E3  EE BB 00    INC clueLineIndex
  425  06:D0E6  AD BB 00    LDA clueLineIndex
  426  06:D0E9  CD 07 00    CMP temp8
  427  06:D0EC  D0 04       BNE .continueSecondLoop
  428                       
  429  06:D0EE  68          PLA 
  430  06:D0EF  4C 0B D1    JMP .leave
  431                       
  432  06:D0F2            .continueSecondLoop:
  433  06:D0F2  68          PLA
  434  06:D0F3  AA          TAX
  435  06:D0F4  E8          INX
  436  06:D0F5  E0 04       CPX #$04
  437  06:D0F7  D0 E2       BNE .secondStringLoop
  438                       
  439  06:D0F9  AD B8 00    LDA clue_draw_address
  440  06:D0FC  18          CLC
  441  06:D0FD  6D 05 00    ADC temp6
  442  06:D100  8D B8 00    STA clue_draw_address
  443  06:D103  AD B9 00    LDA clue_draw_address+1
  444  06:D106  69 00       ADC #$00
  445  06:D108  8D B9 00    STA clue_draw_address+1
  446                       
  447  06:D10B            .leave:
  448  06:D10B  EE BA 00    INC clueTableIndex
  449  06:D10E  60          RTS
  450                     
  451  06:D10F            ClearLineDefs:
  452                     
  453  06:D10F  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:D112  20 20 20  
       06:D115  20 20 20  
       06:D118  20 20     
  454  06:D11A  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:D11D  0D 0D 0D  
       06:D120  0D 0D 0D  
       06:D123  0D 0D 0D  
       06:D126  0D 0D 0D  
       06:D129  0D 0D     
  455  06:D12B  20 20       .db $20, $20
  456                       
  457  06:D12D            PuzzleSizes:
  458                       
  459  06:D12D  05 0A 0F    .db $05, $0A, $0F
  460                       
  461  06:D130            PuzzleImageSizes:
  462                     
  463                       ;.db $05, $0A, $0F
  464  06:D130  19 64 E1    .db $19, $64, $E1
  465                       
  466  06:D133            ImageDrawWrapOffsets:
  467                     
  468  06:D133  1B 16 11   .db $1B, $16, $11
#[1]   Picross.asm
   97                       
   98                       
   99                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  100                     ;;     NMI                  ;;
  101                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  102                     
#[2]   Routines/Common/NMI.asm
  103                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:D136            NMI:
    3                     
    4  06:D136  48          PHA                              ;protect the registers
    5  06:D137  8A          TXA
    6  06:D138  48          PHA
    7  06:D139  98          TYA
    8  06:D13A  48          PHA
    9                       
   10  06:D13B            nmi_started:
   11  06:D13B  A9 00       LDA #$00
   12  06:D13D  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:D140  A9 02       LDA #$02
   14  06:D142  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:D145  AD 10 00    LDA NMI_locks
   17  06:D148  F0 03       BEQ update_controllers
   18  06:D14A  4C B9 D1    JMP WakeUp
   19                     
   20  06:D14D            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:D14D  8A            TXA
    3  06:D14E  48                PHA
    4  06:D14F  98                TYA
    5  06:D150  48                PHA
    6                     
    7  06:D151  A2 00             LDX #$00
    8                     
    9  06:D153            GamePadCheck:
   10  06:D153  A9 01             LDA #$01        ;load 1
   11  06:D155  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:D158  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:D159  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:D15C  A9 80             LDA #$80
   18  06:D15E  8D 1A 00          STA gamepad
   19                     
   20  06:D161            ReadControllerABytesLoop:
   21  06:D161  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:D164  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:D166  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:D168  6E 1A 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:D16B  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:D16D  AD 1B 00          LDA gamepadLast
   31  06:D170  49 FF             EOR #$FF
   32  06:D172  2D 1A 00          AND gamepad
   33  06:D175  8D 1C 00          STA gamepadPressed
   34                             
   35                             
   36  06:D178  AD 1A 00          LDA gamepad
   37  06:D17B  8D 1B 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:D17E  68                PLA
   41  06:D17F  A8                TAY
   42  06:D180  68                PLA
   43  06:D181  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:D182  20 C9 CB    JSR ProcessPPUString
   25                       
   26                       
   27  06:D185  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:D187  8D 05 20    STA PPU_SCROLL
   29  06:D18A  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:D18D  20 E6 CC    JSR UpdatePPUControl
   34                     
   35  06:D190            NMIUpdate:
   36                     
   37  06:D190  20 AD D1    JSR StateNMIUpdate
   38                       
   39  06:D193  AD 1D 00    LDA PPU_Control
   40  06:D196  29 FC       AND #$FC
   41  06:D198  0D 21 00    ORA PPU_ScrollNT
   42  06:D19B  8D 00 20    STA PPU_CTRL
   43                       
   44  06:D19E  AD 1F 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:D1A1  8D 05 20    STA PPU_SCROLL
   46  06:D1A4  AD 20 00    LDA PPU_ScrollY
   47  06:D1A7  8D 05 20    STA PPU_SCROLL
   48                     
   49  06:D1AA  4C B9 D1    JMP WakeUp
   50                     
   51  06:D1AD            StateNMIUpdate:
   52                     
   53                       MACROCallDynamicJump game_mode
                          
       06:D1AD  AD 0E 00    LDA game_mode
       06:D1B0  20 0A CB    JSR Dynamic_Jump
                                  
   54                     
   55  06:D1B3            NMIJumpTable:
   56                     
   57  06:D1B3  C4 D1       .word UpdateTitleNMI
   58  06:D1B5  C8 D1       .word UpdateGameNMI
   59  06:D1B7  C9 D1       .word UpdateGameOverNMI
   60                     
   61  06:D1B9            WakeUp:
   62  06:D1B9  A9 00       LDA #$00
   63  06:D1BB  8D 0C 00    STA sleeping
   64                       
   65  06:D1BE  68          PLA             ;restore the registers
   66  06:D1BF  A8          TAY 
   67  06:D1C0  68          PLA
   68  06:D1C1  AA          TAX
   69  06:D1C2  68          PLA
   70                     
   71  06:D1C3  40          RTI             ; return from interrupt
   72                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   73                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:D1C4            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:D1C4  20 AC CC    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:D1C7  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   74                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:D1C8            UpdateGameNMI:
    2  06:D1C8  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:D1C9            UpdateGameOverNMI:
    2  06:D1C9  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
  104                       
  105                     ;;**************************;;
  106                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  107                     ;;       PRG ROM DATA       ;;
  108                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  109                     ;;**************************;; 
  110                       
  111           0007        .bank 7
  112           E000        .org $E000
  113                     
#[2]   NameTables/Tables.asm
  114                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  1C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  3C E0     
       07:E004  5C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  12 E0       .word Title_Screens, Game_Screens, GameOver_Screens
       07:E008  14 E0     
       07:E00A  1A E0     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  7C E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  7C F8     
       07:E010  7C F8     
   12                       
   13  07:E012            Title_Screens:
   14                     
   15  07:E012  7C E0       .word Title_Screen
   16                       
   17  07:E014            Game_Screens:
   18                     
   19  07:E014  7C E8       .word Game_5, Game_10, Game_15
       07:E016  7C EC     
       07:E018  7C F0     
   20                       
   21  07:E01A            GameOver_Screens:
   22                     
   23  07:E01A  7C F4       .word GameOver_Screen
   24                     
   25  07:E01C            Title_Palette:
   26                     
   27  07:E01C              .incbin "NameTables/Title_PAL.pal"
   28  07:E02C              .incbin "NameTables/Title_PAL.pal"
   29                       
   30  07:E03C            Game_Palette:
   31                     
   32  07:E03C              .incbin "NameTables/Game_PAL.pal"
   33  07:E04C              .incbin "NameTables/Game_PAL.pal"
   34                       
   35  07:E05C            GameOver_Palette:
   36                     
   37  07:E05C              .incbin "NameTables/GameOver_PAL.pal"
   38  07:E06C              .incbin "NameTables/GameOver_PAL.pal"
   39                       
   40  07:E07C            Title_Screen:
   41                     
   42  07:E07C              .incbin "NameTables/Title_NT.nam"
   43                       
   44  07:E47C            Title_Second:
   45                     
   46  07:E47C              .incbin "NameTables/Title_PuzzMen_NT.nam"
   47                       
   48  07:E87C            Game_5: 
   49                     
   50  07:E87C              .incbin "NameTables/Game_NT_5.nam"
   51                       
   52  07:EC7C            Game_10:
   53  07:EC7C              .incbin "NameTables/Game_NT_10.nam"
   54                       
   55  07:F07C            Game_15:
   56  07:F07C              .incbin "NameTables/Game_NT.nam"
   57                       
   58  07:F47C            GameOver_Screen:
   59                     
   60  07:F47C              .incbin "NameTables/GameOver_NT.nam"
   61                       
   62  07:F87C            Blank_Screen:
   63                     
   64  07:F87C              .incbin "NameTables/Blank_NT.nam"
   65                     
   66  07:FC7C            Pause_Menu:
   67  07:FC7C  28 2A 2A    .db $28,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$29
       07:FC7F  2A 2A 2A  
       07:FC82  2A 2A 2A  
       07:FC85  2A 2A 2A  
       07:FC88  29        
   68  07:FC89  2B 24 1C    .db $2b,$24,$1c,$0a,$1f,$0e,$62,$0e,$21,$12,$1d,$24,$3b
       07:FC8C  0A 1F 0E  
       07:FC8F  62 0E 21  
       07:FC92  12 1D 24  
       07:FC95  3B        
   69  07:FC96  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FC99  24 24 24  
       07:FC9C  24 24 24  
       07:FC9F  24 24 24  
       07:FCA2  3B        
   70  07:FCA3  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FCA6  24 24 24  
       07:FCA9  24 24 24  
       07:FCAC  24 24 24  
       07:FCAF  3B        
   71  07:FCB0  2B 24 24    .db $2b,$24,$24,$22,$0e,$1c,$24,$24,$17,$18,$24,$24,$3b
       07:FCB3  22 0E 1C  
       07:FCB6  24 24 17  
       07:FCB9  18 24 24  
       07:FCBC  3B        
   72  07:FCBD  38 3A 3A    .db $38,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$39
       07:FCC0  3A 3A 3A  
       07:FCC3  3A 3A 3A  
       07:FCC6  3A 3A 3A  
       07:FCC9  39        
   73                     
   74                       
   75                     
   76                       
   77                      
   78                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  115                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:FCCA            Sprites:
   38  07:FCCA  D0 FC             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:FCCC  D9 FC     
       07:FCCE  E2 FC     
   39                     
   40  07:FCD0            Title_Sprites:
   41  07:FCD0  02            .db $02
   42  07:FCD1  85 00 00          .db $85,$00,$00,$E8
       07:FCD4  E8        
   43  07:FCD5  A0 01 00          .db $A0,$01,$00,$60
       07:FCD8  60        
   44  07:FCD9            Game_Sprites:
   45  07:FCD9  02            .db $02
   46  07:FCDA  62 02 03          .db $62,$02,$03,$72
       07:FCDD  72        
   47  07:FCDE  5F FF 00          .db $5F,$FF,$00,$60
       07:FCE1  60        
   48  07:FCE2            GameOver_Sprites:
   49  07:FCE2  01                .db $01
   50  07:FCE3  00 00 00          .db $00,$00,$00,$00
       07:FCE6  00        
#[1]   Picross.asm
  116                     
  117           FFFA        .org $FFFA     ;first of the three vectors starts here
  118  07:FFFA  36 D1       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  119                                        ;processor will jump to the label NMI:
  120  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  121                                        ;to the label RESET:
  122  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  123                       
  124                     ;;**************************;;
  125                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  126                     ;;      CHR ROM DATA        ;;
  127                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  128                     ;;**************************;; 
  129                       
  130           0008        .bank 8
  131           0000        .org $0000
  132  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  133                       
  134           0009        .bank 9
  135           0000        .org $0000
  136  09:0000              .incbin "CHRROM/Bank1.chr"
  137                       
  138           000A        .bank 10
  139           0000        .org $0000
  140  0A:0000              .incbin "CHRROM/Bank2.chr"
  141                       
  142           000B        .bank 11
  143           0000        .org $0000
  144  0B:0000              .incbin "CHRROM/Bank3.chr"
