#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      temp5                   .rs 1
    6           0005      temp6                   .rs 1
    7           0006      tempx                   .rs 1
    8           0007      tempy                   .rs 1
    9           0008      time                    .rs 1
   10           0009      sleeping                .rs 1
   11           000A      game_mode               .rs 1
   12           000B      mode_state              .rs 1
   13           000C      NMI_locks               .rs 1
   14           000D      game_locks              .rs 1
   15           000E      pointer_address .rs 2
   16           0010      table_address   .rs 2
   17           0012      jump_address    .rs 2
   18                     
   19                     ;game modes
   20           0000      TITLE_IDX = $00
   21           0001      GAME_IDX = $01
   22           0002      GAMEOVER_IDX = $02
   23                     
   24                     ;locks for input and rendering
   25           0001      BGLOAD_NMI_LOCK = %00000001
   26           0001      EFFECT_GAME_LOCK = %00000001
   27                     
   28                     
   29                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           0014      gamepad                 .rs 1
   19           0015      gamepadLast     .rs 1
   20           0016      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           0017      PPU_Control                     .rs 1
    2           0018      PPU_Mask                        .rs 1
    3           0019      PPU_ScrollX                     .rs 1
    4           001A      PPU_ScrollY                     .rs 1
    5           001B      PPU_ScrollNT            .rs 1   ;first two bits
    6           001C      PPU_NT                          .rs 1
    7                     
    8           001D      PPU_PendingWrite        .rs 1
    9           001E      PPU_StringIdx           .rs 1
   10           001F      PPU_String                      .rs 128
   11                     
   12           004F      PPU_STRINGMAX = $4F ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           009F      mapper_address  .rs 2
    2           00A1      currentCHRBankA .rs 1
    3           00A2      currentCHRBankB .rs 1
    4           00A3      currentPRGBank  .rs 1
    5           00A4      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           00A5      puzzle_address          .rs 2
    2           00A7      clues_address           .rs 2
    3           00A9      clue_start_address      .rs 2
    4           00AB      clue_draw_address       .rs 2
    5           00AD      clueTableIndex          .rs 1
    6           00AE      clueLineIndex           .rs 1
    7           00AF      clueOffsetShift         .rs 1
    8           00B0      clueDrawOffset          .rs 2
    9           00B2      clueDrawAdd                     .rs 1
   10           00B3      clueDrawDecSize         .rs 1
   11           00B4      clueParity                      .rs 1
   12           00B5      mouse_location          .rs 2
   13           00B7      mouse_index                     .rs 2
   14           00B9      currentPaintTile        .rs 1
   15           00BA      solutionCount           .rs 1
   16           00BB      nonSolutionCount        .rs 1
   17           00BC      holdTimer                       .rs 1
   18           00BD      GameTime                        .rs 4   ;in order - second, ten second, minute, 10 minute - max out at 99 minutes
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/ScreenStateVariables.asm
   18                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   19           7000        .rsset $7000
#[3]   Defines/SaveVariables.asm
   20                       .include "Defines/SaveVariables.asm"
    1           7000      bank_index      .rs 1
    2           7001      puzzle_index .rs 1
    3                     
#[2]   Defines/Defines.asm
   21                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1           0000        .bank 0
    2           8000        .org $8000
    3                       
#[3]   Puzzles/house.asm
    4                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  03 82 00    .db $03, $82, $00, $21
       00:8003  21        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  05 11 18    .db $05, $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1E 1C 0E  
       00:80B6  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test.asm
    5                       .include "Puzzles/test.asm"
    1  00:80B7            test:
    2  00:80B7  03 01 00    .db $03, $01, $00, $00
       00:80BA  00        
    3  00:80BB  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:80BE  00 00 00  
       00:80C1  00 00 00  
       00:80C4  00 00 00  
       00:80C7  00 00 00  
       00:80CA  00 00 00  
       00:80CD  00 00 00  
       00:80D0  00 00 00  
       00:80D3  00 00 00  
       00:80D6  00 00 00  
    4  00:80D9  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80DC  FF 00 FF  
       00:80DF  00 FF 00  
       00:80E2  FF 00 FF  
       00:80E5  00 FF 00  
       00:80E8  FF 00 FF  
       00:80EB  00 FF 00  
       00:80EE  FF 00 FF  
       00:80F1  00 FF 00  
       00:80F4  FF 00 FF  
    5  00:80F7  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80FA  FF 00 FF  
       00:80FD  00 FF 00  
       00:8100  FF 00 FF  
       00:8103  00 FF 00  
       00:8106  FF 00 FF  
       00:8109  00 FF 00  
       00:810C  FF 00 FF  
       00:810F  00 FF 00  
       00:8112  FF 00 FF  
    6  00:8115            testImage:
    7  00:8115  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8118  1B 1B 1B  
       00:811B  1B 1B 1B  
       00:811E  1B 1B 1B  
       00:8121  1B 1B 1B  
       00:8124  1B 1B 1B  
       00:8127  1B 1B 1B  
       00:812A  1B 1B 1B  
       00:812D  1B 1B 1B  
       00:8130  1B 1B 1B  
       00:8133  1B 1B 1B  
       00:8136  1B 1B 1B  
       00:8139  1B 1B 1B  
       00:813C  1B 1B 1B  
       00:813F  1B 1B 1B  
       00:8142  1B 1B 1B  
       00:8145  1B 1B 1B  
       00:8148  1B 1B 1B  
       00:814B  1B 1B 00  
       00:814E  FF        
    8  00:814F            testName:
    9  00:814F  04 1D 0E    .db $04, $1D, $0E, $1C, $1D, $FF
       00:8152  1C 1D FF  
#[2]   Banks/Bank0.asm
    6                     
    7           0001        .bank 1
    8           A000        .org $A000
    9                       
   10  01:A000  00 80       .word house, test
       01:A002  B7 80     
   11                       
   12           BFFA        .org $BFFA     ;first of the three vectors starts here
   13  01:BFFA  68 CD       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   14                                        ;processor will jump to the label NMI:
   15  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   16                                        ;to the label RESET:
   17  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  03 62 00    .db $03, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  04 0F 1B    .db $04, $0F, $1B, $18, $10, $FF
       02:80A7  18 10 FF  
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                     
    9  03:A000  00 80       .word frog
   10                     
   11           BFFA        .org $BFFA     ;first of the three vectors starts here
   12  03:BFFA  68 CD       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   13                                        ;processor will jump to the label NMI:
   14  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   15                                        ;to the label RESET:
   16  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  03 7E 00    .db $03, $7E, $00, $2B
       04:8003  2B        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  03 0C 0A    .db $03, $0C, $0A, $1D, $FF
       04:80A5  1D FF     
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8  05:A000  00 80       .word cat
    9                     
   10           BFFA        .org $BFFA     ;first of the three vectors starts here
   11  05:BFFA  68 CD       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   12                                        ;processor will jump to the label NMI:
   13  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   14                                        ;to the label RESET:
   15  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 8F CA    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 93 CA    JSR SetMapperControls
   34                       
   35  06:C040  20 D0 CA    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  20 A6 C7    JSR ChangeGameMode
   38  06:C04D  20 14 CA    JSR InitPPUControl
   39                       
   40                     
   41                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   42                     ;;     Main Program         ;;
   43                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   44                     
   45  06:C050            Forever:
   46                     
   47  06:C050  EE 09 00    INC sleeping
   48                     
   49  06:C053            .loop
   50  06:C053  AD 09 00    LDA sleeping
   51  06:C056  D0 FB       BNE .loop
   52                     
   53  06:C058  EE 08 00    INC time  
   54  06:C05B  20 61 C0    JSR GameLoop
   55                     
   56                     
   57  06:C05E  4C 50 C0    JMP Forever     ;jump back to Forever, infinite loop
   58                       
   59                     ;; dynamic jump table
   60                     
   61  06:C061            GameLoop:
   62                     
   63                       MACROCallDynamicJump game_mode
                          
       06:C061  AD 0A 00    LDA game_mode
       06:C064  20 56 C8    JSR Dynamic_Jump
                                  
   64                       ;; we'll pop the return address here as the table index, so 
   65                       ;; the routine we pick will return us to whatever called Game Loop
   66                       ;; when it returns
   67                     
   68  06:C067            GameLoopJumpTable:
   69                     
   70  06:C067  6D C0       .word UpdateTitle
   71  06:C069  62 C2       .word UpdateGame
   72  06:C06B  57 C7       .word UpdateGameOver
   73                       
   74                     
   75                       ;;RTS is called in the subroutine
   76                     
   77                       
#[2]   Routines/Game_States/UpdateTitle.asm
   78                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C06D            UpdateTitle:
    2                     
    3  06:C06D  AD 0C 00    LDA NMI_locks
    4  06:C070  F0 01       BEQ .unlocked
    5                       
    6  06:C072  60          RTS
    7                       
    8  06:C073            .unlocked:
    9                     
   10  06:C073  20 77 C0    JSR DoUpdateTitle  
   11  06:C076  60          RTS
   12                       
   13  06:C077            DoUpdateTitle:
   14                     
   15  06:C077  AD 0B 00    LDA mode_state
   16  06:C07A  20 56 C8    JSR Dynamic_Jump
   17                         
   18  06:C07D            UpdateTitleJumpTable:
   19                     
   20  06:C07D  89 C0       .word UpdateTitleInit
   21  06:C07F  9A C0       .word UpdateBankSelection
   22  06:C081  B3 C0       .word UpdateScroll
   23  06:C083  D5 C0       .word UpdatePuzzleSelection
   24  06:C085  16 C1       .word UpdateScrollBack
   25  06:C087  33 C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C089            UpdateTitleInit:
   35                     
   36  06:C089  20 F0 C9    JSR TurnOnSprites
   37                       
   38  06:C08C  A9 00       LDA #$00
   39  06:C08E  8D B7 00    STA mouse_index
   40  06:C091  A9 00       LDA #$00
   41  06:C093  8D B8 00    STA mouse_index+1
   42                     
   43  06:C096            .changeModeState:
   44                     
   45  06:C096  EE 0B 00    INC mode_state
   46  06:C099            .leave:
   47  06:C099  60          RTS
   48                       
   49  06:C09A            UpdateBankSelection:
   50                     
   51  06:C09A  20 BA C1    JSR UpdateBankPointer
   52                       
   53  06:C09D  AD 16 00    LDA gamepadPressed
   54  06:C0A0  29 01       AND #GAMEPAD_A
   55  06:C0A2  F0 0E       BEQ .leave
   56                       
   57  06:C0A4            .changeModeState:
   58                     
   59  06:C0A4  AD B7 00    LDA mouse_index
   60  06:C0A7  8D 00 70    STA bank_index
   61  06:C0AA  A9 FF       LDA #$FF
   62  06:C0AC  20 A2 C1    JSR SetPointerSprite
   63                       
   64  06:C0AF  EE 0B 00    INC mode_state
   65  06:C0B2            .leave:
   66  06:C0B2  60          RTS
   67                       
   68  06:C0B3            UpdateScroll:
   69  06:C0B3  EE 19 00    INC PPU_ScrollX
   70  06:C0B6  EE 19 00    INC PPU_ScrollX
   71  06:C0B9  EE 19 00    INC PPU_ScrollX
   72  06:C0BC  EE 19 00    INC PPU_ScrollX
   73  06:C0BF  D0 13       BNE .leave
   74  06:C0C1  AD 1B 00    LDA PPU_ScrollNT
   75  06:C0C4  49 01       EOR #%00000001
   76  06:C0C6  8D 1B 00    STA PPU_ScrollNT
   77                       
   78  06:C0C9            .changeModeState:
   79  06:C0C9  A9 01       LDA #$01
   80  06:C0CB  20 A2 C1    JSR SetPointerSprite
   81  06:C0CE  20 68 C1    JSR InitPuzzlePointer
   82  06:C0D1  EE 0B 00    INC mode_state
   83  06:C0D4            .leave:
   84  06:C0D4  60          RTS
   85                       
   86  06:C0D5            UpdatePuzzleSelection:
   87                     
   88  06:C0D5  20 F7 C1    JSR UpdatePuzzlePointer
   89                       
   90  06:C0D8  AD 16 00    LDA gamepadPressed
   91  06:C0DB  29 02       AND #GAMEPAD_B
   92  06:C0DD  D0 10       BNE .changeToScrollBack
   93  06:C0DF  AD 16 00    LDA gamepadPressed
   94  06:C0E2  29 09       AND #GAMEPAD_CONFIRM
   95  06:C0E4  F0 2F       BEQ .leave
   96                       
   97  06:C0E6  EE 0B 00    INC mode_state
   98  06:C0E9  EE 0B 00    INC mode_state
   99  06:C0EC  4C 15 C1    JMP .leave
  100                       
  101  06:C0EF            .changeToScrollBack:
  102                      
  103  06:C0EF  A9 FF       LDA #$FF
  104  06:C0F1  20 A2 C1    JSR SetPointerSprite
  105  06:C0F4  20 60 C1    JSR InitBankPointer
  106  06:C0F7  AD 00 70    LDA bank_index
  107  06:C0FA  8D B7 00    STA mouse_index
  108  06:C0FD  20 EC C1    JSR SetBankPointerFromIndex
  109                       
  110  06:C100  A9 00       LDA #$00
  111  06:C102  8D 1A 00    STA PPU_ScrollY
  112  06:C105  A9 FC       LDA #$FC
  113  06:C107  8D 19 00    STA PPU_ScrollX
  114  06:C10A  AD 1B 00    LDA PPU_ScrollNT
  115  06:C10D  29 FE       AND #$FE
  116  06:C10F  8D 1B 00    STA PPU_ScrollNT
  117                       
  118  06:C112  EE 0B 00    INC mode_state
  119  06:C115            .leave:
  120  06:C115  60          RTS
  121                       
  122  06:C116            UpdateScrollBack:
  123                     
  124  06:C116  CE 19 00    DEC PPU_ScrollX
  125  06:C119  CE 19 00    DEC PPU_ScrollX
  126  06:C11C  CE 19 00    DEC PPU_ScrollX
  127  06:C11F  CE 19 00    DEC PPU_ScrollX
  128  06:C122  D0 0E       BNE .leave
  129                       
  130  06:C124            .changeModeState:
  131                     
  132  06:C124  A9 01       LDA #$01
  133  06:C126  20 A2 C1    JSR SetPointerSprite
  134  06:C129  CE 0B 00    DEC mode_state
  135  06:C12C  CE 0B 00    DEC mode_state
  136  06:C12F  CE 0B 00    DEC mode_state
  137                       
  138  06:C132            .leave:
  139  06:C132  60          RTS
  140                       
  141  06:C133            UpdateTitleExit:
  142                     
  143                       ;;reset screen scroll
  144  06:C133  A9 00       LDA #$00
  145  06:C135  8D 19 00    STA PPU_ScrollX
  146  06:C138  8D 1B 00    STA PPU_ScrollNT
  147                       
  148                       ;;load bank
  149                     
  150  06:C13B  20 8F CA    JSR ResetMapper
  151  06:C13E  AD 00 70    LDA bank_index
  152  06:C141  8D A3 00    STA currentPRGBank
  153  06:C144  20 9E CA    JSR LoadPRGBank
  154                     
  155                       ;; we can also pick out the puzzle index
  156                       ;; we have the mouse indexes - one vert, one hori
  157                       ;; take vert, mult by 9- alternatively, mult by 8, add index 
  158                       ;; IE - ind = 1, mult 8 = 8, add 1 = 9
  159                       ;; add X index
  160  06:C147  AD B7 00    LDA mouse_index
  161  06:C14A  0A          ASL A
  162  06:C14B  0A          ASL A
  163  06:C14C  0A          ASL A
  164  06:C14D  18          CLC
  165  06:C14E  6D B7 00    ADC mouse_index
  166  06:C151  6D B8 00    ADC mouse_index+1
  167  06:C154  8D 01 70    STA puzzle_index
  168                     
  169  06:C157  20 F9 C9    JSR TurnOffSprites
  170                     
  171  06:C15A  A9 01       LDA #GAME_IDX
  172  06:C15C  20 A6 C7    JSR ChangeGameMode
  173                       
  174  06:C15F            .leave
  175  06:C15F  60          RTS
  176                       
  177  06:C160            InitBankPointer:
  178                     
  179  06:C160  A2 A0       LDX #$A0
  180  06:C162  A9 60       LDA #$60
  181  06:C164  20 7B C1    JSR InitPointer
  182                       
  183  06:C167  60          RTS  
  184                       
  185  06:C168            InitPuzzlePointer:
  186                       
  187  06:C168  A2 AE       LDX #$AE
  188  06:C16A  A9 10       LDA #$10
  189  06:C16C  20 7B C1    JSR InitPointer
  190                       
  191  06:C16F  60          RTS
  192                     
  193  06:C170            ResetMouseIndex:
  194                     
  195  06:C170  A9 00       LDA #$00
  196  06:C172  8D B7 00    STA mouse_index
  197  06:C175  A9 00       LDA #$00
  198  06:C177  8D B8 00    STA mouse_index+1
  199  06:C17A  60          RTS
  200                     
  201  06:C17B            InitPointer:
  202                     
  203  06:C17B  20 82 C1    JSR SetPointerPosition
  204  06:C17E  20 70 C1    JSR ResetMouseIndex
  205  06:C181  60          RTS  
  206                       
  207  06:C182            SetPointerPosition:
  208                     
  209  06:C182  48          PHA
  210  06:C183  8A          TXA
  211  06:C184  20 8C C1    JSR SetPointerYPosition
  212  06:C187  68          PLA
  213  06:C188  20 97 C1    JSR SetPointerXPosition
  214                      
  215  06:C18B  60          RTS
  216                       
  217  06:C18C            SetPointerYPosition:
  218                       
  219  06:C18C  48          PHA
  220  06:C18D  A9 00       LDA #SPRITE_YPOS
  221  06:C18F  20 AD C1    JSR GetPointerDataIndexInX
  222  06:C192  68          PLA
  223  06:C193  9D 00 02    STA SPRITE_DATA, x
  224  06:C196  60          RTS
  225                       
  226  06:C197            SetPointerXPosition:  
  227                       
  228  06:C197  48          PHA
  229  06:C198  A9 03       LDA #SPRITE_XPOS
  230  06:C19A  20 AD C1    JSR GetPointerDataIndexInX
  231  06:C19D  68          PLA
  232  06:C19E  9D 00 02    STA SPRITE_DATA, x 
  233  06:C1A1  60          RTS
  234                     
  235  06:C1A2            SetPointerSprite:
  236                     
  237                     ;; A has aprite we want
  238  06:C1A2  48          PHA
  239  06:C1A3  A9 01       LDA #SPRITE_ID
  240  06:C1A5  20 AD C1    JSR GetPointerDataIndexInX
  241  06:C1A8  68          PLA
  242  06:C1A9  9D 00 02    STA SPRITE_DATA, x
  243  06:C1AC  60          RTS
  244                       
  245  06:C1AD            GetPointerDataIndexInX:
  246                     
  247  06:C1AD  8D 02 00    STA temp3
  248  06:C1B0  A9 01       LDA #$01
  249  06:C1B2  0A          ASL A
  250  06:C1B3  0A          ASL A
  251  06:C1B4  18          CLC
  252  06:C1B5  6D 02 00    ADC temp3
  253  06:C1B8  AA          TAX
  254                       
  255  06:C1B9  60          RTS
  256                       
  257                       
  258  06:C1BA            UpdateBankPointer:
  259                      
  260                       ;;bank pointer is 1D, will loop between 0->3
  261  06:C1BA  AD 16 00    LDA gamepadPressed
  262  06:C1BD  D0 01       BNE .continue
  263  06:C1BF            .leaveEarly:
  264  06:C1BF  60          RTS
  265                       
  266  06:C1C0            .continue:
  267  06:C1C0  A9 00       LDA #$00
  268  06:C1C2  8D 00 00    STA temp1
  269                       
  270  06:C1C5            .parseInputs:
  271  06:C1C5  AD 16 00    LDA gamepadPressed
  272  06:C1C8  29 30       AND #GAMEPAD_VERT
  273  06:C1CA  F0 F3       BEQ .leaveEarly
  274  06:C1CC  0A          ASL A
  275  06:C1CD  0A          ASL A
  276  06:C1CE            .checkDown:
  277  06:C1CE  0A          ASL A
  278  06:C1CF  90 03       BCC .checkUp
  279  06:C1D1  EE 00 00    INC temp1
  280  06:C1D4            .checkUp:
  281  06:C1D4  0A          ASL A
  282  06:C1D5  90 03       BCC .move
  283  06:C1D7  CE 00 00    DEC temp1
  284  06:C1DA            .move:
  285                       
  286  06:C1DA  AD B7 00    LDA mouse_index
  287  06:C1DD  18          CLC
  288  06:C1DE  6D 00 00    ADC temp1
  289  06:C1E1  C9 02       CMP #$02
  290  06:C1E3  F0 04       BEQ .skipMod
  291  06:C1E5  90 02       BCC .skipMod
  292  06:C1E7  A9 00       LDA #$00
  293  06:C1E9            .skipMod:
  294  06:C1E9  8D B7 00    STA mouse_index
  295                       ;; mult mouse_index by 16
  296  06:C1EC            SetBankPointerFromIndex:
  297                     
  298  06:C1EC  0A          ASL A
  299  06:C1ED  0A          ASL A
  300  06:C1EE  0A          ASL A
  301  06:C1EF  0A          ASL A
  302  06:C1F0  18          CLC
  303  06:C1F1  69 A0       ADC #$A0
  304  06:C1F3  20 8C C1    JSR SetPointerYPosition
  305                     
  306  06:C1F6            .leave:
  307                       
  308  06:C1F6  60          RTS
  309                       
  310  06:C1F7            UpdatePuzzlePointer:
  311                     
  312                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  313  06:C1F7  AD 16 00    LDA gamepadPressed
  314  06:C1FA  F0 65       BEQ .leave 
  315                       
  316  06:C1FC  A9 00       LDA #$00
  317  06:C1FE  8D 00 00    STA temp1
  318  06:C201  8D 01 00    STA temp2
  319                       
  320  06:C204            .parseInputs:
  321  06:C204  AD 16 00    LDA gamepadPressed
  322  06:C207  29 F0       AND #GAMEPAD_MOVE
  323  06:C209  F0 56       BEQ .leave
  324  06:C20B  0A          ASL A
  325  06:C20C  90 03       BCC .checkLeft
  326  06:C20E  EE 00 00    INC temp1
  327  06:C211            .checkLeft:
  328  06:C211  0A          ASL A
  329  06:C212  90 03       BCC .checkDown
  330  06:C214  CE 00 00    DEC temp1
  331  06:C217            .checkDown:
  332  06:C217  0A          ASL A
  333  06:C218  90 03       BCC .checkUp
  334  06:C21A  EE 01 00    INC temp2
  335  06:C21D            .checkUp:
  336  06:C21D  0A          ASL A
  337  06:C21E  90 03       BCC .move
  338  06:C220  CE 01 00    DEC temp2
  339                       
  340  06:C223            .move:
  341                     
  342  06:C223  AD B7 00    LDA mouse_index
  343  06:C226  18          CLC
  344  06:C227  6D 01 00    ADC temp2
  345  06:C22A  C9 02       CMP #$02
  346  06:C22C  F0 04       BEQ .skipYMod
  347  06:C22E  90 02       BCC .skipYMod
  348  06:C230  A9 00       LDA #$00
  349  06:C232            .skipYMod:
  350  06:C232  8D B7 00    STA mouse_index
  351                       ;; mult mouse_index by 16
  352  06:C235  0A          ASL A
  353  06:C236  0A          ASL A
  354  06:C237  0A          ASL A
  355  06:C238  0A          ASL A
  356  06:C239  18          CLC
  357  06:C23A  69 AE       ADC #$AE
  358  06:C23C  20 8C C1    JSR SetPointerYPosition
  359                       
  360  06:C23F  AD B8 00    LDA mouse_index+1
  361  06:C242  18          CLC
  362  06:C243  6D 00 00    ADC temp1
  363  06:C246  C9 08       CMP #$08
  364  06:C248  F0 04       BEQ .skipXMod
  365  06:C24A  90 02       BCC .skipXMod
  366  06:C24C  A9 00       LDA #$00
  367  06:C24E            .skipXMod:
  368  06:C24E  8D B8 00    STA mouse_index+1
  369                       ;; we need to move 3 tiles each- so index * 3 * 8,
  370  06:C251  18          CLC
  371  06:C252  6D B8 00    ADC mouse_index+1
  372  06:C255  6D B8 00    ADC mouse_index+1
  373  06:C258  0A          ASL A
  374  06:C259  0A          ASL A
  375  06:C25A  0A          ASL A
  376  06:C25B  18          CLC
  377  06:C25C  69 10       ADC #$10
  378  06:C25E  20 97 C1    JSR SetPointerXPosition
  379                       
  380  06:C261            .leave:
  381                       
  382  06:C261  60          RTS
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   79                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6           20A8      BANK_LEVEL = $20A8
    7           20E5      TIMER_LOC = $20E5
    8                     
    9                     ;;this will change with puzzle sizes
   10           005A      VERT_MIN = $5A ;12 - 1
   11           00DA      VERT_MAX = $DA
   12           006A      HORI_MIN = $6A ;14 - 1
   13           00EA      HORI_MAX = $EA
   14                     
   15           618E      MOUSE_START = $618E
   16                     
   17           0010      HOLD_TIME = $10
   18           0004      HOLD_FREQ = $04
   19                     
   20  06:C262            UpdateGame:
   21                     
   22  06:C262  AD 0C 00    LDA NMI_locks
   23  06:C265  F0 01       BEQ .unlocked
   24                       
   25  06:C267  60          RTS
   26                       
   27  06:C268            .unlocked:
   28                     
   29  06:C268  20 6C C2    JSR DoUpdateGame
   30  06:C26B  60          RTS
   31                       
   32  06:C26C            DoUpdateGame:
   33                     
   34  06:C26C  AD 0B 00    LDA mode_state
   35  06:C26F  20 56 C8    JSR Dynamic_Jump
   36                       
   37  06:C272            UpdateGameJumpTable:
   38                     
   39  06:C272  86 C2       .word UpdateGameInit
   40  06:C274  26 C3       .word UpdateDrawVertClues
   41  06:C276  4E C3       .word UpdateDrawHoriClues
   42  06:C278  91 C3       .word UpdateGamePlay
   43  06:C27A  00 C5       .word UpdateClearPuzzle
   44  06:C27C  13 C5       .word UpdateMoveScreen
   45  06:C27E  79 C5       .word UpdateDrawImage
   46  06:C280  08 C6       .word UpdateWaitInput
   47  06:C282  16 C6       .word UpdateGameFadeOut
   48  06:C284  2B C6       .word UpdateGameExit
   49                     
   50  06:C286            UpdateGameInit:
   51                     
   52                       ;; get the puzzle table in the puzzle address
   53                       MACROGetLabelPointer $A000, table_address
                          
       06:C286  A9 A0             LDA #HIGH($A000)
       06:C288  A2 00             LDX #LOW($A000)
                                  
       06:C28A  8E 10 00          STX table_address
       06:C28D  8D 11 00          STA table_address+1
                                  
   54                       MACROGetDoubleIndex puzzle_index
                          
       06:C290  AD 01 70          LDA puzzle_index
       06:C293  0A                ASL A
       06:C294  A8                TAY
                                  
   55  06:C295  20 7C C8    JSR GetTableAtIndex
   56                       MACROGetPointer table_address, puzzle_address
                          
       06:C298  AD 10 00          LDA table_address
       06:C29B  8D A5 00          STA puzzle_address
       06:C29E  AD 11 00          LDA table_address+1
       06:C2A1  8D A6 00          STA puzzle_address+1
                          
   57                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C2A4  A9 61             LDA #HIGH(MOUSE_START)
       06:C2A6  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C2A8  8E B5 00          STX mouse_location
       06:C2AB  8D B6 00          STA mouse_location+1
                                  
   58                       
   59                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   60  06:C2AE  AD A5 00    LDA puzzle_address
   61  06:C2B1  18          CLC
   62  06:C2B2  69 22       ADC #34
   63  06:C2B4  8D A7 00    STA clues_address
   64  06:C2B7  A9 00       LDA #$00
   65  06:C2B9  6D A6 00    ADC puzzle_address+1
   66  06:C2BC  8D A8 00    STA clues_address+1
   67                     
   68  06:C2BF  A9 00       LDA #$00
   69  06:C2C1  8D AD 00    STA clueTableIndex
   70  06:C2C4  8D AE 00    STA clueLineIndex
   71  06:C2C7  8D B4 00    STA clueParity
   72  06:C2CA  8D AF 00    STA clueOffsetShift
   73  06:C2CD  8D B7 00    STA mouse_index
   74  06:C2D0  8D B8 00    STA mouse_index+1
   75  06:C2D3  8D BA 00    STA solutionCount
   76  06:C2D6  8D BB 00    STA nonSolutionCount
   77  06:C2D9  8D BD 00    STA GameTime
   78  06:C2DC  8D BE 00    STA GameTime+1
   79  06:C2DF  8D BF 00    STA GameTime+2
   80  06:C2E2  8D C0 00    STA GameTime+3
   81                             
   82  06:C2E5  A9 20       LDA #$20
   83  06:C2E7  8D B2 00    STA clueDrawAdd
   84                        
   85                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C2EA  A9 21             LDA #HIGH(VERT_CLUES)
       06:C2EC  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C2EE  8E A9 00          STX clue_start_address
       06:C2F1  8D AA 00          STA clue_start_address+1
                                  
   86  06:C2F4  20 5E CB    JSR ResetClueDrawAddress
   87                       
   88                       MACROAddPPUStringEntryRawData #HIGH(BANK_LEVEL), #LOW(BANK_LEVEL), #DRAW_HORIZONTAL, #$03
                          
       06:C2F7  A9 01       LDA #$01
       06:C2F9  8D 1D 00    STA PPU_PendingWrite
       06:C2FC  A9 20       LDA #HIGH(BANK_LEVEL)
       06:C2FE  20 A8 C9    JSR WriteToPPUString
       06:C301  A9 A8       LDA #LOW(BANK_LEVEL)
       06:C303  20 A8 C9    JSR WriteToPPUString
       06:C306  A9 00       LDA #DRAW_HORIZONTAL
       06:C308  20 A8 C9    JSR WriteToPPUString
       06:C30B  A9 03       LDA #$03 
       06:C30D  20 A8 C9    JSR WriteToPPUString
                            
   89  06:C310  AD 00 70    LDA bank_index
   90  06:C313  20 A8 C9    JSR WriteToPPUString
   91  06:C316  A9 60       LDA #$60
   92  06:C318  20 A8 C9    JSR WriteToPPUString
   93  06:C31B  AE 01 70    LDX puzzle_index
   94  06:C31E  E8          INX
   95  06:C31F  8A          TXA 
   96  06:C320  20 A8 C9    JSR WriteToPPUString
   97                       
   98  06:C323  EE 0B 00    INC mode_state
   99                     
  100  06:C326            UpdateDrawVertClues:
  101                       
  102  06:C326  20 E6 CA    JSR PopulateClues
  103  06:C329  90 22       BCC .leave
  104                       
  105  06:C32B            .changeModeState:
  106                     
  107  06:C32B  A9 00       LDA #$00
  108  06:C32D  8D AE 00    STA clueLineIndex
  109  06:C330  8D B4 00    STA clueParity
  110                       
  111  06:C333  A9 05       LDA #$05
  112  06:C335  8D AF 00    STA clueOffsetShift
  113                       
  114  06:C338  A9 01       LDA #$01
  115  06:C33A  8D B2 00    STA clueDrawAdd
  116                        
  117                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C33D  A9 21             LDA #HIGH(HORI_CLUES)
       06:C33F  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C341  8E A9 00          STX clue_start_address
       06:C344  8D AA 00          STA clue_start_address+1
                                  
  118  06:C347  20 5E CB    JSR ResetClueDrawAddress
  119                     
  120  06:C34A  EE 0B 00    INC mode_state
  121  06:C34D            .leave:
  122  06:C34D  60          RTS
  123                       
  124  06:C34E            UpdateDrawHoriClues:
  125                     
  126  06:C34E  20 E6 CA    JSR PopulateClues
  127  06:C351  90 3D       BCC .leave
  128                     
  129  06:C353            .changeModeState:
  130  06:C353  20 F0 C9    JSR TurnOnSprites
  131                       
  132                       ;;set the timer to 00
  133                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C356  A9 01       LDA #$01
       06:C358  8D 1D 00    STA PPU_PendingWrite
       06:C35B  A9 20       LDA #HIGH(TIMER_LOC)
       06:C35D  20 A8 C9    JSR WriteToPPUString
       06:C360  A9 E5       LDA #LOW(TIMER_LOC)
       06:C362  20 A8 C9    JSR WriteToPPUString
       06:C365  A9 00       LDA #DRAW_HORIZONTAL
       06:C367  20 A8 C9    JSR WriteToPPUString
       06:C36A  A9 05       LDA #$05 
       06:C36C  20 A8 C9    JSR WriteToPPUString
                            
  134  06:C36F  A9 00       LDA #$00
  135  06:C371  20 A8 C9    JSR WriteToPPUString
  136  06:C374  A9 00       LDA #$00
  137  06:C376  20 A8 C9    JSR WriteToPPUString
  138  06:C379  A9 61       LDA #$61
  139  06:C37B  20 A8 C9    JSR WriteToPPUString
  140  06:C37E  A9 00       LDA #$00
  141  06:C380  20 A8 C9    JSR WriteToPPUString
  142  06:C383  A9 00       LDA #$00
  143  06:C385  20 A8 C9    JSR WriteToPPUString
  144                       
  145                       ;;reset time
  146  06:C388  A9 00       LDA #$00
  147  06:C38A  8D 08 00    STA time
  148                       
  149  06:C38D  EE 0B 00    INC mode_state
  150  06:C390            .leave:
  151  06:C390  60          RTS
  152                       
  153  06:C391            UpdateGamePlay:
  154                         
  155  06:C391  20 D8 C6    JSR UpdateTimeDisplay
  156                             
  157  06:C394  A9 00       LDA #$00
  158  06:C396  8D 00 00    STA temp1
  159  06:C399  8D 01 00    STA temp2
  160  06:C39C  8D 02 00    STA temp3
  161                       
  162  06:C39F            .checkPressed:  
  163                     
  164  06:C39F  AD 16 00    LDA gamepadPressed
  165  06:C3A2  29 F0       AND #GAMEPAD_MOVE
  166  06:C3A4  F0 0B       BEQ .checkHeld
  167                       
  168  06:C3A6  A9 10       LDA #HOLD_TIME
  169  06:C3A8  8D BC 00    STA holdTimer 
  170  06:C3AB  AD 16 00    LDA gamepadPressed
  171  06:C3AE  4C C5 C3    JMP .parseInputs
  172                       
  173  06:C3B1            .checkHeld:
  174                       
  175  06:C3B1  AD 14 00    LDA gamepad
  176  06:C3B4  29 F0       AND #GAMEPAD_MOVE
  177  06:C3B6  F0 2F       BEQ .checkPaintPress
  178                       
  179                       ;;decrement the hold timer
  180  06:C3B8  CE BC 00    DEC holdTimer
  181  06:C3BB  D0 2A       BNE .checkPaintPress
  182  06:C3BD  A9 04       LDA #HOLD_FREQ
  183  06:C3BF  8D BC 00    STA holdTimer
  184  06:C3C2  AD 14 00    LDA gamepad
  185                     
  186  06:C3C5            .parseInputs:
  187                     
  188  06:C3C5  29 F0       AND #GAMEPAD_MOVE
  189  06:C3C7  F0 1E       BEQ .checkPaintPress
  190  06:C3C9  0A          ASL A
  191  06:C3CA  90 03       BCC .checkLeft
  192  06:C3CC  EE 00 00    INC temp1
  193  06:C3CF            .checkLeft:
  194  06:C3CF  0A          ASL A
  195  06:C3D0  90 03       BCC .checkDown
  196  06:C3D2  CE 00 00    DEC temp1
  197  06:C3D5            .checkDown:
  198  06:C3D5  0A          ASL A
  199  06:C3D6  90 03       BCC .checkUp
  200  06:C3D8  EE 01 00    INC temp2
  201  06:C3DB            .checkUp:
  202  06:C3DB  0A          ASL A
  203  06:C3DC  90 03       BCC .move
  204  06:C3DE  CE 01 00    DEC temp2
  205                       
  206  06:C3E1            .move:
  207                      
  208  06:C3E1  20 43 C6    JSR MoveMouse
  209  06:C3E4  20 84 C6    JSR UpdateMouseScreenPos
  210                       
  211  06:C3E7            .checkPaintPress:
  212                     
  213  06:C3E7  AD 16 00    LDA gamepadPressed
  214  06:C3EA  29 03       AND #GAMEPAD_AB
  215  06:C3EC  F0 41       BEQ .updatePaint
  216                       ;;A or B pressed, get current tile
  217                       
  218  06:C3EE  8D 00 00    STA temp1
  219                       
  220  06:C3F1  A0 00       LDY #$00
  221  06:C3F3  B1 B5       LDA [mouse_location], y
  222  06:C3F5  8D 01 00    STA temp2
  223                       
  224                         ;;A treats X and Clear as clear
  225                             ;;B treats mark and clear as clear
  226                             ;;clear->mark->x
  227                             
  228                     
  229  06:C3F8  C9 7C       CMP #$7C      ;check if this is a marked tile
  230  06:C3FA  B0 0F       BCS .getClearTile
  231                       ;;cleared tile- store off marked tile to paint with instead
  232                       ;;not a clear tile- a mark or an x - check A or B  
  233  06:C3FC  4E 00 00    LSR temp1
  234  06:C3FF  B0 05       BCS .getMarkTile
  235                       
  236  06:C401            .getXTile:
  237  06:C401  A9 80       LDA #$80
  238  06:C403  4C 29 C4    JMP .finishGetTile
  239                       
  240  06:C406            .getMarkTile:
  241  06:C406  A9 70       LDA #$70
  242  06:C408  4C 29 C4    JMP .finishGetTile
  243                     
  244  06:C40B            .getClearTile:
  245                       
  246  06:C40B  4E 00 00    LSR temp1
  247  06:C40E  90 0A       BCC .checkB
  248  06:C410  AD 01 00    LDA temp2
  249  06:C413  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  250  06:C415  90 0D       BCC .clearTile
  251  06:C417  4C 06 C4    JMP .getMarkTile
  252                       
  253  06:C41A            .checkB:
  254                       
  255  06:C41A  AD 01 00   LDA temp2
  256  06:C41D  C9 8C      CMP #$8C
  257  06:C41F  B0 03      BCS .clearTile
  258  06:C421  4C 01 C4   JMP .getXTile
  259                       
  260  06:C424            .clearTile:
  261  06:C424  A9 60       LDA #$60
  262  06:C426  4C 29 C4    JMP .finishGetTile
  263                       
  264  06:C429            .finishGetTile:
  265  06:C429  8D B9 00    STA currentPaintTile
  266  06:C42C  4C 37 C4    JMP .setTile
  267                     
  268                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  269                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  270                     ;;we can load the nametable into memory as we draw it
  271                     
  272  06:C42F            .updatePaint:
  273                     
  274  06:C42F  AD 14 00    LDA gamepad
  275  06:C432  29 03       AND #GAMEPAD_AB
  276  06:C434  D0 01       BNE .setTile
  277  06:C436  60          RTS  
  278                       
  279  06:C437            .setTile:
  280                     
  281                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  282  06:C437  AD B8 00    LDA mouse_index+1
  283  06:C43A  0A          ASL A
  284  06:C43B  18          CLC
  285  06:C43C  69 04       ADC #$04 ;; add to get past header
  286  06:C43E  8D 00 00    STA temp1
  287                       
  288                       ;;div X position by 8 to get the byte index
  289  06:C441  AD B7 00    LDA mouse_index
  290  06:C444  4A          LSR A
  291  06:C445  4A          LSR A
  292  06:C446  4A          LSR A
  293  06:C447  F0 03       BEQ .getMask
  294                       
  295  06:C449  EE 00 00    INC temp1
  296                       
  297  06:C44C            .getMask:
  298                       
  299  06:C44C  AD B7 00    LDA mouse_index
  300  06:C44F  29 07       AND #$07
  301  06:C451  AA          TAX
  302  06:C452  A9 80       LDA #$80
  303  06:C454  E0 00       CPX #$00
  304  06:C456  F0 04       BEQ .storeMask
  305                     
  306  06:C458            .maskLoop:
  307  06:C458  4A          LSR A
  308  06:C459  CA          DEX
  309  06:C45A  D0 FC       BNE .maskLoop
  310  06:C45C            .storeMask:
  311  06:C45C  8D 01 00    STA temp2
  312                     
  313  06:C45F  AC 00 00    LDY temp1
  314  06:C462  B1 A5       LDA [puzzle_address], y
  315  06:C464  2D 01 00    AND temp2
  316  06:C467  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  317                     
  318  06:C46A  A0 00       LDY #$00
  319  06:C46C  B1 B5       LDA [mouse_location], y
  320  06:C46E  8D 02 00    STA temp3
  321  06:C471  29 F0       AND #$F0
  322  06:C473  CD B9 00    CMP currentPaintTile
  323  06:C476  D0 01       BNE .diffTiles
  324  06:C478  60          RTS
  325                       
  326  06:C479            .diffTiles:
  327                       ;;tiles are different- check if the current tile is marked as a solution tile
  328  06:C479  C9 70       CMP #$70
  329  06:C47B  D0 0B       BNE .checkNewMark
  330                       ;;if erasing a mark, check if the tile was part of the solution
  331  06:C47D  AD 00 00    LDA temp1
  332  06:C480  D0 18       BNE .antiMark
  333  06:C482  CE BB 00    DEC nonSolutionCount
  334  06:C485  4C A3 C4    JMP .overwriteTile
  335                       
  336  06:C488            .checkNewMark:
  337                     
  338  06:C488  AD B9 00    LDA currentPaintTile
  339  06:C48B  C9 70       CMP #$70
  340  06:C48D  D0 14       BNE .overwriteTile
  341                       
  342  06:C48F  AD 00 00    LDA temp1
  343  06:C492  D0 0C       BNE .proMark
  344  06:C494  EE BB 00    INC nonSolutionCount 
  345  06:C497  4C A3 C4    JMP .overwriteTile  
  346                       
  347  06:C49A            .antiMark:
  348  06:C49A  CE BA 00    DEC solutionCount
  349  06:C49D  4C A3 C4    JMP .overwriteTile
  350  06:C4A0            .proMark:   
  351                       
  352  06:C4A0  EE BA 00    INC solutionCount
  353                       
  354  06:C4A3            .overwriteTile:
  355                       ;;overwrite tile
  356  06:C4A3  AD 02 00    LDA temp3
  357  06:C4A6  29 0F       AND #$0F
  358  06:C4A8  0D B9 00    ORA currentPaintTile
  359  06:C4AB  A0 00       LDY #$00
  360  06:C4AD  91 B5       STA [mouse_location], y
  361  06:C4AF  8D 00 00    STA temp1
  362                       
  363  06:C4B2  AD B6 00    LDA mouse_location+1
  364  06:C4B5  29 3F       AND #$3F
  365  06:C4B7  8D 01 00    STA temp2
  366                         
  367                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C4BA  A9 01       LDA #$01
       06:C4BC  8D 1D 00    STA PPU_PendingWrite
       06:C4BF  AD 01 00    LDA temp2
       06:C4C2  20 A8 C9    JSR WriteToPPUString
       06:C4C5  AD B5 00    LDA mouse_location
       06:C4C8  20 A8 C9    JSR WriteToPPUString
       06:C4CB  A9 00       LDA #DRAW_HORIZONTAL
       06:C4CD  20 A8 C9    JSR WriteToPPUString
       06:C4D0  A9 01       LDA #$01 
       06:C4D2  20 A8 C9    JSR WriteToPPUString
                            
  368  06:C4D5  AD 00 00    LDA temp1
  369  06:C4D8  20 A8 C9    JSR WriteToPPUString
  370                       
  371  06:C4DB            .checkSolution: 
  372                     
  373  06:C4DB  A0 01       LDY #$01
  374  06:C4DD  B1 A5       LDA [puzzle_address], y
  375  06:C4DF  CD BA 00    CMP solutionCount
  376  06:C4E2  D0 1B       BNE .leave
  377  06:C4E4  AD BB 00    LDA nonSolutionCount
  378  06:C4E7  F0 03       BEQ .changeModeState
  379                       
  380  06:C4E9  4C FF C4    JMP .leave
  381                       
  382                       ;;update the painting
  383  06:C4EC            .changeModeState:
  384                      
  385  06:C4EC  20 F9 C9    JSR TurnOffSprites
  386                        
  387  06:C4EF  A9 00       LDA #$00
  388  06:C4F1  8D AB 00    STA clue_draw_address
  389  06:C4F4  8D AE 00    STA clueLineIndex
  390  06:C4F7  A9 20       LDA #$20
  391  06:C4F9  8D AC 00    STA clue_draw_address+1
  392                       
  393  06:C4FC  EE 0B 00    INC mode_state
  394                     
  395  06:C4FF            .leave:
  396                      
  397  06:C4FF  60          RTS
  398                       
  399  06:C500            UpdateClearPuzzle:
  400                     
  401  06:C500  20 D2 CB    JSR ClearPuzzle
  402  06:C503  AD AE 00    LDA clueLineIndex
  403  06:C506  C9 1E       CMP #30
  404  06:C508  D0 08       BNE .leave
  405                       
  406  06:C50A            .changeModeState:
  407                     
  408  06:C50A  A9 00       LDA #$00
  409  06:C50C  8D AE 00    STA clueLineIndex ;using this as a scroller
  410  06:C50F  EE 0B 00    INC mode_state
  411                     
  412  06:C512            .leave:
  413                      
  414  06:C512  60          RTS
  415  06:C513            UpdateMoveScreen:
  416                       
  417                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  418                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  419                       
  420  06:C513  AD AE 00    LDA clueLineIndex
  421  06:C516  29 10       AND #$10
  422  06:C518  D0 1D       BNE .scrollY
  423                       
  424                       ;;scroll X over
  425  06:C51A  AD AE 00    LDA clueLineIndex
  426  06:C51D  29 0F       AND #$0F
  427  06:C51F  0A          ASL A
  428  06:C520  0A          ASL A
  429  06:C521  0A          ASL A ;mult by 8
  430  06:C522  8D 19 00    STA PPU_ScrollX
  431                       
  432  06:C525  EE AE 00    INC clueLineIndex
  433  06:C528  AD AE 00    LDA clueLineIndex
  434  06:C52B  C9 06       CMP #$06
  435  06:C52D  D0 49       BNE .leave
  436  06:C52F  A9 10       LDA #$10
  437  06:C531  8D AE 00    STA clueLineIndex
  438  06:C534  4C 78 C5    JMP .leave
  439                       
  440  06:C537            .scrollY:
  441                     
  442  06:C537  AD AE 00    LDA clueLineIndex
  443  06:C53A  29 0F       AND #$0F
  444  06:C53C  0A          ASL A
  445  06:C53D  0A          ASL A
  446  06:C53E  0A          ASL A ;mult by 8
  447  06:C53F  8D 1A 00    STA PPU_ScrollY
  448                     
  449  06:C542  EE AE 00    INC clueLineIndex
  450  06:C545  AD AE 00    LDA clueLineIndex
  451  06:C548  29 0F       AND #$0F
  452  06:C54A  C9 05       CMP #$05
  453  06:C54C  D0 2A       BNE .leave
  454                       
  455  06:C54E            .changeModeState:
  456                     
  457  06:C54E  A9 8E       LDA #$8E
  458  06:C550  8D AB 00    STA clue_draw_address
  459  06:C553  A9 21       LDA #$21
  460  06:C555  8D AC 00    STA clue_draw_address+1
  461                       
  462  06:C558  AD A7 00    LDA clues_address
  463  06:C55B  18          CLC
  464  06:C55C  6D AD 00    ADC clueTableIndex
  465  06:C55F  8D A7 00    STA clues_address
  466  06:C562  AD A8 00    LDA clues_address+1
  467  06:C565  69 00       ADC #$00
  468  06:C567  8D A8 00    STA clues_address+1
  469                       
  470  06:C56A  A9 00       LDA #$00
  471  06:C56C  8D AD 00    STA clueTableIndex
  472  06:C56F  8D AE 00    STA clueLineIndex
  473  06:C572  8D AF 00    STA clueOffsetShift
  474                     
  475  06:C575  EE 0B 00    INC mode_state
  476                     
  477  06:C578            .leave:
  478                      
  479  06:C578  60          RTS
  480  06:C579            UpdateDrawImage:
  481                     
  482                       ;run it twice for a faster draw
  483  06:C579  20 1E CC    JSR DrawImage
  484  06:C57C  AD AD 00    LDA clueTableIndex
  485  06:C57F  C9 39       CMP #57
  486  06:C581  F0 0A       BEQ .changeModeState
  487                       
  488  06:C583  20 1E CC    JSR DrawImage
  489  06:C586  AD AD 00    LDA clueTableIndex
  490  06:C589  C9 39       CMP #57
  491  06:C58B  D0 7A       BNE .leave
  492                       
  493  06:C58D            .changeModeState:
  494                     
  495                       ;;do a palette draw
  496                       ;;puzzle address + 03 has the desired palette offset
  497                     
  498  06:C58D  A0 03       LDY #$03
  499  06:C58F  B1 A5       LDA [puzzle_address],y
  500  06:C591  29 0F       AND #$0F
  501  06:C593  AA          TAX
  502                       
  503  06:C594  B1 A5       LDA [puzzle_address],y
  504  06:C596  29 10       AND #$10
  505  06:C598  F0 15       BEQ .storeBottomVals
  506                       
  507  06:C59A  8A          TXA
  508  06:C59B  09 10       ORA #$10
  509  06:C59D  8D 01 00    STA temp2
  510  06:C5A0  8A          TXA
  511  06:C5A1  09 20       ORA #$20
  512  06:C5A3  8D 02 00    STA temp3
  513  06:C5A6  8A          TXA
  514  06:C5A7  09 30       ORA #$30
  515  06:C5A9  8D 03 00    STA temp4
  516                     
  517  06:C5AC  4C C1 C5    JMP .checkKeepWhite
  518                       
  519  06:C5AF            .storeBottomVals:
  520                     
  521  06:C5AF  8A          TXA
  522  06:C5B0  09 00       ORA #$00
  523  06:C5B2  8D 01 00    STA temp2
  524  06:C5B5  8A          TXA
  525  06:C5B6  09 10       ORA #$10
  526  06:C5B8  8D 02 00    STA temp3
  527  06:C5BB  8A          TXA
  528  06:C5BC  09 20       ORA #$20
  529  06:C5BE  8D 03 00    STA temp4
  530                       
  531  06:C5C1            .checkKeepWhite:
  532                       
  533  06:C5C1  B1 A5       LDA [puzzle_address],y
  534  06:C5C3  29 20       AND #$20
  535  06:C5C5  F0 05       BEQ .loadPalToPPUStr
  536                       
  537  06:C5C7  A9 30       LDA #$30
  538  06:C5C9  8D 03 00    STA temp4
  539                       
  540                       
  541  06:C5CC            .loadPalToPPUStr:
  542                       
  543                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C5CC  A9 01       LDA #$01
       06:C5CE  8D 1D 00    STA PPU_PendingWrite
       06:C5D1  A9 3F       LDA #$3F
       06:C5D3  20 A8 C9    JSR WriteToPPUString
       06:C5D6  A9 01       LDA #$01
       06:C5D8  20 A8 C9    JSR WriteToPPUString
       06:C5DB  A9 00       LDA #DRAW_HORIZONTAL
       06:C5DD  20 A8 C9    JSR WriteToPPUString
       06:C5E0  A9 03       LDA #03 
       06:C5E2  20 A8 C9    JSR WriteToPPUString
                            
  544  06:C5E5  AD 01 00    LDA temp2
  545  06:C5E8  20 A8 C9    JSR WriteToPPUString
  546  06:C5EB  AD 02 00    LDA temp3
  547  06:C5EE  20 A8 C9    JSR WriteToPPUString
  548  06:C5F1  AD 03 00    LDA temp4
  549  06:C5F4  20 A8 C9    JSR WriteToPPUString
  550                       
  551  06:C5F7  A2 01       LDX #$01
  552  06:C5F9            .copyLoop:
  553                       ;;also store in the copy 
  554  06:C5F9  BD 00 00    LDA temp1, x
  555  06:C5FC  9D 00 68    STA Palette_Copy, x
  556  06:C5FF  E8          INX
  557  06:C600  E0 04       CPX #$04
  558  06:C602  D0 F5       BNE .copyLoop
  559                       
  560                       
  561  06:C604  EE 0B 00    INC mode_state
  562                     
  563  06:C607            .leave:
  564                      
  565  06:C607  60          RTS
  566                       
  567  06:C608            UpdateWaitInput:
  568                     
  569  06:C608  AD 16 00    LDA gamepadPressed
  570  06:C60B  F0 08       BEQ .leave
  571                       
  572  06:C60D            .changeModeState:
  573  06:C60D  A9 00       LDA #$00
  574  06:C60F  8D 08 00    STA time
  575  06:C612  EE 0B 00    INC mode_state
  576                     
  577  06:C615            .leave:
  578                      
  579  06:C615  60          RTS
  580                       
  581  06:C616            UpdateGameFadeOut:
  582                     
  583  06:C616  AD 08 00    LDA time
  584  06:C619  29 07       AND #$07
  585  06:C61B  D0 0D       BNE .leave
  586                       ;;every 8 frames, decrement the palettes
  587  06:C61D  20 25 CA    JSR FadeOutPalettes
  588  06:C620  B0 08       BCS .leave
  589                     
  590  06:C622            .changeModeState:
  591  06:C622  A9 00       LDA #$00
  592  06:C624  8D 08 00    STA time
  593  06:C627  EE 0B 00    INC mode_state
  594  06:C62A            .leave:
  595  06:C62A  60          RTS  
  596                     
  597  06:C62B            UpdateGameExit:
  598                     
  599  06:C62B  AD 08 00    LDA time
  600  06:C62E  29 0F       AND #$0F
  601  06:C630  D0 10       BNE .leave
  602                     
  603  06:C632  A9 00       LDA #$00
  604  06:C634  8D 19 00    STA PPU_ScrollX
  605  06:C637  8D 1A 00    STA PPU_ScrollY
  606  06:C63A  8D 1B 00    STA PPU_ScrollNT
  607                       
  608  06:C63D  A9 02       LDA #GAMEOVER_IDX
  609  06:C63F  20 A6 C7    JSR ChangeGameMode
  610  06:C642            .leave:
  611  06:C642  60          RTS
  612                       
  613  06:C643            MoveMouse:
  614                     
  615  06:C643  AD 00 00    LDA temp1
  616  06:C646  0E 00 00    ASL temp1
  617  06:C649  0E 00 00    ASL temp1
  618  06:C64C  0E 00 00    ASL temp1
  619                       
  620  06:C64F  AD 01 00    LDA temp2
  621  06:C652  0E 01 00    ASL temp2 
  622  06:C655  0E 01 00    ASL temp2
  623  06:C658  0E 01 00    ASL temp2
  624                       
  625  06:C65B  A2 03       LDX #SPRITE_XPOS
  626  06:C65D  BD 00 02    LDA SPRITE_DATA, x
  627  06:C660  18          CLC
  628  06:C661  6D 00 00    ADC temp1
  629                       ;;check against borders
  630  06:C664  C9 6A       CMP #HORI_MIN
  631  06:C666  F0 07       BEQ .moveVert
  632  06:C668  C9 EA       CMP #HORI_MAX
  633  06:C66A  F0 03       BEQ .moveVert
  634  06:C66C  9D 00 02    STA SPRITE_DATA, x
  635                     
  636  06:C66F            .moveVert:
  637                     
  638  06:C66F  A2 00       LDX #SPRITE_YPOS
  639  06:C671  BD 00 02    LDA SPRITE_DATA, x
  640  06:C674  18          CLC
  641  06:C675  6D 01 00    ADC temp2
  642                       ;;check against borders
  643  06:C678  C9 5A       CMP #VERT_MIN
  644  06:C67A  F0 07       BEQ .leave
  645  06:C67C  C9 DA       CMP #VERT_MAX
  646  06:C67E  F0 03       BEQ .leave
  647  06:C680  9D 00 02    STA SPRITE_DATA, x
  648                     
  649  06:C683            .leave:
  650  06:C683  60          RTS
  651                             
  652  06:C684            UpdateMouseScreenPos:
  653                     
  654  06:C684  A2 00       LDX #$00
  655  06:C686  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  656  06:C689  4A          LSR A                                         ;0yyy yy..
  657  06:C68A  4A          LSR A                                         ;00yy yyy.
  658  06:C68B  4A          LSR A                                         ;000y yyyy
  659  06:C68C  8D 00 00    STA temp1
  660  06:C68F  8D B8 00    STA mouse_index+1
  661  06:C692  E8          INX
  662  06:C693  E8          INX
  663  06:C694  E8          INX   
  664  06:C695  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  665  06:C698  29 F8       AND #$F8                       ;              ;  xxxx x000
  666  06:C69A  8D 01 00    STA temp2                      ;      ;  
  667  06:C69D  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  668  06:C6A0  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  669  06:C6A3  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  670  06:C6A6  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  671  06:C6A9  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  672  06:C6AC  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  673  06:C6AF  AD 01 00    LDA temp2
  674  06:C6B2  29 1F       AND #$1F
  675  06:C6B4  8D B7 00    STA mouse_index
  676                       
  677  06:C6B7  AD B7 00    LDA mouse_index
  678  06:C6BA  38          SEC 
  679  06:C6BB  E9 0E       SBC #$0E
  680  06:C6BD  8D B7 00    STA mouse_index
  681                       
  682  06:C6C0  AD B8 00    LDA mouse_index+1
  683  06:C6C3  38          SEC 
  684  06:C6C4  E9 0C       SBC #$0C
  685  06:C6C6  8D B8 00    STA mouse_index+1
  686                       
  687                       ;subtract starting offsets for mouse index
  688                       
  689  06:C6C9  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  690  06:C6CC  09 60       ORA #$60                       ;              ;  0110 00yy
  691                       
  692  06:C6CE  8D B6 00    STA mouse_location+1
  693  06:C6D1  AD 01 00    LDA temp2
  694  06:C6D4  8D B5 00    STA mouse_location
  695                       
  696  06:C6D7            .leave:
  697  06:C6D7  60          RTS
  698                       
  699  06:C6D8            UpdateTimeDisplay:
  700                     
  701  06:C6D8  AD 08 00    LDA time
  702  06:C6DB  C9 3C       CMP #60
  703  06:C6DD  D0 77       BNE .leave
  704                       
  705  06:C6DF  A9 00       LDA #$00
  706  06:C6E1  8D 08 00    STA time
  707                       
  708  06:C6E4  EE BD 00    INC GameTime
  709  06:C6E7  AD BD 00    LDA GameTime
  710  06:C6EA  C9 0A       CMP #10
  711  06:C6EC  D0 32       BNE .printTime
  712                       
  713  06:C6EE  A9 00       LDA #$00
  714  06:C6F0  8D BD 00    STA GameTime
  715  06:C6F3  EE BE 00    INC GameTime+1
  716  06:C6F6  AD BE 00    LDA GameTime+1
  717  06:C6F9  C9 06       CMP #6
  718  06:C6FB  D0 23       BNE .printTime
  719                       
  720  06:C6FD  A9 00       LDA #$00
  721  06:C6FF  8D BE 00    STA GameTime+1
  722  06:C702  EE BF 00    INC GameTime+2
  723  06:C705  AD BF 00    LDA GameTime+2
  724  06:C708  C9 0A       CMP #10
  725  06:C70A  D0 14       BNE .printTime
  726                       
  727  06:C70C  A9 00       LDA #$00
  728  06:C70E  8D BF 00    STA GameTime+2
  729  06:C711  EE C0 00    INC GameTime+3
  730  06:C714  AD C0 00    LDA GameTime+3
  731  06:C717  C9 0A       CMP #10
  732  06:C719  D0 05       BNE .printTime
  733                       
  734  06:C71B  A9 00       LDA #$00
  735  06:C71D  8D C0 00    STA GameTime+3
  736                       
  737  06:C720            .printTime:
  738                     
  739                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C720  A9 01       LDA #$01
       06:C722  8D 1D 00    STA PPU_PendingWrite
       06:C725  A9 20       LDA #HIGH(TIMER_LOC)
       06:C727  20 A8 C9    JSR WriteToPPUString
       06:C72A  A9 E5       LDA #LOW(TIMER_LOC)
       06:C72C  20 A8 C9    JSR WriteToPPUString
       06:C72F  A9 00       LDA #DRAW_HORIZONTAL
       06:C731  20 A8 C9    JSR WriteToPPUString
       06:C734  A9 05       LDA #$05 
       06:C736  20 A8 C9    JSR WriteToPPUString
                            
  740  06:C739  AD C0 00    LDA GameTime+3
  741  06:C73C  20 A8 C9    JSR WriteToPPUString
  742  06:C73F  AD BF 00    LDA GameTime+2
  743  06:C742  20 A8 C9    JSR WriteToPPUString
  744  06:C745  A9 61       LDA #$61
  745  06:C747  20 A8 C9    JSR WriteToPPUString
  746  06:C74A  AD BE 00    LDA GameTime+1
  747  06:C74D  20 A8 C9    JSR WriteToPPUString
  748  06:C750  AD BD 00    LDA GameTime
  749  06:C753  20 A8 C9    JSR WriteToPPUString
  750                       
  751                       
  752                       
  753  06:C756            .leave: 
  754  06:C756  60          RTS  
  755                     
  756                     ;;using the line index and a given count based on the direction, 
  757                       
  758                     ;;      JSR ResetMapper
  759                     ;;      INC currentCHRBank
  760                     ;;      LDA currentCHRBank
  761                     ;;      CMP #$03
  762                     ;;      BNE .dontModCHR
  763                             
  764                     ;;      LDA #$00
  765                     
  766                     ;;.dontModCHR:
  767                     ;;      STA currentCHRBank 
  768                     ;;      ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
  769                     ;;      ASL A
  770                     ;;      CLC 
  771                     ;;      ADC #$01
  772                     ;;      JSR LoadCHRBankB
  773                     ;;      
  774                     ;;      JSR ResetMapper
  775                     ;;      INC currentPRGBank
  776                     ;;      LDA currentPRGBank
  777                     ;;      CMP #$03
  778                     ;;      BNE .dontModPRG
  779                             
  780                     ;;      LDA #$00
  781                             
  782                     ;;.dontModPRG:
  783                     ;;       STA currentPRGBank
  784                     ;;       JSR LoadPRGBank
  785                      
  786                     ;;       JSR TestBankA
  787                     ;;       LDA mapperDebugVar
  788                     ;;       STA $6000
  789                     ;;       JMP .noInputDetected
  790                     
  791                     
  792                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   80                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C757            UpdateGameOver:
    2                     
    3  06:C757  AD 0C 00    LDA NMI_locks
    4  06:C75A  F0 01       BEQ .unlocked
    5                       
    6  06:C75C  60          RTS
    7                       
    8  06:C75D            .unlocked:
    9                     
   10  06:C75D  20 61 C7    JSR DoUpdateGameOver 
   11  06:C760  60          RTS
   12                       
   13  06:C761            DoUpdateGameOver:
   14                     
   15  06:C761  AD 0B 00    LDA mode_state
   16  06:C764  20 56 C8    JSR Dynamic_Jump
   17                         
   18  06:C767            UpdateGameOverJumpTable:
   19                     
   20  06:C767  6F C7       .word UpdateGameOverInit
   21  06:C769  76 C7       .word UpdateGameOverWaitInput
   22  06:C76B  84 C7       .word UpdateGameOverFadeOut
   23  06:C76D  99 C7       .word UpdateGameOverExit
   24                       
   25  06:C76F            UpdateGameOverInit:
   26                     
   27  06:C76F  20 F0 C9    JSR TurnOnSprites
   28  06:C772  EE 0B 00    INC mode_state
   29  06:C775  60          RTS
   30                     
   31  06:C776            UpdateGameOverWaitInput:
   32                     
   33  06:C776  AD 16 00    LDA gamepadPressed
   34  06:C779  F0 08       BEQ .leave
   35                     
   36  06:C77B            .changeModeState:
   37                     
   38  06:C77B  A9 00       LDA #$00
   39  06:C77D  8D 08 00    STA time
   40  06:C780  EE 0B 00    INC mode_state
   41  06:C783            .leave:
   42  06:C783  60          RTS
   43                     
   44  06:C784            UpdateGameOverFadeOut:
   45                     
   46  06:C784  AD 08 00    LDA time
   47  06:C787  29 07       AND #$07
   48  06:C789  D0 0D       BNE .leave
   49                       ;;every 8 frames, decrement the palettes
   50  06:C78B  20 25 CA    JSR FadeOutPalettes
   51  06:C78E  B0 08       BCS .leave
   52                     
   53  06:C790            .changeModeState:
   54  06:C790  A9 00       LDA #$00
   55  06:C792  8D 08 00    STA time
   56  06:C795  EE 0B 00    INC mode_state
   57  06:C798            .leave:
   58  06:C798  60          RTS
   59                     
   60  06:C799            UpdateGameOverExit:
   61                     
   62  06:C799  AD 08 00    LDA time
   63  06:C79C  29 0F       AND #$0F
   64  06:C79E  D0 05       BNE .leave
   65                     
   66  06:C7A0  A9 00       LDA #TITLE_IDX
   67  06:C7A2  20 A6 C7    JSR ChangeGameMode
   68                       
   69  06:C7A5            .leave:
   70  06:C7A5  60          RTS
#[1]   Picross.asm
   81                       
   82                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   83                     ;;     Routines             ;;
   84                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   85                     
   86                     
#[2]   Routines/Common/GameModeRoutines.asm
   87                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C7A6            ChangeGameMode:
    2  06:C7A6  8D 0A 00    STA game_mode
    3  06:C7A9  A9 00       LDA #$00
    4  06:C7AB  8D 0B 00    STA mode_state
    5  06:C7AE  20 BC C9    JSR ClearPPUString
    6  06:C7B1  20 B5 C7    JSR LoadGameModeScreen
    7  06:C7B4  60          RTS
    8                       
    9  06:C7B5            LoadGameModeScreen:
   10                     
   11                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C7B5  AD 0C 00    LDA NMI_locks
       06:C7B8  09 01       ORA #BGLOAD_NMI_LOCK
       06:C7BA  8D 0C 00    STA NMI_locks
                                  
   12                       
   13  06:C7BD  A9 00       LDA #$00
   14  06:C7BF  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   15                     
   16  06:C7C2  20 F0 C7    JSR LoadGameModeBackground
   17  06:C7C5  20 33 C8    JSR LoadGameModeSprites
   18                     
   19                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C7C8  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C7CA  49 FF       EOR #$FF
       06:C7CC  2D 0C 00    AND NMI_locks  
       06:C7CF  8D 0C 00    STA NMI_locks
                          
   20                     
   21                       
   22                       ;; load the CHR bank for this mode
   23  06:C7D2  20 8F CA    JSR ResetMapper
   24                       ;;remember, we're loading the SECOND set in each chr bank
   25                       ;;so we'll take the index from the game mode chr table and add one mult 2
   26  06:C7D5  AE 0A 00    LDX game_mode
   27  06:C7D8  BD 50 C8    LDA gameModeInitCHRROMB, x
   28  06:C7DB  0A          ASL A
   29  06:C7DC  18          CLC 
   30  06:C7DD  69 01       ADC #$01
   31  06:C7DF  20 B4 CA    JSR LoadCHRBankB
   32                       
   33  06:C7E2  20 8F CA    JSR ResetMapper
   34  06:C7E5  AE 0A 00    LDX game_mode
   35  06:C7E8  BD 53 C8    LDA gameModeInitCHRROMA, x
   36  06:C7EB  0A          ASL A
   37  06:C7EC  20 A9 CA    JSR LoadCHRBankA
   38                       
   39                       
   40                       
   41  06:C7EF  60          RTS
   42                       
   43  06:C7F0            LoadGameModeBackground:
   44                             
   45                       MACROGetDoubleIndex game_mode
                          
       06:C7F0  AD 0A 00          LDA game_mode
       06:C7F3  0A                ASL A
       06:C7F4  A8                TAY
                                  
   46  06:C7F5  8C 00 00    STY temp1
   47                             
   48                       MACROGetLabelPointer Palettes, table_address
                          
       06:C7F8  A9 E0             LDA #HIGH(Palettes)
       06:C7FA  A2 00             LDX #LOW(Palettes)
                                  
       06:C7FC  8E 10 00          STX table_address
       06:C7FF  8D 11 00          STA table_address+1
                                  
   49  06:C802  20 7C C8    JSR GetTableAtIndex
   50                     
   51  06:C805  20 89 C8    JSR LoadFullPaletteFromTable
   52                             
   53  06:C808  AC 00 00    LDY temp1
   54                       MACROGetLabelPointer NameTables, table_address
                          
       06:C80B  A9 E0             LDA #HIGH(NameTables)
       06:C80D  A2 06             LDX #LOW(NameTables)
                                  
       06:C80F  8E 10 00          STX table_address
       06:C812  8D 11 00          STA table_address+1
                                  
   55  06:C815  20 7C C8    JSR GetTableAtIndex
   56                             
   57  06:C818  A9 00       LDA #$00
   58  06:C81A  20 A9 C8    JSR LoadFullBackgroundFromTable
   59                       
   60  06:C81D  AC 00 00    LDY temp1
   61                       MACROGetLabelPointer NameTables2, table_address
                          
       06:C820  A9 E0             LDA #HIGH(NameTables2)
       06:C822  A2 0C             LDX #LOW(NameTables2)
                                  
       06:C824  8E 10 00          STX table_address
       06:C827  8D 11 00          STA table_address+1
                                  
   62  06:C82A  20 7C C8    JSR GetTableAtIndex
   63                       
   64  06:C82D  A9 01       LDA #$01
   65  06:C82F  20 A9 C8    JSR LoadFullBackgroundFromTable
   66                       
   67  06:C832  60          RTS
   68                       
   69  06:C833            LoadGameModeSprites:
   70                     
   71                       MACROGetDoubleIndex game_mode  
                          
       06:C833  AD 0A 00          LDA game_mode
       06:C836  0A                ASL A
       06:C837  A8                TAY
                                  
   72                       MACROGetLabelPointer Sprites, table_address
                          
       06:C838  A9 F4             LDA #HIGH(Sprites)
       06:C83A  A2 72             LDX #LOW(Sprites)
                                  
       06:C83C  8E 10 00          STX table_address
       06:C83F  8D 11 00          STA table_address+1
                                  
   73  06:C842  20 7C C8    JSR GetTableAtIndex
   74  06:C845  A0 00       LDY #$00
   75  06:C847  B1 10       LDA [table_address],y
   76  06:C849  EE 10 00    INC table_address
   77  06:C84C  20 91 C9    JSR LoadSprites_impl
   78                       
   79  06:C84F  60          RTS
   80                       
   81  06:C850            gameModeInitCHRROMB:
   82  06:C850  00 02 02          .db $00, $02, $02
   83  06:C853            gameModeInitCHRROMA:
   84  06:C853  00 02 02          .db $00, $02, $02
   85                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   88                       .include "Routines/Utils/PointerUtils.asm"
    1  06:C856            Dynamic_Jump:
    2                     
    3  06:C856  0A          ASL A                                 ;; double the index passed into A
    4  06:C857  8E 06 00    STX tempx
    5  06:C85A  8C 07 00    STY tempy
    6  06:C85D  A8          TAY
    7  06:C85E  C8          INY  
    8  06:C85F  68          PLA
    9  06:C860  8D 12 00    STA jump_address
   10  06:C863  68          PLA 
   11  06:C864  8D 13 00    STA jump_address+1            
   12  06:C867  B1 12       LDA [jump_address], y
   13  06:C869  AA          TAX
   14  06:C86A  C8          INY
   15  06:C86B  B1 12       LDA [jump_address], y
   16  06:C86D  8E 12 00    STX jump_address
   17  06:C870  8D 13 00    STA jump_address+1
   18  06:C873  AE 06 00    LDX tempx
   19  06:C876  AC 07 00    LDY tempy
   20  06:C879  6C 12 00    JMP [jump_address]
   21                       
   22  06:C87C            GetTableAtIndex:
   23                     
   24  06:C87C  B1 10             LDA [table_address], y
   25  06:C87E  AA                TAX
   26  06:C87F  C8                INY
   27  06:C880  B1 10             LDA [table_address], y
   28                             
   29  06:C882            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:C882  8E 10 00          STX table_address
   33  06:C885  8D 11 00          STA table_address+1
   34  06:C888  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   89                       .include "Routines/Utils/PPUUtils.asm"
    1  06:C889            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:C889  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C88C  A9 3F       LDA #HIGH($3F00)
       06:C88E  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C891  A9 00       LDA #LOW($3F00)
       06:C893  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:C896  A0 00       LDY #$00              ; start out at 0
    5  06:C898  A2 00       LDX #$00
    6  06:C89A            .loop:
    7  06:C89A  B1 10       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:C89C  8D 07 20    STA PPU_DATA            ; write to PPU
    9  06:C89F  9D 00 68    STA Palette_Copy, x
   10  06:C8A2  C8          INY                   ; X = X + 1
   11  06:C8A3  E8          INX
   12  06:C8A4  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   13  06:C8A6  D0 F2       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   14  06:C8A8  60          RTS
   15                     
   16  06:C8A9            LoadFullBackgroundFromTable:
   17                     
   18                         ;;use A as an index for which nametable to write to
   19  06:C8A9  20 DC C9          JSR SetNametableFromIndex
   20  06:C8AC  8A                TXA
   21  06:C8AD  4A                LSR A
   22  06:C8AE  29 01             AND #$01
   23  06:C8B0  D0 0D             BNE .copyScreenB
   24                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:C8B2  A9 60             LDA #HIGH(Screen_Copy)
       06:C8B4  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:C8B6  8E 0E 00          STX pointer_address
       06:C8B9  8D 0F 00          STA pointer_address+1
                                  
   25  06:C8BC  4C C9 C8          JMP .setCounters
   26                             
   27  06:C8BF            .copyScreenB:
   28                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:C8BF  A9 64             LDA #HIGH(ScreenB_Copy)
       06:C8C1  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:C8C3  8E 0E 00          STX pointer_address
       06:C8C6  8D 0F 00          STA pointer_address+1
                                  
   29                             
   30                             ;;set pointer
   31                             ;; set counters
   32  06:C8C9            .setCounters:
   33  06:C8C9  A0 00             LDY #$00
   34  06:C8CB  A2 00             LDX #$00
   35                             
   36                             ;;start loop
   37                     
   38  06:C8CD            .outerloop:
   39                     
   40  06:C8CD            .innerloop:
   41                     
   42  06:C8CD  B1 10             LDA [table_address], y
   43  06:C8CF  8D 07 20          STA PPU_DATA
   44  06:C8D2  91 0E             STA [pointer_address],y
   45  06:C8D4  C8                INY
   46  06:C8D5  C0 00             CPY #$00
   47  06:C8D7  D0 F4             BNE .innerloop
   48                     
   49  06:C8D9  EE 0F 00          INC pointer_address+1
   50  06:C8DC  EE 11 00          INC table_address+1
   51                             
   52  06:C8DF  E8                INX
   53  06:C8E0  E0 04             CPX #$04
   54  06:C8E2  D0 E9             BNE .outerloop
   55  06:C8E4  60                RTS
   56                             
   57                     
   58           0000      DATA_LEN = temp1
   59           0001      WRITE_SETTINGS = temp2
   60                             
   61  06:C8E5            ProcessPPUString:
   62                     
   63  06:C8E5  AD 1D 00          LDA PPU_PendingWrite
   64  06:C8E8  D0 01             BNE .continueProcess
   65  06:C8EA  60                RTS
   66                             
   67  06:C8EB            .continueProcess:
   68  06:C8EB  A0 00             LDY #$00
   69                             
   70  06:C8ED  A9 1F             LDA #LOW(PPU_String)
   71  06:C8EF  8D 0E 00          STA pointer_address
   72  06:C8F2  A9 00             LDA #HIGH(PPU_String)
   73  06:C8F4  8D 0F 00          STA pointer_address + 1
   74                     
   75  06:C8F7            .outerloop:
   76  06:C8F7  AD 02 20          LDA PPU_STATUS
   77  06:C8FA  B1 0E             LDA [pointer_address], y
   78  06:C8FC  F0 79             BEQ .finish
   79  06:C8FE  8D 06 20          STA PPU_ADDR
   80  06:C901  C8                INY
   81  06:C902  B1 0E             LDA [pointer_address], y
   82  06:C904  8D 06 20          STA PPU_ADDR
   83  06:C907  C8            INY 
   84  06:C908  B1 0E             LDA [pointer_address], y
   85  06:C90A  8D 01 00          STA WRITE_SETTINGS
   86  06:C90D  C8                INY
   87                             
   88  06:C90E  AD 00 20          LDA PPU_CTRL
   89  06:C911  29 FB             AND #$FB
   90  06:C913  8D 00 20          STA PPU_CTRL
   91                             
   92  06:C916  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
   93  06:C919  29 80             AND #%10000000
   94  06:C91B  F0 06             BEQ .checkRepeat
   95  06:C91D  0D 00 20          ORA PPU_CTRL 
   96  06:C920  8D 00 20          STA PPU_CTRL 
   97                             
   98                             
   99  06:C923            .checkRepeat:
  100  06:C923  AD 01 00    LDA WRITE_SETTINGS
  101  06:C926  29 40       AND #%01000000
  102  06:C928  F0 19       BEQ .checkTable
  103                       
  104  06:C92A  AD 01 00    LDA WRITE_SETTINGS
  105  06:C92D  29 3F       AND #$3F
  106  06:C92F  8D 00 00    STA DATA_LEN
  107                       ;;the usual data length byte is now the repeatable byte
  108  06:C932  A2 00       LDX #$00
  109                       
  110  06:C934            .repeatLoop:
  111  06:C934  B1 0E       LDA [pointer_address], y
  112  06:C936  8D 07 20    STA PPU_DATA
  113  06:C939  E8          INX 
  114  06:C93A  EC 00 00    CPX DATA_LEN
  115  06:C93D  D0 F5       BNE .repeatLoop
  116  06:C93F  C8          INY
  117  06:C940  4C F7 C8    JMP .outerloop
  118                             
  119  06:C943            .checkTable:
  120  06:C943  AD 01 00          LDA WRITE_SETTINGS
  121  06:C946  29 20             AND #%00100000
  122  06:C948  F0 16             BEQ .rawData
  123                             
  124  06:C94A  B1 0E             LDA [pointer_address], y
  125  06:C94C  8D 10 00          STA table_address
  126  06:C94F  C8                INY 
  127  06:C950  B1 0E             LDA [pointer_address], y
  128  06:C952  8D 11 00          STA table_address + 1
  129  06:C955  C8                INY
  130  06:C956  98                TYA 
  131  06:C957  48                PHA
  132  06:C958  20 7B C9          JSR WriteToPPUFromTable
  133  06:C95B  68                PLA
  134  06:C95C  A8                TAY
  135  06:C95D  4C F7 C8          JMP .outerloop
  136                             
  137  06:C960            .rawData:
  138                     
  139  06:C960  B1 0E             LDA [pointer_address], y
  140  06:C962  C8                INY
  141  06:C963  8D 00 00          STA DATA_LEN
  142                     
  143  06:C966  A2 00             LDX #$00
  144                     
  145  06:C968            .innerloop:
  146                             
  147  06:C968  B1 0E             LDA [pointer_address], y
  148  06:C96A  8D 07 20          STA PPU_DATA
  149  06:C96D  C8                INY
  150  06:C96E  E8                INX
  151  06:C96F  EC 00 00          CPX DATA_LEN
  152  06:C972  D0 F4             BNE .innerloop
  153  06:C974  4C F7 C8          JMP .outerloop
  154                             
  155  06:C977            .finish:
  156  06:C977  20 BC C9          JSR ClearPPUString
  157  06:C97A            .leave:
  158  06:C97A  60                RTS
  159                             
  160  06:C97B            WriteToPPUFromTable:
  161  06:C97B  A0 00             LDY #$00
  162  06:C97D  B1 10             LDA [table_address], y
  163  06:C97F  C8                INY
  164  06:C980  8D 00 00          STA DATA_LEN
  165  06:C983            .innerloop:
  166  06:C983  B1 10             LDA [table_address], y
  167  06:C985  8D 07 20          STA PPU_DATA
  168  06:C988  C8                INY
  169  06:C989  CC 00 00          CPY DATA_LEN
  170  06:C98C  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  171  06:C98E  F0 F3             BEQ .innerloop
  172  06:C990  60                RTS
  173                       
  174  06:C991            LoadSprites_impl:
  175                       ;;A will be the amount of sprites to load
  176  06:C991  8D 00 00    STA DATA_LEN
  177  06:C994  0E 00 00    ASL DATA_LEN
  178  06:C997  0E 00 00    ASL DATA_LEN
  179                       
  180  06:C99A  A0 00       LDY #$00              ; start at 0
  181                       
  182  06:C99C            .loop:
  183  06:C99C  B1 10       LDA [table_address], y; load data from address (sprites +  x)
  184  06:C99E  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  185  06:C9A1  C8          INY                   ; X = X + 1
  186  06:C9A2  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  187  06:C9A5  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  188                                             ; if compare was equal to 16, keep going down   
  189  06:C9A7  60          RTS
  190                     
  191                     
  192  06:C9A8            WriteToPPUString:
  193                     
  194  06:C9A8  AE 1E 00          LDX PPU_StringIdx
  195  06:C9AB  E0 4F             CPX #PPU_STRINGMAX
  196  06:C9AD  F0 0C             BEQ .finish
  197                             
  198  06:C9AF  9D 1F 00          STA PPU_String, x
  199  06:C9B2  EE 1E 00          INC PPU_StringIdx
  200  06:C9B5  E8                INX
  201  06:C9B6  A9 00             LDA #$00
  202  06:C9B8  9D 1F 00          STA PPU_String, x
  203                                     
  204  06:C9BB            .finish:
  205  06:C9BB  60                RTS
  206                     
  207  06:C9BC            ClearPPUString:
  208                             
  209  06:C9BC  A9 00             LDA #$00
  210  06:C9BE  8D 1E 00          STA PPU_StringIdx
  211  06:C9C1  8D 1F 00          STA PPU_String
  212  06:C9C4  8D 1D 00          STA PPU_PendingWrite
  213  06:C9C7  60                RTS
  214                     
  215  06:C9C8            DetectSprite0:
  216  06:C9C8            WaitNotSprite0:
  217  06:C9C8  AD 02 20    lda PPU_STATUS
  218  06:C9CB  29 40       and #SPRITE_0_MASK
  219  06:C9CD  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  220                     
  221  06:C9CF            WaitSprite0:
  222  06:C9CF  AD 02 20    lda $2002
  223  06:C9D2  29 40       and #SPRITE_0_MASK
  224  06:C9D4  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  225                     
  226  06:C9D6  A2 05       ldx #$05                              ;do a scanline wait
  227  06:C9D8            WaitScanline:
  228  06:C9D8  CA          dex
  229  06:C9D9  D0 FD       bne WaitScanline
  230  06:C9DB  60          RTS
  231                     
  232                     
  233  06:C9DC            SetNametableFromIndex:
  234                     
  235  06:C9DC  48          PHA
  236  06:C9DD  AD 02 20    LDA PPU_STATUS
  237  06:C9E0  68          PLA
  238  06:C9E1  0A          ASL A
  239  06:C9E2  AA          TAX
  240  06:C9E3  BD 78 CA    LDA NameTableMemList+1, x
  241  06:C9E6  8D 06 20    STA PPU_ADDR
  242  06:C9E9  BD 77 CA    LDA NameTableMemList, x
  243  06:C9EC  8D 06 20    STA PPU_ADDR
  244  06:C9EF  60          RTS
  245                       
  246  06:C9F0            TurnOnSprites:
  247                      
  248  06:C9F0  AD 18 00    LDA PPU_Mask
  249  06:C9F3  09 10       ORA #%00010000
  250  06:C9F5  8D 18 00    STA PPU_Mask
  251  06:C9F8  60          RTS
  252                       
  253  06:C9F9            TurnOffSprites:
  254                       
  255  06:C9F9  AD 18 00    LDA PPU_Mask
  256  06:C9FC  29 EF       AND #%11101111
  257  06:C9FE  8D 18 00    STA PPU_Mask
  258  06:CA01  60          RTS
  259                     
  260  06:CA02            UpdatePPUControl:
  261                     
  262  06:CA02  AD 17 00    LDA PPU_Control
  263  06:CA05  29 FC       AND #$FC
  264  06:CA07  0D 1C 00    ORA PPU_NT
  265  06:CA0A  8D 00 20    STA PPU_CTRL
  266  06:CA0D  AD 18 00    LDA PPU_Mask
  267  06:CA10  8D 01 20    STA PPU_MASK
  268  06:CA13  60          RTS
  269                       
  270  06:CA14            InitPPUControl:
  271                       
  272                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  273                       ; enable sprites, enable background, no clipping on left side
  274  06:CA14  A9 90       LDA #%10010000
  275  06:CA16  8D 00 20    STA PPU_CTRL
  276  06:CA19  8D 17 00    STA PPU_Control
  277  06:CA1C  A9 1E       LDA #%00011110
  278  06:CA1E  8D 01 20    STA PPU_MASK
  279  06:CA21  8D 18 00    STA PPU_Mask
  280  06:CA24  60          RTS
  281                       
  282  06:CA25            FadeOutPalettes:
  283                     
  284                     ;;take the current values, and decrement the lower nibbles
  285                     ;;we can access from the palette copy 
  286                     ;;we'll make this fade out one level per call
  287                     ;;once all the palettes are blacked out we'll return true, so we'll keep the carry flag as a return result
  288                     
  289                     ;;go through the palette copy, decrement, make a raw data PPU string and add all the bytes into it
  290                     ;;for any palette color already in the 0x range, change it to 0f to get black
  291                     
  292                       MACROGetLabelPointer Palette_Copy, table_address
                          
       06:CA25  A9 68             LDA #HIGH(Palette_Copy)
       06:CA27  A2 00             LDX #LOW(Palette_Copy)
                                  
       06:CA29  8E 10 00          STX table_address
       06:CA2C  8D 11 00          STA table_address+1
                                  
  293                     ;;palette copy address is now X accessable
  294                     
  295  06:CA2F  A0 00       LDY #$00
  296                       MACROAddPPUStringEntryRawData #$3F, #$00, #DRAW_HORIZONTAL, #$20  
                          
       06:CA31  A9 01       LDA #$01
       06:CA33  8D 1D 00    STA PPU_PendingWrite
       06:CA36  A9 3F       LDA #$3F
       06:CA38  20 A8 C9    JSR WriteToPPUString
       06:CA3B  A9 00       LDA #$00
       06:CA3D  20 A8 C9    JSR WriteToPPUString
       06:CA40  A9 00       LDA #DRAW_HORIZONTAL
       06:CA42  20 A8 C9    JSR WriteToPPUString
       06:CA45  A9 20       LDA #$20 
       06:CA47  20 A8 C9    JSR WriteToPPUString
                            
  297                     
  298  06:CA4A  A9 00       LDA #$00
  299  06:CA4C  8D 00 00    STA temp1
  300                       
  301  06:CA4F            .loop:
  302                     
  303  06:CA4F  B1 10       LDA [table_address], y
  304  06:CA51  C9 0F       CMP #$0F
  305  06:CA53  F0 15       BEQ .addToString
  306  06:CA55  C9 10       CMP #$10
  307  06:CA57  90 0D       BCC .setBlack
  308                       
  309  06:CA59  A9 80       LDA #$80
  310  06:CA5B  8D 00 00    STA temp1
  311                       
  312  06:CA5E  B1 10       LDA [table_address], y
  313  06:CA60  38          SEC
  314  06:CA61  E9 10       SBC #$10
  315  06:CA63  4C 68 CA    JMP .setColor
  316                     
  317  06:CA66            .setBlack:
  318                     
  319  06:CA66  A9 0F       LDA #$0F
  320                     
  321  06:CA68            .setColor:
  322  06:CA68  91 10       STA [table_address], y
  323                     
  324  06:CA6A            .addToString:
  325                     
  326  06:CA6A  20 A8 C9    JSR WriteToPPUString
  327                     
  328  06:CA6D            .incY:
  329                       
  330  06:CA6D  C8          INY
  331  06:CA6E  C0 20       CPY #$20
  332  06:CA70  D0 DD       BNE .loop
  333                     
  334  06:CA72  0E 00 00    ASL temp1     ;get carry out, if we have one
  335                     
  336  06:CA75  60          RTS
  337                       
  338  06:CA76            FadeInPalettes:
  339                     
  340                     ;;need to be able to store off a target palette first
  341                     ;;we can use the palette copy we make during the game mode change as the target
  342  06:CA76  60          RTS
  343                     
  344  06:CA77            NameTableMemList:
  345  06:CA77  00 20       .word $2000, $2400, $2800, $2C00
       06:CA79  00 24     
       06:CA7B  00 28     
       06:CA7D  00 2C     
  346  06:CA7F            PalettesMemList:
  347  06:CA7F  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:CA81  04 3F     
       06:CA83  08 3F     
       06:CA85  0C 3F     
  348  06:CA87  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:CA89  14 3F     
       06:CA8B  18 3F     
       06:CA8D  1C 3F     
  349                       
  350           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   90                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:CA8F            ResetMapper:
    7  06:CA8F  EE 8F CA    inc ResetMapper
    8  06:CA92  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:CA93            SetMapperControls:
   23                       ;;A = controls
   24  06:CA93  AA          TAX
   25  06:CA94  A9 80       LDA #MAPPERCONTROL
   26  06:CA96  8D A0 00    STA mapper_address+1
   27  06:CA99  8A          TXA
   28  06:CA9A  20 BF CA    JSR SendMapperCommand
   29  06:CA9D  60          RTS
   30                     
   31  06:CA9E            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:CA9E  AA                TAX
   35  06:CA9F  A9 E0             LDA #PRGBANK
   36  06:CAA1  8D A0 00          STA mapper_address+1
   37  06:CAA4  8A                TXA
   38  06:CAA5  20 BF CA          JSR SendMapperCommand
   39  06:CAA8  60                RTS
   40                             
   41  06:CAA9            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:CAA9  AA                TAX
   44  06:CAAA  A9 A0             LDA #CHRBANK1
   45  06:CAAC  8D A0 00          STA mapper_address+1
   46  06:CAAF  8A                TXA
   47  06:CAB0  20 BF CA          JSR SendMapperCommand
   48  06:CAB3  60                RTS
   49                             
   50  06:CAB4            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:CAB4  AA                TAX
   53  06:CAB5  A9 C0             LDA #CHRBANK2
   54  06:CAB7  8D A0 00          STA mapper_address+1
   55  06:CABA  8A                TXA
   56  06:CABB  20 BF CA          JSR SendMapperCommand
   57  06:CABE  60                RTS
   58                             
   59  06:CABF            SendMapperCommand:
   60                     
   61  06:CABF  A0 00             LDY #$00
   62                             
   63  06:CAC1  91 9F             STA [mapper_address], y
   64  06:CAC3  4A                LSR A
   65  06:CAC4  91 9F             STA [mapper_address], y
   66  06:CAC6  4A                LSR A
   67  06:CAC7  91 9F             STA [mapper_address], y
   68  06:CAC9  4A                LSR A 
   69  06:CACA  91 9F             STA [mapper_address], y
   70  06:CACC  4A                LSR A
   71  06:CACD  91 9F             STA [mapper_address], y
   72                             
   73  06:CACF  60                RTS
   74                             
   75  06:CAD0            ResetBanks:
   76                     
   77  06:CAD0  20 8F CA          JSR ResetMapper
   78  06:CAD3  A9 00             LDA #$00
   79  06:CAD5  20 9E CA          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:CAD8  20 8F CA          JSR ResetMapper
   83  06:CADB  A9 00             LDA #$00
   84  06:CADD  20 A9 CA          JSR LoadCHRBankA
   85  06:CAE0  A9 01             LDA #$01
   86  06:CAE2  20 B4 CA          JSR LoadCHRBankB
   87  06:CAE5  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   91                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:CAE6            PopulateClues:
    2                     
    3  06:CAE6            .getByte:
    4  06:CAE6  AC AD 00    LDY clueTableIndex
    5  06:CAE9  B1 A7       LDA [clues_address], y
    6  06:CAEB  D0 07       BNE .checkNewLine
    7  06:CAED  EE AD 00    INC clueTableIndex
    8  06:CAF0  A9 00       LDA #$00
    9  06:CAF2  F0 38       BEQ .drawClue
   10                       ;was 0, set up a draw
   11  06:CAF4            .checkNewLine
   12  06:CAF4  C9 FF       CMP #$FF
   13  06:CAF6  D0 17       BNE .getClue
   14                       
   15                       ;;was FF- need to inc stuff
   16  06:CAF8  EE AD 00    INC clueTableIndex
   17  06:CAFB  A9 00       LDA #$00
   18  06:CAFD  8D B4 00    STA clueParity
   19                       
   20  06:CB00  EE AE 00    INC clueLineIndex
   21  06:CB03  AD AE 00    LDA clueLineIndex
   22  06:CB06  C9 0F       CMP #$0F
   23                       ;CMP #$01
   24  06:CB08  F0 28       BEQ .leave    ;carry will be set
   25                       
   26  06:CB0A  20 A4 CB    JSR CreateOffsetFromIndex
   27                      
   28  06:CB0D  D0 D7       BNE .getByte
   29                       
   30  06:CB0F            .getClue:
   31                       ;;clues go from high nibble to low nibble
   32  06:CB0F  48          PHA 
   33  06:CB10  AD B4 00    LDA clueParity
   34  06:CB13  D0 0A       BNE .getSecondClue
   35  06:CB15  EE B4 00    INC clueParity
   36  06:CB18  68          PLA
   37  06:CB19  4A          LSR A
   38  06:CB1A  4A          LSR A
   39  06:CB1B  4A          LSR A
   40  06:CB1C  4A          LSR A         ;move clue over to lower nibble
   41  06:CB1D  D0 0D       BNE .drawClue
   42                       
   43  06:CB1F            .getSecondClue:
   44                     
   45  06:CB1F  CE B4 00    DEC clueParity
   46  06:CB22  EE AD 00    INC clueTableIndex
   47  06:CB25  68          PLA 
   48  06:CB26  29 0F       AND #$0F
   49  06:CB28  D0 02       BNE .drawClue
   50                       ;;if 0, skip
   51  06:CB2A  F0 BA       BEQ .getByte
   52                      
   53  06:CB2C            .drawClue:
   54                       
   55  06:CB2C  09 40       ORA #$40
   56  06:CB2E  20 33 CB    JSR WriteClueByteToPPUString
   57  06:CB31  18          CLC
   58                       
   59  06:CB32            .leave:
   60  06:CB32  60          RTS
   61                       
   62  06:CB33            WriteClueByteToPPUString:
   63                     
   64  06:CB33  8D 00 00    STA temp1 ;store off the tile value
   65                     
   66                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:CB36  A9 01       LDA #$01
       06:CB38  8D 1D 00    STA PPU_PendingWrite
       06:CB3B  AD AC 00    LDA clue_draw_address+1
       06:CB3E  20 A8 C9    JSR WriteToPPUString
       06:CB41  AD AB 00    LDA clue_draw_address
       06:CB44  20 A8 C9    JSR WriteToPPUString
       06:CB47  A9 00       LDA #DRAW_HORIZONTAL
       06:CB49  20 A8 C9    JSR WriteToPPUString
       06:CB4C  A9 01       LDA #$01 
       06:CB4E  20 A8 C9    JSR WriteToPPUString
                            
   67  06:CB51  AD 00 00    LDA temp1
   68  06:CB54  20 A8 C9    JSR WriteToPPUString
   69                       
   70  06:CB57  AD B2 00    LDA clueDrawAdd
   71  06:CB5A  20 81 CB    JSR SubFromClueDrawAddress
   72                         
   73  06:CB5D  60          RTS
   74                       
   75  06:CB5E            ResetClueDrawAddress:
   76                     
   77                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:CB5E  AD A9 00          LDA clue_start_address
       06:CB61  8D AB 00          STA clue_draw_address
       06:CB64  AD AA 00          LDA clue_start_address+1
       06:CB67  8D AC 00          STA clue_draw_address+1
                          
   78                       
   79  06:CB6A  60          RTS
   80                       
   81  06:CB6B            AddToClueDrawAddress:
   82                     
   83  06:CB6B  8D 00 00    STA temp1
   84                       
   85  06:CB6E  AD AB 00    LDA clue_draw_address
   86  06:CB71  18          CLC
   87  06:CB72  6D 00 00    ADC temp1
   88  06:CB75  8D AB 00    STA clue_draw_address
   89  06:CB78  AD AC 00    LDA clue_draw_address+1
   90  06:CB7B  69 00       ADC #$00
   91  06:CB7D  8D AC 00    STA clue_draw_address+1
   92                       
   93  06:CB80  60          RTS
   94                         
   95  06:CB81            SubFromClueDrawAddress:
   96                     
   97  06:CB81  8D 00 00    STA temp1
   98                       
   99  06:CB84  AD AB 00    LDA clue_draw_address
  100  06:CB87  38          SEC
  101  06:CB88  ED 00 00    SBC temp1
  102  06:CB8B  8D AB 00    STA clue_draw_address
  103  06:CB8E  AD AC 00    LDA clue_draw_address+1
  104  06:CB91  E9 00       SBC #$00
  105  06:CB93  8D AC 00    STA clue_draw_address+1
  106                       
  107  06:CB96  60          RTS
  108                       
  109  06:CB97            AddToClueDrawAddressHi:
  110                     
  111  06:CB97  8D 00 00    STA temp1
  112                       
  113  06:CB9A  AD AC 00    LDA clue_draw_address+1
  114  06:CB9D  6D 00 00    ADC temp1
  115  06:CBA0  8D AC 00    STA clue_draw_address+1
  116                       
  117  06:CBA3  60          RTS
  118                       
  119  06:CBA4            CreateOffsetFromIndex:
  120                     
  121                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  122  06:CBA4  AD AE 00    LDA clueLineIndex
  123  06:CBA7  8D B0 00    STA clueDrawOffset
  124  06:CBAA  A9 00       LDA #$00
  125  06:CBAC  8D B1 00    STA clueDrawOffset+1
  126                       
  127  06:CBAF  AD AF 00    LDA clueOffsetShift   
  128  06:CBB2  F0 0E       BEQ .addOffset
  129                       
  130  06:CBB4  A2 00       LDX #$00
  131                       
  132  06:CBB6            .loopShift:
  133  06:CBB6  0E B0 00    ASL clueDrawOffset
  134  06:CBB9  2E B1 00    ROL clueDrawOffset+1
  135  06:CBBC  E8          INX
  136  06:CBBD  EC AF 00    CPX clueOffsetShift
  137  06:CBC0  D0 F4       BNE .loopShift
  138                       
  139  06:CBC2            .addOffset:
  140                       
  141  06:CBC2  20 5E CB    JSR ResetClueDrawAddress
  142  06:CBC5  AD B0 00    LDA clueDrawOffset
  143  06:CBC8  20 6B CB    JSR AddToClueDrawAddress 
  144  06:CBCB  AD B1 00    LDA clueDrawOffset+1
  145  06:CBCE  20 97 CB    JSR AddToClueDrawAddressHi
  146                       
  147  06:CBD1  60          RTS  
  148                       
  149  06:CBD2            ClearPuzzle:
  150                     
  151                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  152                      
  153                       MACROGetLabelPointer ClearLineDefTables, table_address
                          
       06:CBD2  A9 CD             LDA #HIGH(ClearLineDefTables)
       06:CBD4  A2 48             LDX #LOW(ClearLineDefTables)
                                  
       06:CBD6  8E 10 00          STX table_address
       06:CBD9  8D 11 00          STA table_address+1
                                  
  154  06:CBDC  A0 00       LDY #$00
  155  06:CBDE  20 7C C8    JSR GetTableAtIndex
  156                       
  157                       
  158  06:CBE1  AC AE 00    LDY clueLineIndex
  159  06:CBE4  B1 10       LDA [table_address], y
  160  06:CBE6  8D 00 00    STA temp1
  161                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:CBE9  A9 01       LDA #$01
       06:CBEB  8D 1D 00    STA PPU_PendingWrite
       06:CBEE  AD AC 00    LDA clue_draw_address+1
       06:CBF1  20 A8 C9    JSR WriteToPPUString
       06:CBF4  AD AB 00    LDA clue_draw_address
       06:CBF7  20 A8 C9    JSR WriteToPPUString
       06:CBFA  A9 40       LDA #$40
       06:CBFC  09 00       ORA #DRAW_HORIZONTAL
       06:CBFE  0D 00 00    ORA temp1
       06:CC01  20 A8 C9    JSR WriteToPPUString
       06:CC04  A9 24       LDA #$24
       06:CC06  20 A8 C9    JSR WriteToPPUString
                            
  162                       ;;no need to load anything else
  163                       
  164  06:CC09  AD AB 00    LDA clue_draw_address
  165  06:CC0C  18          CLC
  166  06:CC0D  69 20       ADC #32
  167  06:CC0F  8D AB 00    STA clue_draw_address
  168  06:CC12  AD AC 00    LDA clue_draw_address+1
  169  06:CC15  69 00       ADC #$00
  170  06:CC17  8D AC 00    STA clue_draw_address+1
  171                       
  172  06:CC1A  EE AE 00    INC clueLineIndex
  173  06:CC1D  60          RTS
  174                       
  175  06:CC1E            DrawImage:
  176                     
  177                       ;;we have clueTableIndex, which should be at the image bytes now
  178                       ;;clue line index will keep track of our place in a byte
  179                        
  180  06:CC1E  A9 00       LDA #$00
  181  06:CC20  8D 00 00    STA temp1
  182  06:CC23  8D 01 00    STA temp2
  183  06:CC26  8D 02 00    STA temp3
  184  06:CC29  8D 03 00    STA temp4
  185  06:CC2C  8D 05 00    STA temp6
  186                       
  187  06:CC2F  A9 04       LDA #$04
  188  06:CC31  8D 04 00    STA temp5
  189                       
  190  06:CC34  AC AD 00    LDY clueTableIndex
  191  06:CC37  B1 A7       LDA [clues_address], y
  192                     
  193  06:CC39  0A          ASL A
  194  06:CC3A  2E 00 00    ROL temp1
  195  06:CC3D  0A          ASL A
  196  06:CC3E  2E 00 00    ROL temp1
  197  06:CC41  0A          ASL A
  198  06:CC42  2E 01 00    ROL temp2
  199  06:CC45  0A          ASL A
  200  06:CC46  2E 01 00    ROL temp2
  201  06:CC49  0A          ASL A
  202  06:CC4A  2E 02 00    ROL temp3
  203  06:CC4D  0A          ASL A
  204  06:CC4E  2E 02 00    ROL temp3
  205  06:CC51  0A          ASL A
  206  06:CC52  2E 03 00    ROL temp4
  207  06:CC55  0A          ASL A
  208  06:CC56  2E 03 00    ROL temp4
  209                       
  210                     
  211  06:CC59  A2 00       LDX #$00
  212  06:CC5B            .moveUpTiles:
  213  06:CC5B  BD 00 00    LDA temp1, x
  214  06:CC5E  09 24       ORA #$24
  215  06:CC60  9D 00 00    STA temp1, x
  216  06:CC63  E8          INX
  217  06:CC64  E0 04       CPX #$04
  218  06:CC66  D0 F3       BNE .moveUpTiles
  219                       
  220                       
  221  06:CC68  AD AF 00    LDA clueOffsetShift
  222  06:CC6B  18          CLC
  223  06:CC6C  69 04       ADC #$04
  224                     
  225  06:CC6E  8D AF 00    STA clueOffsetShift
  226                       ;;clue offset shift + 4, check if we went over 15
  227  06:CC71  38          SEC
  228  06:CC72  E9 0F       SBC #15 ;;subtract 15
  229  06:CC74  90 12       BCC .makeStrings
  230  06:CC76  F0 10       BEQ .makeStrings
  231                       
  232  06:CC78  8D AF 00    STA clueOffsetShift ;loop offset over
  233  06:CC7B  8D 05 00    STA temp6 ; length of second string
  234  06:CC7E  AD 04 00    LDA temp5
  235  06:CC81  38          SEC
  236  06:CC82  ED 05 00    SBC temp6 
  237  06:CC85  8D 04 00    STA temp5 ;length of first string 
  238                       
  239  06:CC88            .makeStrings:
  240                       
  241  06:CC88  A2 00       LDX #$00
  242                       
  243  06:CC8A  AD 04 00    LDA temp5
  244  06:CC8D  F0 50       BEQ .makeSecondString
  245  06:CC8F  8A          TXA
  246  06:CC90  48          PHA
  247                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp5
                          
       06:CC91  A9 01       LDA #$01
       06:CC93  8D 1D 00    STA PPU_PendingWrite
       06:CC96  AD AC 00    LDA clue_draw_address+1
       06:CC99  20 A8 C9    JSR WriteToPPUString
       06:CC9C  AD AB 00    LDA clue_draw_address
       06:CC9F  20 A8 C9    JSR WriteToPPUString
       06:CCA2  A9 00       LDA #DRAW_HORIZONTAL
       06:CCA4  20 A8 C9    JSR WriteToPPUString
       06:CCA7  AD 04 00    LDA temp5 
       06:CCAA  20 A8 C9    JSR WriteToPPUString
                            
  248  06:CCAD  68          PLA
  249  06:CCAE  AA          TAX
  250                       
  251  06:CCAF            .firstStringLoop:
  252                       
  253  06:CCAF  8A          TXA 
  254  06:CCB0  48          PHA
  255  06:CCB1  BD 00 00    LDA temp1, x
  256  06:CCB4  20 A8 C9    JSR WriteToPPUString
  257                       
  258  06:CCB7  EE AE 00    INC clueLineIndex
  259  06:CCBA  AD AE 00    LDA clueLineIndex
  260  06:CCBD  C9 E1       CMP #225
  261  06:CCBF  D0 04       BNE .continueLoop
  262  06:CCC1  68          PLA 
  263  06:CCC2  4C 44 CD    JMP .leave
  264                       
  265  06:CCC5            .continueLoop:
  266  06:CCC5  68          PLA
  267  06:CCC6  AA          TAX
  268  06:CCC7  E8          INX
  269  06:CCC8  EC 04 00    CPX temp5
  270  06:CCCB  D0 E2       BNE .firstStringLoop
  271                       
  272  06:CCCD  AD AB 00    LDA clue_draw_address
  273  06:CCD0  18          CLC
  274  06:CCD1  6D 04 00    ADC temp5
  275  06:CCD4  8D AB 00    STA clue_draw_address
  276  06:CCD7  AD AC 00    LDA clue_draw_address+1
  277  06:CCDA  69 00       ADC #$00
  278  06:CCDC  8D AC 00    STA clue_draw_address+1
  279                       
  280  06:CCDF            .makeSecondString:
  281                     
  282  06:CCDF  AD 05 00    LDA temp6
  283  06:CCE2  F0 60       BEQ .leave
  284                       
  285                       ;;loop draw address to next line
  286  06:CCE4  AD AB 00    LDA clue_draw_address
  287  06:CCE7  18          CLC
  288  06:CCE8  69 11       ADC #17
  289  06:CCEA  8D AB 00    STA clue_draw_address
  290  06:CCED  AD AC 00    LDA clue_draw_address+1
  291  06:CCF0  69 00       ADC #$00
  292  06:CCF2  8D AC 00    STA clue_draw_address+1
  293  06:CCF5  8A          TXA
  294  06:CCF6  48          PHA
  295                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp6
                          
       06:CCF7  A9 01       LDA #$01
       06:CCF9  8D 1D 00    STA PPU_PendingWrite
       06:CCFC  AD AC 00    LDA clue_draw_address+1
       06:CCFF  20 A8 C9    JSR WriteToPPUString
       06:CD02  AD AB 00    LDA clue_draw_address
       06:CD05  20 A8 C9    JSR WriteToPPUString
       06:CD08  A9 00       LDA #DRAW_HORIZONTAL
       06:CD0A  20 A8 C9    JSR WriteToPPUString
       06:CD0D  AD 05 00    LDA temp6 
       06:CD10  20 A8 C9    JSR WriteToPPUString
                            
  296  06:CD13  68          PLA 
  297  06:CD14  AA          TAX
  298                       
  299  06:CD15            .secondStringLoop:
  300                     
  301  06:CD15  8A          TXA
  302  06:CD16  48          PHA 
  303  06:CD17  BD 00 00    LDA temp1, x
  304  06:CD1A  20 A8 C9    JSR WriteToPPUString
  305                       
  306  06:CD1D  EE AE 00    INC clueLineIndex
  307  06:CD20  AD AE 00    LDA clueLineIndex
  308  06:CD23  C9 E1       CMP #225
  309  06:CD25  D0 04       BNE .continueSecondLoop
  310                       
  311  06:CD27  68          PLA 
  312  06:CD28  4C 44 CD    JMP .leave
  313                       
  314  06:CD2B            .continueSecondLoop:
  315  06:CD2B  68          PLA
  316  06:CD2C  AA          TAX
  317  06:CD2D  E8          INX
  318  06:CD2E  E0 04       CPX #$04
  319  06:CD30  D0 E3       BNE .secondStringLoop
  320                       
  321  06:CD32  AD AB 00    LDA clue_draw_address
  322  06:CD35  18          CLC
  323  06:CD36  6D 05 00    ADC temp6
  324  06:CD39  8D AB 00    STA clue_draw_address
  325  06:CD3C  AD AC 00    LDA clue_draw_address+1
  326  06:CD3F  69 00       ADC #$00
  327  06:CD41  8D AC 00    STA clue_draw_address+1
  328                       
  329  06:CD44            .leave:
  330  06:CD44  EE AD 00    INC clueTableIndex
  331  06:CD47  60          RTS
  332                     
  333  06:CD48            ClearLineDefTables:
  334                     
  335  06:CD48  4A CD       .word Clear15x15LineDefs
  336                     
  337  06:CD4A            Clear15x15LineDefs:
  338  06:CD4A  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:CD4D  20 20 20  
       06:CD50  20 20 20  
       06:CD53  20 20     
  339  06:CD55  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:CD58  0D 0D 0D  
       06:CD5B  0D 0D 0D  
       06:CD5E  0D 0D 0D  
       06:CD61  0D 0D 0D  
       06:CD64  0D 0D     
  340  06:CD66  20 20       .db $20, $20
#[1]   Picross.asm
   92                       
   93                       
   94                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   95                     ;;     NMI                  ;;
   96                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   97                     
#[2]   Routines/Common/NMI.asm
   98                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:CD68            NMI:
    3                     
    4  06:CD68  48          PHA                              ;protect the registers
    5  06:CD69  8A          TXA
    6  06:CD6A  48          PHA
    7  06:CD6B  98          TYA
    8  06:CD6C  48          PHA
    9                       
   10  06:CD6D            nmi_started:
   11  06:CD6D  A9 00       LDA #$00
   12  06:CD6F  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:CD72  A9 02       LDA #$02
   14  06:CD74  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:CD77  AD 0C 00    LDA NMI_locks
   17  06:CD7A  F0 03       BEQ update_controllers
   18  06:CD7C  4C EB CD    JMP WakeUp
   19                     
   20  06:CD7F            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:CD7F  8A            TXA
    3  06:CD80  48                PHA
    4  06:CD81  98                TYA
    5  06:CD82  48                PHA
    6                     
    7  06:CD83  A2 00             LDX #$00
    8                     
    9  06:CD85            GamePadCheck:
   10  06:CD85  A9 01             LDA #$01        ;load 1
   11  06:CD87  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:CD8A  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:CD8B  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:CD8E  A9 80             LDA #$80
   18  06:CD90  8D 14 00          STA gamepad
   19                     
   20  06:CD93            ReadControllerABytesLoop:
   21  06:CD93  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:CD96  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:CD98  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:CD9A  6E 14 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:CD9D  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:CD9F  AD 15 00          LDA gamepadLast
   31  06:CDA2  49 FF             EOR #$FF
   32  06:CDA4  2D 14 00          AND gamepad
   33  06:CDA7  8D 16 00          STA gamepadPressed
   34                             
   35                             
   36  06:CDAA  AD 14 00          LDA gamepad
   37  06:CDAD  8D 15 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:CDB0  68                PLA
   41  06:CDB1  A8                TAY
   42  06:CDB2  68                PLA
   43  06:CDB3  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:CDB4  20 E5 C8    JSR ProcessPPUString
   25                       
   26                       
   27  06:CDB7  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:CDB9  8D 05 20    STA PPU_SCROLL
   29  06:CDBC  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:CDBF  20 02 CA    JSR UpdatePPUControl
   34                     
   35  06:CDC2            NMIUpdate:
   36                     
   37  06:CDC2  20 DF CD    JSR StateNMIUpdate
   38                       
   39  06:CDC5  AD 17 00    LDA PPU_Control
   40  06:CDC8  29 FC       AND #$FC
   41  06:CDCA  0D 1B 00    ORA PPU_ScrollNT
   42  06:CDCD  8D 00 20    STA PPU_CTRL
   43                       
   44  06:CDD0  AD 19 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:CDD3  8D 05 20    STA PPU_SCROLL
   46  06:CDD6  AD 1A 00    LDA PPU_ScrollY
   47  06:CDD9  8D 05 20    STA PPU_SCROLL
   48                     
   49  06:CDDC  4C EB CD    JMP WakeUp
   50                     
   51  06:CDDF            StateNMIUpdate:
   52                     
   53                       MACROCallDynamicJump game_mode
                          
       06:CDDF  AD 0A 00    LDA game_mode
       06:CDE2  20 56 C8    JSR Dynamic_Jump
                                  
   54                     
   55  06:CDE5            NMIJumpTable:
   56                     
   57  06:CDE5  F6 CD       .word UpdateTitleNMI
   58  06:CDE7  FA CD       .word UpdateGameNMI
   59  06:CDE9  FB CD       .word UpdateGameOverNMI
   60                     
   61  06:CDEB            WakeUp:
   62  06:CDEB  A9 00       LDA #$00
   63  06:CDED  8D 09 00    STA sleeping
   64                       
   65  06:CDF0  68          PLA             ;restore the registers
   66  06:CDF1  A8          TAY 
   67  06:CDF2  68          PLA
   68  06:CDF3  AA          TAX
   69  06:CDF4  68          PLA
   70                     
   71  06:CDF5  40          RTI             ; return from interrupt
   72                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   73                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:CDF6            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:CDF6  20 C8 C9    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:CDF9  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   74                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:CDFA            UpdateGameNMI:
    2  06:CDFA  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:CDFB            UpdateGameOverNMI:
    2  06:CDFB  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
   99                       
  100                     ;;**************************;;
  101                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  102                     ;;       PRG ROM DATA       ;;
  103                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  104                     ;;**************************;; 
  105                       
  106           0007        .bank 7
  107           E000        .org $E000
  108                     
#[2]   NameTables/Tables.asm
  109                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  12 E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  32 E0     
       07:E004  52 E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  72 E0       .word Title_Screen, Game_Screen, GameOver_Screen
       07:E008  72 E8     
       07:E00A  72 EC     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  72 E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  72 F0     
       07:E010  72 F0     
   12                     
   13  07:E012            Title_Palette:
   14                     
   15  07:E012              .incbin "NameTables/Title_PAL.pal"
   16  07:E022              .incbin "NameTables/Title_PAL.pal"
   17                       
   18  07:E032            Game_Palette:
   19                     
   20  07:E032              .incbin "NameTables/Game_PAL.pal"
   21  07:E042              .incbin "NameTables/Game_PAL.pal"
   22                       
   23  07:E052            GameOver_Palette:
   24                     
   25  07:E052              .incbin "NameTables/GameOver_PAL.pal"
   26  07:E062              .incbin "NameTables/GameOver_PAL.pal"
   27                       
   28  07:E072            Title_Screen:
   29                     
   30  07:E072              .incbin "NameTables/Title_NT.nam"
   31                       
   32  07:E472            Title_Second:
   33                     
   34  07:E472              .incbin "NameTables/Title_PuzzMen_NT.nam"
   35                       
   36  07:E872            Game_Screen: 
   37                     
   38  07:E872              .incbin "NameTables/Game_NT.nam"
   39                       
   40  07:EC72            GameOver_Screen:
   41                     
   42  07:EC72              .incbin "NameTables/GameOver_NT.nam"
   43                       
   44  07:F072            Blank_Screen:
   45                     
   46  07:F072              .incbin "NameTables/Blank_NT.nam"
   47                     
   48                       
   49                     
   50                       
   51                      
   52                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  110                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:F472            Sprites:
   38  07:F472  78 F4             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:F474  81 F4     
       07:F476  86 F4     
   39                     
   40  07:F478            Title_Sprites:
   41  07:F478  02            .db $02
   42  07:F479  85 00 00          .db $85,$00,$00,$E8
       07:F47C  E8        
   43  07:F47D  A0 01 00          .db $A0,$01,$00,$60
       07:F480  60        
   44  07:F481            Game_Sprites:
   45  07:F481  01            .db $01
   46  07:F482  62 00 03          .db $62,$00,$03,$72
       07:F485  72        
   47  07:F486            GameOver_Sprites:
   48  07:F486  01                .db $01
   49  07:F487  00 00 00          .db $00,$00,$00,$00
       07:F48A  00        
#[1]   Picross.asm
  111                     
  112           FFFA        .org $FFFA     ;first of the three vectors starts here
  113  07:FFFA  68 CD       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  114                                        ;processor will jump to the label NMI:
  115  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  116                                        ;to the label RESET:
  117  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  118                       
  119                     ;;**************************;;
  120                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  121                     ;;      CHR ROM DATA        ;;
  122                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  123                     ;;**************************;; 
  124                       
  125           0008        .bank 8
  126           0000        .org $0000
  127  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  128                       
  129           0009        .bank 9
  130           0000        .org $0000
  131  09:0000              .incbin "CHRROM/Bank1.chr"
  132                       
  133           000A        .bank 10
  134           0000        .org $0000
  135  0A:0000              .incbin "CHRROM/Bank2.chr"
  136                       
  137           000B        .bank 11
  138           0000        .org $0000
  139  0B:0000              .incbin "CHRROM/Bank3.chr"
