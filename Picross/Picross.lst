#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      temp5                   .rs 1
    6           0005      temp6                   .rs 1
    7           0006      tempx                   .rs 1
    8           0007      tempy                   .rs 1
    9           0008      time                    .rs 1
   10           0009      sleeping                .rs 1
   11           000A      mode_loadFlags  .rs 1
   12           000B      game_mode               .rs 1
   13           000C      mode_state              .rs 1
   14           000D      NMI_locks               .rs 1
   15           000E      game_locks              .rs 1
   16           000F      pointer_address .rs 2
   17           0011      table_address   .rs 2
   18           0013      jump_address    .rs 2
   19                     
   20                     ;game modes
   21           0000      TITLE_IDX = $00
   22           0001      GAME_IDX = $01
   23           0002      GAMEOVER_IDX = $02
   24                     
   25                     ;locks for input and rendering
   26           0001      BGLOAD_NMI_LOCK = %00000001
   27           0001      EFFECT_GAME_LOCK = %00000001
   28                     
   29                     
   30                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           0015      gamepad                 .rs 1
   19           0016      gamepadLast     .rs 1
   20           0017      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           0018      PPU_Control                     .rs 1
    2           0019      PPU_Mask                        .rs 1
    3           001A      PPU_ScrollX                     .rs 1
    4           001B      PPU_ScrollY                     .rs 1
    5           001C      PPU_ScrollNT            .rs 1   ;first two bits
    6           001D      PPU_NT                          .rs 1
    7                     
    8           001E      PPU_PendingWrite        .rs 1
    9           001F      PPU_StringIdx           .rs 1
   10           0020      PPU_String                      .rs 128
   11                     
   12           004F      PPU_STRINGMAX = $4F ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           00A0      mapper_address  .rs 2
    2           00A2      currentCHRBankA .rs 1
    3           00A3      currentCHRBankB .rs 1
    4           00A4      currentPRGBank  .rs 1
    5           00A5      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           A000      PUZZLE_TABLE = $A000
    2           A01B      NAMES_TABLE = $A01B
    3           A036      SPRITES_TABLE = $A036
    4                     
    5           00A6      puzzle_address          .rs 2
    6           00A8      clues_address           .rs 2
    7           00AA      pause_address           .rs 2
    8           00AC      copy_address        .rs 2
    9           00AE      pause_draw_address  .rs 2
   10           00B0      clue_start_address      .rs 2
   11           00B2      clue_draw_address       .rs 2
   12           00B4      clueTableIndex          .rs 1
   13           00B5      clueLineIndex           .rs 1
   14           00B6      clueOffsetShift         .rs 1
   15           00B7      clueDrawAdd                     .rs 1
   16           00B8      clueDrawOffset          .rs 2
   17           00BA      clueDrawDecSize         .rs 1
   18           00BB      clueParity                      .rs 1
   19           00BC      mouse_location          .rs 2
   20           00BE      mouse_index                     .rs 2
   21           00C0      currentPaintTile        .rs 1
   22           00C1      solutionCount           .rs 1
   23           00C2      nonSolutionCount        .rs 1
   24           00C3      pauseState                      .rs 1
   25           00C4      holdTimer                       .rs 1
   26           00C5      GameTime                        .rs 4   ;in order - second, ten second, minute, 10 minute - max out at 99 minutes
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/ScreenStateVariables.asm
   18                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   19           7000        .rsset $7000
#[3]   Defines/SaveVariables.asm
   20                       .include "Defines/SaveVariables.asm"
    1           7000      bank_index      .rs 1
    2           7001      puzzle_index .rs 1
    3                     ;we can save these for the continue
    4                     ;we'll save out data for the puzzles- just need to know if it's 1) complete and 2) the time
    5                     ;we can do that in 4 bytes each, so 324 bytes
    6           7002      puzzle_clear_data .rs 324
    7                     
#[2]   Defines/Defines.asm
   21                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1                     
    2                     
    3           0000        .bank 0
    4           8000        .org $8000
    5                       
#[3]   Puzzles/house.asm
    6                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  03 82 00    .db $03, $82, $00, $21
       00:8003  21        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  05 11 18    .db $05, $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1E 1C 0E  
       00:80B6  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test.asm
    7                       .include "Puzzles/test.asm"
    1  00:80B7            test:
    2  00:80B7  03 01 00    .db $03, $01, $00, $00
       00:80BA  00        
    3  00:80BB  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:80BE  00 00 00  
       00:80C1  00 00 00  
       00:80C4  00 00 00  
       00:80C7  00 00 00  
       00:80CA  00 00 00  
       00:80CD  00 00 00  
       00:80D0  00 00 00  
       00:80D3  00 00 00  
       00:80D6  00 00 00  
    4  00:80D9  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80DC  FF 00 FF  
       00:80DF  00 FF 00  
       00:80E2  FF 00 FF  
       00:80E5  00 FF 00  
       00:80E8  FF 00 FF  
       00:80EB  00 FF 00  
       00:80EE  FF 00 FF  
       00:80F1  00 FF 00  
       00:80F4  FF 00 FF  
    5  00:80F7  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80FA  FF 00 FF  
       00:80FD  00 FF 00  
       00:8100  FF 00 FF  
       00:8103  00 FF 00  
       00:8106  FF 00 FF  
       00:8109  00 FF 00  
       00:810C  FF 00 FF  
       00:810F  00 FF 00  
       00:8112  FF 00 FF  
    6  00:8115            testImage:
    7  00:8115  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8118  1B 1B 1B  
       00:811B  1B 1B 1B  
       00:811E  1B 1B 1B  
       00:8121  1B 1B 1B  
       00:8124  1B 1B 1B  
       00:8127  1B 1B 1B  
       00:812A  1B 1B 1B  
       00:812D  1B 1B 1B  
       00:8130  1B 1B 1B  
       00:8133  1B 1B 1B  
       00:8136  1B 1B 1B  
       00:8139  1B 1B 1B  
       00:813C  1B 1B 1B  
       00:813F  1B 1B 1B  
       00:8142  1B 1B 1B  
       00:8145  1B 1B 1B  
       00:8148  1B 1B 1B  
       00:814B  1B 1B 00  
       00:814E  FF        
    8  00:814F            testName:
    9  00:814F  04 1D 0E    .db $04, $1D, $0E, $1C, $1D, $FF
       00:8152  1C 1D FF  
#[2]   Banks/Bank0.asm
    8                     
    9           0001        .bank 1
   10           A000        .org $A000
   11                     ;puzzles
   12  01:A000  00 80       .word house, test, test, test, test, test, test, test, test
       01:A002  B7 80     
       01:A004  B7 80     
       01:A006  B7 80     
       01:A008  B7 80     
       01:A00A  B7 80     
       01:A00C  B7 80     
       01:A00E  B7 80     
       01:A010  B7 80     
   13  01:A012  00 80       .word house, test, test, test, test, test, test, test, test
       01:A014  B7 80     
       01:A016  B7 80     
       01:A018  B7 80     
       01:A01A  B7 80     
       01:A01C  B7 80     
       01:A01E  B7 80     
       01:A020  B7 80     
       01:A022  B7 80     
   14  01:A024  00 80       .word house, test, test, test, test, test, test, test, test
       01:A026  B7 80     
       01:A028  B7 80     
       01:A02A  B7 80     
       01:A02C  B7 80     
       01:A02E  B7 80     
       01:A030  B7 80     
       01:A032  B7 80     
       01:A034  B7 80     
   15                     ;puzzle names
   16  01:A036  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A038  4F 81     
       01:A03A  4F 81     
       01:A03C  4F 81     
       01:A03E  4F 81     
       01:A040  4F 81     
       01:A042  4F 81     
       01:A044  4F 81     
       01:A046  4F 81     
   17  01:A048  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A04A  4F 81     
       01:A04C  4F 81     
       01:A04E  4F 81     
       01:A050  4F 81     
       01:A052  4F 81     
       01:A054  4F 81     
       01:A056  4F 81     
       01:A058  4F 81     
   18  01:A05A  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A05C  4F 81     
       01:A05E  4F 81     
       01:A060  4F 81     
       01:A062  4F 81     
       01:A064  4F 81     
       01:A066  4F 81     
       01:A068  4F 81     
       01:A06A  4F 81     
   19                     ;puzzle sprites
   20  01:A06C  00 00 00    .db $00, $00, $00, $00
       01:A06F  00        
   21  01:A070  00 00 00    .db $00, $00, $00, $00
       01:A073  00        
   22  01:A074  00 00 00    .db $00, $00, $00, $00
       01:A077  00        
   23  01:A078  00 00 00    .db $00, $00, $00, $00
       01:A07B  00        
   24  01:A07C  00 00 00    .db $00, $00, $00, $00
       01:A07F  00        
   25  01:A080  00 00 00    .db $00, $00, $00, $00
       01:A083  00        
   26  01:A084  00 00 00    .db $00, $00, $00, $00
       01:A087  00        
   27  01:A088  00 00 00    .db $00, $00, $00, $00
       01:A08B  00        
   28  01:A08C  00 00 00    .db $00, $00, $00, $00
       01:A08F  00        
   29  01:A090  00 00 00    .db $00, $00, $00, $00
       01:A093  00        
   30  01:A094  00 00 00    .db $00, $00, $00, $00
       01:A097  00        
   31  01:A098  00 00 00    .db $00, $00, $00, $00
       01:A09B  00        
   32  01:A09C  00 00 00    .db $00, $00, $00, $00
       01:A09F  00        
   33  01:A0A0  00 00 00    .db $00, $00, $00, $00
       01:A0A3  00        
   34  01:A0A4  00 00 00    .db $00, $00, $00, $00
       01:A0A7  00        
   35  01:A0A8  00 00 00    .db $00, $00, $00, $00
       01:A0AB  00        
   36  01:A0AC  00 00 00    .db $00, $00, $00, $00
       01:A0AF  00        
   37  01:A0B0  00 00 00    .db $00, $00, $00, $00
       01:A0B3  00        
   38  01:A0B4  00 00 00    .db $00, $00, $00, $00
       01:A0B7  00        
   39  01:A0B8  00 00 00    .db $00, $00, $00, $00
       01:A0BB  00        
   40  01:A0BC  00 00 00    .db $00, $00, $00, $00
       01:A0BF  00        
   41  01:A0C0  00 00 00    .db $00, $00, $00, $00
       01:A0C3  00        
   42  01:A0C4  00 00 00    .db $00, $00, $00, $00
       01:A0C7  00        
   43  01:A0C8  00 00 00    .db $00, $00, $00, $00
       01:A0CB  00        
   44  01:A0CC  00 00 00    .db $00, $00, $00, $00
       01:A0CF  00        
   45  01:A0D0  00 00 00    .db $00, $00, $00, $00
       01:A0D3  00        
   46  01:A0D4  00 00 00    .db $00, $00, $00, $00
       01:A0D7  00        
   47                       
   48                       
   49           BFFA        .org $BFFA     ;first of the three vectors starts here
   50  01:BFFA  F4 CE       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   51                                        ;processor will jump to the label NMI:
   52  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   53                                        ;to the label RESET:
   54  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  03 62 00    .db $03, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  04 0F 1B    .db $04, $0F, $1B, $18, $10, $FF
       02:80A7  18 10 FF  
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                      
    9                     ;puzzles
   10  03:A000  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A002  00 80     
       03:A004  00 80     
       03:A006  00 80     
       03:A008  00 80     
       03:A00A  00 80     
       03:A00C  00 80     
       03:A00E  00 80     
       03:A010  00 80     
   11  03:A012  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A014  00 80     
       03:A016  00 80     
       03:A018  00 80     
       03:A01A  00 80     
       03:A01C  00 80     
       03:A01E  00 80     
       03:A020  00 80     
       03:A022  00 80     
   12  03:A024  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A026  00 80     
       03:A028  00 80     
       03:A02A  00 80     
       03:A02C  00 80     
       03:A02E  00 80     
       03:A030  00 80     
       03:A032  00 80     
       03:A034  00 80     
   13                     ;puzzle names
   14  03:A036  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A038  A4 80     
       03:A03A  A4 80     
       03:A03C  A4 80     
       03:A03E  A4 80     
       03:A040  A4 80     
       03:A042  A4 80     
       03:A044  A4 80     
       03:A046  A4 80     
   15  03:A048  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A04A  A4 80     
       03:A04C  A4 80     
       03:A04E  A4 80     
       03:A050  A4 80     
       03:A052  A4 80     
       03:A054  A4 80     
       03:A056  A4 80     
       03:A058  A4 80     
   16  03:A05A  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A05C  A4 80     
       03:A05E  A4 80     
       03:A060  A4 80     
       03:A062  A4 80     
       03:A064  A4 80     
       03:A066  A4 80     
       03:A068  A4 80     
       03:A06A  A4 80     
   17                     ;puzzle sprites
   18  03:A06C  00 00 00    .db $00, $00, $00, $00
       03:A06F  00        
   19  03:A070  00 00 00    .db $00, $00, $00, $00
       03:A073  00        
   20  03:A074  00 00 00    .db $00, $00, $00, $00
       03:A077  00        
   21  03:A078  00 00 00    .db $00, $00, $00, $00
       03:A07B  00        
   22  03:A07C  00 00 00    .db $00, $00, $00, $00
       03:A07F  00        
   23  03:A080  00 00 00    .db $00, $00, $00, $00
       03:A083  00        
   24  03:A084  00 00 00    .db $00, $00, $00, $00
       03:A087  00        
   25  03:A088  00 00 00    .db $00, $00, $00, $00
       03:A08B  00        
   26  03:A08C  00 00 00    .db $00, $00, $00, $00
       03:A08F  00        
   27  03:A090  00 00 00    .db $00, $00, $00, $00
       03:A093  00        
   28  03:A094  00 00 00    .db $00, $00, $00, $00
       03:A097  00        
   29  03:A098  00 00 00    .db $00, $00, $00, $00
       03:A09B  00        
   30  03:A09C  00 00 00    .db $00, $00, $00, $00
       03:A09F  00        
   31  03:A0A0  00 00 00    .db $00, $00, $00, $00
       03:A0A3  00        
   32  03:A0A4  00 00 00    .db $00, $00, $00, $00
       03:A0A7  00        
   33  03:A0A8  00 00 00    .db $00, $00, $00, $00
       03:A0AB  00        
   34  03:A0AC  00 00 00    .db $00, $00, $00, $00
       03:A0AF  00        
   35  03:A0B0  00 00 00    .db $00, $00, $00, $00
       03:A0B3  00        
   36  03:A0B4  00 00 00    .db $00, $00, $00, $00
       03:A0B7  00        
   37  03:A0B8  00 00 00    .db $00, $00, $00, $00
       03:A0BB  00        
   38  03:A0BC  00 00 00    .db $00, $00, $00, $00
       03:A0BF  00        
   39  03:A0C0  00 00 00    .db $00, $00, $00, $00
       03:A0C3  00        
   40  03:A0C4  00 00 00    .db $00, $00, $00, $00
       03:A0C7  00        
   41  03:A0C8  00 00 00    .db $00, $00, $00, $00
       03:A0CB  00        
   42  03:A0CC  00 00 00    .db $00, $00, $00, $00
       03:A0CF  00        
   43  03:A0D0  00 00 00    .db $00, $00, $00, $00
       03:A0D3  00        
   44  03:A0D4  00 00 00    .db $00, $00, $00, $00
       03:A0D7  00        
   45                       
   46                       
   47           BFFA        .org $BFFA     ;first of the three vectors starts here
   48  03:BFFA  F4 CE       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   49                                        ;processor will jump to the label NMI:
   50  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   51                                        ;to the label RESET:
   52  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  03 7E 00    .db $03, $7E, $00, $2B
       04:8003  2B        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  03 0C 0A    .db $03, $0C, $0A, $1D, $FF
       04:80A5  1D FF     
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8                       
    9                     ;puzzles
   10  05:A000  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A002  00 80     
       05:A004  00 80     
       05:A006  00 80     
       05:A008  00 80     
       05:A00A  00 80     
       05:A00C  00 80     
       05:A00E  00 80     
       05:A010  00 80     
   11  05:A012  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A014  00 80     
       05:A016  00 80     
       05:A018  00 80     
       05:A01A  00 80     
       05:A01C  00 80     
       05:A01E  00 80     
       05:A020  00 80     
       05:A022  00 80     
   12  05:A024  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat
       05:A026  00 80     
       05:A028  00 80     
       05:A02A  00 80     
       05:A02C  00 80     
       05:A02E  00 80     
       05:A030  00 80     
       05:A032  00 80     
       05:A034  00 80     
   13                     ;puzzle names
   14  05:A036  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A038  A2 80     
       05:A03A  A2 80     
       05:A03C  A2 80     
       05:A03E  A2 80     
       05:A040  A2 80     
       05:A042  A2 80     
       05:A044  A2 80     
       05:A046  A2 80     
   15  05:A048  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A04A  A2 80     
       05:A04C  A2 80     
       05:A04E  A2 80     
       05:A050  A2 80     
       05:A052  A2 80     
       05:A054  A2 80     
       05:A056  A2 80     
       05:A058  A2 80     
   16  05:A05A  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName
       05:A05C  A2 80     
       05:A05E  A2 80     
       05:A060  A2 80     
       05:A062  A2 80     
       05:A064  A2 80     
       05:A066  A2 80     
       05:A068  A2 80     
       05:A06A  A2 80     
   17                     ;puzzle sprites
   18  05:A06C  00 00 00    .db $00, $00, $00, $00
       05:A06F  00        
   19  05:A070  00 00 00    .db $00, $00, $00, $00
       05:A073  00        
   20  05:A074  00 00 00    .db $00, $00, $00, $00
       05:A077  00        
   21  05:A078  00 00 00    .db $00, $00, $00, $00
       05:A07B  00        
   22  05:A07C  00 00 00    .db $00, $00, $00, $00
       05:A07F  00        
   23  05:A080  00 00 00    .db $00, $00, $00, $00
       05:A083  00        
   24  05:A084  00 00 00    .db $00, $00, $00, $00
       05:A087  00        
   25  05:A088  00 00 00    .db $00, $00, $00, $00
       05:A08B  00        
   26  05:A08C  00 00 00    .db $00, $00, $00, $00
       05:A08F  00        
   27  05:A090  00 00 00    .db $00, $00, $00, $00
       05:A093  00        
   28  05:A094  00 00 00    .db $00, $00, $00, $00
       05:A097  00        
   29  05:A098  00 00 00    .db $00, $00, $00, $00
       05:A09B  00        
   30  05:A09C  00 00 00    .db $00, $00, $00, $00
       05:A09F  00        
   31  05:A0A0  00 00 00    .db $00, $00, $00, $00
       05:A0A3  00        
   32  05:A0A4  00 00 00    .db $00, $00, $00, $00
       05:A0A7  00        
   33  05:A0A8  00 00 00    .db $00, $00, $00, $00
       05:A0AB  00        
   34  05:A0AC  00 00 00    .db $00, $00, $00, $00
       05:A0AF  00        
   35  05:A0B0  00 00 00    .db $00, $00, $00, $00
       05:A0B3  00        
   36  05:A0B4  00 00 00    .db $00, $00, $00, $00
       05:A0B7  00        
   37  05:A0B8  00 00 00    .db $00, $00, $00, $00
       05:A0BB  00        
   38  05:A0BC  00 00 00    .db $00, $00, $00, $00
       05:A0BF  00        
   39  05:A0C0  00 00 00    .db $00, $00, $00, $00
       05:A0C3  00        
   40  05:A0C4  00 00 00    .db $00, $00, $00, $00
       05:A0C7  00        
   41  05:A0C8  00 00 00    .db $00, $00, $00, $00
       05:A0CB  00        
   42  05:A0CC  00 00 00    .db $00, $00, $00, $00
       05:A0CF  00        
   43  05:A0D0  00 00 00    .db $00, $00, $00, $00
       05:A0D3  00        
   44  05:A0D4  00 00 00    .db $00, $00, $00, $00
       05:A0D7  00        
   45                     
   46           BFFA        .org $BFFA     ;first of the three vectors starts here
   47  05:BFFA  F4 CE       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   48                                        ;processor will jump to the label NMI:
   49  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   50                                        ;to the label RESET:
   51  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 69 CB    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 6D CB    JSR SetMapperControls
   34                       
   35  06:C040  20 AA CB    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  A2 00       LDX #$00
   38  06:C04C  20 64 C8    JSR ChangeGameMode
   39  06:C04F  20 EE CA    JSR InitPPUControl
   40                       
   41                     
   42                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   43                     ;;     Main Program         ;;
   44                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   45                     
   46  06:C052            Forever:
   47                     
   48  06:C052  EE 09 00    INC sleeping
   49                     
   50  06:C055            .loop
   51  06:C055  AD 09 00    LDA sleeping
   52  06:C058  D0 FB       BNE .loop
   53                     
   54  06:C05A  EE 08 00    INC time  
   55  06:C05D  20 63 C0    JSR GameLoop
   56                     
   57                     
   58  06:C060  4C 52 C0    JMP Forever     ;jump back to Forever, infinite loop
   59                       
   60                     ;; dynamic jump table
   61                     
   62  06:C063            GameLoop:
   63                     
   64                       MACROCallDynamicJump game_mode
                          
       06:C063  AD 0B 00    LDA game_mode
       06:C066  20 21 C9    JSR Dynamic_Jump
                                  
   65                       ;; we'll pop the return address here as the table index, so 
   66                       ;; the routine we pick will return us to whatever called Game Loop
   67                       ;; when it returns
   68                     
   69  06:C069            GameLoopJumpTable:
   70                     
   71  06:C069  6F C0       .word UpdateTitle
   72  06:C06B  66 C2       .word UpdateGame
   73  06:C06D  13 C8       .word UpdateGameOver
   74                       
   75                     
   76                       ;;RTS is called in the subroutine
   77                     
   78                       
#[2]   Routines/Game_States/UpdateTitle.asm
   79                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C06F            UpdateTitle:
    2                     
    3  06:C06F  AD 0D 00    LDA NMI_locks
    4  06:C072  F0 01       BEQ .unlocked
    5                       
    6  06:C074  60          RTS
    7                       
    8  06:C075            .unlocked:
    9                     
   10  06:C075  20 79 C0    JSR DoUpdateTitle  
   11  06:C078  60          RTS
   12                       
   13  06:C079            DoUpdateTitle:
   14                     
   15  06:C079  AD 0C 00    LDA mode_state
   16  06:C07C  20 21 C9    JSR Dynamic_Jump
   17                         
   18  06:C07F            UpdateTitleJumpTable:
   19                     
   20  06:C07F  8B C0       .word UpdateTitleInit
   21  06:C081  9C C0       .word UpdateBankSelection
   22  06:C083  B5 C0       .word UpdateScroll
   23  06:C085  D7 C0       .word UpdatePuzzleSelection
   24  06:C087  18 C1       .word UpdateScrollBack
   25  06:C089  35 C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C08B            UpdateTitleInit:
   35                     
   36  06:C08B  20 CA CA    JSR TurnOnSprites
   37                       
   38  06:C08E  A9 00       LDA #$00
   39  06:C090  8D BE 00    STA mouse_index
   40  06:C093  A9 00       LDA #$00
   41  06:C095  8D BF 00    STA mouse_index+1
   42                     
   43  06:C098            .changeModeState:
   44                     
   45  06:C098  EE 0C 00    INC mode_state
   46  06:C09B            .leave:
   47  06:C09B  60          RTS
   48                       
   49  06:C09C            UpdateBankSelection:
   50                     
   51  06:C09C  20 BE C1    JSR UpdateBankPointer
   52                       
   53  06:C09F  AD 17 00    LDA gamepadPressed
   54  06:C0A2  29 01       AND #GAMEPAD_A
   55  06:C0A4  F0 0E       BEQ .leave
   56                       
   57  06:C0A6            .changeModeState:
   58                     
   59  06:C0A6  AD BE 00    LDA mouse_index
   60  06:C0A9  8D 00 70    STA bank_index
   61  06:C0AC  A9 FF       LDA #$FF
   62  06:C0AE  20 A6 C1    JSR SetPointerSprite
   63                       
   64  06:C0B1  EE 0C 00    INC mode_state
   65  06:C0B4            .leave:
   66  06:C0B4  60          RTS
   67                       
   68  06:C0B5            UpdateScroll:
   69  06:C0B5  EE 1A 00    INC PPU_ScrollX
   70  06:C0B8  EE 1A 00    INC PPU_ScrollX
   71  06:C0BB  EE 1A 00    INC PPU_ScrollX
   72  06:C0BE  EE 1A 00    INC PPU_ScrollX
   73  06:C0C1  D0 13       BNE .leave
   74  06:C0C3  AD 1C 00    LDA PPU_ScrollNT
   75  06:C0C6  49 01       EOR #%00000001
   76  06:C0C8  8D 1C 00    STA PPU_ScrollNT
   77                       
   78  06:C0CB            .changeModeState:
   79  06:C0CB  A9 01       LDA #$01
   80  06:C0CD  20 A6 C1    JSR SetPointerSprite
   81  06:C0D0  20 6C C1    JSR InitPuzzlePointer
   82  06:C0D3  EE 0C 00    INC mode_state
   83  06:C0D6            .leave:
   84  06:C0D6  60          RTS
   85                       
   86  06:C0D7            UpdatePuzzleSelection:
   87                     
   88  06:C0D7  20 FB C1    JSR UpdatePuzzlePointer
   89                       
   90  06:C0DA  AD 17 00    LDA gamepadPressed
   91  06:C0DD  29 02       AND #GAMEPAD_B
   92  06:C0DF  D0 10       BNE .changeToScrollBack
   93  06:C0E1  AD 17 00    LDA gamepadPressed
   94  06:C0E4  29 09       AND #GAMEPAD_CONFIRM
   95  06:C0E6  F0 2F       BEQ .leave
   96                       
   97  06:C0E8  EE 0C 00    INC mode_state
   98  06:C0EB  EE 0C 00    INC mode_state
   99  06:C0EE  4C 17 C1    JMP .leave
  100                       
  101  06:C0F1            .changeToScrollBack:
  102                      
  103  06:C0F1  A9 FF       LDA #$FF
  104  06:C0F3  20 A6 C1    JSR SetPointerSprite
  105  06:C0F6  20 64 C1    JSR InitBankPointer
  106  06:C0F9  AD 00 70    LDA bank_index
  107  06:C0FC  8D BE 00    STA mouse_index
  108  06:C0FF  20 F0 C1    JSR SetBankPointerFromIndex
  109                       
  110  06:C102  A9 00       LDA #$00
  111  06:C104  8D 1B 00    STA PPU_ScrollY
  112  06:C107  A9 FC       LDA #$FC
  113  06:C109  8D 1A 00    STA PPU_ScrollX
  114  06:C10C  AD 1C 00    LDA PPU_ScrollNT
  115  06:C10F  29 FE       AND #$FE
  116  06:C111  8D 1C 00    STA PPU_ScrollNT
  117                       
  118  06:C114  EE 0C 00    INC mode_state
  119  06:C117            .leave:
  120  06:C117  60          RTS
  121                       
  122  06:C118            UpdateScrollBack:
  123                     
  124  06:C118  CE 1A 00    DEC PPU_ScrollX
  125  06:C11B  CE 1A 00    DEC PPU_ScrollX
  126  06:C11E  CE 1A 00    DEC PPU_ScrollX
  127  06:C121  CE 1A 00    DEC PPU_ScrollX
  128  06:C124  D0 0E       BNE .leave
  129                       
  130  06:C126            .changeModeState:
  131                     
  132  06:C126  A9 01       LDA #$01
  133  06:C128  20 A6 C1    JSR SetPointerSprite
  134  06:C12B  CE 0C 00    DEC mode_state
  135  06:C12E  CE 0C 00    DEC mode_state
  136  06:C131  CE 0C 00    DEC mode_state
  137                       
  138  06:C134            .leave:
  139  06:C134  60          RTS
  140                       
  141  06:C135            UpdateTitleExit:
  142                     
  143                       ;;reset screen scroll
  144  06:C135  A9 00       LDA #$00
  145  06:C137  8D 1A 00    STA PPU_ScrollX
  146  06:C13A  8D 1C 00    STA PPU_ScrollNT
  147                       
  148                       ;;load bank
  149                     
  150  06:C13D  20 69 CB    JSR ResetMapper
  151  06:C140  AD 00 70    LDA bank_index
  152  06:C143  8D A4 00    STA currentPRGBank
  153  06:C146  20 78 CB    JSR LoadPRGBank
  154                     
  155                       ;; we can also pick out the puzzle index
  156                       ;; we have the mouse indexes - one vert, one hori
  157                       ;; take vert, mult by 9- alternatively, mult by 8, add index 
  158                       ;; IE - ind = 1, mult 8 = 8, add 1 = 9
  159                       ;; add X index
  160  06:C149  AD BE 00    LDA mouse_index
  161  06:C14C  0A          ASL A
  162  06:C14D  0A          ASL A
  163  06:C14E  0A          ASL A
  164  06:C14F  18          CLC
  165  06:C150  6D BE 00    ADC mouse_index
  166  06:C153  6D BF 00    ADC mouse_index+1
  167  06:C156  8D 01 70    STA puzzle_index
  168                     
  169  06:C159  20 D3 CA    JSR TurnOffSprites
  170                     
  171  06:C15C  A9 01       LDA #GAME_IDX
  172  06:C15E  A2 02       LDX #$02
  173  06:C160  20 64 C8    JSR ChangeGameMode
  174                       
  175  06:C163            .leave
  176  06:C163  60          RTS
  177                       
  178  06:C164            InitBankPointer:
  179                     
  180  06:C164  A2 A0       LDX #$A0
  181  06:C166  A9 60       LDA #$60
  182  06:C168  20 7F C1    JSR InitPointer
  183                       
  184  06:C16B  60          RTS  
  185                       
  186  06:C16C            InitPuzzlePointer:
  187                       
  188  06:C16C  A2 AE       LDX #$AE
  189  06:C16E  A9 10       LDA #$10
  190  06:C170  20 7F C1    JSR InitPointer
  191                       
  192  06:C173  60          RTS
  193                     
  194  06:C174            ResetMouseIndex:
  195                     
  196  06:C174  A9 00       LDA #$00
  197  06:C176  8D BE 00    STA mouse_index
  198  06:C179  A9 00       LDA #$00
  199  06:C17B  8D BF 00    STA mouse_index+1
  200  06:C17E  60          RTS
  201                     
  202  06:C17F            InitPointer:
  203                     
  204  06:C17F  20 86 C1    JSR SetPointerPosition
  205  06:C182  20 74 C1    JSR ResetMouseIndex
  206  06:C185  60          RTS  
  207                       
  208  06:C186            SetPointerPosition:
  209                     
  210  06:C186  48          PHA
  211  06:C187  8A          TXA
  212  06:C188  20 90 C1    JSR SetPointerYPosition
  213  06:C18B  68          PLA
  214  06:C18C  20 9B C1    JSR SetPointerXPosition
  215                      
  216  06:C18F  60          RTS
  217                       
  218  06:C190            SetPointerYPosition:
  219                       
  220  06:C190  48          PHA
  221  06:C191  A9 00       LDA #SPRITE_YPOS
  222  06:C193  20 B1 C1    JSR GetPointerDataIndexInX
  223  06:C196  68          PLA
  224  06:C197  9D 00 02    STA SPRITE_DATA, x
  225  06:C19A  60          RTS
  226                       
  227  06:C19B            SetPointerXPosition:  
  228                       
  229  06:C19B  48          PHA
  230  06:C19C  A9 03       LDA #SPRITE_XPOS
  231  06:C19E  20 B1 C1    JSR GetPointerDataIndexInX
  232  06:C1A1  68          PLA
  233  06:C1A2  9D 00 02    STA SPRITE_DATA, x 
  234  06:C1A5  60          RTS
  235                     
  236  06:C1A6            SetPointerSprite:
  237                     
  238                     ;; A has aprite we want
  239  06:C1A6  48          PHA
  240  06:C1A7  A9 01       LDA #SPRITE_ID
  241  06:C1A9  20 B1 C1    JSR GetPointerDataIndexInX
  242  06:C1AC  68          PLA
  243  06:C1AD  9D 00 02    STA SPRITE_DATA, x
  244  06:C1B0  60          RTS
  245                       
  246  06:C1B1            GetPointerDataIndexInX:
  247                     
  248  06:C1B1  8D 02 00    STA temp3
  249  06:C1B4  A9 01       LDA #$01
  250  06:C1B6  0A          ASL A
  251  06:C1B7  0A          ASL A
  252  06:C1B8  18          CLC
  253  06:C1B9  6D 02 00    ADC temp3
  254  06:C1BC  AA          TAX
  255                       
  256  06:C1BD  60          RTS
  257                       
  258                       
  259  06:C1BE            UpdateBankPointer:
  260                      
  261                       ;;bank pointer is 1D, will loop between 0->3
  262  06:C1BE  AD 17 00    LDA gamepadPressed
  263  06:C1C1  D0 01       BNE .continue
  264  06:C1C3            .leaveEarly:
  265  06:C1C3  60          RTS
  266                       
  267  06:C1C4            .continue:
  268  06:C1C4  A9 00       LDA #$00
  269  06:C1C6  8D 00 00    STA temp1
  270                       
  271  06:C1C9            .parseInputs:
  272  06:C1C9  AD 17 00    LDA gamepadPressed
  273  06:C1CC  29 30       AND #GAMEPAD_VERT
  274  06:C1CE  F0 F3       BEQ .leaveEarly
  275  06:C1D0  0A          ASL A
  276  06:C1D1  0A          ASL A
  277  06:C1D2            .checkDown:
  278  06:C1D2  0A          ASL A
  279  06:C1D3  90 03       BCC .checkUp
  280  06:C1D5  EE 00 00    INC temp1
  281  06:C1D8            .checkUp:
  282  06:C1D8  0A          ASL A
  283  06:C1D9  90 03       BCC .move
  284  06:C1DB  CE 00 00    DEC temp1
  285  06:C1DE            .move:
  286                       
  287  06:C1DE  AD BE 00    LDA mouse_index
  288  06:C1E1  18          CLC
  289  06:C1E2  6D 00 00    ADC temp1
  290  06:C1E5  C9 02       CMP #$02
  291  06:C1E7  F0 04       BEQ .skipMod
  292  06:C1E9  90 02       BCC .skipMod
  293  06:C1EB  A9 00       LDA #$00
  294  06:C1ED            .skipMod:
  295  06:C1ED  8D BE 00    STA mouse_index
  296                       ;; mult mouse_index by 16
  297  06:C1F0            SetBankPointerFromIndex:
  298                     
  299  06:C1F0  0A          ASL A
  300  06:C1F1  0A          ASL A
  301  06:C1F2  0A          ASL A
  302  06:C1F3  0A          ASL A
  303  06:C1F4  18          CLC
  304  06:C1F5  69 A0       ADC #$A0
  305  06:C1F7  20 90 C1    JSR SetPointerYPosition
  306                     
  307  06:C1FA            .leave:
  308                       
  309  06:C1FA  60          RTS
  310                       
  311  06:C1FB            UpdatePuzzlePointer:
  312                     
  313                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  314  06:C1FB  AD 17 00    LDA gamepadPressed
  315  06:C1FE  F0 65       BEQ .leave 
  316                       
  317  06:C200  A9 00       LDA #$00
  318  06:C202  8D 00 00    STA temp1
  319  06:C205  8D 01 00    STA temp2
  320                       
  321  06:C208            .parseInputs:
  322  06:C208  AD 17 00    LDA gamepadPressed
  323  06:C20B  29 F0       AND #GAMEPAD_MOVE
  324  06:C20D  F0 56       BEQ .leave
  325  06:C20F  0A          ASL A
  326  06:C210  90 03       BCC .checkLeft
  327  06:C212  EE 00 00    INC temp1
  328  06:C215            .checkLeft:
  329  06:C215  0A          ASL A
  330  06:C216  90 03       BCC .checkDown
  331  06:C218  CE 00 00    DEC temp1
  332  06:C21B            .checkDown:
  333  06:C21B  0A          ASL A
  334  06:C21C  90 03       BCC .checkUp
  335  06:C21E  EE 01 00    INC temp2
  336  06:C221            .checkUp:
  337  06:C221  0A          ASL A
  338  06:C222  90 03       BCC .move
  339  06:C224  CE 01 00    DEC temp2
  340                       
  341  06:C227            .move:
  342                     
  343  06:C227  AD BE 00    LDA mouse_index
  344  06:C22A  18          CLC
  345  06:C22B  6D 01 00    ADC temp2
  346  06:C22E  C9 02       CMP #$02
  347  06:C230  F0 04       BEQ .skipYMod
  348  06:C232  90 02       BCC .skipYMod
  349  06:C234  A9 00       LDA #$00
  350  06:C236            .skipYMod:
  351  06:C236  8D BE 00    STA mouse_index
  352                       ;; mult mouse_index by 16
  353  06:C239  0A          ASL A
  354  06:C23A  0A          ASL A
  355  06:C23B  0A          ASL A
  356  06:C23C  0A          ASL A
  357  06:C23D  18          CLC
  358  06:C23E  69 AE       ADC #$AE
  359  06:C240  20 90 C1    JSR SetPointerYPosition
  360                       
  361  06:C243  AD BF 00    LDA mouse_index+1
  362  06:C246  18          CLC
  363  06:C247  6D 00 00    ADC temp1
  364  06:C24A  C9 08       CMP #$08
  365  06:C24C  F0 04       BEQ .skipXMod
  366  06:C24E  90 02       BCC .skipXMod
  367  06:C250  A9 00       LDA #$00
  368  06:C252            .skipXMod:
  369  06:C252  8D BF 00    STA mouse_index+1
  370                       ;; we need to move 3 tiles each- so index * 3 * 8,
  371  06:C255  18          CLC
  372  06:C256  6D BF 00    ADC mouse_index+1
  373  06:C259  6D BF 00    ADC mouse_index+1
  374  06:C25C  0A          ASL A
  375  06:C25D  0A          ASL A
  376  06:C25E  0A          ASL A
  377  06:C25F  18          CLC
  378  06:C260  69 10       ADC #$10
  379  06:C262  20 9B C1    JSR SetPointerXPosition
  380                       
  381  06:C265            .leave:
  382                       
  383  06:C265  60          RTS
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   80                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6           20A8      BANK_LEVEL = $20A8
    7           20E5      TIMER_LOC = $20E5
    8                     
    9                     ;;this will change with puzzle sizes
   10           005A      VERT_MIN = $5A ;12 - 1
   11           00DA      VERT_MAX = $DA
   12           006A      HORI_MIN = $6A ;14 - 1
   13           00EA      HORI_MAX = $EA
   14                     
   15           618E      MOUSE_START = $618E
   16                     
   17           0010      HOLD_TIME = $10
   18           0004      HOLD_FREQ = $04
   19                     
   20  06:C266            UpdateGame:
   21                     
   22  06:C266  AD 0D 00    LDA NMI_locks
   23  06:C269  F0 01       BEQ .unlocked
   24                       
   25  06:C26B  60          RTS
   26                       
   27  06:C26C            .unlocked:
   28                     
   29  06:C26C  20 70 C2    JSR DoUpdateGame
   30  06:C26F  60          RTS
   31                       
   32  06:C270            DoUpdateGame:
   33                     
   34  06:C270  AD 0C 00    LDA mode_state
   35  06:C273  20 21 C9    JSR Dynamic_Jump
   36                       
   37  06:C276            UpdateGameJumpTable:
   38                     
   39  06:C276  8A C2       .word UpdateGameInit
   40  06:C278  2A C3       .word UpdateDrawVertClues
   41  06:C27A  52 C3       .word UpdateDrawHoriClues
   42  06:C27C  95 C3       .word UpdateGamePlay
   43  06:C27E  4D C5       .word UpdateClearPuzzle
   44  06:C280  60 C5       .word UpdateMoveScreen
   45  06:C282  C6 C5       .word UpdateDrawImage
   46  06:C284  55 C6       .word UpdateWaitInput
   47  06:C286  63 C6       .word UpdateGameFadeOut
   48  06:C288  78 C6       .word UpdateGameExit
   49                     
   50  06:C28A            UpdateGameInit:
   51                     
   52                       ;; get the puzzle table in the puzzle address
   53                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C28A  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C28C  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C28E  8E 11 00          STX table_address
       06:C291  8D 12 00          STA table_address+1
                                  
   54                       MACROGetDoubleIndex puzzle_index
                          
       06:C294  AD 01 70          LDA puzzle_index
       06:C297  0A                ASL A
       06:C298  A8                TAY
                                  
   55  06:C299  20 47 C9    JSR GetTableAtIndex
   56                       MACROGetPointer table_address, puzzle_address
                          
       06:C29C  AD 11 00          LDA table_address
       06:C29F  8D A6 00          STA puzzle_address
       06:C2A2  AD 12 00          LDA table_address+1
       06:C2A5  8D A7 00          STA puzzle_address+1
                          
   57                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C2A8  A9 61             LDA #HIGH(MOUSE_START)
       06:C2AA  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C2AC  8E BC 00          STX mouse_location
       06:C2AF  8D BD 00          STA mouse_location+1
                                  
   58                       
   59                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   60  06:C2B2  AD A6 00    LDA puzzle_address
   61  06:C2B5  18          CLC
   62  06:C2B6  69 22       ADC #34
   63  06:C2B8  8D A8 00    STA clues_address
   64  06:C2BB  A9 00       LDA #$00
   65  06:C2BD  6D A7 00    ADC puzzle_address+1
   66  06:C2C0  8D A9 00    STA clues_address+1
   67                     
   68  06:C2C3  A9 00       LDA #$00
   69  06:C2C5  8D B4 00    STA clueTableIndex
   70  06:C2C8  8D B5 00    STA clueLineIndex
   71  06:C2CB  8D BB 00    STA clueParity
   72  06:C2CE  8D B6 00    STA clueOffsetShift
   73  06:C2D1  8D BE 00    STA mouse_index
   74  06:C2D4  8D BF 00    STA mouse_index+1
   75  06:C2D7  8D C1 00    STA solutionCount
   76  06:C2DA  8D C2 00    STA nonSolutionCount
   77  06:C2DD  8D C5 00    STA GameTime
   78  06:C2E0  8D C6 00    STA GameTime+1
   79  06:C2E3  8D C7 00    STA GameTime+2
   80  06:C2E6  8D C8 00    STA GameTime+3
   81                             
   82  06:C2E9  A9 20       LDA #$20
   83  06:C2EB  8D B7 00    STA clueDrawAdd
   84                        
   85                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C2EE  A9 21             LDA #HIGH(VERT_CLUES)
       06:C2F0  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C2F2  8E B0 00          STX clue_start_address
       06:C2F5  8D B1 00          STA clue_start_address+1
                                  
   86  06:C2F8  20 4F CC    JSR ResetClueDrawAddress
   87                       
   88                       MACROAddPPUStringEntryRawData #HIGH(BANK_LEVEL), #LOW(BANK_LEVEL), #DRAW_HORIZONTAL, #$03
                          
       06:C2FB  A9 01       LDA #$01
       06:C2FD  8D 1E 00    STA PPU_PendingWrite
       06:C300  A9 20       LDA #HIGH(BANK_LEVEL)
       06:C302  20 82 CA    JSR WriteToPPUString
       06:C305  A9 A8       LDA #LOW(BANK_LEVEL)
       06:C307  20 82 CA    JSR WriteToPPUString
       06:C30A  A9 00       LDA #DRAW_HORIZONTAL
       06:C30C  20 82 CA    JSR WriteToPPUString
       06:C30F  A9 03       LDA #$03 
       06:C311  20 82 CA    JSR WriteToPPUString
                            
   89  06:C314  AD 00 70    LDA bank_index
   90  06:C317  20 82 CA    JSR WriteToPPUString
   91  06:C31A  A9 60       LDA #$60
   92  06:C31C  20 82 CA    JSR WriteToPPUString
   93  06:C31F  AE 01 70    LDX puzzle_index
   94  06:C322  E8          INX
   95  06:C323  8A          TXA 
   96  06:C324  20 82 CA    JSR WriteToPPUString
   97                       
   98  06:C327  EE 0C 00    INC mode_state
   99                     
  100  06:C32A            UpdateDrawVertClues:
  101                       
  102  06:C32A  20 C0 CB    JSR PopulateClues
  103  06:C32D  90 22       BCC .leave
  104                       
  105  06:C32F            .changeModeState:
  106                     
  107  06:C32F  A9 00       LDA #$00
  108  06:C331  8D B5 00    STA clueLineIndex
  109  06:C334  8D BB 00    STA clueParity
  110                       
  111  06:C337  A9 05       LDA #$05
  112  06:C339  8D B6 00    STA clueOffsetShift
  113                       
  114  06:C33C  A9 01       LDA #$01
  115  06:C33E  8D B7 00    STA clueDrawAdd
  116                        
  117                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C341  A9 21             LDA #HIGH(HORI_CLUES)
       06:C343  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C345  8E B0 00          STX clue_start_address
       06:C348  8D B1 00          STA clue_start_address+1
                                  
  118  06:C34B  20 4F CC    JSR ResetClueDrawAddress
  119                     
  120  06:C34E  EE 0C 00    INC mode_state
  121  06:C351            .leave:
  122  06:C351  60          RTS
  123                       
  124  06:C352            UpdateDrawHoriClues:
  125                     
  126  06:C352  20 C0 CB    JSR PopulateClues
  127  06:C355  90 3D       BCC .leave
  128                     
  129  06:C357            .changeModeState:
  130  06:C357  20 CA CA    JSR TurnOnSprites
  131                       
  132                       ;;set the timer to 00
  133                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C35A  A9 01       LDA #$01
       06:C35C  8D 1E 00    STA PPU_PendingWrite
       06:C35F  A9 20       LDA #HIGH(TIMER_LOC)
       06:C361  20 82 CA    JSR WriteToPPUString
       06:C364  A9 E5       LDA #LOW(TIMER_LOC)
       06:C366  20 82 CA    JSR WriteToPPUString
       06:C369  A9 00       LDA #DRAW_HORIZONTAL
       06:C36B  20 82 CA    JSR WriteToPPUString
       06:C36E  A9 05       LDA #$05 
       06:C370  20 82 CA    JSR WriteToPPUString
                            
  134  06:C373  A9 00       LDA #$00
  135  06:C375  20 82 CA    JSR WriteToPPUString
  136  06:C378  A9 00       LDA #$00
  137  06:C37A  20 82 CA    JSR WriteToPPUString
  138  06:C37D  A9 61       LDA #$61
  139  06:C37F  20 82 CA    JSR WriteToPPUString
  140  06:C382  A9 00       LDA #$00
  141  06:C384  20 82 CA    JSR WriteToPPUString
  142  06:C387  A9 00       LDA #$00
  143  06:C389  20 82 CA    JSR WriteToPPUString
  144                       
  145                       ;;reset time
  146  06:C38C  A9 00       LDA #$00
  147  06:C38E  8D 08 00    STA time
  148                       
  149  06:C391  EE 0C 00    INC mode_state
  150  06:C394            .leave:
  151  06:C394  60          RTS
  152                       
  153  06:C395            UpdateGamePlay:
  154                         
  155  06:C395  AD C3 00    LDA pauseState
  156  06:C398  F0 04       BEQ .checkPause
  157  06:C39A  20 A6 C7    JSR UpdatePause
  158  06:C39D  60          RTS
  159                       
  160  06:C39E            .checkPause:
  161                       
  162  06:C39E  AD 17 00    LDA gamepadPressed
  163  06:C3A1  29 08       AND #GAMEPAD_START
  164  06:C3A3  F0 22       BEQ .updatePlay
  165  06:C3A5  A9 01       LDA #$01
  166  06:C3A7  8D C3 00    STA pauseState
  167  06:C3AA  A9 00       LDA #$00
  168  06:C3AC  8D B5 00    STA clueLineIndex 
  169  06:C3AF  8D B6 00    STA clueOffsetShift            
  170                     
  171                       ;;we need the pause screen table loaded
  172                       MACROGetLabelPointer Pause_Menu, pause_address
                          
       06:C3B2  A9 FC             LDA #HIGH(Pause_Menu)
       06:C3B4  A2 7C             LDX #LOW(Pause_Menu)
                                  
       06:C3B6  8E AA 00          STX pause_address
       06:C3B9  8D AB 00          STA pause_address+1
                                  
  173                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C3BC  A9 21             LDA #HIGH($210A)
       06:C3BE  A2 0A             LDX #LOW($210A)
                                  
       06:C3C0  8E AE 00          STX pause_draw_address
       06:C3C3  8D AF 00          STA pause_draw_address+1
                                  
  174                       
  175                       
  176  06:C3C6  60          RTS
  177                     
  178  06:C3C7            .updatePlay:
  179                     
  180  06:C3C7  20 27 C7    JSR UpdateTimeDisplay
  181                             
  182  06:C3CA  A9 00       LDA #$00
  183  06:C3CC  8D 00 00    STA temp1
  184  06:C3CF  8D 01 00    STA temp2
  185  06:C3D2  8D 02 00    STA temp3
  186                       
  187  06:C3D5            .checkPressed:  
  188                     
  189  06:C3D5  AD 17 00    LDA gamepadPressed
  190  06:C3D8  29 F0       AND #GAMEPAD_MOVE
  191  06:C3DA  F0 0B       BEQ .checkHeld
  192                       
  193  06:C3DC  A9 10       LDA #HOLD_TIME
  194  06:C3DE  8D C4 00    STA holdTimer 
  195  06:C3E1  AD 17 00    LDA gamepadPressed
  196  06:C3E4  4C FB C3    JMP .parseInputs
  197                       
  198  06:C3E7            .checkHeld:
  199                       
  200  06:C3E7  AD 15 00    LDA gamepad
  201  06:C3EA  29 F0       AND #GAMEPAD_MOVE
  202  06:C3EC  F0 2F       BEQ .checkPaintPress
  203                       
  204                       ;;decrement the hold timer
  205  06:C3EE  CE C4 00    DEC holdTimer
  206  06:C3F1  D0 2A       BNE .checkPaintPress
  207  06:C3F3  A9 04       LDA #HOLD_FREQ
  208  06:C3F5  8D C4 00    STA holdTimer
  209  06:C3F8  AD 15 00    LDA gamepad
  210                     
  211  06:C3FB            .parseInputs:
  212                     
  213  06:C3FB  29 F0       AND #GAMEPAD_MOVE
  214  06:C3FD  F0 1E       BEQ .checkPaintPress
  215  06:C3FF  0A          ASL A
  216  06:C400  90 03       BCC .checkLeft
  217  06:C402  EE 00 00    INC temp1
  218  06:C405            .checkLeft:
  219  06:C405  0A          ASL A
  220  06:C406  90 03       BCC .checkDown
  221  06:C408  CE 00 00    DEC temp1
  222  06:C40B            .checkDown:
  223  06:C40B  0A          ASL A
  224  06:C40C  90 03       BCC .checkUp
  225  06:C40E  EE 01 00    INC temp2
  226  06:C411            .checkUp:
  227  06:C411  0A          ASL A
  228  06:C412  90 03       BCC .move
  229  06:C414  CE 01 00    DEC temp2
  230                       
  231  06:C417            .move:
  232                      
  233  06:C417  20 92 C6    JSR MoveMouse
  234  06:C41A  20 D3 C6    JSR UpdateMouseScreenPos
  235                       
  236  06:C41D            .checkPaintPress:
  237                     
  238  06:C41D  AD 17 00    LDA gamepadPressed
  239  06:C420  29 03       AND #GAMEPAD_AB
  240  06:C422  F0 41       BEQ .updatePaint
  241                       ;;A or B pressed, get current tile
  242                       
  243  06:C424  8D 00 00    STA temp1
  244                       
  245  06:C427  A0 00       LDY #$00
  246  06:C429  B1 BC       LDA [mouse_location], y
  247  06:C42B  8D 01 00    STA temp2
  248                       
  249                         ;;A treats X and Clear as clear
  250                             ;;B treats mark and clear as clear
  251                             ;;clear->mark->x
  252                             
  253                     
  254  06:C42E  C9 7C       CMP #$7C      ;check if this is a marked tile
  255  06:C430  B0 0F       BCS .getClearTile
  256                       ;;cleared tile- store off marked tile to paint with instead
  257                       ;;not a clear tile- a mark or an x - check A or B  
  258  06:C432  4E 00 00    LSR temp1
  259  06:C435  B0 05       BCS .getMarkTile
  260                       
  261  06:C437            .getXTile:
  262  06:C437  A9 80       LDA #$80
  263  06:C439  4C 5F C4    JMP .finishGetTile
  264                       
  265  06:C43C            .getMarkTile:
  266  06:C43C  A9 70       LDA #$70
  267  06:C43E  4C 5F C4    JMP .finishGetTile
  268                     
  269  06:C441            .getClearTile:
  270                       
  271  06:C441  4E 00 00    LSR temp1
  272  06:C444  90 0A       BCC .checkB
  273  06:C446  AD 01 00    LDA temp2
  274  06:C449  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  275  06:C44B  90 0D       BCC .clearTile
  276  06:C44D  4C 3C C4    JMP .getMarkTile
  277                       
  278  06:C450            .checkB:
  279                       
  280  06:C450  AD 01 00   LDA temp2
  281  06:C453  C9 8C      CMP #$8C
  282  06:C455  B0 03      BCS .clearTile
  283  06:C457  4C 37 C4   JMP .getXTile
  284                       
  285  06:C45A            .clearTile:
  286  06:C45A  A9 60       LDA #$60
  287  06:C45C  4C 5F C4    JMP .finishGetTile
  288                       
  289  06:C45F            .finishGetTile:
  290  06:C45F  8D C0 00    STA currentPaintTile
  291  06:C462  4C 6D C4    JMP .setTile
  292                     
  293                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  294                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  295                     ;;we can load the nametable into memory as we draw it
  296                     
  297  06:C465            .updatePaint:
  298                     
  299  06:C465  AD 15 00    LDA gamepad
  300  06:C468  29 03       AND #GAMEPAD_AB
  301  06:C46A  D0 01       BNE .setTile
  302  06:C46C  60          RTS  
  303                       
  304  06:C46D            .setTile:
  305                     
  306                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  307  06:C46D  AD BF 00    LDA mouse_index+1
  308  06:C470  0A          ASL A
  309  06:C471  18          CLC
  310  06:C472  69 04       ADC #$04 ;; add to get past header
  311  06:C474  8D 00 00    STA temp1
  312                       
  313                       ;;div X position by 8 to get the byte index
  314  06:C477  AD BE 00    LDA mouse_index
  315  06:C47A  4A          LSR A
  316  06:C47B  4A          LSR A
  317  06:C47C  4A          LSR A
  318  06:C47D  F0 03       BEQ .getMask
  319                       
  320  06:C47F  EE 00 00    INC temp1
  321                       
  322  06:C482            .getMask:
  323                       
  324  06:C482  AD BE 00    LDA mouse_index
  325  06:C485  29 07       AND #$07
  326  06:C487  AA          TAX
  327  06:C488  A9 80       LDA #$80
  328  06:C48A  E0 00       CPX #$00
  329  06:C48C  F0 04       BEQ .storeMask
  330                     
  331  06:C48E            .maskLoop:
  332  06:C48E  4A          LSR A
  333  06:C48F  CA          DEX
  334  06:C490  D0 FC       BNE .maskLoop
  335  06:C492            .storeMask:
  336  06:C492  8D 01 00    STA temp2
  337                     
  338  06:C495  AC 00 00    LDY temp1
  339  06:C498  B1 A6       LDA [puzzle_address], y
  340  06:C49A  2D 01 00    AND temp2
  341  06:C49D  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  342                     
  343  06:C4A0  A0 00       LDY #$00
  344  06:C4A2  B1 BC       LDA [mouse_location], y
  345  06:C4A4  8D 02 00    STA temp3
  346  06:C4A7  29 F0       AND #$F0
  347  06:C4A9  CD C0 00    CMP currentPaintTile
  348  06:C4AC  D0 01       BNE .diffTiles
  349  06:C4AE  60          RTS
  350                       
  351  06:C4AF            .diffTiles:
  352                       ;;tiles are different- check if the current tile is marked as a solution tile
  353  06:C4AF  C9 70       CMP #$70
  354  06:C4B1  D0 0B       BNE .checkNewMark
  355                       ;;if erasing a mark, check if the tile was part of the solution
  356  06:C4B3  AD 00 00    LDA temp1
  357  06:C4B6  D0 18       BNE .antiMark
  358  06:C4B8  CE C2 00    DEC nonSolutionCount
  359  06:C4BB  4C D9 C4    JMP .overwriteTile
  360                       
  361  06:C4BE            .checkNewMark:
  362                     
  363  06:C4BE  AD C0 00    LDA currentPaintTile
  364  06:C4C1  C9 70       CMP #$70
  365  06:C4C3  D0 14       BNE .overwriteTile
  366                       
  367  06:C4C5  AD 00 00    LDA temp1
  368  06:C4C8  D0 0C       BNE .proMark
  369  06:C4CA  EE C2 00    INC nonSolutionCount 
  370  06:C4CD  4C D9 C4    JMP .overwriteTile  
  371                       
  372  06:C4D0            .antiMark:
  373  06:C4D0  CE C1 00    DEC solutionCount
  374  06:C4D3  4C D9 C4    JMP .overwriteTile
  375  06:C4D6            .proMark:   
  376                       
  377  06:C4D6  EE C1 00    INC solutionCount
  378                       
  379  06:C4D9            .overwriteTile:
  380                       ;;overwrite tile
  381  06:C4D9  AD 02 00    LDA temp3
  382  06:C4DC  29 0F       AND #$0F
  383  06:C4DE  0D C0 00    ORA currentPaintTile
  384  06:C4E1  A0 00       LDY #$00
  385  06:C4E3  91 BC       STA [mouse_location], y
  386  06:C4E5  8D 00 00    STA temp1
  387                       
  388  06:C4E8  AD BD 00    LDA mouse_location+1
  389  06:C4EB  29 3F       AND #$3F
  390  06:C4ED  8D 01 00    STA temp2
  391                         
  392                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C4F0  A9 01       LDA #$01
       06:C4F2  8D 1E 00    STA PPU_PendingWrite
       06:C4F5  AD 01 00    LDA temp2
       06:C4F8  20 82 CA    JSR WriteToPPUString
       06:C4FB  AD BC 00    LDA mouse_location
       06:C4FE  20 82 CA    JSR WriteToPPUString
       06:C501  A9 00       LDA #DRAW_HORIZONTAL
       06:C503  20 82 CA    JSR WriteToPPUString
       06:C506  A9 01       LDA #$01 
       06:C508  20 82 CA    JSR WriteToPPUString
                            
  393  06:C50B  AD 00 00    LDA temp1
  394  06:C50E  20 82 CA    JSR WriteToPPUString
  395                       
  396                       ;;also copy to ... copy
  397  06:C511  AD B2 00    LDA clue_draw_address
  398  06:C514  8D AC 00    STA copy_address
  399  06:C517  AD B3 00    LDA clue_draw_address+1
  400  06:C51A  29 0F       AND #$0F
  401  06:C51C  09 60       ORA #$60
  402  06:C51E  8D AD 00    STA copy_address+1
  403  06:C521  AD 00 00    LDA temp1
  404  06:C524  A0 00       LDY #$00
  405  06:C526  91 AC       STA [copy_address],y
  406                       
  407  06:C528            .checkSolution: 
  408                     
  409  06:C528  A0 01       LDY #$01
  410  06:C52A  B1 A6       LDA [puzzle_address], y
  411  06:C52C  CD C1 00    CMP solutionCount
  412  06:C52F  D0 1B       BNE .leave
  413  06:C531  AD C2 00    LDA nonSolutionCount
  414  06:C534  F0 03       BEQ .changeModeState
  415                       
  416  06:C536  4C 4C C5    JMP .leave
  417                       
  418                       ;;update the painting
  419  06:C539            .changeModeState:
  420                      
  421  06:C539  20 D3 CA    JSR TurnOffSprites
  422                        
  423  06:C53C  A9 00       LDA #$00
  424  06:C53E  8D B2 00    STA clue_draw_address
  425  06:C541  8D B5 00    STA clueLineIndex
  426  06:C544  A9 20       LDA #$20
  427  06:C546  8D B3 00    STA clue_draw_address+1
  428                       
  429  06:C549  EE 0C 00    INC mode_state
  430                     
  431  06:C54C            .leave:
  432                      
  433  06:C54C  60          RTS
  434                       
  435  06:C54D            UpdateClearPuzzle:
  436                     
  437  06:C54D  20 C3 CC    JSR ClearPuzzle
  438  06:C550  AD B5 00    LDA clueLineIndex
  439  06:C553  C9 1E       CMP #30
  440  06:C555  D0 08       BNE .leave
  441                       
  442  06:C557            .changeModeState:
  443                     
  444  06:C557  A9 00       LDA #$00
  445  06:C559  8D B5 00    STA clueLineIndex ;using this as a scroller
  446  06:C55C  EE 0C 00    INC mode_state
  447                     
  448  06:C55F            .leave:
  449                      
  450  06:C55F  60          RTS
  451  06:C560            UpdateMoveScreen:
  452                       
  453                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  454                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  455                       
  456  06:C560  AD B5 00    LDA clueLineIndex
  457  06:C563  29 10       AND #$10
  458  06:C565  D0 1D       BNE .scrollY
  459                       
  460                       ;;scroll X over
  461  06:C567  AD B5 00    LDA clueLineIndex
  462  06:C56A  29 0F       AND #$0F
  463  06:C56C  0A          ASL A
  464  06:C56D  0A          ASL A
  465  06:C56E  0A          ASL A ;mult by 8
  466  06:C56F  8D 1A 00    STA PPU_ScrollX
  467                       
  468  06:C572  EE B5 00    INC clueLineIndex
  469  06:C575  AD B5 00    LDA clueLineIndex
  470  06:C578  C9 06       CMP #$06
  471  06:C57A  D0 49       BNE .leave
  472  06:C57C  A9 10       LDA #$10
  473  06:C57E  8D B5 00    STA clueLineIndex
  474  06:C581  4C C5 C5    JMP .leave
  475                       
  476  06:C584            .scrollY:
  477                     
  478  06:C584  AD B5 00    LDA clueLineIndex
  479  06:C587  29 0F       AND #$0F
  480  06:C589  0A          ASL A
  481  06:C58A  0A          ASL A
  482  06:C58B  0A          ASL A ;mult by 8
  483  06:C58C  8D 1B 00    STA PPU_ScrollY
  484                     
  485  06:C58F  EE B5 00    INC clueLineIndex
  486  06:C592  AD B5 00    LDA clueLineIndex
  487  06:C595  29 0F       AND #$0F
  488  06:C597  C9 05       CMP #$05
  489  06:C599  D0 2A       BNE .leave
  490                       
  491  06:C59B            .changeModeState:
  492                     
  493  06:C59B  A9 8E       LDA #$8E
  494  06:C59D  8D B2 00    STA clue_draw_address
  495  06:C5A0  A9 21       LDA #$21
  496  06:C5A2  8D B3 00    STA clue_draw_address+1
  497                       
  498  06:C5A5  AD A8 00    LDA clues_address
  499  06:C5A8  18          CLC
  500  06:C5A9  6D B4 00    ADC clueTableIndex
  501  06:C5AC  8D A8 00    STA clues_address
  502  06:C5AF  AD A9 00    LDA clues_address+1
  503  06:C5B2  69 00       ADC #$00
  504  06:C5B4  8D A9 00    STA clues_address+1
  505                       
  506  06:C5B7  A9 00       LDA #$00
  507  06:C5B9  8D B4 00    STA clueTableIndex
  508  06:C5BC  8D B5 00    STA clueLineIndex
  509  06:C5BF  8D B6 00    STA clueOffsetShift
  510                     
  511  06:C5C2  EE 0C 00    INC mode_state
  512                     
  513  06:C5C5            .leave:
  514                      
  515  06:C5C5  60          RTS
  516  06:C5C6            UpdateDrawImage:
  517                     
  518                       ;run it twice for a faster draw
  519  06:C5C6  20 AA CD    JSR DrawImage
  520  06:C5C9  AD B4 00    LDA clueTableIndex
  521  06:C5CC  C9 39       CMP #57
  522  06:C5CE  F0 0A       BEQ .changeModeState
  523                       
  524  06:C5D0  20 AA CD    JSR DrawImage
  525  06:C5D3  AD B4 00    LDA clueTableIndex
  526  06:C5D6  C9 39       CMP #57
  527  06:C5D8  D0 7A       BNE .leave
  528                       
  529  06:C5DA            .changeModeState:
  530                     
  531                       ;;do a palette draw
  532                       ;;puzzle address + 03 has the desired palette offset
  533                     
  534  06:C5DA  A0 03       LDY #$03
  535  06:C5DC  B1 A6       LDA [puzzle_address],y
  536  06:C5DE  29 0F       AND #$0F
  537  06:C5E0  AA          TAX
  538                       
  539  06:C5E1  B1 A6       LDA [puzzle_address],y
  540  06:C5E3  29 10       AND #$10
  541  06:C5E5  F0 15       BEQ .storeBottomVals
  542                       
  543  06:C5E7  8A          TXA
  544  06:C5E8  09 10       ORA #$10
  545  06:C5EA  8D 01 00    STA temp2
  546  06:C5ED  8A          TXA
  547  06:C5EE  09 20       ORA #$20
  548  06:C5F0  8D 02 00    STA temp3
  549  06:C5F3  8A          TXA
  550  06:C5F4  09 30       ORA #$30
  551  06:C5F6  8D 03 00    STA temp4
  552                     
  553  06:C5F9  4C 0E C6    JMP .checkKeepWhite
  554                       
  555  06:C5FC            .storeBottomVals:
  556                     
  557  06:C5FC  8A          TXA
  558  06:C5FD  09 00       ORA #$00
  559  06:C5FF  8D 01 00    STA temp2
  560  06:C602  8A          TXA
  561  06:C603  09 10       ORA #$10
  562  06:C605  8D 02 00    STA temp3
  563  06:C608  8A          TXA
  564  06:C609  09 20       ORA #$20
  565  06:C60B  8D 03 00    STA temp4
  566                       
  567  06:C60E            .checkKeepWhite:
  568                       
  569  06:C60E  B1 A6       LDA [puzzle_address],y
  570  06:C610  29 20       AND #$20
  571  06:C612  F0 05       BEQ .loadPalToPPUStr
  572                       
  573  06:C614  A9 30       LDA #$30
  574  06:C616  8D 03 00    STA temp4
  575                       
  576                       
  577  06:C619            .loadPalToPPUStr:
  578                       
  579                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C619  A9 01       LDA #$01
       06:C61B  8D 1E 00    STA PPU_PendingWrite
       06:C61E  A9 3F       LDA #$3F
       06:C620  20 82 CA    JSR WriteToPPUString
       06:C623  A9 01       LDA #$01
       06:C625  20 82 CA    JSR WriteToPPUString
       06:C628  A9 00       LDA #DRAW_HORIZONTAL
       06:C62A  20 82 CA    JSR WriteToPPUString
       06:C62D  A9 03       LDA #03 
       06:C62F  20 82 CA    JSR WriteToPPUString
                            
  580  06:C632  AD 01 00    LDA temp2
  581  06:C635  20 82 CA    JSR WriteToPPUString
  582  06:C638  AD 02 00    LDA temp3
  583  06:C63B  20 82 CA    JSR WriteToPPUString
  584  06:C63E  AD 03 00    LDA temp4
  585  06:C641  20 82 CA    JSR WriteToPPUString
  586                       
  587  06:C644  A2 01       LDX #$01
  588  06:C646            .copyLoop:
  589                       ;;also store in the copy 
  590  06:C646  BD 00 00    LDA temp1, x
  591  06:C649  9D 00 68    STA Palette_Copy, x
  592  06:C64C  E8          INX
  593  06:C64D  E0 04       CPX #$04
  594  06:C64F  D0 F5       BNE .copyLoop
  595                       
  596                       
  597  06:C651  EE 0C 00    INC mode_state
  598                     
  599  06:C654            .leave:
  600                      
  601  06:C654  60          RTS
  602                       
  603  06:C655            UpdateWaitInput:
  604                     
  605  06:C655  AD 17 00    LDA gamepadPressed
  606  06:C658  F0 08       BEQ .leave
  607                       
  608  06:C65A            .changeModeState:
  609  06:C65A  A9 00       LDA #$00
  610  06:C65C  8D 08 00    STA time
  611  06:C65F  EE 0C 00    INC mode_state
  612                     
  613  06:C662            .leave:
  614                      
  615  06:C662  60          RTS
  616                       
  617  06:C663            UpdateGameFadeOut:
  618                     
  619  06:C663  AD 08 00    LDA time
  620  06:C666  29 07       AND #$07
  621  06:C668  D0 0D       BNE .leave
  622                       ;;every 8 frames, decrement the palettes
  623  06:C66A  20 FF CA    JSR FadeOutPalettes
  624  06:C66D  B0 08       BCS .leave
  625                     
  626  06:C66F            .changeModeState:
  627  06:C66F  A9 00       LDA #$00
  628  06:C671  8D 08 00    STA time
  629  06:C674  EE 0C 00    INC mode_state
  630  06:C677            .leave:
  631  06:C677  60          RTS  
  632                     
  633  06:C678            UpdateGameExit:
  634                     
  635  06:C678  AD 08 00    LDA time
  636  06:C67B  29 0F       AND #$0F
  637  06:C67D  D0 12       BNE .leave
  638                     
  639  06:C67F  A9 00       LDA #$00
  640  06:C681  8D 1A 00    STA PPU_ScrollX
  641  06:C684  8D 1B 00    STA PPU_ScrollY
  642  06:C687  8D 1C 00    STA PPU_ScrollNT
  643                       
  644  06:C68A  A9 02       LDA #GAMEOVER_IDX
  645  06:C68C  A2 00       LDX #$00
  646  06:C68E  20 64 C8    JSR ChangeGameMode
  647  06:C691            .leave:
  648  06:C691  60          RTS
  649                       
  650  06:C692            MoveMouse:
  651                     
  652  06:C692  AD 00 00    LDA temp1
  653  06:C695  0E 00 00    ASL temp1
  654  06:C698  0E 00 00    ASL temp1
  655  06:C69B  0E 00 00    ASL temp1
  656                       
  657  06:C69E  AD 01 00    LDA temp2
  658  06:C6A1  0E 01 00    ASL temp2 
  659  06:C6A4  0E 01 00    ASL temp2
  660  06:C6A7  0E 01 00    ASL temp2
  661                       
  662  06:C6AA  A2 03       LDX #SPRITE_XPOS
  663  06:C6AC  BD 00 02    LDA SPRITE_DATA, x
  664  06:C6AF  18          CLC
  665  06:C6B0  6D 00 00    ADC temp1
  666                       ;;check against borders
  667  06:C6B3  C9 6A       CMP #HORI_MIN
  668  06:C6B5  F0 07       BEQ .moveVert
  669  06:C6B7  C9 EA       CMP #HORI_MAX
  670  06:C6B9  F0 03       BEQ .moveVert
  671  06:C6BB  9D 00 02    STA SPRITE_DATA, x
  672                     
  673  06:C6BE            .moveVert:
  674                     
  675  06:C6BE  A2 00       LDX #SPRITE_YPOS
  676  06:C6C0  BD 00 02    LDA SPRITE_DATA, x
  677  06:C6C3  18          CLC
  678  06:C6C4  6D 01 00    ADC temp2
  679                       ;;check against borders
  680  06:C6C7  C9 5A       CMP #VERT_MIN
  681  06:C6C9  F0 07       BEQ .leave
  682  06:C6CB  C9 DA       CMP #VERT_MAX
  683  06:C6CD  F0 03       BEQ .leave
  684  06:C6CF  9D 00 02    STA SPRITE_DATA, x
  685                     
  686  06:C6D2            .leave:
  687  06:C6D2  60          RTS
  688                             
  689  06:C6D3            UpdateMouseScreenPos:
  690                     
  691  06:C6D3  A2 00       LDX #$00
  692  06:C6D5  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  693  06:C6D8  4A          LSR A                                         ;0yyy yy..
  694  06:C6D9  4A          LSR A                                         ;00yy yyy.
  695  06:C6DA  4A          LSR A                                         ;000y yyyy
  696  06:C6DB  8D 00 00    STA temp1
  697  06:C6DE  8D BF 00    STA mouse_index+1
  698  06:C6E1  E8          INX
  699  06:C6E2  E8          INX
  700  06:C6E3  E8          INX   
  701  06:C6E4  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  702  06:C6E7  29 F8       AND #$F8                       ;              ;  xxxx x000
  703  06:C6E9  8D 01 00    STA temp2                      ;      ;  
  704  06:C6EC  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  705  06:C6EF  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  706  06:C6F2  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  707  06:C6F5  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  708  06:C6F8  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  709  06:C6FB  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  710  06:C6FE  AD 01 00    LDA temp2
  711  06:C701  29 1F       AND #$1F
  712  06:C703  8D BE 00    STA mouse_index
  713                       
  714  06:C706  AD BE 00    LDA mouse_index
  715  06:C709  38          SEC 
  716  06:C70A  E9 0E       SBC #$0E
  717  06:C70C  8D BE 00    STA mouse_index
  718                       
  719  06:C70F  AD BF 00    LDA mouse_index+1
  720  06:C712  38          SEC 
  721  06:C713  E9 0C       SBC #$0C
  722  06:C715  8D BF 00    STA mouse_index+1
  723                       
  724                       ;subtract starting offsets for mouse index
  725                       
  726  06:C718  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  727  06:C71B  09 60       ORA #$60                       ;              ;  0110 00yy
  728                       
  729  06:C71D  8D BD 00    STA mouse_location+1
  730  06:C720  AD 01 00    LDA temp2
  731  06:C723  8D BC 00    STA mouse_location
  732                       
  733  06:C726            .leave:
  734  06:C726  60          RTS
  735                       
  736  06:C727            UpdateTimeDisplay:
  737                     
  738  06:C727  AD 08 00    LDA time
  739  06:C72A  C9 3C       CMP #60
  740  06:C72C  D0 77       BNE .leave
  741                       
  742  06:C72E  A9 00       LDA #$00
  743  06:C730  8D 08 00    STA time
  744                       
  745  06:C733  EE C5 00    INC GameTime
  746  06:C736  AD C5 00    LDA GameTime
  747  06:C739  C9 0A       CMP #10
  748  06:C73B  D0 32       BNE .printTime
  749                       
  750  06:C73D  A9 00       LDA #$00
  751  06:C73F  8D C5 00    STA GameTime
  752  06:C742  EE C6 00    INC GameTime+1
  753  06:C745  AD C6 00    LDA GameTime+1
  754  06:C748  C9 06       CMP #6
  755  06:C74A  D0 23       BNE .printTime
  756                       
  757  06:C74C  A9 00       LDA #$00
  758  06:C74E  8D C6 00    STA GameTime+1
  759  06:C751  EE C7 00    INC GameTime+2
  760  06:C754  AD C7 00    LDA GameTime+2
  761  06:C757  C9 0A       CMP #10
  762  06:C759  D0 14       BNE .printTime
  763                       
  764  06:C75B  A9 00       LDA #$00
  765  06:C75D  8D C7 00    STA GameTime+2
  766  06:C760  EE C8 00    INC GameTime+3
  767  06:C763  AD C8 00    LDA GameTime+3
  768  06:C766  C9 0A       CMP #10
  769  06:C768  D0 05       BNE .printTime
  770                       
  771  06:C76A  A9 00       LDA #$00
  772  06:C76C  8D C8 00    STA GameTime+3
  773                       
  774  06:C76F            .printTime:
  775                     
  776                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C76F  A9 01       LDA #$01
       06:C771  8D 1E 00    STA PPU_PendingWrite
       06:C774  A9 20       LDA #HIGH(TIMER_LOC)
       06:C776  20 82 CA    JSR WriteToPPUString
       06:C779  A9 E5       LDA #LOW(TIMER_LOC)
       06:C77B  20 82 CA    JSR WriteToPPUString
       06:C77E  A9 00       LDA #DRAW_HORIZONTAL
       06:C780  20 82 CA    JSR WriteToPPUString
       06:C783  A9 05       LDA #$05 
       06:C785  20 82 CA    JSR WriteToPPUString
                            
  777  06:C788  AD C8 00    LDA GameTime+3
  778  06:C78B  20 82 CA    JSR WriteToPPUString
  779  06:C78E  AD C7 00    LDA GameTime+2
  780  06:C791  20 82 CA    JSR WriteToPPUString
  781  06:C794  A9 61       LDA #$61
  782  06:C796  20 82 CA    JSR WriteToPPUString
  783  06:C799  AD C6 00    LDA GameTime+1
  784  06:C79C  20 82 CA    JSR WriteToPPUString
  785  06:C79F  AD C5 00    LDA GameTime
  786  06:C7A2  20 82 CA    JSR WriteToPPUString
  787                       
  788                       
  789                       
  790  06:C7A5            .leave: 
  791  06:C7A5  60          RTS  
  792                       
  793  06:C7A6            UpdatePause:
  794                     
  795                     ;;load screen
  796                     ;;update selection
  797                     ;; close - remove screen, then upause
  798                     ;; quit - jump to fade out
  799  06:C7A6  AD C3 00    LDA pauseState
  800  06:C7A9  20 21 C9    JSR Dynamic_Jump
  801                     
  802  06:C7AC            UpdatePauseJumpTable:  
  803                     
  804  06:C7AC  12 C8       .word ExitPause                       ;fail safe
  805  06:C7AE  B4 C7       .word UpdateLoadPauseScreen
  806  06:C7B0  C2 C7       .word UpdatePauseScreen
  807  06:C7B2  02 C8       .word UpdateUnloadPauseScreen
  808                       
  809  06:C7B4            UpdateLoadPauseScreen:
  810                       
  811  06:C7B4  20 0F CD    JSR LoadPauseScreen
  812  06:C7B7  AD B6 00    LDA clueOffsetShift
  813  06:C7BA  C9 06       CMP #$06
  814  06:C7BC  D0 03       BNE .leave
  815                       
  816  06:C7BE            .changePauseState:
  817  06:C7BE  EE C3 00    INC pauseState
  818  06:C7C1            .leave:
  819  06:C7C1  60          RTS
  820                       
  821  06:C7C2            UpdatePauseScreen:
  822                       
  823  06:C7C2  AD 17 00    LDA gamepadPressed
  824  06:C7C5  C9 08       CMP #GAMEPAD_START
  825  06:C7C7  F0 07       BEQ .unPause
  826  06:C7C9  C9 01       CMP #GAMEPAD_A
  827  06:C7CB  F0 25       BEQ .quit
  828  06:C7CD  4C 01 C8    JMP .leave 
  829                     
  830  06:C7D0            .unPause:
  831                     
  832  06:C7D0  A9 00       LDA #$00
  833  06:C7D2  8D B5 00    STA clueLineIndex
  834  06:C7D5  8D B6 00    STA clueOffsetShift
  835                     
  836                       MACROGetLabelPointer $610A, pause_address
                          
       06:C7D8  A9 61             LDA #HIGH($610A)
       06:C7DA  A2 0A             LDX #LOW($610A)
                                  
       06:C7DC  8E AA 00          STX pause_address
       06:C7DF  8D AB 00          STA pause_address+1
                                  
  837                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C7E2  A9 21             LDA #HIGH($210A)
       06:C7E4  A2 0A             LDX #LOW($210A)
                                  
       06:C7E6  8E AE 00          STX pause_draw_address
       06:C7E9  8D AF 00          STA pause_draw_address+1
                                  
  838  06:C7EC  EE C3 00    INC pauseState
  839  06:C7EF  4C 01 C8    JMP .leave
  840                       
  841  06:C7F2            .quit:
  842                     
  843  06:C7F2  A9 00       LDA #$00
  844  06:C7F4  8D C3 00    STA pauseState
  845  06:C7F7  A9 00       LDA #$00
  846  06:C7F9  8D 08 00    STA time
  847  06:C7FC  A9 08       LDA #$08
  848  06:C7FE  8D 0C 00    STA mode_state
  849                       
  850  06:C801            .leave:
  851  06:C801  60          RTS
  852                       
  853  06:C802            UpdateUnloadPauseScreen:
  854                       
  855  06:C802  20 56 CD    JSR ClearPauseScreen
  856  06:C805  AD B6 00    LDA clueOffsetShift
  857  06:C808  C9 06       CMP #$06
  858  06:C80A  D0 05       BNE .leave
  859  06:C80C            .changePauseState:
  860  06:C80C  A9 00       LDA #$00
  861  06:C80E  8D C3 00    STA pauseState
  862  06:C811            .leave:
  863  06:C811  60          RTS
  864                       
  865  06:C812            ExitPause:
  866  06:C812  60          RTS
  867                       
  868                       
  869                     
  870                     
  871                     ;;using the line index and a given count based on the direction, 
  872                       
  873                     ;;      JSR ResetMapper
  874                     ;;      INC currentCHRBank
  875                     ;;      LDA currentCHRBank
  876                     ;;      CMP #$03
  877                     ;;      BNE .dontModCHR
  878                             
  879                     ;;      LDA #$00
  880                     
  881                     ;;.dontModCHR:
  882                     ;;      STA currentCHRBank 
  883                     ;;      ;4kb switches- all the banks are seqential, so we gotta add 1 and mult by 2 for BG tiles
  884                     ;;      ASL A
  885                     ;;      CLC 
  886                     ;;      ADC #$01
  887                     ;;      JSR LoadCHRBankB
  888                     ;;      
  889                     ;;      JSR ResetMapper
  890                     ;;      INC currentPRGBank
  891                     ;;      LDA currentPRGBank
  892                     ;;      CMP #$03
  893                     ;;      BNE .dontModPRG
  894                             
  895                     ;;      LDA #$00
  896                             
  897                     ;;.dontModPRG:
  898                     ;;       STA currentPRGBank
  899                     ;;       JSR LoadPRGBank
  900                      
  901                     ;;       JSR TestBankA
  902                     ;;       LDA mapperDebugVar
  903                     ;;       STA $6000
  904                     ;;       JMP .noInputDetected
  905                     
  906                     
  907                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   81                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:C813            UpdateGameOver:
    2                     
    3  06:C813  AD 0D 00    LDA NMI_locks
    4  06:C816  F0 01       BEQ .unlocked
    5                       
    6  06:C818  60          RTS
    7                       
    8  06:C819            .unlocked:
    9                     
   10  06:C819  20 1D C8    JSR DoUpdateGameOver 
   11  06:C81C  60          RTS
   12                       
   13  06:C81D            DoUpdateGameOver:
   14                     
   15  06:C81D  AD 0C 00    LDA mode_state
   16  06:C820  20 21 C9    JSR Dynamic_Jump
   17                         
   18  06:C823            UpdateGameOverJumpTable:
   19                     
   20  06:C823  2B C8       .word UpdateGameOverInit
   21  06:C825  32 C8       .word UpdateGameOverWaitInput
   22  06:C827  40 C8       .word UpdateGameOverFadeOut
   23  06:C829  55 C8       .word UpdateGameOverExit
   24                       
   25  06:C82B            UpdateGameOverInit:
   26                     
   27  06:C82B  20 CA CA    JSR TurnOnSprites
   28  06:C82E  EE 0C 00    INC mode_state
   29  06:C831  60          RTS
   30                     
   31  06:C832            UpdateGameOverWaitInput:
   32                     
   33  06:C832  AD 17 00    LDA gamepadPressed
   34  06:C835  F0 08       BEQ .leave
   35                     
   36  06:C837            .changeModeState:
   37                     
   38  06:C837  A9 00       LDA #$00
   39  06:C839  8D 08 00    STA time
   40  06:C83C  EE 0C 00    INC mode_state
   41  06:C83F            .leave:
   42  06:C83F  60          RTS
   43                     
   44  06:C840            UpdateGameOverFadeOut:
   45                     
   46  06:C840  AD 08 00    LDA time
   47  06:C843  29 07       AND #$07
   48  06:C845  D0 0D       BNE .leave
   49                       ;;every 8 frames, decrement the palettes
   50  06:C847  20 FF CA    JSR FadeOutPalettes
   51  06:C84A  B0 08       BCS .leave
   52                     
   53  06:C84C            .changeModeState:
   54  06:C84C  A9 00       LDA #$00
   55  06:C84E  8D 08 00    STA time
   56  06:C851  EE 0C 00    INC mode_state
   57  06:C854            .leave:
   58  06:C854  60          RTS
   59                     
   60  06:C855            UpdateGameOverExit:
   61                     
   62  06:C855  AD 08 00    LDA time
   63  06:C858  29 0F       AND #$0F
   64  06:C85A  D0 07       BNE .leave
   65                     
   66  06:C85C  A9 00       LDA #TITLE_IDX
   67  06:C85E  A2 00       LDX #$00
   68  06:C860  20 64 C8    JSR ChangeGameMode
   69                       
   70  06:C863            .leave:
   71  06:C863  60          RTS
#[1]   Picross.asm
   82                       
   83                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   84                     ;;     Routines             ;;
   85                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   86                     
   87                     
#[2]   Routines/Common/GameModeRoutines.asm
   88                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:C864            ChangeGameMode:
    2                       ;A - game mode index
    3                       ;X - high nibble: palette start flag, low nibble: screen index
    4  06:C864  8D 0B 00    STA game_mode
    5  06:C867  8E 0A 00    STX mode_loadFlags
    6  06:C86A  A9 00       LDA #$00
    7  06:C86C  8D 0C 00    STA mode_state
    8  06:C86F  20 96 CA    JSR ClearPPUString
    9  06:C872  20 76 C8    JSR LoadGameModeScreen
   10  06:C875  60          RTS
   11                       
   12  06:C876            LoadGameModeScreen:
   13                     
   14                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C876  AD 0D 00    LDA NMI_locks
       06:C879  09 01       ORA #BGLOAD_NMI_LOCK
       06:C87B  8D 0D 00    STA NMI_locks
                                  
   15                       
   16  06:C87E  A9 00       LDA #$00
   17  06:C880  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   18                     
   19  06:C883  20 B1 C8    JSR LoadGameModeBackground
   20  06:C886  20 FE C8    JSR LoadGameModeSprites
   21                     
   22                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:C889  A9 01       LDA #BGLOAD_NMI_LOCK
       06:C88B  49 FF       EOR #$FF
       06:C88D  2D 0D 00    AND NMI_locks  
       06:C890  8D 0D 00    STA NMI_locks
                          
   23                     
   24                       
   25                       ;; load the CHR bank for this mode
   26  06:C893  20 69 CB    JSR ResetMapper
   27                       ;;remember, we're loading the SECOND set in each chr bank
   28                       ;;so we'll take the index from the game mode chr table and add one mult 2
   29  06:C896  AE 0B 00    LDX game_mode
   30  06:C899  BD 1B C9    LDA gameModeInitCHRROMB, x
   31  06:C89C  0A          ASL A
   32  06:C89D  18          CLC 
   33  06:C89E  69 01       ADC #$01
   34  06:C8A0  20 8E CB    JSR LoadCHRBankB
   35                       
   36  06:C8A3  20 69 CB    JSR ResetMapper
   37  06:C8A6  AE 0B 00    LDX game_mode
   38  06:C8A9  BD 1E C9    LDA gameModeInitCHRROMA, x
   39  06:C8AC  0A          ASL A
   40  06:C8AD  20 83 CB    JSR LoadCHRBankA
   41                       
   42                       
   43                       
   44  06:C8B0  60          RTS
   45                       
   46  06:C8B1            LoadGameModeBackground:
   47                             
   48                       MACROGetDoubleIndex game_mode
                          
       06:C8B1  AD 0B 00          LDA game_mode
       06:C8B4  0A                ASL A
       06:C8B5  A8                TAY
                                  
   49  06:C8B6  8C 00 00    STY temp1
   50                             
   51                       MACROGetLabelPointer Palettes, table_address
                          
       06:C8B9  A9 E0             LDA #HIGH(Palettes)
       06:C8BB  A2 00             LDX #LOW(Palettes)
                                  
       06:C8BD  8E 11 00          STX table_address
       06:C8C0  8D 12 00          STA table_address+1
                                  
   52  06:C8C3  20 47 C9    JSR GetTableAtIndex
   53                     
   54  06:C8C6  20 54 C9    JSR LoadFullPaletteFromTable
   55                             
   56  06:C8C9  AC 00 00    LDY temp1
   57                       MACROGetLabelPointer NameTables, table_address
                          
       06:C8CC  A9 E0             LDA #HIGH(NameTables)
       06:C8CE  A2 06             LDX #LOW(NameTables)
                                  
       06:C8D0  8E 11 00          STX table_address
       06:C8D3  8D 12 00          STA table_address+1
                                  
   58  06:C8D6  20 47 C9    JSR GetTableAtIndex
   59  06:C8D9  AD 0A 00    LDA mode_loadFlags
   60  06:C8DC  29 0F       AND #$0F
   61  06:C8DE  0A          ASL A
   62  06:C8DF  A8          TAY
   63  06:C8E0  20 47 C9    JSR GetTableAtIndex
   64                             
   65  06:C8E3  A9 00       LDA #$00
   66  06:C8E5  20 83 C9    JSR LoadFullBackgroundFromTable
   67                       
   68  06:C8E8  AC 00 00    LDY temp1
   69                       MACROGetLabelPointer NameTables2, table_address
                          
       06:C8EB  A9 E0             LDA #HIGH(NameTables2)
       06:C8ED  A2 0C             LDX #LOW(NameTables2)
                                  
       06:C8EF  8E 11 00          STX table_address
       06:C8F2  8D 12 00          STA table_address+1
                                  
   70  06:C8F5  20 47 C9    JSR GetTableAtIndex
   71                       
   72  06:C8F8  A9 01       LDA #$01
   73  06:C8FA  20 83 C9    JSR LoadFullBackgroundFromTable
   74                       
   75  06:C8FD  60          RTS
   76                       
   77  06:C8FE            LoadGameModeSprites:
   78                     
   79                       MACROGetDoubleIndex game_mode  
                          
       06:C8FE  AD 0B 00          LDA game_mode
       06:C901  0A                ASL A
       06:C902  A8                TAY
                                  
   80                       MACROGetLabelPointer Sprites, table_address
                          
       06:C903  A9 FC             LDA #HIGH(Sprites)
       06:C905  A2 CA             LDX #LOW(Sprites)
                                  
       06:C907  8E 11 00          STX table_address
       06:C90A  8D 12 00          STA table_address+1
                                  
   81  06:C90D  20 47 C9    JSR GetTableAtIndex
   82  06:C910  A0 00       LDY #$00
   83  06:C912  B1 11       LDA [table_address],y
   84  06:C914  EE 11 00    INC table_address
   85  06:C917  20 6B CA    JSR LoadSprites_impl
   86                       
   87  06:C91A  60          RTS
   88                       
   89  06:C91B            gameModeInitCHRROMB:
   90  06:C91B  00 02 02          .db $00, $02, $02
   91  06:C91E            gameModeInitCHRROMA:
   92  06:C91E  00 02 02          .db $00, $02, $02
   93                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   89                       .include "Routines/Utils/PointerUtils.asm"
    1  06:C921            Dynamic_Jump:
    2                     
    3  06:C921  0A          ASL A                                 ;; double the index passed into A
    4  06:C922  8E 06 00    STX tempx
    5  06:C925  8C 07 00    STY tempy
    6  06:C928  A8          TAY
    7  06:C929  C8          INY  
    8  06:C92A  68          PLA
    9  06:C92B  8D 13 00    STA jump_address
   10  06:C92E  68          PLA 
   11  06:C92F  8D 14 00    STA jump_address+1            
   12  06:C932  B1 13       LDA [jump_address], y
   13  06:C934  AA          TAX
   14  06:C935  C8          INY
   15  06:C936  B1 13       LDA [jump_address], y
   16  06:C938  8E 13 00    STX jump_address
   17  06:C93B  8D 14 00    STA jump_address+1
   18  06:C93E  AE 06 00    LDX tempx
   19  06:C941  AC 07 00    LDY tempy
   20  06:C944  6C 13 00    JMP [jump_address]
   21                       
   22  06:C947            GetTableAtIndex:
   23                     
   24  06:C947  B1 11             LDA [table_address], y
   25  06:C949  AA                TAX
   26  06:C94A  C8                INY
   27  06:C94B  B1 11             LDA [table_address], y
   28                             
   29  06:C94D            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:C94D  8E 11 00          STX table_address
   33  06:C950  8D 12 00          STA table_address+1
   34  06:C953  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   90                       .include "Routines/Utils/PPUUtils.asm"
    1  06:C954            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:C954  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:C957  A9 3F       LDA #HIGH($3F00)
       06:C959  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:C95C  A9 00       LDA #LOW($3F00)
       06:C95E  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:C961  A0 00       LDY #$00              ; start out at 0
    5  06:C963  A2 00       LDX #$00
    6  06:C965            .loop:
    7  06:C965  B1 11       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:C967  9D 00 68    STA Palette_Copy, x
    9  06:C96A  48          PHA 
   10  06:C96B  AD 0A 00    LDA mode_loadFlags
   11  06:C96E  29 10       AND #$10
   12  06:C970  D0 04       BNE .setBlack
   13  06:C972  68          PLA 
   14  06:C973  4C 79 C9    JMP .setPPUData
   15  06:C976            .setBlack:
   16                     
   17  06:C976  68          PLA 
   18  06:C977  A9 0F       LDA #$0F
   19                       
   20  06:C979            .setPPUData:
   21  06:C979  8D 07 20    STA PPU_DATA            ; write to PPU
   22  06:C97C  C8          INY                   ; X = X + 1
   23  06:C97D  E8          INX
   24  06:C97E  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   25  06:C980  D0 E3       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   26  06:C982  60          RTS
   27                     
   28  06:C983            LoadFullBackgroundFromTable:
   29                     
   30                         ;;use A as an index for which nametable to write to
   31  06:C983  20 B6 CA          JSR SetNametableFromIndex
   32  06:C986  8A                TXA
   33  06:C987  4A                LSR A
   34  06:C988  29 01             AND #$01
   35  06:C98A  D0 0D             BNE .copyScreenB
   36                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:C98C  A9 60             LDA #HIGH(Screen_Copy)
       06:C98E  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:C990  8E 0F 00          STX pointer_address
       06:C993  8D 10 00          STA pointer_address+1
                                  
   37  06:C996  4C A3 C9          JMP .setCounters
   38                             
   39  06:C999            .copyScreenB:
   40                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:C999  A9 64             LDA #HIGH(ScreenB_Copy)
       06:C99B  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:C99D  8E 0F 00          STX pointer_address
       06:C9A0  8D 10 00          STA pointer_address+1
                                  
   41                             
   42                             ;;set pointer
   43                             ;; set counters
   44  06:C9A3            .setCounters:
   45  06:C9A3  A0 00             LDY #$00
   46  06:C9A5  A2 00             LDX #$00
   47                             
   48                             ;;start loop
   49                     
   50  06:C9A7            .outerloop:
   51                     
   52  06:C9A7            .innerloop:
   53                     
   54  06:C9A7  B1 11             LDA [table_address], y
   55  06:C9A9  8D 07 20          STA PPU_DATA
   56  06:C9AC  91 0F             STA [pointer_address],y
   57  06:C9AE  C8                INY
   58  06:C9AF  C0 00             CPY #$00
   59  06:C9B1  D0 F4             BNE .innerloop
   60                     
   61  06:C9B3  EE 10 00          INC pointer_address+1
   62  06:C9B6  EE 12 00          INC table_address+1
   63                             
   64  06:C9B9  E8                INX
   65  06:C9BA  E0 04             CPX #$04
   66  06:C9BC  D0 E9             BNE .outerloop
   67  06:C9BE  60                RTS
   68                             
   69                     
   70           0000      DATA_LEN = temp1
   71           0001      WRITE_SETTINGS = temp2
   72                             
   73  06:C9BF            ProcessPPUString:
   74                     
   75  06:C9BF  AD 1E 00          LDA PPU_PendingWrite
   76  06:C9C2  D0 01             BNE .continueProcess
   77  06:C9C4  60                RTS
   78                             
   79  06:C9C5            .continueProcess:
   80  06:C9C5  A0 00             LDY #$00
   81                             
   82  06:C9C7  A9 20             LDA #LOW(PPU_String)
   83  06:C9C9  8D 0F 00          STA pointer_address
   84  06:C9CC  A9 00             LDA #HIGH(PPU_String)
   85  06:C9CE  8D 10 00          STA pointer_address + 1
   86                     
   87  06:C9D1            .outerloop:
   88  06:C9D1  AD 02 20          LDA PPU_STATUS
   89  06:C9D4  B1 0F             LDA [pointer_address], y
   90  06:C9D6  F0 79             BEQ .finish
   91  06:C9D8  8D 06 20          STA PPU_ADDR
   92  06:C9DB  C8                INY
   93  06:C9DC  B1 0F             LDA [pointer_address], y
   94  06:C9DE  8D 06 20          STA PPU_ADDR
   95  06:C9E1  C8            INY 
   96  06:C9E2  B1 0F             LDA [pointer_address], y
   97  06:C9E4  8D 01 00          STA WRITE_SETTINGS
   98  06:C9E7  C8                INY
   99                             
  100  06:C9E8  AD 00 20          LDA PPU_CTRL
  101  06:C9EB  29 FB             AND #$FB
  102  06:C9ED  8D 00 20          STA PPU_CTRL
  103                             
  104  06:C9F0  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
  105  06:C9F3  29 80             AND #%10000000
  106  06:C9F5  F0 06             BEQ .checkRepeat
  107  06:C9F7  0D 00 20          ORA PPU_CTRL 
  108  06:C9FA  8D 00 20          STA PPU_CTRL 
  109                             
  110                             
  111  06:C9FD            .checkRepeat:
  112  06:C9FD  AD 01 00    LDA WRITE_SETTINGS
  113  06:CA00  29 40       AND #%01000000
  114  06:CA02  F0 19       BEQ .checkTable
  115                       
  116  06:CA04  AD 01 00    LDA WRITE_SETTINGS
  117  06:CA07  29 3F       AND #$3F
  118  06:CA09  8D 00 00    STA DATA_LEN
  119                       ;;the usual data length byte is now the repeatable byte
  120  06:CA0C  A2 00       LDX #$00
  121                       
  122  06:CA0E            .repeatLoop:
  123  06:CA0E  B1 0F       LDA [pointer_address], y
  124  06:CA10  8D 07 20    STA PPU_DATA
  125  06:CA13  E8          INX 
  126  06:CA14  EC 00 00    CPX DATA_LEN
  127  06:CA17  D0 F5       BNE .repeatLoop
  128  06:CA19  C8          INY
  129  06:CA1A  4C D1 C9    JMP .outerloop
  130                             
  131  06:CA1D            .checkTable:
  132  06:CA1D  AD 01 00          LDA WRITE_SETTINGS
  133  06:CA20  29 20             AND #%00100000
  134  06:CA22  F0 16             BEQ .rawData
  135                             
  136  06:CA24  B1 0F             LDA [pointer_address], y
  137  06:CA26  8D 11 00          STA table_address
  138  06:CA29  C8                INY 
  139  06:CA2A  B1 0F             LDA [pointer_address], y
  140  06:CA2C  8D 12 00          STA table_address + 1
  141  06:CA2F  C8                INY
  142  06:CA30  98                TYA 
  143  06:CA31  48                PHA
  144  06:CA32  20 55 CA          JSR WriteToPPUFromTable
  145  06:CA35  68                PLA
  146  06:CA36  A8                TAY
  147  06:CA37  4C D1 C9          JMP .outerloop
  148                             
  149  06:CA3A            .rawData:
  150                     
  151  06:CA3A  B1 0F             LDA [pointer_address], y
  152  06:CA3C  C8                INY
  153  06:CA3D  8D 00 00          STA DATA_LEN
  154                     
  155  06:CA40  A2 00             LDX #$00
  156                     
  157  06:CA42            .innerloop:
  158                             
  159  06:CA42  B1 0F             LDA [pointer_address], y
  160  06:CA44  8D 07 20          STA PPU_DATA
  161  06:CA47  C8                INY
  162  06:CA48  E8                INX
  163  06:CA49  EC 00 00          CPX DATA_LEN
  164  06:CA4C  D0 F4             BNE .innerloop
  165  06:CA4E  4C D1 C9          JMP .outerloop
  166                             
  167  06:CA51            .finish:
  168  06:CA51  20 96 CA          JSR ClearPPUString
  169  06:CA54            .leave:
  170  06:CA54  60                RTS
  171                             
  172  06:CA55            WriteToPPUFromTable:
  173  06:CA55  A0 00             LDY #$00
  174  06:CA57  B1 11             LDA [table_address], y
  175  06:CA59  C8                INY
  176  06:CA5A  8D 00 00          STA DATA_LEN
  177  06:CA5D            .innerloop:
  178  06:CA5D  B1 11             LDA [table_address], y
  179  06:CA5F  8D 07 20          STA PPU_DATA
  180  06:CA62  C8                INY
  181  06:CA63  CC 00 00          CPY DATA_LEN
  182  06:CA66  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  183  06:CA68  F0 F3             BEQ .innerloop
  184  06:CA6A  60                RTS
  185                       
  186  06:CA6B            LoadSprites_impl:
  187                       ;;A will be the amount of sprites to load
  188  06:CA6B  8D 00 00    STA DATA_LEN
  189  06:CA6E  0E 00 00    ASL DATA_LEN
  190  06:CA71  0E 00 00    ASL DATA_LEN
  191                       
  192  06:CA74  A0 00       LDY #$00              ; start at 0
  193                       
  194  06:CA76            .loop:
  195  06:CA76  B1 11       LDA [table_address], y; load data from address (sprites +  x)
  196  06:CA78  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  197  06:CA7B  C8          INY                   ; X = X + 1
  198  06:CA7C  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  199  06:CA7F  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  200                                             ; if compare was equal to 16, keep going down   
  201  06:CA81  60          RTS
  202                     
  203                     
  204  06:CA82            WriteToPPUString:
  205                     
  206  06:CA82  AE 1F 00          LDX PPU_StringIdx
  207  06:CA85  E0 4F             CPX #PPU_STRINGMAX
  208  06:CA87  F0 0C             BEQ .finish
  209                             
  210  06:CA89  9D 20 00          STA PPU_String, x
  211  06:CA8C  EE 1F 00          INC PPU_StringIdx
  212  06:CA8F  E8                INX
  213  06:CA90  A9 00             LDA #$00
  214  06:CA92  9D 20 00          STA PPU_String, x
  215                                     
  216  06:CA95            .finish:
  217  06:CA95  60                RTS
  218                     
  219  06:CA96            ClearPPUString:
  220                             
  221  06:CA96  A9 00             LDA #$00
  222  06:CA98  8D 1F 00          STA PPU_StringIdx
  223  06:CA9B  8D 20 00          STA PPU_String
  224  06:CA9E  8D 1E 00          STA PPU_PendingWrite
  225  06:CAA1  60                RTS
  226                     
  227  06:CAA2            DetectSprite0:
  228  06:CAA2            WaitNotSprite0:
  229  06:CAA2  AD 02 20    lda PPU_STATUS
  230  06:CAA5  29 40       and #SPRITE_0_MASK
  231  06:CAA7  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  232                     
  233  06:CAA9            WaitSprite0:
  234  06:CAA9  AD 02 20    lda $2002
  235  06:CAAC  29 40       and #SPRITE_0_MASK
  236  06:CAAE  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  237                     
  238  06:CAB0  A2 05       ldx #$05                              ;do a scanline wait
  239  06:CAB2            WaitScanline:
  240  06:CAB2  CA          dex
  241  06:CAB3  D0 FD       bne WaitScanline
  242  06:CAB5  60          RTS
  243                     
  244                     
  245  06:CAB6            SetNametableFromIndex:
  246                     
  247  06:CAB6  48          PHA
  248  06:CAB7  AD 02 20    LDA PPU_STATUS
  249  06:CABA  68          PLA
  250  06:CABB  0A          ASL A
  251  06:CABC  AA          TAX
  252  06:CABD  BD 52 CB    LDA NameTableMemList+1, x
  253  06:CAC0  8D 06 20    STA PPU_ADDR
  254  06:CAC3  BD 51 CB    LDA NameTableMemList, x
  255  06:CAC6  8D 06 20    STA PPU_ADDR
  256  06:CAC9  60          RTS
  257                       
  258  06:CACA            TurnOnSprites:
  259                      
  260  06:CACA  AD 19 00    LDA PPU_Mask
  261  06:CACD  09 10       ORA #%00010000
  262  06:CACF  8D 19 00    STA PPU_Mask
  263  06:CAD2  60          RTS
  264                       
  265  06:CAD3            TurnOffSprites:
  266                       
  267  06:CAD3  AD 19 00    LDA PPU_Mask
  268  06:CAD6  29 EF       AND #%11101111
  269  06:CAD8  8D 19 00    STA PPU_Mask
  270  06:CADB  60          RTS
  271                     
  272  06:CADC            UpdatePPUControl:
  273                     
  274  06:CADC  AD 18 00    LDA PPU_Control
  275  06:CADF  29 FC       AND #$FC
  276  06:CAE1  0D 1D 00    ORA PPU_NT
  277  06:CAE4  8D 00 20    STA PPU_CTRL
  278  06:CAE7  AD 19 00    LDA PPU_Mask
  279  06:CAEA  8D 01 20    STA PPU_MASK
  280  06:CAED  60          RTS
  281                       
  282  06:CAEE            InitPPUControl:
  283                       
  284                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  285                       ; enable sprites, enable background, no clipping on left side
  286  06:CAEE  A9 90       LDA #%10010000
  287  06:CAF0  8D 00 20    STA PPU_CTRL
  288  06:CAF3  8D 18 00    STA PPU_Control
  289  06:CAF6  A9 1E       LDA #%00011110
  290  06:CAF8  8D 01 20    STA PPU_MASK
  291  06:CAFB  8D 19 00    STA PPU_Mask
  292  06:CAFE  60          RTS
  293                       
  294  06:CAFF            FadeOutPalettes:
  295                     
  296                     ;;take the current values, and decrement the lower nibbles
  297                     ;;we can access from the palette copy 
  298                     ;;we'll make this fade out one level per call
  299                     ;;once all the palettes are blacked out we'll return true, so we'll keep the carry flag as a return result
  300                     
  301                     ;;go through the palette copy, decrement, make a raw data PPU string and add all the bytes into it
  302                     ;;for any palette color already in the 0x range, change it to 0f to get black
  303                     
  304                       MACROGetLabelPointer Palette_Copy, table_address
                          
       06:CAFF  A9 68             LDA #HIGH(Palette_Copy)
       06:CB01  A2 00             LDX #LOW(Palette_Copy)
                                  
       06:CB03  8E 11 00          STX table_address
       06:CB06  8D 12 00          STA table_address+1
                                  
  305                     ;;palette copy address is now X accessable
  306                     
  307  06:CB09  A0 00       LDY #$00
  308                       MACROAddPPUStringEntryRawData #$3F, #$00, #DRAW_HORIZONTAL, #$20  
                          
       06:CB0B  A9 01       LDA #$01
       06:CB0D  8D 1E 00    STA PPU_PendingWrite
       06:CB10  A9 3F       LDA #$3F
       06:CB12  20 82 CA    JSR WriteToPPUString
       06:CB15  A9 00       LDA #$00
       06:CB17  20 82 CA    JSR WriteToPPUString
       06:CB1A  A9 00       LDA #DRAW_HORIZONTAL
       06:CB1C  20 82 CA    JSR WriteToPPUString
       06:CB1F  A9 20       LDA #$20 
       06:CB21  20 82 CA    JSR WriteToPPUString
                            
  309                     
  310  06:CB24  A9 00       LDA #$00
  311  06:CB26  8D 00 00    STA temp1
  312                       
  313  06:CB29            .loop:
  314                     
  315  06:CB29  B1 11       LDA [table_address], y
  316  06:CB2B  C9 0F       CMP #$0F
  317  06:CB2D  F0 15       BEQ .addToString
  318  06:CB2F  C9 10       CMP #$10
  319  06:CB31  90 0D       BCC .setBlack
  320                       
  321  06:CB33  A9 80       LDA #$80
  322  06:CB35  8D 00 00    STA temp1
  323                       
  324  06:CB38  B1 11       LDA [table_address], y
  325  06:CB3A  38          SEC
  326  06:CB3B  E9 10       SBC #$10
  327  06:CB3D  4C 42 CB    JMP .setColor
  328                     
  329  06:CB40            .setBlack:
  330                     
  331  06:CB40  A9 0F       LDA #$0F
  332                     
  333  06:CB42            .setColor:
  334  06:CB42  91 11       STA [table_address], y
  335                     
  336  06:CB44            .addToString:
  337                     
  338  06:CB44  20 82 CA    JSR WriteToPPUString
  339                     
  340  06:CB47            .incY:
  341                       
  342  06:CB47  C8          INY
  343  06:CB48  C0 20       CPY #$20
  344  06:CB4A  D0 DD       BNE .loop
  345                     
  346  06:CB4C  0E 00 00    ASL temp1     ;get carry out, if we have one
  347                     
  348  06:CB4F  60          RTS
  349                       
  350  06:CB50            FadeInPalettes:
  351                     
  352                     ;;need to be able to store off a target palette first
  353                     ;;we can use the palette copy we make during the game mode change as the target
  354  06:CB50  60          RTS
  355                     
  356  06:CB51            NameTableMemList:
  357  06:CB51  00 20       .word $2000, $2400, $2800, $2C00
       06:CB53  00 24     
       06:CB55  00 28     
       06:CB57  00 2C     
  358  06:CB59            PalettesMemList:
  359  06:CB59  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:CB5B  04 3F     
       06:CB5D  08 3F     
       06:CB5F  0C 3F     
  360  06:CB61  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:CB63  14 3F     
       06:CB65  18 3F     
       06:CB67  1C 3F     
  361                       
  362           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   91                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:CB69            ResetMapper:
    7  06:CB69  EE 69 CB    inc ResetMapper
    8  06:CB6C  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:CB6D            SetMapperControls:
   23                       ;;A = controls
   24  06:CB6D  AA          TAX
   25  06:CB6E  A9 80       LDA #MAPPERCONTROL
   26  06:CB70  8D A1 00    STA mapper_address+1
   27  06:CB73  8A          TXA
   28  06:CB74  20 99 CB    JSR SendMapperCommand
   29  06:CB77  60          RTS
   30                     
   31  06:CB78            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:CB78  AA                TAX
   35  06:CB79  A9 E0             LDA #PRGBANK
   36  06:CB7B  8D A1 00          STA mapper_address+1
   37  06:CB7E  8A                TXA
   38  06:CB7F  20 99 CB          JSR SendMapperCommand
   39  06:CB82  60                RTS
   40                             
   41  06:CB83            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:CB83  AA                TAX
   44  06:CB84  A9 A0             LDA #CHRBANK1
   45  06:CB86  8D A1 00          STA mapper_address+1
   46  06:CB89  8A                TXA
   47  06:CB8A  20 99 CB          JSR SendMapperCommand
   48  06:CB8D  60                RTS
   49                             
   50  06:CB8E            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:CB8E  AA                TAX
   53  06:CB8F  A9 C0             LDA #CHRBANK2
   54  06:CB91  8D A1 00          STA mapper_address+1
   55  06:CB94  8A                TXA
   56  06:CB95  20 99 CB          JSR SendMapperCommand
   57  06:CB98  60                RTS
   58                             
   59  06:CB99            SendMapperCommand:
   60                     
   61  06:CB99  A0 00             LDY #$00
   62                             
   63  06:CB9B  91 A0             STA [mapper_address], y
   64  06:CB9D  4A                LSR A
   65  06:CB9E  91 A0             STA [mapper_address], y
   66  06:CBA0  4A                LSR A
   67  06:CBA1  91 A0             STA [mapper_address], y
   68  06:CBA3  4A                LSR A 
   69  06:CBA4  91 A0             STA [mapper_address], y
   70  06:CBA6  4A                LSR A
   71  06:CBA7  91 A0             STA [mapper_address], y
   72                             
   73  06:CBA9  60                RTS
   74                             
   75  06:CBAA            ResetBanks:
   76                     
   77  06:CBAA  20 69 CB          JSR ResetMapper
   78  06:CBAD  A9 00             LDA #$00
   79  06:CBAF  20 78 CB          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:CBB2  20 69 CB          JSR ResetMapper
   83  06:CBB5  A9 00             LDA #$00
   84  06:CBB7  20 83 CB          JSR LoadCHRBankA
   85  06:CBBA  A9 01             LDA #$01
   86  06:CBBC  20 8E CB          JSR LoadCHRBankB
   87  06:CBBF  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   92                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:CBC0            PopulateClues:
    2                     
    3  06:CBC0            .getByte:
    4  06:CBC0  AC B4 00    LDY clueTableIndex
    5  06:CBC3  B1 A8       LDA [clues_address], y
    6  06:CBC5  D0 07       BNE .checkNewLine
    7  06:CBC7  EE B4 00    INC clueTableIndex
    8  06:CBCA  A9 00       LDA #$00
    9  06:CBCC  F0 38       BEQ .drawClue
   10                       ;was 0, set up a draw
   11  06:CBCE            .checkNewLine
   12  06:CBCE  C9 FF       CMP #$FF
   13  06:CBD0  D0 17       BNE .getClue
   14                       
   15                       ;;was FF- need to inc stuff
   16  06:CBD2  EE B4 00    INC clueTableIndex
   17  06:CBD5  A9 00       LDA #$00
   18  06:CBD7  8D BB 00    STA clueParity
   19                       
   20  06:CBDA  EE B5 00    INC clueLineIndex
   21  06:CBDD  AD B5 00    LDA clueLineIndex
   22  06:CBE0  C9 0F       CMP #$0F
   23                       ;CMP #$01
   24  06:CBE2  F0 28       BEQ .leave    ;carry will be set
   25                       
   26  06:CBE4  20 95 CC    JSR CreateOffsetFromIndex
   27                      
   28  06:CBE7  D0 D7       BNE .getByte
   29                       
   30  06:CBE9            .getClue:
   31                       ;;clues go from high nibble to low nibble
   32  06:CBE9  48          PHA 
   33  06:CBEA  AD BB 00    LDA clueParity
   34  06:CBED  D0 0A       BNE .getSecondClue
   35  06:CBEF  EE BB 00    INC clueParity
   36  06:CBF2  68          PLA
   37  06:CBF3  4A          LSR A
   38  06:CBF4  4A          LSR A
   39  06:CBF5  4A          LSR A
   40  06:CBF6  4A          LSR A         ;move clue over to lower nibble
   41  06:CBF7  D0 0D       BNE .drawClue
   42                       
   43  06:CBF9            .getSecondClue:
   44                     
   45  06:CBF9  CE BB 00    DEC clueParity
   46  06:CBFC  EE B4 00    INC clueTableIndex
   47  06:CBFF  68          PLA 
   48  06:CC00  29 0F       AND #$0F
   49  06:CC02  D0 02       BNE .drawClue
   50                       ;;if 0, skip
   51  06:CC04  F0 BA       BEQ .getByte
   52                      
   53  06:CC06            .drawClue:
   54                       
   55  06:CC06  09 40       ORA #$40
   56  06:CC08  20 0D CC    JSR WriteClueByteToPPUString
   57  06:CC0B  18          CLC
   58                       
   59  06:CC0C            .leave:
   60  06:CC0C  60          RTS
   61                       
   62  06:CC0D            WriteClueByteToPPUString:
   63                     
   64  06:CC0D  8D 00 00    STA temp1 ;store off the tile value
   65                     
   66                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:CC10  A9 01       LDA #$01
       06:CC12  8D 1E 00    STA PPU_PendingWrite
       06:CC15  AD B3 00    LDA clue_draw_address+1
       06:CC18  20 82 CA    JSR WriteToPPUString
       06:CC1B  AD B2 00    LDA clue_draw_address
       06:CC1E  20 82 CA    JSR WriteToPPUString
       06:CC21  A9 00       LDA #DRAW_HORIZONTAL
       06:CC23  20 82 CA    JSR WriteToPPUString
       06:CC26  A9 01       LDA #$01 
       06:CC28  20 82 CA    JSR WriteToPPUString
                            
   67  06:CC2B  AD 00 00    LDA temp1
   68  06:CC2E  20 82 CA    JSR WriteToPPUString
   69                       
   70                       ;;also copy to ... copy
   71  06:CC31  AD B2 00    LDA clue_draw_address
   72  06:CC34  8D AC 00    STA copy_address
   73  06:CC37  AD B3 00    LDA clue_draw_address+1
   74  06:CC3A  29 0F       AND #$0F
   75  06:CC3C  09 60       ORA #$60
   76  06:CC3E  8D AD 00    STA copy_address+1
   77  06:CC41  AD 00 00    LDA temp1
   78  06:CC44  A0 00       LDY #$00
   79  06:CC46  91 AC       STA [copy_address],y
   80                       
   81  06:CC48  AD B7 00    LDA clueDrawAdd
   82  06:CC4B  20 72 CC    JSR SubFromClueDrawAddress
   83                         
   84  06:CC4E  60          RTS
   85                       
   86  06:CC4F            ResetClueDrawAddress:
   87                     
   88                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:CC4F  AD B0 00          LDA clue_start_address
       06:CC52  8D B2 00          STA clue_draw_address
       06:CC55  AD B1 00          LDA clue_start_address+1
       06:CC58  8D B3 00          STA clue_draw_address+1
                          
   89                       
   90  06:CC5B  60          RTS
   91                       
   92  06:CC5C            AddToClueDrawAddress:
   93                     
   94  06:CC5C  8D 00 00    STA temp1
   95                       
   96  06:CC5F  AD B2 00    LDA clue_draw_address
   97  06:CC62  18          CLC
   98  06:CC63  6D 00 00    ADC temp1
   99  06:CC66  8D B2 00    STA clue_draw_address
  100  06:CC69  AD B3 00    LDA clue_draw_address+1
  101  06:CC6C  69 00       ADC #$00
  102  06:CC6E  8D B3 00    STA clue_draw_address+1
  103                       
  104  06:CC71  60          RTS
  105                         
  106  06:CC72            SubFromClueDrawAddress:
  107                     
  108  06:CC72  8D 00 00    STA temp1
  109                       
  110  06:CC75  AD B2 00    LDA clue_draw_address
  111  06:CC78  38          SEC
  112  06:CC79  ED 00 00    SBC temp1
  113  06:CC7C  8D B2 00    STA clue_draw_address
  114  06:CC7F  AD B3 00    LDA clue_draw_address+1
  115  06:CC82  E9 00       SBC #$00
  116  06:CC84  8D B3 00    STA clue_draw_address+1
  117                       
  118  06:CC87  60          RTS
  119                       
  120  06:CC88            AddToClueDrawAddressHi:
  121                     
  122  06:CC88  8D 00 00    STA temp1
  123                       
  124  06:CC8B  AD B3 00    LDA clue_draw_address+1
  125  06:CC8E  6D 00 00    ADC temp1
  126  06:CC91  8D B3 00    STA clue_draw_address+1
  127                       
  128  06:CC94  60          RTS
  129                       
  130  06:CC95            CreateOffsetFromIndex:
  131                     
  132                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  133  06:CC95  AD B5 00    LDA clueLineIndex
  134  06:CC98  8D B8 00    STA clueDrawOffset
  135  06:CC9B  A9 00       LDA #$00
  136  06:CC9D  8D B9 00    STA clueDrawOffset+1
  137                       
  138  06:CCA0  AD B6 00    LDA clueOffsetShift   
  139  06:CCA3  F0 0E       BEQ .addOffset
  140                       
  141  06:CCA5  A2 00       LDX #$00
  142                       
  143  06:CCA7            .loopShift:
  144  06:CCA7  0E B8 00    ASL clueDrawOffset
  145  06:CCAA  2E B9 00    ROL clueDrawOffset+1
  146  06:CCAD  E8          INX
  147  06:CCAE  EC B6 00    CPX clueOffsetShift
  148  06:CCB1  D0 F4       BNE .loopShift
  149                       
  150  06:CCB3            .addOffset:
  151                       
  152  06:CCB3  20 4F CC    JSR ResetClueDrawAddress
  153  06:CCB6  AD B8 00    LDA clueDrawOffset
  154  06:CCB9  20 5C CC    JSR AddToClueDrawAddress 
  155  06:CCBC  AD B9 00    LDA clueDrawOffset+1
  156  06:CCBF  20 88 CC    JSR AddToClueDrawAddressHi
  157                       
  158  06:CCC2  60          RTS  
  159                       
  160  06:CCC3            ClearPuzzle:
  161                     
  162                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  163                      
  164                       MACROGetLabelPointer ClearLineDefTables, table_address
                          
       06:CCC3  A9 CE             LDA #HIGH(ClearLineDefTables)
       06:CCC5  A2 D4             LDX #LOW(ClearLineDefTables)
                                  
       06:CCC7  8E 11 00          STX table_address
       06:CCCA  8D 12 00          STA table_address+1
                                  
  165  06:CCCD  A0 00       LDY #$00
  166  06:CCCF  20 47 C9    JSR GetTableAtIndex
  167                       
  168                       
  169  06:CCD2  AC B5 00    LDY clueLineIndex
  170  06:CCD5  B1 11       LDA [table_address], y
  171  06:CCD7  8D 00 00    STA temp1
  172                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:CCDA  A9 01       LDA #$01
       06:CCDC  8D 1E 00    STA PPU_PendingWrite
       06:CCDF  AD B3 00    LDA clue_draw_address+1
       06:CCE2  20 82 CA    JSR WriteToPPUString
       06:CCE5  AD B2 00    LDA clue_draw_address
       06:CCE8  20 82 CA    JSR WriteToPPUString
       06:CCEB  A9 40       LDA #$40
       06:CCED  09 00       ORA #DRAW_HORIZONTAL
       06:CCEF  0D 00 00    ORA temp1
       06:CCF2  20 82 CA    JSR WriteToPPUString
       06:CCF5  A9 24       LDA #$24
       06:CCF7  20 82 CA    JSR WriteToPPUString
                            
  173                       ;;no need to load anything else
  174                       
  175  06:CCFA  AD B2 00    LDA clue_draw_address
  176  06:CCFD  18          CLC
  177  06:CCFE  69 20       ADC #32
  178  06:CD00  8D B2 00    STA clue_draw_address
  179  06:CD03  AD B3 00    LDA clue_draw_address+1
  180  06:CD06  69 00       ADC #$00
  181  06:CD08  8D B3 00    STA clue_draw_address+1
  182                       
  183  06:CD0B  EE B5 00    INC clueLineIndex
  184  06:CD0E  60          RTS
  185                       
  186  06:CD0F            LoadPauseScreen:
  187                     
  188                     ;;use clue indexes again
  189                     ;;we want to draw one line at a time
  190                     ;;we have control codes, but those don't matter since we have to build ou the strings before hand
  191                     
  192                     ;load pause table
  193                     ;there are 6 lines of 13 tiles
  194                     ;one byte for the 6 lines, one byte to keep track of our index
  195                       ;STA clueLineIndex 
  196                       ;STA clueOffsetShift
  197                     
  198                     ;;pause_address has the table we want
  199                     ;;pause_draw_address will be the draw location
  200                     
  201                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:CD0F  A9 01       LDA #$01
       06:CD11  8D 1E 00    STA PPU_PendingWrite
       06:CD14  AD AF 00    LDA pause_draw_address+1
       06:CD17  20 82 CA    JSR WriteToPPUString
       06:CD1A  AD AE 00    LDA pause_draw_address
       06:CD1D  20 82 CA    JSR WriteToPPUString
       06:CD20  A9 00       LDA #DRAW_HORIZONTAL
       06:CD22  20 82 CA    JSR WriteToPPUString
       06:CD25  A9 0D       LDA #13 
       06:CD27  20 82 CA    JSR WriteToPPUString
                            
  202                     
  203  06:CD2A  A2 00       LDX #$00
  204  06:CD2C  AC B5 00    LDY clueLineIndex
  205  06:CD2F            .loop:
  206                      
  207  06:CD2F  8A          TXA
  208  06:CD30  48          PHA
  209  06:CD31  B1 AA       LDA [pause_address],y
  210  06:CD33  20 82 CA    JSR WriteToPPUString
  211  06:CD36  68          PLA
  212  06:CD37  AA          TAX
  213  06:CD38  C8          INY
  214  06:CD39  E8          INX 
  215  06:CD3A  E0 0D       CPX #13
  216  06:CD3C  D0 F1       BNE .loop
  217                       
  218  06:CD3E  8C B5 00    STY clueLineIndex
  219                       
  220  06:CD41  AD AE 00    LDA pause_draw_address
  221  06:CD44  18          CLC
  222  06:CD45  69 20       ADC #$20
  223  06:CD47  8D AE 00    STA pause_draw_address
  224  06:CD4A  AD AF 00    LDA pause_draw_address+1
  225  06:CD4D  69 00       ADC #$00
  226  06:CD4F  8D AF 00    STA pause_draw_address+1
  227                       
  228  06:CD52  EE B6 00    INC clueOffsetShift
  229  06:CD55  60          RTS
  230                       
  231                       
  232                     
  233                     
  234  06:CD56            ClearPauseScreen:  
  235                     
  236                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:CD56  A9 01       LDA #$01
       06:CD58  8D 1E 00    STA PPU_PendingWrite
       06:CD5B  AD AF 00    LDA pause_draw_address+1
       06:CD5E  20 82 CA    JSR WriteToPPUString
       06:CD61  AD AE 00    LDA pause_draw_address
       06:CD64  20 82 CA    JSR WriteToPPUString
       06:CD67  A9 00       LDA #DRAW_HORIZONTAL
       06:CD69  20 82 CA    JSR WriteToPPUString
       06:CD6C  A9 0D       LDA #13 
       06:CD6E  20 82 CA    JSR WriteToPPUString
                            
  237                     
  238  06:CD71  A2 00       LDX #$00
  239  06:CD73  A0 00       LDY #$00
  240  06:CD75            .loop:
  241                      
  242  06:CD75  8A          TXA
  243  06:CD76  48          PHA
  244  06:CD77  B1 AA       LDA [pause_address],y
  245  06:CD79  20 82 CA    JSR WriteToPPUString
  246  06:CD7C  68          PLA
  247  06:CD7D  AA          TAX
  248  06:CD7E  C8          INY
  249  06:CD7F  E8          INX 
  250  06:CD80  E0 0D       CPX #13
  251  06:CD82  D0 F1       BNE .loop
  252                       
  253                       
  254  06:CD84  AD AE 00    LDA pause_draw_address
  255  06:CD87  18          CLC
  256  06:CD88  69 20       ADC #$20
  257  06:CD8A  8D AE 00    STA pause_draw_address
  258  06:CD8D  AD AF 00    LDA pause_draw_address+1
  259  06:CD90  69 00       ADC #$00
  260  06:CD92  8D AF 00    STA pause_draw_address+1
  261                       
  262  06:CD95  AD AA 00    LDA pause_address
  263  06:CD98  18          CLC
  264  06:CD99  69 20       ADC #$20
  265  06:CD9B  8D AA 00    STA pause_address
  266  06:CD9E  AD AB 00    LDA pause_address+1
  267  06:CDA1  69 00       ADC #$00
  268  06:CDA3  8D AB 00    STA pause_address+1
  269                       
  270  06:CDA6  EE B6 00    INC clueOffsetShift
  271  06:CDA9  60         RTS
  272  06:CDAA            DrawImage:
  273                     
  274                       ;;we have clueTableIndex, which should be at the image bytes now
  275                       ;;clue line index will keep track of our place in a byte
  276                        
  277  06:CDAA  A9 00       LDA #$00
  278  06:CDAC  8D 00 00    STA temp1
  279  06:CDAF  8D 01 00    STA temp2
  280  06:CDB2  8D 02 00    STA temp3
  281  06:CDB5  8D 03 00    STA temp4
  282  06:CDB8  8D 05 00    STA temp6
  283                       
  284  06:CDBB  A9 04       LDA #$04
  285  06:CDBD  8D 04 00    STA temp5
  286                       
  287  06:CDC0  AC B4 00    LDY clueTableIndex
  288  06:CDC3  B1 A8       LDA [clues_address], y
  289                     
  290  06:CDC5  0A          ASL A
  291  06:CDC6  2E 00 00    ROL temp1
  292  06:CDC9  0A          ASL A
  293  06:CDCA  2E 00 00    ROL temp1
  294  06:CDCD  0A          ASL A
  295  06:CDCE  2E 01 00    ROL temp2
  296  06:CDD1  0A          ASL A
  297  06:CDD2  2E 01 00    ROL temp2
  298  06:CDD5  0A          ASL A
  299  06:CDD6  2E 02 00    ROL temp3
  300  06:CDD9  0A          ASL A
  301  06:CDDA  2E 02 00    ROL temp3
  302  06:CDDD  0A          ASL A
  303  06:CDDE  2E 03 00    ROL temp4
  304  06:CDE1  0A          ASL A
  305  06:CDE2  2E 03 00    ROL temp4
  306                       
  307                     
  308  06:CDE5  A2 00       LDX #$00
  309  06:CDE7            .moveUpTiles:
  310  06:CDE7  BD 00 00    LDA temp1, x
  311  06:CDEA  09 24       ORA #$24
  312  06:CDEC  9D 00 00    STA temp1, x
  313  06:CDEF  E8          INX
  314  06:CDF0  E0 04       CPX #$04
  315  06:CDF2  D0 F3       BNE .moveUpTiles
  316                       
  317                       
  318  06:CDF4  AD B6 00    LDA clueOffsetShift
  319  06:CDF7  18          CLC
  320  06:CDF8  69 04       ADC #$04
  321                     
  322  06:CDFA  8D B6 00    STA clueOffsetShift
  323                       ;;clue offset shift + 4, check if we went over 15
  324  06:CDFD  38          SEC
  325  06:CDFE  E9 0F       SBC #15 ;;subtract 15
  326  06:CE00  90 12       BCC .makeStrings
  327  06:CE02  F0 10       BEQ .makeStrings
  328                       
  329  06:CE04  8D B6 00    STA clueOffsetShift ;loop offset over
  330  06:CE07  8D 05 00    STA temp6 ; length of second string
  331  06:CE0A  AD 04 00    LDA temp5
  332  06:CE0D  38          SEC
  333  06:CE0E  ED 05 00    SBC temp6 
  334  06:CE11  8D 04 00    STA temp5 ;length of first string 
  335                       
  336  06:CE14            .makeStrings:
  337                       
  338  06:CE14  A2 00       LDX #$00
  339                       
  340  06:CE16  AD 04 00    LDA temp5
  341  06:CE19  F0 50       BEQ .makeSecondString
  342  06:CE1B  8A          TXA
  343  06:CE1C  48          PHA
  344                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp5
                          
       06:CE1D  A9 01       LDA #$01
       06:CE1F  8D 1E 00    STA PPU_PendingWrite
       06:CE22  AD B3 00    LDA clue_draw_address+1
       06:CE25  20 82 CA    JSR WriteToPPUString
       06:CE28  AD B2 00    LDA clue_draw_address
       06:CE2B  20 82 CA    JSR WriteToPPUString
       06:CE2E  A9 00       LDA #DRAW_HORIZONTAL
       06:CE30  20 82 CA    JSR WriteToPPUString
       06:CE33  AD 04 00    LDA temp5 
       06:CE36  20 82 CA    JSR WriteToPPUString
                            
  345  06:CE39  68          PLA
  346  06:CE3A  AA          TAX
  347                       
  348  06:CE3B            .firstStringLoop:
  349                       
  350  06:CE3B  8A          TXA 
  351  06:CE3C  48          PHA
  352  06:CE3D  BD 00 00    LDA temp1, x
  353  06:CE40  20 82 CA    JSR WriteToPPUString
  354                       
  355  06:CE43  EE B5 00    INC clueLineIndex
  356  06:CE46  AD B5 00    LDA clueLineIndex
  357  06:CE49  C9 E1       CMP #225
  358  06:CE4B  D0 04       BNE .continueLoop
  359  06:CE4D  68          PLA 
  360  06:CE4E  4C D0 CE    JMP .leave
  361                       
  362  06:CE51            .continueLoop:
  363  06:CE51  68          PLA
  364  06:CE52  AA          TAX
  365  06:CE53  E8          INX
  366  06:CE54  EC 04 00    CPX temp5
  367  06:CE57  D0 E2       BNE .firstStringLoop
  368                       
  369  06:CE59  AD B2 00    LDA clue_draw_address
  370  06:CE5C  18          CLC
  371  06:CE5D  6D 04 00    ADC temp5
  372  06:CE60  8D B2 00    STA clue_draw_address
  373  06:CE63  AD B3 00    LDA clue_draw_address+1
  374  06:CE66  69 00       ADC #$00
  375  06:CE68  8D B3 00    STA clue_draw_address+1
  376                       
  377  06:CE6B            .makeSecondString:
  378                     
  379  06:CE6B  AD 05 00    LDA temp6
  380  06:CE6E  F0 60       BEQ .leave
  381                       
  382                       ;;loop draw address to next line
  383  06:CE70  AD B2 00    LDA clue_draw_address
  384  06:CE73  18          CLC
  385  06:CE74  69 11       ADC #17
  386  06:CE76  8D B2 00    STA clue_draw_address
  387  06:CE79  AD B3 00    LDA clue_draw_address+1
  388  06:CE7C  69 00       ADC #$00
  389  06:CE7E  8D B3 00    STA clue_draw_address+1
  390  06:CE81  8A          TXA
  391  06:CE82  48          PHA
  392                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp6
                          
       06:CE83  A9 01       LDA #$01
       06:CE85  8D 1E 00    STA PPU_PendingWrite
       06:CE88  AD B3 00    LDA clue_draw_address+1
       06:CE8B  20 82 CA    JSR WriteToPPUString
       06:CE8E  AD B2 00    LDA clue_draw_address
       06:CE91  20 82 CA    JSR WriteToPPUString
       06:CE94  A9 00       LDA #DRAW_HORIZONTAL
       06:CE96  20 82 CA    JSR WriteToPPUString
       06:CE99  AD 05 00    LDA temp6 
       06:CE9C  20 82 CA    JSR WriteToPPUString
                            
  393  06:CE9F  68          PLA 
  394  06:CEA0  AA          TAX
  395                       
  396  06:CEA1            .secondStringLoop:
  397                     
  398  06:CEA1  8A          TXA
  399  06:CEA2  48          PHA 
  400  06:CEA3  BD 00 00    LDA temp1, x
  401  06:CEA6  20 82 CA    JSR WriteToPPUString
  402                       
  403  06:CEA9  EE B5 00    INC clueLineIndex
  404  06:CEAC  AD B5 00    LDA clueLineIndex
  405  06:CEAF  C9 E1       CMP #225
  406  06:CEB1  D0 04       BNE .continueSecondLoop
  407                       
  408  06:CEB3  68          PLA 
  409  06:CEB4  4C D0 CE    JMP .leave
  410                       
  411  06:CEB7            .continueSecondLoop:
  412  06:CEB7  68          PLA
  413  06:CEB8  AA          TAX
  414  06:CEB9  E8          INX
  415  06:CEBA  E0 04       CPX #$04
  416  06:CEBC  D0 E3       BNE .secondStringLoop
  417                       
  418  06:CEBE  AD B2 00    LDA clue_draw_address
  419  06:CEC1  18          CLC
  420  06:CEC2  6D 05 00    ADC temp6
  421  06:CEC5  8D B2 00    STA clue_draw_address
  422  06:CEC8  AD B3 00    LDA clue_draw_address+1
  423  06:CECB  69 00       ADC #$00
  424  06:CECD  8D B3 00    STA clue_draw_address+1
  425                       
  426  06:CED0            .leave:
  427  06:CED0  EE B4 00    INC clueTableIndex
  428  06:CED3  60          RTS
  429                     
  430  06:CED4            ClearLineDefTables:
  431                     
  432  06:CED4  D6 CE       .word Clear15x15LineDefs
  433                     
  434  06:CED6            Clear15x15LineDefs:
  435  06:CED6  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:CED9  20 20 20  
       06:CEDC  20 20 20  
       06:CEDF  20 20     
  436  06:CEE1  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:CEE4  0D 0D 0D  
       06:CEE7  0D 0D 0D  
       06:CEEA  0D 0D 0D  
       06:CEED  0D 0D 0D  
       06:CEF0  0D 0D     
  437  06:CEF2  20 20       .db $20, $20
#[1]   Picross.asm
   93                       
   94                       
   95                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   96                     ;;     NMI                  ;;
   97                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   98                     
#[2]   Routines/Common/NMI.asm
   99                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:CEF4            NMI:
    3                     
    4  06:CEF4  48          PHA                              ;protect the registers
    5  06:CEF5  8A          TXA
    6  06:CEF6  48          PHA
    7  06:CEF7  98          TYA
    8  06:CEF8  48          PHA
    9                       
   10  06:CEF9            nmi_started:
   11  06:CEF9  A9 00       LDA #$00
   12  06:CEFB  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:CEFE  A9 02       LDA #$02
   14  06:CF00  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:CF03  AD 0D 00    LDA NMI_locks
   17  06:CF06  F0 03       BEQ update_controllers
   18  06:CF08  4C 77 CF    JMP WakeUp
   19                     
   20  06:CF0B            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:CF0B  8A            TXA
    3  06:CF0C  48                PHA
    4  06:CF0D  98                TYA
    5  06:CF0E  48                PHA
    6                     
    7  06:CF0F  A2 00             LDX #$00
    8                     
    9  06:CF11            GamePadCheck:
   10  06:CF11  A9 01             LDA #$01        ;load 1
   11  06:CF13  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:CF16  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:CF17  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:CF1A  A9 80             LDA #$80
   18  06:CF1C  8D 15 00          STA gamepad
   19                     
   20  06:CF1F            ReadControllerABytesLoop:
   21  06:CF1F  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:CF22  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:CF24  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:CF26  6E 15 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:CF29  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:CF2B  AD 16 00          LDA gamepadLast
   31  06:CF2E  49 FF             EOR #$FF
   32  06:CF30  2D 15 00          AND gamepad
   33  06:CF33  8D 17 00          STA gamepadPressed
   34                             
   35                             
   36  06:CF36  AD 15 00          LDA gamepad
   37  06:CF39  8D 16 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:CF3C  68                PLA
   41  06:CF3D  A8                TAY
   42  06:CF3E  68                PLA
   43  06:CF3F  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:CF40  20 BF C9    JSR ProcessPPUString
   25                       
   26                       
   27  06:CF43  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:CF45  8D 05 20    STA PPU_SCROLL
   29  06:CF48  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:CF4B  20 DC CA    JSR UpdatePPUControl
   34                     
   35  06:CF4E            NMIUpdate:
   36                     
   37  06:CF4E  20 6B CF    JSR StateNMIUpdate
   38                       
   39  06:CF51  AD 18 00    LDA PPU_Control
   40  06:CF54  29 FC       AND #$FC
   41  06:CF56  0D 1C 00    ORA PPU_ScrollNT
   42  06:CF59  8D 00 20    STA PPU_CTRL
   43                       
   44  06:CF5C  AD 1A 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:CF5F  8D 05 20    STA PPU_SCROLL
   46  06:CF62  AD 1B 00    LDA PPU_ScrollY
   47  06:CF65  8D 05 20    STA PPU_SCROLL
   48                     
   49  06:CF68  4C 77 CF    JMP WakeUp
   50                     
   51  06:CF6B            StateNMIUpdate:
   52                     
   53                       MACROCallDynamicJump game_mode
                          
       06:CF6B  AD 0B 00    LDA game_mode
       06:CF6E  20 21 C9    JSR Dynamic_Jump
                                  
   54                     
   55  06:CF71            NMIJumpTable:
   56                     
   57  06:CF71  82 CF       .word UpdateTitleNMI
   58  06:CF73  86 CF       .word UpdateGameNMI
   59  06:CF75  87 CF       .word UpdateGameOverNMI
   60                     
   61  06:CF77            WakeUp:
   62  06:CF77  A9 00       LDA #$00
   63  06:CF79  8D 09 00    STA sleeping
   64                       
   65  06:CF7C  68          PLA             ;restore the registers
   66  06:CF7D  A8          TAY 
   67  06:CF7E  68          PLA
   68  06:CF7F  AA          TAX
   69  06:CF80  68          PLA
   70                     
   71  06:CF81  40          RTI             ; return from interrupt
   72                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   73                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:CF82            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:CF82  20 A2 CA    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:CF85  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   74                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:CF86            UpdateGameNMI:
    2  06:CF86  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:CF87            UpdateGameOverNMI:
    2  06:CF87  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
  100                       
  101                     ;;**************************;;
  102                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  103                     ;;       PRG ROM DATA       ;;
  104                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  105                     ;;**************************;; 
  106                       
  107           0007        .bank 7
  108           E000        .org $E000
  109                     
#[2]   NameTables/Tables.asm
  110                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  1C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  3C E0     
       07:E004  5C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  12 E0       .word Title_Screens, Game_Screens, GameOver_Screens
       07:E008  14 E0     
       07:E00A  1A E0     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  7C E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  7C F8     
       07:E010  7C F8     
   12                       
   13  07:E012            Title_Screens:
   14                     
   15  07:E012  7C E0       .word Title_Screen
   16                       
   17  07:E014            Game_Screens:
   18                     
   19  07:E014  7C E8       .word Game_5, Game_10, Game_15
       07:E016  7C EC     
       07:E018  7C F0     
   20                       
   21  07:E01A            GameOver_Screens:
   22                     
   23  07:E01A  7C F4       .word GameOver_Screen
   24                     
   25  07:E01C            Title_Palette:
   26                     
   27  07:E01C              .incbin "NameTables/Title_PAL.pal"
   28  07:E02C              .incbin "NameTables/Title_PAL.pal"
   29                       
   30  07:E03C            Game_Palette:
   31                     
   32  07:E03C              .incbin "NameTables/Game_PAL.pal"
   33  07:E04C              .incbin "NameTables/Game_PAL.pal"
   34                       
   35  07:E05C            GameOver_Palette:
   36                     
   37  07:E05C              .incbin "NameTables/GameOver_PAL.pal"
   38  07:E06C              .incbin "NameTables/GameOver_PAL.pal"
   39                       
   40  07:E07C            Title_Screen:
   41                     
   42  07:E07C              .incbin "NameTables/Title_NT.nam"
   43                       
   44  07:E47C            Title_Second:
   45                     
   46  07:E47C              .incbin "NameTables/Title_PuzzMen_NT.nam"
   47                       
   48  07:E87C            Game_5: 
   49                     
   50  07:E87C              .incbin "NameTables/Game_NT_5.nam"
   51                       
   52  07:EC7C            Game_10:
   53  07:EC7C              .incbin "NameTables/Game_NT_10.nam"
   54                       
   55  07:F07C            Game_15:
   56  07:F07C              .incbin "NameTables/Game_NT.nam"
   57                       
   58  07:F47C            GameOver_Screen:
   59                     
   60  07:F47C              .incbin "NameTables/GameOver_NT.nam"
   61                       
   62  07:F87C            Blank_Screen:
   63                     
   64  07:F87C              .incbin "NameTables/Blank_NT.nam"
   65                     
   66  07:FC7C            Pause_Menu:
   67  07:FC7C  28 2A 2A    .db $28,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$29
       07:FC7F  2A 2A 2A  
       07:FC82  2A 2A 2A  
       07:FC85  2A 2A 2A  
       07:FC88  29        
   68  07:FC89  2B 24 1C    .db $2b,$24,$1c,$0a,$1f,$0e,$62,$0e,$21,$12,$1d,$24,$3b
       07:FC8C  0A 1F 0E  
       07:FC8F  62 0E 21  
       07:FC92  12 1D 24  
       07:FC95  3B        
   69  07:FC96  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FC99  24 24 24  
       07:FC9C  24 24 24  
       07:FC9F  24 24 24  
       07:FCA2  3B        
   70  07:FCA3  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FCA6  24 24 24  
       07:FCA9  24 24 24  
       07:FCAC  24 24 24  
       07:FCAF  3B        
   71  07:FCB0  2B 24 24    .db $2b,$24,$24,$22,$0e,$1c,$24,$24,$17,$18,$24,$24,$3b
       07:FCB3  22 0E 1C  
       07:FCB6  24 24 17  
       07:FCB9  18 24 24  
       07:FCBC  3B        
   72  07:FCBD  38 3A 3A    .db $38,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$39
       07:FCC0  3A 3A 3A  
       07:FCC3  3A 3A 3A  
       07:FCC6  3A 3A 3A  
       07:FCC9  39        
   73                     
   74                       
   75                     
   76                       
   77                      
   78                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  111                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:FCCA            Sprites:
   38  07:FCCA  D0 FC             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:FCCC  D9 FC     
       07:FCCE  DE FC     
   39                     
   40  07:FCD0            Title_Sprites:
   41  07:FCD0  02            .db $02
   42  07:FCD1  85 00 00          .db $85,$00,$00,$E8
       07:FCD4  E8        
   43  07:FCD5  A0 01 00          .db $A0,$01,$00,$60
       07:FCD8  60        
   44  07:FCD9            Game_Sprites:
   45  07:FCD9  01            .db $01
   46  07:FCDA  62 00 03          .db $62,$00,$03,$72
       07:FCDD  72        
   47  07:FCDE            GameOver_Sprites:
   48  07:FCDE  01                .db $01
   49  07:FCDF  00 00 00          .db $00,$00,$00,$00
       07:FCE2  00        
#[1]   Picross.asm
  112                     
  113           FFFA        .org $FFFA     ;first of the three vectors starts here
  114  07:FFFA  F4 CE       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  115                                        ;processor will jump to the label NMI:
  116  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  117                                        ;to the label RESET:
  118  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  119                       
  120                     ;;**************************;;
  121                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  122                     ;;      CHR ROM DATA        ;;
  123                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  124                     ;;**************************;; 
  125                       
  126           0008        .bank 8
  127           0000        .org $0000
  128  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  129                       
  130           0009        .bank 9
  131           0000        .org $0000
  132  09:0000              .incbin "CHRROM/Bank1.chr"
  133                       
  134           000A        .bank 10
  135           0000        .org $0000
  136  0A:0000              .incbin "CHRROM/Bank2.chr"
  137                       
  138           000B        .bank 11
  139           0000        .org $0000
  140  0B:0000              .incbin "CHRROM/Bank3.chr"
