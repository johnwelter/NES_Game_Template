#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      temp5                   .rs 1
    6           0005      temp6                   .rs 1
    7           0006      temp7                   .rs 1
    8           0007      temp8                   .rs 1
    9           0008      tempx                   .rs 1
   10           0009      tempy                   .rs 1
   11           000A      time                    .rs 1
   12           000B      scaledTime              .rs 1
   13           000C      sleeping                .rs 1
   14           000D      mode_loadFlags  .rs 1
   15                     ;;0rcb xxxx
   16                     ;;r = read from save copy 
   17                     ;;c = write to save copy
   18           000E      game_mode               .rs 1
   19           000F      mode_state              .rs 1
   20           0010      NMI_locks               .rs 1
   21           0011      game_locks              .rs 1
   22           0012      pointer_address .rs 2
   23           0014      pointerB_address .rs 2
   24           0016      table_address   .rs 2
   25           0018      jump_address    .rs 2
   26                     
   27                     ;game modes
   28           0000      TITLE_IDX = $00
   29           0001      GAME_IDX = $01
   30           0002      GAMEOVER_IDX = $02
   31                     
   32                     ;locks for input and rendering
   33           0001      BGLOAD_NMI_LOCK = %00000001
   34           0001      EFFECT_GAME_LOCK = %00000001
   35                     
   36                     
   37                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           001A      gamepad                 .rs 1
   19           001B      gamepadLast     .rs 1
   20           001C      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           001D      PPU_Control                     .rs 1
    2           001E      PPU_Mask                        .rs 1
    3           001F      PPU_ScrollX                     .rs 1
    4           0020      PPU_ScrollY                     .rs 1
    5           0021      PPU_ScrollNT            .rs 1   ;first two bits
    6           0022      PPU_NT                          .rs 1
    7                     
    8           0023      PPU_PendingWrite        .rs 1
    9           0024      PPU_StringIdx           .rs 1
   10           0025      PPU_String                      .rs 128
   11                     
   12           004F      PPU_STRINGMAX = $4F ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           00A5      mapper_address  .rs 2
    2           00A7      currentCHRBankA .rs 1
    3           00A8      currentCHRBankB .rs 1
    4           00A9      currentPRGBank  .rs 1
    5           00AA      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           A000      PUZZLE_TABLE = $A000
    2           A036      NAMES_TABLE = $A036
    3           A06C      SPRITES_TABLE = $A06C
    4                     
    5           00AB      tempBank                        .rs 1
    6           00AC      tempPuzz                        .rs 1
    7           00AD      puzzle_address          .rs 2
    8           00AF      clues_address           .rs 2
    9           00B1      title_address           .rs 2
   10           00B3      pause_address           .rs 2
   11           00B5      copy_address        .rs 2
   12           00B7      pause_draw_address  .rs 2
   13           00B9      title_draw_address      .rs 2
   14           00BB      clue_start_address      .rs 2
   15           00BD      clue_draw_address       .rs 2
   16           00BF      clueTableIndex          .rs 1
   17           00C0      clueLineIndex           .rs 1
   18           00C1      clueOffsetShift         .rs 1
   19           00C2      clueDrawAdd                     .rs 1
   20           00C3      clueDrawOffset          .rs 2
   21           00C5      clueDrawDecSize         .rs 1
   22           00C6      clueParity                      .rs 1
   23           00C7      mouse_location          .rs 2
   24           00C9      mouse_index                     .rs 2
   25           00CB      currentPaintTile        .rs 1
   26           00CC      pauseState                      .rs 1
   27           00CD      pauseInputLock          .rs 1
   28           00CE      holdTimer                       .rs 1
   29           00CF      targetGameMode          .rs 1
   30           00D0      targetScreenLoad        .rs 1
   31           00D1      recordSet                       .rs 1
#[2]   Defines/Defines.asm
   10           00D2      sound_ptr .rs 2
   11           00D4      sound_ptr2 .rs 2
   12           00D6      current_song .rs 1
   13                     ;; 0100 is the stack
   14                     ;; 0200 is sprite ram
   15           0300        .rsset $0300
   16           0400        .rsset $0400
   17           0500        .rsset $0500
   18           0600        .rsset $0600
   19           0700        .rsset $0700
   20           6000        .rsset $6000
#[3]   Defines/ScreenStateVariables.asm
   21                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      SaveScreen_Copy .rs 1024
    4           6C00      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   22           7000        .rsset $7000
#[3]   Defines/SaveVariables.asm
   23                       .include "Defines/SaveVariables.asm"
    1           7000      hasContinue .rs 1
    2           7001      solutionCount           .rs 1
    3           7002      nonSolutionCount        .rs 1
    4           7003      GameTime                        .rs 4   ;in order - second, ten second, minute, 10 minute - max out at 99 minutes
    5           7007      bank_index      .rs 1
    6           7008      puzzle_index .rs 1
    7           7009      image_table_offset .rs 1
    8                     ;we can save these for the continue
    9                     ;on a continue- we just need to load the back ground as it was
   10                     ;we'll save out data for the puzzles- just need to know if it's 1) complete and 2) the time
   11                     ;we can do that in 4 bytes each, so 324 bytes
   12           700A      puzzle_clear_bank0 .rs 108
   13           7076      puzzle_clear_bank1 .rs 108
   14           70E2      puzzle_clear_bank2 .rs 108
   15                     
#[2]   Defines/Defines.asm
   24                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     MACROAddPPUStringEntryTablePtr .macro
   76                      
   77                       LDA #$01
   78                       STA PPU_PendingWrite
   79                       LDA \1
   80                       JSR WriteToPPUString
   81                       LDA \2
   82                       JSR WriteToPPUString
   83                       LDA #$20
   84                       ORA \3
   85                       JSR WriteToPPUString
   86                       LDA \4
   87                       JSR WriteToPPUString
   88                       LDA \4+1
   89                       JSR WriteToPPUString
   90                      
   91                       .endm
   92                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1                     
    2                     
    3           0000        .bank 0
    4           8000        .org $8000
    5                       
#[3]   Puzzles/house.asm
    6                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  02 82 00    .db $02, $82, $00, $21
       00:8003  21        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  05 11 18    .db $05, $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1E 1C 0E  
       00:80B6  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test.asm
    7                       .include "Puzzles/test.asm"
    1  00:80B7            test:
    2  00:80B7  02 01 00    .db $02, $01, $00, $00
       00:80BA  00        
    3  00:80BB  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:80BE  00 00 00  
       00:80C1  00 00 00  
       00:80C4  00 00 00  
       00:80C7  00 00 00  
       00:80CA  00 00 00  
       00:80CD  00 00 00  
       00:80D0  00 00 00  
       00:80D3  00 00 00  
       00:80D6  00 00 00  
    4  00:80D9  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80DC  FF 00 FF  
       00:80DF  00 FF 00  
       00:80E2  FF 00 FF  
       00:80E5  00 FF 00  
       00:80E8  FF 00 FF  
       00:80EB  00 FF 00  
       00:80EE  FF 00 FF  
       00:80F1  00 FF 00  
       00:80F4  FF 00 FF  
    5  00:80F7  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80FA  FF 00 FF  
       00:80FD  00 FF 00  
       00:8100  FF 00 FF  
       00:8103  00 FF 00  
       00:8106  FF 00 FF  
       00:8109  00 FF 00  
       00:810C  FF 00 FF  
       00:810F  00 FF 00  
       00:8112  FF 00 FF  
    6  00:8115            testImage:
    7  00:8115  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8118  1B 1B 1B  
       00:811B  1B 1B 1B  
       00:811E  1B 1B 1B  
       00:8121  1B 1B 1B  
       00:8124  1B 1B 1B  
       00:8127  1B 1B 1B  
       00:812A  1B 1B 1B  
       00:812D  1B 1B 1B  
       00:8130  1B 1B 1B  
       00:8133  1B 1B 1B  
       00:8136  1B 1B 1B  
       00:8139  1B 1B 1B  
       00:813C  1B 1B 1B  
       00:813F  1B 1B 1B  
       00:8142  1B 1B 1B  
       00:8145  1B 1B 1B  
       00:8148  1B 1B 1B  
       00:814B  1B 1B 00  
       00:814E  FF        
    8  00:814F            testName:
    9  00:814F  04 1D 0E    .db $04, $1D, $0E, $1C, $1D, $FF
       00:8152  1C 1D FF  
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test5.asm
    8                       .include "Puzzles/test5.asm"
    1  00:8155            test5:
    2  00:8155  00 01 00    .db $00, $01, $00, $32
       00:8158  32        
    3  00:8159  80 00 00    .db $80, $00, $00, $00, $00
       00:815C  00 00     
    4  00:815E  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:8161  FF 00 FF  
       00:8164  00 FF 00  
       00:8167  FF        
    5  00:8168  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:816B  FF 00 FF  
       00:816E  00 FF 00  
       00:8171  FF        
    6  00:8172            test5Image:
    7  00:8172  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8175  1B 1B 1B  
       00:8178  00 FF     
    8  00:817A            test5Name:
    9  00:817A  05 1D 0E    .db $05, $1D, $0E, $1C, $1D, $05, $FF
       00:817D  1C 1D 05  
       00:8180  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test10.asm
    9                       .include "Puzzles/test10.asm"
    1  00:8181            test10:
    2  00:8181  01 01 00    .db $01, $01, $00, $16
       00:8184  16        
    3  00:8185  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:8188  00 00 00  
       00:818B  00 00 00  
       00:818E  00 00 00  
       00:8191  00 00 00  
       00:8194  00 00 00  
       00:8197  00 00     
    4  00:8199  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:819C  FF 00 FF  
       00:819F  00 FF 00  
       00:81A2  FF 00 FF  
       00:81A5  00 FF 00  
       00:81A8  FF 00 FF  
       00:81AB  00 FF     
    5  00:81AD  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:81B0  FF 00 FF  
       00:81B3  00 FF 00  
       00:81B6  FF 00 FF  
       00:81B9  00 FF 00  
       00:81BC  FF 00 FF  
       00:81BF  00 FF     
    6  00:81C1            test10Image:
    7  00:81C1  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $FF
       00:81C4  1B 1B 1B  
       00:81C7  1B 1B 1B  
       00:81CA  1B 1B 1B  
       00:81CD  1B 1B 1B  
       00:81D0  1B 1B 1B  
       00:81D3  1B 1B 1B  
       00:81D6  1B 1B 1B  
       00:81D9  1B FF     
    8  00:81DB            test10Name:
    9  00:81DB  06 1D 0E    .db $06, $1D, $0E, $1C, $1D, $01, $00, $FF
       00:81DE  1C 1D 01  
       00:81E1  00 FF     
#[2]   Banks/Bank0.asm
#[3]   Puzzles/myGlyph.asm
   10                       .include "Puzzles/myGlyph.asm"
    1  00:81E3            myGlyph:
    2  00:81E3  02 0F 00    .db $02, $0F, $00, $00
       00:81E6  00        
    3  00:81E7  AA AA 00    .db $AA, $AA, $00, $00, $80, $00, $00, $00, $80, $00, $00, $00, $80, $00, $00, $00, $80, $00, $00, $00, $80, $00, $00, $00, $80, $00, $00, $00, $80, $00
       00:81EA  00 80 00  
       00:81ED  00 00 80  
       00:81F0  00 00 00  
       00:81F3  80 00 00  
       00:81F6  00 80 00  
       00:81F9  00 00 80  
       00:81FC  00 00 00  
       00:81FF  80 00 00  
       00:8202  00 80 00  
    4  00:8205  11 11 11    .db $11, $11, $11, $11, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF
       00:8208  11 FF 00  
       00:820B  FF 10 FF  
       00:820E  00 FF 10  
       00:8211  FF 00 FF  
       00:8214  10 FF 00  
       00:8217  FF 10 FF  
       00:821A  00 FF 10  
       00:821D  FF 00 FF  
       00:8220  10 FF 00  
       00:8223  FF 10 FF  
    5  00:8226  11 11 11    .db $11, $11, $11, $11, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF, $00, $FF, $10, $FF
       00:8229  11 FF 00  
       00:822C  FF 10 FF  
       00:822F  00 FF 10  
       00:8232  FF 00 FF  
       00:8235  10 FF 00  
       00:8238  FF 10 FF  
       00:823B  00 FF 10  
       00:823E  FF 00 FF  
       00:8241  10 FF 00  
       00:8244  FF 10 FF  
    6  00:8247            myGlyphImage:
    7  00:8247  D4 1F F0   .db $D4, $1F, $F0, $F3, $40, $F7, $57, $0D, $80, $AE, $8D, $16, $FA, $F0, $F5, $55, $5F, $AF, $C5, $AE, $F9, $7E, $8C, $EB, $E5, $55, $71, $B7, $DC, $A9, $7B, $EB, $4A, $21, $F2, $BD, $60, $99, $FA, $EA, $A1, $69, $3C, $02, $55, $25, $BF, $FA, $30, $06, $AF, $E0, $A0, $80, $3F, $C0, $00, $FF
       00:824A  F3 40 F7  
       00:824D  57 0D 80  
       00:8250  AE 8D 16  
       00:8253  FA F0 F5  
       00:8256  55 5F AF  
       00:8259  C5 AE F9  
       00:825C  7E 8C EB  
       00:825F  E5 55 71  
       00:8262  B7 DC A9  
       00:8265  7B EB 4A  
       00:8268  21 F2 BD  
       00:826B  60 99 FA  
       00:826E  EA A1 69  
       00:8271  3C 02 55  
       00:8274  25 BF FA  
       00:8277  30 06 AF  
       00:827A  E0 A0 80  
       00:827D  3F C0 00  
       00:8280  FF        
    8  00:8281            myGlyphName:
    9  00:8281  07 16 22    .db $07, $16, $22, $10, $15, $22, $19, $11, $FF
       00:8284  10 15 22  
       00:8287  19 11 FF  
#[2]   Banks/Bank0.asm
   11                     
   12           0001        .bank 1
   13           A000        .org $A000
   14                     ;puzzles
   15  01:A000  55 81       .word test5, test10, myGlyph, test, test, test, test, test, test
       01:A002  81 81     
       01:A004  E3 81     
       01:A006  B7 80     
       01:A008  B7 80     
       01:A00A  B7 80     
       01:A00C  B7 80     
       01:A00E  B7 80     
       01:A010  B7 80     
   16  01:A012  00 80       .word house, test, test, test, test, test, test, test, test
       01:A014  B7 80     
       01:A016  B7 80     
       01:A018  B7 80     
       01:A01A  B7 80     
       01:A01C  B7 80     
       01:A01E  B7 80     
       01:A020  B7 80     
       01:A022  B7 80     
   17  01:A024  00 80       .word house, test, test, test, test, test, test, test, test
       01:A026  B7 80     
       01:A028  B7 80     
       01:A02A  B7 80     
       01:A02C  B7 80     
       01:A02E  B7 80     
       01:A030  B7 80     
       01:A032  B7 80     
       01:A034  B7 80     
   18                     ;puzzle names
   19  01:A036  7A 81       .word test5Name, test10Name, myGlyphName, testName, testName, testName, testName, testName, testName
       01:A038  DB 81     
       01:A03A  81 82     
       01:A03C  4F 81     
       01:A03E  4F 81     
       01:A040  4F 81     
       01:A042  4F 81     
       01:A044  4F 81     
       01:A046  4F 81     
   20  01:A048  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A04A  4F 81     
       01:A04C  4F 81     
       01:A04E  4F 81     
       01:A050  4F 81     
       01:A052  4F 81     
       01:A054  4F 81     
       01:A056  4F 81     
       01:A058  4F 81     
   21  01:A05A  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A05C  4F 81     
       01:A05E  4F 81     
       01:A060  4F 81     
       01:A062  4F 81     
       01:A064  4F 81     
       01:A066  4F 81     
       01:A068  4F 81     
       01:A06A  4F 81     
   22                     ;puzzle sprites
   23  01:A06C  00 00 00    .db $00, $00, $00, $00
       01:A06F  00        
   24  01:A070  00 00 00    .db $00, $00, $00, $00
       01:A073  00        
   25  01:A074  00 00 00    .db $00, $00, $00, $00
       01:A077  00        
   26  01:A078  00 00 00    .db $00, $00, $00, $00
       01:A07B  00        
   27  01:A07C  00 00 00    .db $00, $00, $00, $00
       01:A07F  00        
   28  01:A080  00 00 00    .db $00, $00, $00, $00
       01:A083  00        
   29  01:A084  00 00 00    .db $00, $00, $00, $00
       01:A087  00        
   30  01:A088  00 00 00    .db $00, $00, $00, $00
       01:A08B  00        
   31  01:A08C  00 00 00    .db $00, $00, $00, $00
       01:A08F  00        
   32  01:A090  00 00 00    .db $00, $00, $00, $00
       01:A093  00        
   33  01:A094  00 00 00    .db $00, $00, $00, $00
       01:A097  00        
   34  01:A098  00 00 00    .db $00, $00, $00, $00
       01:A09B  00        
   35  01:A09C  00 00 00    .db $00, $00, $00, $00
       01:A09F  00        
   36  01:A0A0  00 00 00    .db $00, $00, $00, $00
       01:A0A3  00        
   37  01:A0A4  00 00 00    .db $00, $00, $00, $00
       01:A0A7  00        
   38  01:A0A8  00 00 00    .db $00, $00, $00, $00
       01:A0AB  00        
   39  01:A0AC  00 00 00    .db $00, $00, $00, $00
       01:A0AF  00        
   40  01:A0B0  00 00 00    .db $00, $00, $00, $00
       01:A0B3  00        
   41  01:A0B4  00 00 00    .db $00, $00, $00, $00
       01:A0B7  00        
   42  01:A0B8  00 00 00    .db $00, $00, $00, $00
       01:A0BB  00        
   43  01:A0BC  00 00 00    .db $00, $00, $00, $00
       01:A0BF  00        
   44  01:A0C0  00 00 00    .db $00, $00, $00, $00
       01:A0C3  00        
   45  01:A0C4  00 00 00    .db $00, $00, $00, $00
       01:A0C7  00        
   46  01:A0C8  00 00 00    .db $00, $00, $00, $00
       01:A0CB  00        
   47  01:A0CC  00 00 00    .db $00, $00, $00, $00
       01:A0CF  00        
   48  01:A0D0  00 00 00    .db $00, $00, $00, $00
       01:A0D3  00        
   49  01:A0D4  00 00 00    .db $00, $00, $00, $00
       01:A0D7  00        
   50                     
   51           BFFA        .org $BFFA     ;first of the three vectors starts here
   52  01:BFFA  04 D6       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   53                                        ;processor will jump to the label NMI:
   54  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   55                                        ;to the label RESET:
   56  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  02 62 00    .db $02, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  04 0F 1B    .db $04, $0F, $1B, $18, $10, $FF
       02:80A7  18 10 FF  
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                      
    9                     ;puzzles
   10  03:A000  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A002  00 80     
       03:A004  00 80     
       03:A006  00 80     
       03:A008  00 80     
       03:A00A  00 80     
       03:A00C  00 80     
       03:A00E  00 80     
       03:A010  00 80     
   11  03:A012  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A014  00 80     
       03:A016  00 80     
       03:A018  00 80     
       03:A01A  00 80     
       03:A01C  00 80     
       03:A01E  00 80     
       03:A020  00 80     
       03:A022  00 80     
   12  03:A024  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A026  00 80     
       03:A028  00 80     
       03:A02A  00 80     
       03:A02C  00 80     
       03:A02E  00 80     
       03:A030  00 80     
       03:A032  00 80     
       03:A034  00 80     
   13                     ;puzzle names
   14  03:A036  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A038  A4 80     
       03:A03A  A4 80     
       03:A03C  A4 80     
       03:A03E  A4 80     
       03:A040  A4 80     
       03:A042  A4 80     
       03:A044  A4 80     
       03:A046  A4 80     
   15  03:A048  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A04A  A4 80     
       03:A04C  A4 80     
       03:A04E  A4 80     
       03:A050  A4 80     
       03:A052  A4 80     
       03:A054  A4 80     
       03:A056  A4 80     
       03:A058  A4 80     
   16  03:A05A  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A05C  A4 80     
       03:A05E  A4 80     
       03:A060  A4 80     
       03:A062  A4 80     
       03:A064  A4 80     
       03:A066  A4 80     
       03:A068  A4 80     
       03:A06A  A4 80     
   17                     ;puzzle sprites
   18  03:A06C  00 00 00    .db $00, $00, $00, $00
       03:A06F  00        
   19  03:A070  00 00 00    .db $00, $00, $00, $00
       03:A073  00        
   20  03:A074  00 00 00    .db $00, $00, $00, $00
       03:A077  00        
   21  03:A078  00 00 00    .db $00, $00, $00, $00
       03:A07B  00        
   22  03:A07C  00 00 00    .db $00, $00, $00, $00
       03:A07F  00        
   23  03:A080  00 00 00    .db $00, $00, $00, $00
       03:A083  00        
   24  03:A084  00 00 00    .db $00, $00, $00, $00
       03:A087  00        
   25  03:A088  00 00 00    .db $00, $00, $00, $00
       03:A08B  00        
   26  03:A08C  00 00 00    .db $00, $00, $00, $00
       03:A08F  00        
   27  03:A090  00 00 00    .db $00, $00, $00, $00
       03:A093  00        
   28  03:A094  00 00 00    .db $00, $00, $00, $00
       03:A097  00        
   29  03:A098  00 00 00    .db $00, $00, $00, $00
       03:A09B  00        
   30  03:A09C  00 00 00    .db $00, $00, $00, $00
       03:A09F  00        
   31  03:A0A0  00 00 00    .db $00, $00, $00, $00
       03:A0A3  00        
   32  03:A0A4  00 00 00    .db $00, $00, $00, $00
       03:A0A7  00        
   33  03:A0A8  00 00 00    .db $00, $00, $00, $00
       03:A0AB  00        
   34  03:A0AC  00 00 00    .db $00, $00, $00, $00
       03:A0AF  00        
   35  03:A0B0  00 00 00    .db $00, $00, $00, $00
       03:A0B3  00        
   36  03:A0B4  00 00 00    .db $00, $00, $00, $00
       03:A0B7  00        
   37  03:A0B8  00 00 00    .db $00, $00, $00, $00
       03:A0BB  00        
   38  03:A0BC  00 00 00    .db $00, $00, $00, $00
       03:A0BF  00        
   39  03:A0C0  00 00 00    .db $00, $00, $00, $00
       03:A0C3  00        
   40  03:A0C4  00 00 00    .db $00, $00, $00, $00
       03:A0C7  00        
   41  03:A0C8  00 00 00    .db $00, $00, $00, $00
       03:A0CB  00        
   42  03:A0CC  00 00 00    .db $00, $00, $00, $00
       03:A0CF  00        
   43  03:A0D0  00 00 00    .db $00, $00, $00, $00
       03:A0D3  00        
   44  03:A0D4  00 00 00    .db $00, $00, $00, $00
       03:A0D7  00        
   45                       
   46                       
   47           BFFA        .org $BFFA     ;first of the three vectors starts here
   48  03:BFFA  04 D6       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   49                                        ;processor will jump to the label NMI:
   50  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   51                                        ;to the label RESET:
   52  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  02 7E 00    .db $02, $7E, $00, $2B
       04:8003  2B        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  03 0C 0A    .db $03, $0C, $0A, $1D, $FF
       04:80A5  1D FF     
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8                       
    9                     ;puzzles
   10  05:A000  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A002  00 80     
       05:A004  00 80     
       05:A006  00 80     
       05:A008  00 80     
       05:A00A  00 80     
       05:A00C  00 80     
       05:A00E  00 80     
       05:A010  00 80     
   11  05:A012  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A014  00 80     
       05:A016  00 80     
       05:A018  00 80     
       05:A01A  00 80     
       05:A01C  00 80     
       05:A01E  00 80     
       05:A020  00 80     
       05:A022  00 80     
   12  05:A024  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat
       05:A026  00 80     
       05:A028  00 80     
       05:A02A  00 80     
       05:A02C  00 80     
       05:A02E  00 80     
       05:A030  00 80     
       05:A032  00 80     
       05:A034  00 80     
   13                     ;puzzle names
   14  05:A036  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A038  A2 80     
       05:A03A  A2 80     
       05:A03C  A2 80     
       05:A03E  A2 80     
       05:A040  A2 80     
       05:A042  A2 80     
       05:A044  A2 80     
       05:A046  A2 80     
   15  05:A048  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A04A  A2 80     
       05:A04C  A2 80     
       05:A04E  A2 80     
       05:A050  A2 80     
       05:A052  A2 80     
       05:A054  A2 80     
       05:A056  A2 80     
       05:A058  A2 80     
   16  05:A05A  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName
       05:A05C  A2 80     
       05:A05E  A2 80     
       05:A060  A2 80     
       05:A062  A2 80     
       05:A064  A2 80     
       05:A066  A2 80     
       05:A068  A2 80     
       05:A06A  A2 80     
   17                     ;puzzle sprites
   18  05:A06C  00 00 00    .db $00, $00, $00, $00
       05:A06F  00        
   19  05:A070  00 00 00    .db $00, $00, $00, $00
       05:A073  00        
   20  05:A074  00 00 00    .db $00, $00, $00, $00
       05:A077  00        
   21  05:A078  00 00 00    .db $00, $00, $00, $00
       05:A07B  00        
   22  05:A07C  00 00 00    .db $00, $00, $00, $00
       05:A07F  00        
   23  05:A080  00 00 00    .db $00, $00, $00, $00
       05:A083  00        
   24  05:A084  00 00 00    .db $00, $00, $00, $00
       05:A087  00        
   25  05:A088  00 00 00    .db $00, $00, $00, $00
       05:A08B  00        
   26  05:A08C  00 00 00    .db $00, $00, $00, $00
       05:A08F  00        
   27  05:A090  00 00 00    .db $00, $00, $00, $00
       05:A093  00        
   28  05:A094  00 00 00    .db $00, $00, $00, $00
       05:A097  00        
   29  05:A098  00 00 00    .db $00, $00, $00, $00
       05:A09B  00        
   30  05:A09C  00 00 00    .db $00, $00, $00, $00
       05:A09F  00        
   31  05:A0A0  00 00 00    .db $00, $00, $00, $00
       05:A0A3  00        
   32  05:A0A4  00 00 00    .db $00, $00, $00, $00
       05:A0A7  00        
   33  05:A0A8  00 00 00    .db $00, $00, $00, $00
       05:A0AB  00        
   34  05:A0AC  00 00 00    .db $00, $00, $00, $00
       05:A0AF  00        
   35  05:A0B0  00 00 00    .db $00, $00, $00, $00
       05:A0B3  00        
   36  05:A0B4  00 00 00    .db $00, $00, $00, $00
       05:A0B7  00        
   37  05:A0B8  00 00 00    .db $00, $00, $00, $00
       05:A0BB  00        
   38  05:A0BC  00 00 00    .db $00, $00, $00, $00
       05:A0BF  00        
   39  05:A0C0  00 00 00    .db $00, $00, $00, $00
       05:A0C3  00        
   40  05:A0C4  00 00 00    .db $00, $00, $00, $00
       05:A0C7  00        
   41  05:A0C8  00 00 00    .db $00, $00, $00, $00
       05:A0CB  00        
   42  05:A0CC  00 00 00    .db $00, $00, $00, $00
       05:A0CF  00        
   43  05:A0D0  00 00 00    .db $00, $00, $00, $00
       05:A0D3  00        
   44  05:A0D4  00 00 00    .db $00, $00, $00, $00
       05:A0D7  00        
   45                     
   46           BFFA        .org $BFFA     ;first of the three vectors starts here
   47  05:BFFA  04 D6       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   48                                        ;processor will jump to the label NMI:
   49  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   50                                        ;to the label RESET:
   51  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 AF D1    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 B3 D1    JSR SetMapperControls
   34                       
   35  06:C040  20 F0 D1    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  20 9B D6    jsr sound_init
   37                         
   38  06:C04B  A9 01       lda #$01
   39  06:C04D  8D D6 00    sta current_song
   40  06:C050  AD D6 00    lda current_song
   41  06:C053  20 C9 D6    jsr sound_load
   42                     
   43  06:C056  A9 00       LDA #TITLE_IDX
   44  06:C058  A2 00       LDX #$00
   45  06:C05A  20 75 CE    JSR ChangeGameMode
   46  06:C05D  20 34 D1    JSR InitPPUControl
   47                       
   48                     
   49                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   50                     ;;     Main Program         ;;
   51                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   52                     
   53  06:C060            Forever:
   54                     
   55  06:C060  EE 0C 00    INC sleeping
   56                     
   57  06:C063            .loop
   58  06:C063  AD 0C 00    LDA sleeping
   59  06:C066  D0 FB       BNE .loop
   60                     
   61  06:C068  EE 0A 00    INC time  
   62  06:C06B  AD CC 00    LDA pauseState
   63  06:C06E  D0 03       BNE .skipScaleUpdate
   64  06:C070  EE 0B 00    INC scaledTime
   65  06:C073            .skipScaleUpdate:
   66  06:C073  20 79 C0    JSR GameLoop
   67                     
   68                     
   69  06:C076  4C 60 C0    JMP Forever     ;jump back to Forever, infinite loop
   70                       
   71                     ;; dynamic jump table
   72                     
   73  06:C079            GameLoop:
   74                     
   75                       MACROCallDynamicJump game_mode
                          
       06:C079  AD 0E 00    LDA game_mode
       06:C07C  20 46 CF    JSR Dynamic_Jump
                                  
   76                       ;; we'll pop the return address here as the table index, so 
   77                       ;; the routine we pick will return us to whatever called Game Loop
   78                       ;; when it returns
   79                     
   80  06:C07F            GameLoopJumpTable:
   81                     
   82  06:C07F  85 C0       .word UpdateTitle
   83  06:C081  54 C4       .word UpdateGame
   84  06:C083  5F CC       .word UpdateGameOver
   85                       
   86                     
   87                       ;;RTS is called in the subroutine
   88                     
   89                       
#[2]   Routines/Game_States/UpdateTitle.asm
   90                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C085            UpdateTitle:
    2                     
    3  06:C085  AD 10 00    LDA NMI_locks
    4  06:C088  F0 01       BEQ .unlocked
    5                       
    6  06:C08A  60          RTS
    7                       
    8  06:C08B            .unlocked:
    9                     
   10  06:C08B  20 8F C0    JSR DoUpdateTitle  
   11  06:C08E  60          RTS
   12                       
   13  06:C08F            DoUpdateTitle:
   14                     
   15  06:C08F  AD 0F 00    LDA mode_state
   16  06:C092  20 46 CF    JSR Dynamic_Jump
   17                         
   18  06:C095            UpdateTitleJumpTable:
   19                     
   20  06:C095  A1 C0       .word UpdateTitleInit
   21  06:C097  D7 C0       .word UpdateBankSelection
   22  06:C099  08 C1       .word UpdateScroll
   23  06:C09B  31 C1       .word UpdatePuzzleSelection
   24  06:C09D  8C C1       .word UpdateScrollBack
   25  06:C09F  AB C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C0A1            UpdateTitleInit:
   35                     
   36  06:C0A1  20 10 D1    JSR TurnOnSprites
   37                       
   38  06:C0A4  AD 00 70    LDA hasContinue
   39  06:C0A7  F0 20       BEQ .skipContinueText
   40                       MACROAddPPUStringEntryTable #$2B, #$4D, #DRAW_HORIZONTAL, ContinueText
                           
       06:C0A9  A9 01       LDA #$01
       06:C0AB  8D 23 00    STA PPU_PendingWrite
       06:C0AE  A9 2B       LDA #$2B
       06:C0B0  20 C8 D0    JSR WriteToPPUString
       06:C0B3  A9 4D       LDA #$4D
       06:C0B5  20 C8 D0    JSR WriteToPPUString
       06:C0B8  A9 20       LDA #$20
       06:C0BA  09 00       ORA #DRAW_HORIZONTAL
       06:C0BC  20 C8 D0    JSR WriteToPPUString
       06:C0BF  A9 4B       LDA #LOW(ContinueText)
       06:C0C1  20 C8 D0    JSR WriteToPPUString
       06:C0C4  A9 C4       LDA #HIGH(ContinueText)
       06:C0C6  20 C8 D0    JSR WriteToPPUString
                           
   41                       
   42  06:C0C9            .skipContinueText:
   43                       
   44  06:C0C9  A9 00       LDA #$00
   45  06:C0CB  8D C9 00    STA mouse_index
   46  06:C0CE  A9 00       LDA #$00
   47  06:C0D0  8D CA 00    STA mouse_index+1
   48                     
   49  06:C0D3            .changeModeState:
   50                     
   51  06:C0D3  EE 0F 00    INC mode_state
   52  06:C0D6            .leave:
   53  06:C0D6  60          RTS
   54                       
   55  06:C0D7            UpdateBankSelection:
   56                     
   57  06:C0D7  20 87 C2    JSR UpdateBankPointer
   58                       
   59  06:C0DA  AD 1C 00    LDA gamepadPressed
   60  06:C0DD  29 01       AND #GAMEPAD_A
   61  06:C0DF  F0 26       BEQ .leave
   62                       
   63  06:C0E1            .changeModeState:
   64                       
   65  06:C0E1  AD C9 00    LDA mouse_index
   66  06:C0E4  C9 03       CMP #$03
   67  06:C0E6  D0 0F       BNE .setBank
   68                       
   69  06:C0E8  EE 0F 00    INC mode_state
   70  06:C0EB  EE 0F 00    INC mode_state
   71  06:C0EE  EE 0F 00    INC mode_state
   72                       
   73                       ;;load bank
   74  06:C0F1  20 45 C3    JSR LoadBank
   75                       
   76  06:C0F4  4C 01 C1    JMP .goToNext
   77                       
   78  06:C0F7            .setBank:
   79  06:C0F7  8D AB 00    STA tempBank
   80  06:C0FA  A9 FF       LDA #$FF
   81  06:C0FC  A2 01       LDX #$01
   82  06:C0FE  20 69 C2    JSR SetSpriteImage
   83                     
   84  06:C101            .goToNext:
   85  06:C101  EE 0F 00    INC mode_state
   86  06:C104  4C 07 C1    JMP .leave
   87                     
   88                     
   89  06:C107            .leave:
   90  06:C107  60          RTS
   91                       
   92  06:C108            UpdateScroll:
   93  06:C108  EE 1F 00    INC PPU_ScrollX
   94  06:C10B  EE 1F 00    INC PPU_ScrollX
   95  06:C10E  EE 1F 00    INC PPU_ScrollX
   96  06:C111  EE 1F 00    INC PPU_ScrollX
   97  06:C114  D0 1A       BNE .leave
   98  06:C116  AD 21 00    LDA PPU_ScrollNT
   99  06:C119  49 01       EOR #%00000001
  100  06:C11B  8D 21 00    STA PPU_ScrollNT
  101                       
  102  06:C11E            .changeModeState:
  103  06:C11E  A9 01       LDA #$01
  104  06:C120  A2 01       LDX #$01
  105  06:C122  20 69 C2    JSR SetSpriteImage
  106  06:C125  20 2B C2    JSR InitPuzzlePointer
  107  06:C128  EE 0F 00    INC mode_state
  108  06:C12B  A9 FF       LDA #$FF
  109  06:C12D  8D AC 00    STA tempPuzz
  110  06:C130            .leave:
  111  06:C130  60          RTS
  112                       
  113  06:C131            UpdatePuzzleSelection:
  114                     
  115  06:C131  20 D6 C2    JSR UpdatePuzzlePointer
  116                       
  117  06:C134  AD C9 00    LDA mouse_index
  118  06:C137  0A          ASL A
  119  06:C138  0A          ASL A
  120  06:C139  0A          ASL A
  121  06:C13A  18          CLC
  122  06:C13B  6D C9 00    ADC mouse_index
  123  06:C13E  6D CA 00    ADC mouse_index+1
  124  06:C141  CD AC 00    CMP tempPuzz
  125  06:C144  F0 06       BEQ .checkButtonPresses       ;no change
  126  06:C146  8D AC 00    STA tempPuzz
  127                       
  128  06:C149  20 52 C3    JSR UpdatePuzzleInfo
  129                       
  130  06:C14C            .checkButtonPresses:
  131                     
  132  06:C14C  AD 1C 00    LDA gamepadPressed
  133  06:C14F  29 02       AND #GAMEPAD_B
  134  06:C151  D0 10       BNE .changeToScrollBack
  135  06:C153  AD 1C 00    LDA gamepadPressed
  136  06:C156  29 09       AND #GAMEPAD_CONFIRM
  137  06:C158  F0 31       BEQ .leave
  138                       
  139  06:C15A  EE 0F 00    INC mode_state
  140  06:C15D  EE 0F 00    INC mode_state
  141  06:C160  4C 8B C1    JMP .leave
  142                       
  143  06:C163            .changeToScrollBack:
  144                      
  145  06:C163  A9 FF       LDA #$FF
  146  06:C165  A2 01       LDX #$01
  147  06:C167  20 69 C2    JSR SetSpriteImage
  148  06:C16A  20 23 C2    JSR InitBankPointer
  149  06:C16D  AD 07 70    LDA bank_index
  150  06:C170  8D C9 00    STA mouse_index
  151  06:C173  20 C9 C2    JSR SetBankPointerFromIndex
  152                       
  153  06:C176  A9 00       LDA #$00
  154  06:C178  8D 20 00    STA PPU_ScrollY
  155  06:C17B  A9 FC       LDA #$FC
  156  06:C17D  8D 1F 00    STA PPU_ScrollX
  157  06:C180  AD 21 00    LDA PPU_ScrollNT
  158  06:C183  29 FE       AND #$FE
  159  06:C185  8D 21 00    STA PPU_ScrollNT
  160                       
  161  06:C188  EE 0F 00    INC mode_state
  162  06:C18B            .leave:
  163  06:C18B  60          RTS
  164                       
  165  06:C18C            UpdateScrollBack:
  166                     
  167  06:C18C  CE 1F 00    DEC PPU_ScrollX
  168  06:C18F  CE 1F 00    DEC PPU_ScrollX
  169  06:C192  CE 1F 00    DEC PPU_ScrollX
  170  06:C195  CE 1F 00    DEC PPU_ScrollX
  171  06:C198  D0 10       BNE .leave
  172                       
  173  06:C19A            .changeModeState:
  174                     
  175  06:C19A  A9 01       LDA #$01
  176  06:C19C  A2 01       LDX #$01
  177  06:C19E  20 69 C2    JSR SetSpriteImage
  178  06:C1A1  CE 0F 00    DEC mode_state
  179  06:C1A4  CE 0F 00    DEC mode_state
  180  06:C1A7  CE 0F 00    DEC mode_state
  181                       
  182  06:C1AA            .leave:
  183  06:C1AA  60          RTS
  184                       
  185  06:C1AB            UpdateTitleExit:
  186                     
  187                       ;;reset screen scroll
  188  06:C1AB  A9 00       LDA #$00
  189  06:C1AD  8D 1F 00    STA PPU_ScrollX
  190  06:C1B0  8D 21 00    STA PPU_ScrollNT
  191                       
  192  06:C1B3  A9 20       LDA #%00100000
  193  06:C1B5  8D 00 00    STA temp1
  194                       
  195  06:C1B8  AD C9 00    LDA mouse_index
  196  06:C1BB  C9 03       CMP #$03
  197  06:C1BD  D0 06       BNE .loadPuzzle
  198                       
  199  06:C1BF  0E 00 00    ASL temp1
  200  06:C1C2  4C D9 C1    JMP .setupPuzzle
  201                       
  202  06:C1C5            .loadPuzzle:
  203                       ;; we can also pick out the puzzle index
  204                       ;; we have the mouse indexes - one vert, one hori
  205                       ;; take vert, mult by 9- alternatively, mult by 8, add index 
  206                       ;; IE - ind = 1, mult 8 = 8, add 1 = 9
  207                       ;; add X index
  208  06:C1C5  AD AB 00    LDA tempBank
  209  06:C1C8  8D 07 70    STA bank_index
  210  06:C1CB  20 45 C3    JSR LoadBank
  211                       
  212  06:C1CE  AD AC 00    LDA tempPuzz
  213  06:C1D1  8D 08 70    STA puzzle_index
  214  06:C1D4  A9 00       LDA #$00
  215  06:C1D6  8D 00 70    STA hasContinue
  216                     
  217                     
  218  06:C1D9            .setupPuzzle:
  219                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C1D9  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C1DB  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C1DD  8E 16 00          STX table_address
       06:C1E0  8D 17 00          STA table_address+1
                                  
  220                       MACROGetDoubleIndex puzzle_index
                          
       06:C1E3  AD 08 70          LDA puzzle_index
       06:C1E6  0A                ASL A
       06:C1E7  A8                TAY
                                  
  221  06:C1E8  20 6C CF    JSR GetTableAtIndex
  222                       MACROGetPointer table_address, puzzle_address
                          
       06:C1EB  AD 16 00          LDA table_address
       06:C1EE  8D AD 00          STA puzzle_address
       06:C1F1  AD 17 00          LDA table_address+1
       06:C1F4  8D AE 00          STA puzzle_address+1
                          
  223                       
  224                       MACROGetLabelPointer NAMES_TABLE, table_address
                          
       06:C1F7  A9 A0             LDA #HIGH(NAMES_TABLE)
       06:C1F9  A2 36             LDX #LOW(NAMES_TABLE)
                                  
       06:C1FB  8E 16 00          STX table_address
       06:C1FE  8D 17 00          STA table_address+1
                                  
  225                       MACROGetDoubleIndex puzzle_index
                          
       06:C201  AD 08 70          LDA puzzle_index
       06:C204  0A                ASL A
       06:C205  A8                TAY
                                  
  226  06:C206  20 6C CF    JSR GetTableAtIndex
  227                       MACROGetPointer table_address, title_address
                          
       06:C209  AD 16 00          LDA table_address
       06:C20C  8D B1 00          STA title_address
       06:C20F  AD 17 00          LDA table_address+1
       06:C212  8D B2 00          STA title_address+1
                          
  228                     
  229  06:C215  A0 00       LDY #$00
  230  06:C217  B1 AD       LDA [puzzle_address], y
  231  06:C219  0D 00 00    ORA temp1
  232                       
  233  06:C21C  AA          TAX
  234                       
  235                     
  236  06:C21D  A9 01       LDA #GAME_IDX
  237  06:C21F  20 75 CE    JSR ChangeGameMode
  238                       
  239  06:C222            .leave
  240  06:C222  60          RTS
  241                       
  242  06:C223            InitBankPointer:
  243                     
  244  06:C223  A2 A0       LDX #$A0
  245  06:C225  A9 60       LDA #$60
  246  06:C227  20 3E C2    JSR InitPointer
  247                       
  248  06:C22A  60          RTS  
  249                       
  250  06:C22B            InitPuzzlePointer:
  251                       
  252  06:C22B  A2 AE       LDX #$AE
  253  06:C22D  A9 10       LDA #$10
  254  06:C22F  20 3E C2    JSR InitPointer
  255                       
  256  06:C232  60          RTS
  257                     
  258  06:C233            ResetMouseIndex:
  259                     
  260  06:C233  A9 00       LDA #$00
  261  06:C235  8D C9 00    STA mouse_index
  262  06:C238  A9 00       LDA #$00
  263  06:C23A  8D CA 00    STA mouse_index+1
  264  06:C23D  60          RTS
  265                     
  266  06:C23E            InitPointer:
  267                     
  268  06:C23E  20 45 C2    JSR SetPointerPosition
  269  06:C241  20 33 C2    JSR ResetMouseIndex
  270  06:C244  60          RTS  
  271                       
  272  06:C245            SetPointerPosition:
  273                     
  274  06:C245  48          PHA
  275  06:C246  8A          TXA
  276  06:C247  A2 01       LDX #$01
  277  06:C249  20 53 C2    JSR SetSpriteYPosition
  278  06:C24C  68          PLA
  279  06:C24D  A2 01       LDX #$01
  280  06:C24F  20 5E C2    JSR SetSpriteXPosition
  281                      
  282  06:C252  60          RTS
  283                       
  284  06:C253            SetSpriteYPosition:
  285                       
  286  06:C253  48          PHA
  287  06:C254  A9 00       LDA #SPRITE_YPOS
  288  06:C256  20 74 C2    JSR GetSpriteDataIndexInX
  289  06:C259  68          PLA
  290  06:C25A  9D 00 02    STA SPRITE_DATA, x
  291  06:C25D  60          RTS
  292                       
  293  06:C25E            SetSpriteXPosition:  
  294                       
  295  06:C25E  48          PHA
  296  06:C25F  A9 03       LDA #SPRITE_XPOS
  297  06:C261  20 74 C2    JSR GetSpriteDataIndexInX
  298  06:C264  68          PLA
  299  06:C265  9D 00 02    STA SPRITE_DATA, x 
  300  06:C268  60          RTS
  301                     
  302  06:C269            SetSpriteImage:
  303                     
  304                     ;; A has sprite image index we want
  305                     ;; X has the sprite index
  306  06:C269  48          PHA
  307  06:C26A  A9 01       LDA #SPRITE_ID
  308  06:C26C  20 74 C2    JSR GetSpriteDataIndexInX
  309  06:C26F  68          PLA
  310  06:C270  9D 00 02    STA SPRITE_DATA, x
  311  06:C273  60          RTS
  312                       
  313  06:C274            GetSpriteDataIndexInX:
  314                     
  315                       ;; A has data index we want to get
  316                       ;; X has sprite index
  317  06:C274  8D 02 00    STA temp3
  318  06:C277  8A          TXA
  319  06:C278  0A          ASL A
  320  06:C279  0A          ASL A
  321  06:C27A  18          CLC
  322  06:C27B  6D 02 00    ADC temp3
  323  06:C27E  AA          TAX
  324                       
  325  06:C27F  60          RTS  
  326  06:C280            GetSpriteData:
  327                     
  328                       ;;A is data we want
  329                       ;;X is Sprite
  330  06:C280  20 74 C2    JSR GetSpriteDataIndexInX
  331  06:C283  BD 00 02    LDA SPRITE_DATA, x
  332  06:C286  60          RTS
  333                       
  334  06:C287            UpdateBankPointer:
  335                      
  336                       ;;bank pointer is 1D, will loop between 0->3
  337  06:C287  AD 1C 00    LDA gamepadPressed
  338  06:C28A  D0 01       BNE .continue
  339  06:C28C            .leaveEarly:
  340  06:C28C  60          RTS
  341                       
  342  06:C28D            .continue:
  343  06:C28D  A9 00       LDA #$00
  344  06:C28F  8D 00 00    STA temp1
  345                       
  346  06:C292  A9 02       LDA #$02
  347  06:C294  8D 01 00    STA temp2
  348                       
  349  06:C297  AD 00 70    LDA hasContinue
  350  06:C29A  F0 05       BEQ .parseInputs
  351  06:C29C  A9 03       LDA #$03
  352  06:C29E  8D 01 00    STA temp2
  353                       
  354  06:C2A1            .parseInputs:
  355  06:C2A1  AD 1C 00    LDA gamepadPressed
  356  06:C2A4  29 30       AND #GAMEPAD_VERT
  357  06:C2A6  F0 E4       BEQ .leaveEarly
  358  06:C2A8  0A          ASL A
  359  06:C2A9  0A          ASL A
  360  06:C2AA            .checkDown:
  361  06:C2AA  0A          ASL A
  362  06:C2AB  90 03       BCC .checkUp
  363  06:C2AD  EE 00 00    INC temp1
  364  06:C2B0            .checkUp:
  365  06:C2B0  0A          ASL A
  366  06:C2B1  90 03       BCC .move
  367  06:C2B3  CE 00 00    DEC temp1
  368  06:C2B6            .move:
  369                       
  370  06:C2B6  AD C9 00    LDA mouse_index
  371  06:C2B9  18          CLC
  372  06:C2BA  6D 00 00    ADC temp1
  373  06:C2BD  CD 01 00    CMP temp2
  374  06:C2C0  F0 04       BEQ .skipMod
  375  06:C2C2  90 02       BCC .skipMod
  376  06:C2C4  A9 00       LDA #$00
  377  06:C2C6            .skipMod:
  378  06:C2C6  8D C9 00    STA mouse_index
  379                       ;; mult mouse_index by 16
  380  06:C2C9            SetBankPointerFromIndex:
  381                     
  382  06:C2C9  0A          ASL A
  383  06:C2CA  0A          ASL A
  384  06:C2CB  0A          ASL A
  385  06:C2CC  0A          ASL A
  386  06:C2CD  18          CLC
  387  06:C2CE  69 A0       ADC #$A0
  388  06:C2D0  A2 01       LDX #$01
  389  06:C2D2  20 53 C2    JSR SetSpriteYPosition
  390                     
  391  06:C2D5            .leave:
  392                       
  393  06:C2D5  60          RTS
  394                       
  395  06:C2D6            UpdatePuzzlePointer:
  396                     
  397                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  398  06:C2D6  AD 1C 00    LDA gamepadPressed
  399  06:C2D9  F0 69       BEQ .leave 
  400                       
  401  06:C2DB  A9 00       LDA #$00
  402  06:C2DD  8D 00 00    STA temp1
  403  06:C2E0  8D 01 00    STA temp2
  404                       
  405  06:C2E3            .parseInputs:
  406  06:C2E3  AD 1C 00    LDA gamepadPressed
  407  06:C2E6  29 F0       AND #GAMEPAD_MOVE
  408  06:C2E8  F0 5A       BEQ .leave
  409  06:C2EA  0A          ASL A
  410  06:C2EB  90 03       BCC .checkLeft
  411  06:C2ED  EE 00 00    INC temp1
  412  06:C2F0            .checkLeft:
  413  06:C2F0  0A          ASL A
  414  06:C2F1  90 03       BCC .checkDown
  415  06:C2F3  CE 00 00    DEC temp1
  416  06:C2F6            .checkDown:
  417  06:C2F6  0A          ASL A
  418  06:C2F7  90 03       BCC .checkUp
  419  06:C2F9  EE 01 00    INC temp2
  420  06:C2FC            .checkUp:
  421  06:C2FC  0A          ASL A
  422  06:C2FD  90 03       BCC .move
  423  06:C2FF  CE 01 00    DEC temp2
  424                       
  425  06:C302            .move:
  426                     
  427  06:C302  AD C9 00    LDA mouse_index
  428  06:C305  18          CLC
  429  06:C306  6D 01 00    ADC temp2
  430  06:C309  C9 02       CMP #$02
  431  06:C30B  F0 04       BEQ .skipYMod
  432  06:C30D  90 02       BCC .skipYMod
  433  06:C30F  A9 00       LDA #$00
  434  06:C311            .skipYMod:
  435  06:C311  8D C9 00    STA mouse_index
  436                       ;; mult mouse_index by 16
  437  06:C314  0A          ASL A
  438  06:C315  0A          ASL A
  439  06:C316  0A          ASL A
  440  06:C317  0A          ASL A
  441  06:C318  18          CLC
  442  06:C319  69 AE       ADC #$AE
  443  06:C31B  A2 01       LDX #$01
  444  06:C31D  20 53 C2    JSR SetSpriteYPosition
  445                       
  446  06:C320  AD CA 00    LDA mouse_index+1
  447  06:C323  18          CLC
  448  06:C324  6D 00 00    ADC temp1
  449  06:C327  C9 08       CMP #$08
  450  06:C329  F0 04       BEQ .skipXMod
  451  06:C32B  90 02       BCC .skipXMod
  452  06:C32D  A9 00       LDA #$00
  453  06:C32F            .skipXMod:
  454  06:C32F  8D CA 00    STA mouse_index+1
  455                       ;; we need to move 3 tiles each- so index * 3 * 8,
  456  06:C332  18          CLC
  457  06:C333  6D CA 00    ADC mouse_index+1
  458  06:C336  6D CA 00    ADC mouse_index+1
  459  06:C339  0A          ASL A
  460  06:C33A  0A          ASL A
  461  06:C33B  0A          ASL A
  462  06:C33C  18          CLC
  463  06:C33D  69 10       ADC #$10
  464  06:C33F  A2 01       LDX #$01
  465  06:C341  20 5E C2    JSR SetSpriteXPosition
  466                       
  467  06:C344            .leave:
  468                       
  469  06:C344  60          RTS
  470                     
  471  06:C345            LoadBank:
  472                     
  473                       ;;load bank
  474  06:C345  20 AF D1    JSR ResetMapper
  475  06:C348  AD 07 70    LDA bank_index
  476  06:C34B  8D A9 00    STA currentPRGBank
  477  06:C34E  20 BE D1    JSR LoadPRGBank
  478  06:C351  60          RTS
  479                       
  480  06:C352            UpdatePuzzleInfo:
  481                     
  482                     
  483                       MACROGetLabelPointer PuzzleSaveLocations, table_address
                          
       06:C352  A9 CC             LDA #HIGH(PuzzleSaveLocations)
       06:C354  A2 59             LDX #LOW(PuzzleSaveLocations)
                                  
       06:C356  8E 16 00          STX table_address
       06:C359  8D 17 00          STA table_address+1
                                  
  484  06:C35C  AD AB 00    LDA tempBank
  485  06:C35F  0A          ASL A
  486  06:C360  A8          TAY
  487  06:C361  20 6C CF    JSR GetTableAtIndex
  488                       
  489                       ;;load title/time
  490                       ;;time first, we haven't done titles
  491  06:C364  A2 00       LDX #$00
  492  06:C366  BD 20 FD    LDA SelectDefaultTime,x
  493  06:C369  8D 01 00    STA temp2
  494  06:C36C  E8          INX
  495  06:C36D  BD 20 FD    LDA SelectDefaultTime,x
  496  06:C370  8D 00 00    STA temp1
  497                       
  498  06:C373  AD AC 00    LDA tempPuzz
  499  06:C376  0A          ASL A
  500  06:C377  0A          ASL A
  501  06:C378  A8          TAY
  502  06:C379  B1 16       LDA [table_address], y
  503  06:C37B  10 43       BPL .loadDefaultTime
  504                       
  505                       ;;time exists!
  506  06:C37D  29 0F       AND #$0F
  507  06:C37F  8D 02 00    STA temp3
  508  06:C382  C8          INY
  509  06:C383  C8          INY
  510  06:C384  C8          INY
  511                       MACROAddPPUStringEntryRawData temp1, temp2, #DRAW_HORIZONTAL, #$05
                          
       06:C385  A9 01       LDA #$01
       06:C387  8D 23 00    STA PPU_PendingWrite
       06:C38A  AD 00 00    LDA temp1
       06:C38D  20 C8 D0    JSR WriteToPPUString
       06:C390  AD 01 00    LDA temp2
       06:C393  20 C8 D0    JSR WriteToPPUString
       06:C396  A9 00       LDA #DRAW_HORIZONTAL
       06:C398  20 C8 D0    JSR WriteToPPUString
       06:C39B  A9 05       LDA #$05 
       06:C39D  20 C8 D0    JSR WriteToPPUString
                            
  512  06:C3A0  B1 16       LDA [table_address], y
  513  06:C3A2  20 C8 D0    JSR WriteToPPUString
  514  06:C3A5  88          DEY
  515  06:C3A6  B1 16       LDA [table_address], y
  516  06:C3A8  20 C8 D0    JSR WriteToPPUString
  517  06:C3AB  A9 61       LDA #$61
  518  06:C3AD  20 C8 D0    JSR WriteToPPUString
  519  06:C3B0  88          DEY
  520  06:C3B1  B1 16       LDA [table_address], y
  521  06:C3B3  20 C8 D0    JSR WriteToPPUString
  522  06:C3B6  88          DEY
  523  06:C3B7  AD 02 00    LDA temp3
  524  06:C3BA  20 C8 D0    JSR WriteToPPUString  
  525  06:C3BD  4C 02 C4    JMP .drawTitle
  526                     
  527  06:C3C0            .loadDefaultTime:
  528                       
  529                       MACROAddPPUStringEntryRepeat #$26, #$47, #DRAW_HORIZONTAL, #$10, #$63
                          
       06:C3C0  A9 01       LDA #$01
       06:C3C2  8D 23 00    STA PPU_PendingWrite
       06:C3C5  A9 26       LDA #$26
       06:C3C7  20 C8 D0    JSR WriteToPPUString
       06:C3CA  A9 47       LDA #$47
       06:C3CC  20 C8 D0    JSR WriteToPPUString
       06:C3CF  A9 40       LDA #$40
       06:C3D1  09 00       ORA #DRAW_HORIZONTAL
       06:C3D3  09 10       ORA #$10
       06:C3D5  20 C8 D0    JSR WriteToPPUString
       06:C3D8  A9 63       LDA #$63
       06:C3DA  20 C8 D0    JSR WriteToPPUString
                            
  530                       MACROAddPPUStringEntryTable temp1, temp2, #DRAW_HORIZONTAL, DefaultTimeString
                           
       06:C3DD  A9 01       LDA #$01
       06:C3DF  8D 23 00    STA PPU_PendingWrite
       06:C3E2  AD 00 00    LDA temp1
       06:C3E5  20 C8 D0    JSR WriteToPPUString
       06:C3E8  AD 01 00    LDA temp2
       06:C3EB  20 C8 D0    JSR WriteToPPUString
       06:C3EE  A9 20       LDA #$20
       06:C3F0  09 00       ORA #DRAW_HORIZONTAL
       06:C3F2  20 C8 D0    JSR WriteToPPUString
       06:C3F5  A9 22       LDA #LOW(DefaultTimeString)
       06:C3F7  20 C8 D0    JSR WriteToPPUString
       06:C3FA  A9 FD       LDA #HIGH(DefaultTimeString)
       06:C3FC  20 C8 D0    JSR WriteToPPUString
                           
  531  06:C3FF  4C 4A C4    JMP .leave
  532                     
  533  06:C402            .drawTitle:
  534                       MACROAddPPUStringEntryRepeat #$26, #$47, #DRAW_HORIZONTAL, #$10, #$24
                          
       06:C402  A9 01       LDA #$01
       06:C404  8D 23 00    STA PPU_PendingWrite
       06:C407  A9 26       LDA #$26
       06:C409  20 C8 D0    JSR WriteToPPUString
       06:C40C  A9 47       LDA #$47
       06:C40E  20 C8 D0    JSR WriteToPPUString
       06:C411  A9 40       LDA #$40
       06:C413  09 00       ORA #DRAW_HORIZONTAL
       06:C415  09 10       ORA #$10
       06:C417  20 C8 D0    JSR WriteToPPUString
       06:C41A  A9 24       LDA #$24
       06:C41C  20 C8 D0    JSR WriteToPPUString
                            
  535                       
  536                       MACROGetLabelPointer NAMES_TABLE, table_address
                          
       06:C41F  A9 A0             LDA #HIGH(NAMES_TABLE)
       06:C421  A2 36             LDX #LOW(NAMES_TABLE)
                                  
       06:C423  8E 16 00          STX table_address
       06:C426  8D 17 00          STA table_address+1
                                  
  537                       MACROGetDoubleIndex tempPuzz
                          
       06:C429  AD AC 00          LDA tempPuzz
       06:C42C  0A                ASL A
       06:C42D  A8                TAY
                                  
  538  06:C42E  20 6C CF    JSR GetTableAtIndex
  539                       MACROGetPointer table_address, title_address
                          
       06:C431  AD 16 00          LDA table_address
       06:C434  8D B1 00          STA title_address
       06:C437  AD 17 00          LDA table_address+1
       06:C43A  8D B2 00          STA title_address+1
                          
  540                     
  541                       ;draw title at 264F
  542  06:C43D  A9 4F       LDA #$4F 
  543  06:C43F  8D B9 00    STA title_draw_address
  544  06:C442  A9 26       LDA #$26
  545  06:C444  8D BA 00    STA title_draw_address+1
  546                       
  547  06:C447  20 59 D5    JSR DrawTitle
  548  06:C44A            .leave:
  549  06:C44A  60          RTS
  550                       
  551  06:C44B            ContinueText:
  552                     
  553  06:C44B  08 0C 18    .db $08, $0C, $18, $17, $1D, $12, $17, $1E, $0E
       06:C44E  17 1D 12  
       06:C451  17 1E 0E  
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   91                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6           20A8      BANK_LEVEL = $20A8
    7           20E5      TIMER_LOC = $20E5
    8                     
    9           618E      MOUSE_START = $618E
   10                     
   11           0010      HOLD_TIME = $10
   12           0004      HOLD_FREQ = $04
   13                     
   14  06:C454            UpdateGame:
   15                     
   16  06:C454  AD 10 00    LDA NMI_locks
   17  06:C457  F0 01       BEQ .unlocked
   18                       
   19  06:C459  60          RTS
   20                       
   21  06:C45A            .unlocked:
   22                     
   23  06:C45A  20 5E C4    JSR DoUpdateGame
   24  06:C45D  60          RTS
   25                       
   26  06:C45E            DoUpdateGame:
   27                     
   28  06:C45E  AD 0F 00    LDA mode_state
   29  06:C461  20 46 CF    JSR Dynamic_Jump
   30                       
   31  06:C464            UpdateGameJumpTable:
   32                     
   33  06:C464  78 C4       .word UpdateGameInit
   34  06:C466  35 C5       .word UpdateDrawVertClues
   35  06:C468  62 C5       .word UpdateDrawHoriClues
   36  06:C46A  BC C5       .word UpdateGamePlay
   37  06:C46C  87 C7       .word UpdateClearPuzzle
   38  06:C46E  9A C7       .word UpdateMoveScreen
   39  06:C470  13 C8       .word UpdateDrawImage
   40  06:C472  B0 C8       .word UpdateWaitInput
   41  06:C474  C6 C8       .word UpdateGameFadeOut
   42  06:C476  EC C8       .word UpdateGameExit
   43                     
   44  06:C478            UpdateGameInit:
   45                     
   46                       ;;start bank song
   47                     
   48  06:C478  AD 07 70    LDA bank_index
   49  06:C47B  D0 00       BNE .skipMusicSet
   50                       ;LDX #$F0
   51                       ;LDY #$A0
   52                     
   53                       ;lda #1 ; NTSC
   54                       ;jsr famistudio_init
   55                       ;lda #0
   56                       ;jsr famistudio_music_play
   57                       
   58  06:C47D            .skipMusicSet:
   59                       ;; get the puzzle table in the puzzle address
   60                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C47D  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C47F  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C481  8E 16 00          STX table_address
       06:C484  8D 17 00          STA table_address+1
                                  
   61                       MACROGetDoubleIndex puzzle_index
                          
       06:C487  AD 08 70          LDA puzzle_index
       06:C48A  0A                ASL A
       06:C48B  A8                TAY
                                  
   62  06:C48C  20 6C CF    JSR GetTableAtIndex
   63                       MACROGetPointer table_address, puzzle_address
                          
       06:C48F  AD 16 00          LDA table_address
       06:C492  8D AD 00          STA puzzle_address
       06:C495  AD 17 00          LDA table_address+1
       06:C498  8D AE 00          STA puzzle_address+1
                          
   64                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C49B  A9 61             LDA #HIGH(MOUSE_START)
       06:C49D  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C49F  8E C7 00          STX mouse_location
       06:C4A2  8D C8 00          STA mouse_location+1
                                  
   65                     
   66                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   67  06:C4A5  A0 00       LDY #$00
   68  06:C4A7  B1 AD       LDA [puzzle_address], y
   69  06:C4A9  AA          TAX
   70  06:C4AA  BD 56 CC    LDA PuzzleHeaderSkips, x
   71  06:C4AD  8D 00 00    STA temp1
   72                       
   73  06:C4B0  AD AD 00    LDA puzzle_address
   74  06:C4B3  18          CLC
   75  06:C4B4  6D 00 00    ADC temp1
   76  06:C4B7  8D AF 00    STA clues_address
   77  06:C4BA  A9 00       LDA #$00
   78  06:C4BC  6D AE 00    ADC puzzle_address+1
   79  06:C4BF  8D B0 00    STA clues_address+1
   80                     
   81  06:C4C2  A9 00       LDA #$00
   82  06:C4C4  8D BF 00    STA clueTableIndex
   83  06:C4C7  8D C0 00    STA clueLineIndex
   84  06:C4CA  8D C6 00    STA clueParity
   85  06:C4CD  8D C1 00    STA clueOffsetShift
   86  06:C4D0  8D C9 00    STA mouse_index
   87  06:C4D3  8D CA 00    STA mouse_index+1
   88                       
   89  06:C4D6  A9 01       LDA #$01
   90  06:C4D8  8D CD 00    STA pauseInputLock 
   91                      
   92  06:C4DB  AD 00 70    LDA hasContinue
   93  06:C4DE  D0 14       BNE .skipSolutionReset
   94                       
   95  06:C4E0  A9 00       LDA #$00
   96  06:C4E2  8D 01 70    STA solutionCount
   97  06:C4E5  8D 02 70    STA nonSolutionCount
   98  06:C4E8  8D 03 70    STA GameTime
   99  06:C4EB  8D 04 70    STA GameTime+1
  100  06:C4EE  8D 05 70    STA GameTime+2
  101  06:C4F1  8D 06 70    STA GameTime+3
  102                       
  103  06:C4F4            .skipSolutionReset:     
  104                       
  105  06:C4F4  A9 20       LDA #$20
  106  06:C4F6  8D C2 00    STA clueDrawAdd
  107                      
  108                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C4F9  A9 21             LDA #HIGH(VERT_CLUES)
       06:C4FB  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C4FD  8E BB 00          STX clue_start_address
       06:C500  8D BC 00          STA clue_start_address+1
                                  
  109  06:C503  20 AF D2    JSR ResetClueDrawAddress
  110                       
  111                       MACROAddPPUStringEntryRawData #HIGH(BANK_LEVEL), #LOW(BANK_LEVEL), #DRAW_HORIZONTAL, #$03
                          
       06:C506  A9 01       LDA #$01
       06:C508  8D 23 00    STA PPU_PendingWrite
       06:C50B  A9 20       LDA #HIGH(BANK_LEVEL)
       06:C50D  20 C8 D0    JSR WriteToPPUString
       06:C510  A9 A8       LDA #LOW(BANK_LEVEL)
       06:C512  20 C8 D0    JSR WriteToPPUString
       06:C515  A9 00       LDA #DRAW_HORIZONTAL
       06:C517  20 C8 D0    JSR WriteToPPUString
       06:C51A  A9 03       LDA #$03 
       06:C51C  20 C8 D0    JSR WriteToPPUString
                            
  112  06:C51F  AD 07 70    LDA bank_index
  113  06:C522  20 C8 D0    JSR WriteToPPUString
  114  06:C525  A9 60       LDA #$60
  115  06:C527  20 C8 D0    JSR WriteToPPUString
  116  06:C52A  AE 08 70    LDX puzzle_index
  117  06:C52D  E8          INX
  118  06:C52E  8A          TXA 
  119  06:C52F  20 C8 D0    JSR WriteToPPUString
  120                       
  121  06:C532  EE 0F 00    INC mode_state
  122                     
  123  06:C535            UpdateDrawVertClues:
  124                       
  125  06:C535  AD 00 70    LDA hasContinue
  126  06:C538  D0 05       BNE .changeModeState
  127  06:C53A  20 06 D2    JSR PopulateClues
  128                       
  129  06:C53D  90 22       BCC .leave
  130                       
  131  06:C53F            .changeModeState:
  132                     
  133  06:C53F  A9 00       LDA #$00
  134  06:C541  8D C0 00    STA clueLineIndex
  135  06:C544  8D C6 00    STA clueParity
  136                       
  137  06:C547  A9 05       LDA #$05
  138  06:C549  8D C1 00    STA clueOffsetShift
  139                       
  140  06:C54C  A9 01       LDA #$01
  141  06:C54E  8D C2 00    STA clueDrawAdd
  142                        
  143                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C551  A9 21             LDA #HIGH(HORI_CLUES)
       06:C553  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C555  8E BB 00          STX clue_start_address
       06:C558  8D BC 00          STA clue_start_address+1
                                  
  144  06:C55B  20 AF D2    JSR ResetClueDrawAddress
  145                     
  146  06:C55E  EE 0F 00    INC mode_state
  147  06:C561            .leave:
  148  06:C561  60          RTS
  149                       
  150  06:C562            UpdateDrawHoriClues:
  151                     
  152  06:C562  AD 00 70    LDA hasContinue
  153  06:C565  D0 0B       BNE .changeModeState
  154  06:C567  20 06 D2    JSR PopulateClues
  155  06:C56A  AD BF 00    LDA clueTableIndex
  156  06:C56D  8D 09 70    STA image_table_offset
  157  06:C570  90 49       BCC .leave
  158                     
  159  06:C572            .changeModeState:
  160  06:C572  20 10 D1    JSR TurnOnSprites
  161                       
  162                       ;;set the timer to 00
  163                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C575  A9 01       LDA #$01
       06:C577  8D 23 00    STA PPU_PendingWrite
       06:C57A  A9 20       LDA #HIGH(TIMER_LOC)
       06:C57C  20 C8 D0    JSR WriteToPPUString
       06:C57F  A9 E5       LDA #LOW(TIMER_LOC)
       06:C581  20 C8 D0    JSR WriteToPPUString
       06:C584  A9 00       LDA #DRAW_HORIZONTAL
       06:C586  20 C8 D0    JSR WriteToPPUString
       06:C589  A9 05       LDA #$05 
       06:C58B  20 C8 D0    JSR WriteToPPUString
                            
  164  06:C58E  AD 06 70    LDA GameTime+3
  165  06:C591  20 C8 D0    JSR WriteToPPUString
  166  06:C594  AD 05 70    LDA GameTime+2
  167  06:C597  20 C8 D0    JSR WriteToPPUString
  168  06:C59A  A9 61       LDA #$61
  169  06:C59C  20 C8 D0    JSR WriteToPPUString
  170  06:C59F  AD 04 70    LDA GameTime+1
  171  06:C5A2  20 C8 D0    JSR WriteToPPUString
  172  06:C5A5  AD 03 70    LDA GameTime
  173  06:C5A8  20 C8 D0    JSR WriteToPPUString
  174                       
  175                       ;;reset time
  176  06:C5AB  A9 00       LDA #$00
  177  06:C5AD  8D 0A 00    STA time
  178  06:C5B0  8D 0B 00    STA scaledTime
  179                       
  180                       ;;clear has continue
  181  06:C5B3  A9 00       LDA #$00
  182  06:C5B5  8D 00 70    STA hasContinue 
  183                       
  184                       
  185  06:C5B8  EE 0F 00    INC mode_state
  186  06:C5BB            .leave:
  187  06:C5BB  60          RTS
  188                       
  189  06:C5BC            UpdateGamePlay:
  190                         
  191  06:C5BC  AD CC 00    LDA pauseState
  192  06:C5BF  F0 04       BEQ .checkPause
  193  06:C5C1  20 C2 CA    JSR UpdatePause
  194  06:C5C4  60          RTS
  195                       
  196  06:C5C5            .checkPause:
  197                       
  198  06:C5C5  AD 1C 00    LDA gamepadPressed
  199  06:C5C8  29 08       AND #GAMEPAD_START
  200  06:C5CA  F0 29       BEQ .updatePlay
  201  06:C5CC  A9 01       LDA #$01
  202  06:C5CE  8D CC 00    STA pauseState
  203  06:C5D1  A9 00       LDA #$00
  204  06:C5D3  8D C0 00    STA clueLineIndex 
  205  06:C5D6  8D C1 00    STA clueOffsetShift   
  206                     
  207  06:C5D9  A9 FF       LDA #$FF
  208  06:C5DB  A2 00       LDX #$00
  209  06:C5DD  20 69 C2    JSR SetSpriteImage
  210                     
  211                       ;;we need the pause screen table loaded
  212                       MACROGetLabelPointer Pause_Menu, pause_address
                          
       06:C5E0  A9 FC             LDA #HIGH(Pause_Menu)
       06:C5E2  A2 7C             LDX #LOW(Pause_Menu)
                                  
       06:C5E4  8E B3 00          STX pause_address
       06:C5E7  8D B4 00          STA pause_address+1
                                  
  213                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C5EA  A9 21             LDA #HIGH($210A)
       06:C5EC  A2 0A             LDX #LOW($210A)
                                  
       06:C5EE  8E B7 00          STX pause_draw_address
       06:C5F1  8D B8 00          STA pause_draw_address+1
                                  
  214                       
  215                       
  216  06:C5F4  60          RTS
  217                     
  218  06:C5F5            .updatePlay:
  219                     
  220  06:C5F5  20 72 CA    JSR UpdateTimeDisplay
  221                             
  222  06:C5F8  A9 00       LDA #$00
  223  06:C5FA  8D 00 00    STA temp1
  224  06:C5FD  8D 01 00    STA temp2
  225  06:C600  8D 02 00    STA temp3
  226                       
  227  06:C603            .checkPressed:  
  228                     
  229  06:C603  AD 1C 00    LDA gamepadPressed
  230  06:C606  29 F0       AND #GAMEPAD_MOVE
  231  06:C608  F0 0B       BEQ .checkHeld
  232                       
  233  06:C60A  A9 10       LDA #HOLD_TIME
  234  06:C60C  8D CE 00    STA holdTimer 
  235  06:C60F  AD 1C 00    LDA gamepadPressed
  236  06:C612  4C 29 C6    JMP .parseInputs
  237                       
  238  06:C615            .checkHeld:
  239                       
  240  06:C615  AD 1A 00    LDA gamepad
  241  06:C618  29 F0       AND #GAMEPAD_MOVE
  242  06:C61A  F0 2F       BEQ .checkPaintPress
  243                       
  244                       ;;decrement the hold timer
  245  06:C61C  CE CE 00    DEC holdTimer
  246  06:C61F  D0 2A       BNE .checkPaintPress
  247  06:C621  A9 04       LDA #HOLD_FREQ
  248  06:C623  8D CE 00    STA holdTimer
  249  06:C626  AD 1A 00    LDA gamepad
  250                     
  251  06:C629            .parseInputs:
  252                     
  253  06:C629  29 F0       AND #GAMEPAD_MOVE
  254  06:C62B  F0 1E       BEQ .checkPaintPress
  255  06:C62D  0A          ASL A
  256  06:C62E  90 03       BCC .checkLeft
  257  06:C630  EE 00 00    INC temp1
  258  06:C633            .checkLeft:
  259  06:C633  0A          ASL A
  260  06:C634  90 03       BCC .checkDown
  261  06:C636  CE 00 00    DEC temp1
  262  06:C639            .checkDown:
  263  06:C639  0A          ASL A
  264  06:C63A  90 03       BCC .checkUp
  265  06:C63C  EE 01 00    INC temp2
  266  06:C63F            .checkUp:
  267  06:C63F  0A          ASL A
  268  06:C640  90 03       BCC .move
  269  06:C642  CE 01 00    DEC temp2
  270                       
  271  06:C645            .move:
  272                      
  273  06:C645  20 07 C9    JSR MoveMouse
  274  06:C648  20 FE C9    JSR UpdateMouseScreenPos
  275                       
  276  06:C64B            .checkPaintPress:
  277                     
  278  06:C64B  AD 1C 00    LDA gamepadPressed
  279  06:C64E  29 03       AND #GAMEPAD_AB
  280  06:C650  F0 41       BEQ .updatePaint
  281                       ;;A or B pressed, get current tile
  282                       
  283  06:C652  8D 00 00    STA temp1
  284                       
  285  06:C655  A0 00       LDY #$00
  286  06:C657  B1 C7       LDA [mouse_location], y
  287  06:C659  8D 01 00    STA temp2
  288                       
  289                         ;;A treats X and Clear as clear
  290                             ;;B treats mark and clear as clear
  291                             ;;clear->mark->x
  292                             
  293                     
  294  06:C65C  C9 7C       CMP #$7C      ;check if this is a marked tile
  295  06:C65E  B0 0F       BCS .getClearTile
  296                       ;;cleared tile- store off marked tile to paint with instead
  297                       ;;not a clear tile- a mark or an x - check A or B  
  298  06:C660  4E 00 00    LSR temp1
  299  06:C663  B0 05       BCS .getMarkTile
  300                       
  301  06:C665            .getXTile:
  302  06:C665  A9 80       LDA #$80
  303  06:C667  4C 8D C6    JMP .finishGetTile
  304                       
  305  06:C66A            .getMarkTile:
  306  06:C66A  A9 70       LDA #$70
  307  06:C66C  4C 8D C6    JMP .finishGetTile
  308                     
  309  06:C66F            .getClearTile:
  310                       
  311  06:C66F  4E 00 00    LSR temp1
  312  06:C672  90 0A       BCC .checkB
  313  06:C674  AD 01 00    LDA temp2
  314  06:C677  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  315  06:C679  90 0D       BCC .clearTile
  316  06:C67B  4C 6A C6    JMP .getMarkTile
  317                       
  318  06:C67E            .checkB:
  319                       
  320  06:C67E  AD 01 00   LDA temp2
  321  06:C681  C9 8C      CMP #$8C
  322  06:C683  B0 03      BCS .clearTile
  323  06:C685  4C 65 C6   JMP .getXTile
  324                       
  325  06:C688            .clearTile:
  326  06:C688  A9 60       LDA #$60
  327  06:C68A  4C 8D C6    JMP .finishGetTile
  328                       
  329  06:C68D            .finishGetTile:
  330  06:C68D  8D CB 00    STA currentPaintTile
  331  06:C690  4C A5 C6    JMP .setTile
  332                     
  333                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  334                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  335                     ;;we can load the nametable into memory as we draw it
  336                     
  337  06:C693            .updatePaint:
  338                     
  339  06:C693  AD 1A 00    LDA gamepad
  340  06:C696  29 03       AND #GAMEPAD_AB
  341  06:C698  D0 06       BNE .checkInputLock
  342                       
  343  06:C69A  A9 00       LDA #$00
  344  06:C69C  8D CD 00    STA pauseInputLock
  345                       
  346  06:C69F            .leaveEarly:
  347  06:C69F  60          RTS  
  348                     
  349  06:C6A0            .checkInputLock:
  350                     
  351                       ;;check if the input lock is on
  352  06:C6A0  2D CD 00    AND pauseInputLock
  353  06:C6A3  D0 FA       BNE .leaveEarly
  354                       
  355  06:C6A5            .setTile:
  356                       
  357  06:C6A5  AD C9 00    LDA mouse_index
  358  06:C6A8  0D CA 00    ORA mouse_index+1
  359  06:C6AB  29 10       AND #$10
  360  06:C6AD  F0 22       BEQ .getPuzzleTile
  361                       
  362  06:C6AF  AD 1C 00    LDA gamepadPressed ; only draw on click
  363  06:C6B2  29 03       AND #GAMEPAD_AB
  364  06:C6B4  F0 E9       BEQ .leaveEarly
  365                       
  366  06:C6B6  A0 00       LDY #$00
  367  06:C6B8  B1 C7       LDA [mouse_location], y
  368  06:C6BA  C9 40       CMP #$40
  369  06:C6BC  90 E1       BCC .leaveEarly
  370  06:C6BE  C9 5F       CMP #$5F
  371  06:C6C0  F0 02       BEQ .toggleClue
  372  06:C6C2  B0 DB       BCS .leaveEarly
  373                     
  374  06:C6C4            .toggleClue:
  375  06:C6C4  8D 02 00    STA temp3
  376  06:C6C7  29 F0       AND #$F0
  377  06:C6C9  49 10       EOR #$10
  378  06:C6CB  8D CB 00    STA currentPaintTile
  379  06:C6CE  4C D4 C6    JMP .overwriteTile
  380                       
  381  06:C6D1            .getPuzzleTile:
  382  06:C6D1  20 C9 CB    JSR CheckAgainstSolution
  383                       
  384  06:C6D4            .overwriteTile:
  385                       ;;overwrite tile
  386  06:C6D4  AD 02 00    LDA temp3             ;tile taken from current mouse location
  387  06:C6D7  29 0F       AND #$0F
  388  06:C6D9  0D CB 00    ORA currentPaintTile
  389  06:C6DC  A0 00       LDY #$00
  390  06:C6DE  91 C7       STA [mouse_location], y
  391  06:C6E0  8D 00 00    STA temp1
  392                       
  393  06:C6E3  AD C8 00    LDA mouse_location+1
  394  06:C6E6  29 3F       AND #$3F
  395  06:C6E8  8D 01 00    STA temp2
  396                         
  397                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C6EB  A9 01       LDA #$01
       06:C6ED  8D 23 00    STA PPU_PendingWrite
       06:C6F0  AD 01 00    LDA temp2
       06:C6F3  20 C8 D0    JSR WriteToPPUString
       06:C6F6  AD C7 00    LDA mouse_location
       06:C6F9  20 C8 D0    JSR WriteToPPUString
       06:C6FC  A9 00       LDA #DRAW_HORIZONTAL
       06:C6FE  20 C8 D0    JSR WriteToPPUString
       06:C701  A9 01       LDA #$01 
       06:C703  20 C8 D0    JSR WriteToPPUString
                            
  398  06:C706  AD 00 00    LDA temp1
  399  06:C709  20 C8 D0    JSR WriteToPPUString
  400                       
  401                       ;;also copy to save copy
  402  06:C70C  AD C7 00    LDA mouse_location
  403  06:C70F  8D B5 00    STA copy_address
  404  06:C712  AD C8 00    LDA mouse_location+1
  405  06:C715  29 0F       AND #$0F
  406  06:C717  09 60       ORA #$60
  407  06:C719  18          CLC
  408  06:C71A  69 08       ADC #$08
  409  06:C71C  8D B6 00    STA copy_address+1
  410                       
  411  06:C71F  AD 00 00    LDA temp1
  412  06:C722  A0 00       LDY #$00
  413  06:C724  91 B5       STA [copy_address],y
  414                       
  415  06:C726            .checkSolution: 
  416                     
  417  06:C726  A0 01       LDY #$01
  418  06:C728  B1 AD       LDA [puzzle_address], y
  419  06:C72A  CD 01 70    CMP solutionCount
  420  06:C72D  D0 57       BNE .leave
  421  06:C72F  AD 02 70    LDA nonSolutionCount
  422  06:C732  F0 03       BEQ .changeModeState
  423                       
  424  06:C734  4C 86 C7    JMP .leave
  425                       
  426                       ;;update the painting
  427  06:C737            .changeModeState:
  428                      
  429  06:C737  20 19 D1    JSR TurnOffSprites
  430                        
  431  06:C73A  A9 00       LDA #$00
  432  06:C73C  8D BD 00    STA clue_draw_address
  433  06:C73F  8D C0 00    STA clueLineIndex
  434  06:C742  A9 20       LDA #$20
  435  06:C744  8D BE 00    STA clue_draw_address+1
  436                       
  437  06:C747  EE 0F 00    INC mode_state
  438                       
  439                       ;;the puzzle is solved, store the time and solved bit in memory
  440                       ;;if the puzzle was solved before, only update the time
  441                       
  442                       MACROGetLabelPointer PuzzleSaveLocations, table_address
                          
       06:C74A  A9 CC             LDA #HIGH(PuzzleSaveLocations)
       06:C74C  A2 59             LDX #LOW(PuzzleSaveLocations)
                                  
       06:C74E  8E 16 00          STX table_address
       06:C751  8D 17 00          STA table_address+1
                                  
  443  06:C754  AD 07 70    LDA bank_index
  444  06:C757  0A          ASL A
  445  06:C758  A8          TAY
  446  06:C759  20 6C CF    JSR GetTableAtIndex
  447                       
  448  06:C75C  20 87 CB    JSR CheckNewBestTime
  449                       
  450  06:C75F  AD D1 00    LDA recordSet
  451  06:C762  F0 22       BEQ .leave
  452                       
  453  06:C764  AD 08 70    LDA puzzle_index
  454  06:C767  0A          ASL A
  455  06:C768  0A          ASL A
  456  06:C769  A8          TAY
  457  06:C76A  AD 03 70    LDA GameTime
  458  06:C76D  09 80       ORA #$80
  459  06:C76F  91 16       STA [table_address], y
  460  06:C771  C8          INY
  461  06:C772  AD 04 70    LDA GameTime+1
  462  06:C775  91 16       STA [table_address], y
  463  06:C777  C8          INY
  464  06:C778  AD 05 70    LDA GameTime+2
  465  06:C77B  91 16       STA [table_address], y
  466  06:C77D  C8          INY
  467  06:C77E  AD 06 70    LDA GameTime+3
  468  06:C781  91 16       STA [table_address],y
  469  06:C783  4C 86 C7    JMP .leave
  470                       
  471  06:C786            .leave:
  472                      
  473  06:C786  60          RTS
  474                       
  475  06:C787            UpdateClearPuzzle:
  476                     
  477  06:C787  20 23 D3    JSR ClearPuzzle
  478  06:C78A  AD C0 00    LDA clueLineIndex
  479  06:C78D  C9 1E       CMP #30
  480  06:C78F  D0 08       BNE .leave
  481                       
  482  06:C791            .changeModeState:
  483                     
  484  06:C791  A9 00       LDA #$00
  485  06:C793  8D C0 00    STA clueLineIndex ;using this as a scroller
  486  06:C796  EE 0F 00    INC mode_state
  487                     
  488  06:C799            .leave:
  489                      
  490  06:C799  60          RTS
  491  06:C79A            UpdateMoveScreen:
  492                       
  493                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  494                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  495                       
  496  06:C79A  A0 00       LDY #$00
  497  06:C79C  B1 AD       LDA [puzzle_address], y
  498  06:C79E  AA          TAX
  499  06:C79F  BD 50 CC    LDA PuzzleScrollHori, x
  500  06:C7A2  8D 00 00    STA temp1
  501  06:C7A5  BD 53 CC    LDA PuzzleScrollVert, x
  502  06:C7A8  8D 01 00    STA temp2
  503                       
  504  06:C7AB  AD C0 00    LDA clueLineIndex
  505  06:C7AE  29 10       AND #$10
  506  06:C7B0  D0 1E       BNE .scrollY
  507                       
  508                       ;;scroll X over
  509  06:C7B2  AD C0 00    LDA clueLineIndex
  510  06:C7B5  29 0F       AND #$0F
  511  06:C7B7  0A          ASL A
  512  06:C7B8  0A          ASL A
  513  06:C7B9  0A          ASL A ;mult by 8
  514  06:C7BA  8D 1F 00    STA PPU_ScrollX
  515                       
  516  06:C7BD  EE C0 00    INC clueLineIndex
  517  06:C7C0  AD C0 00    LDA clueLineIndex
  518  06:C7C3  CD 00 00    CMP temp1
  519  06:C7C6  D0 4A       BNE .leave
  520  06:C7C8  A9 10       LDA #$10
  521  06:C7CA  8D C0 00    STA clueLineIndex
  522  06:C7CD  4C 12 C8    JMP .leave
  523                       
  524  06:C7D0            .scrollY:
  525                     
  526  06:C7D0  AD C0 00    LDA clueLineIndex
  527  06:C7D3  29 0F       AND #$0F
  528  06:C7D5  0A          ASL A
  529  06:C7D6  0A          ASL A
  530  06:C7D7  0A          ASL A ;mult by 8
  531  06:C7D8  8D 20 00    STA PPU_ScrollY
  532                     
  533  06:C7DB  EE C0 00    INC clueLineIndex
  534  06:C7DE  AD C0 00    LDA clueLineIndex
  535  06:C7E1  29 0F       AND #$0F
  536  06:C7E3  CD 01 00    CMP temp2
  537  06:C7E6  D0 2A       BNE .leave
  538                       
  539  06:C7E8            .changeModeState:
  540                     
  541  06:C7E8  A9 8E       LDA #$8E
  542  06:C7EA  8D BD 00    STA clue_draw_address
  543  06:C7ED  A9 21       LDA #$21
  544  06:C7EF  8D BE 00    STA clue_draw_address+1
  545                       
  546  06:C7F2  AD AF 00    LDA clues_address
  547  06:C7F5  18          CLC
  548  06:C7F6  6D 09 70    ADC image_table_offset
  549  06:C7F9  8D AF 00    STA clues_address
  550  06:C7FC  AD B0 00    LDA clues_address+1
  551  06:C7FF  69 00       ADC #$00
  552  06:C801  8D B0 00    STA clues_address+1
  553                       
  554  06:C804  A9 00       LDA #$00
  555  06:C806  8D BF 00    STA clueTableIndex
  556  06:C809  8D C0 00    STA clueLineIndex
  557  06:C80C  8D C1 00    STA clueOffsetShift
  558                     
  559  06:C80F  EE 0F 00    INC mode_state
  560                     
  561  06:C812            .leave:
  562                      
  563  06:C812  60          RTS
  564  06:C813            UpdateDrawImage:
  565                     
  566                       ;run it twice for a faster draw
  567  06:C813  20 05 D4    JSR DrawImage
  568  06:C816  AD BF 00    LDA clueTableIndex
  569  06:C819  CD 09 00    CMP tempy
  570                     
  571  06:C81C  F0 01       BEQ .changeModeState
  572  06:C81E  60          RTS
  573                       
  574  06:C81F            .changeModeState:
  575                     
  576                       ;;do a palette draw
  577                       ;;puzzle address + 03 has the desired palette offset
  578                     
  579  06:C81F  A0 03       LDY #$03
  580  06:C821  B1 AD       LDA [puzzle_address],y
  581  06:C823  29 0F       AND #$0F
  582  06:C825  AA          TAX
  583                       
  584  06:C826  B1 AD       LDA [puzzle_address],y
  585  06:C828  29 10       AND #$10
  586  06:C82A  F0 15       BEQ .storeBottomVals
  587                       
  588  06:C82C  8A          TXA
  589  06:C82D  09 10       ORA #$10
  590  06:C82F  8D 01 00    STA temp2
  591  06:C832  8A          TXA
  592  06:C833  09 20       ORA #$20
  593  06:C835  8D 02 00    STA temp3
  594  06:C838  8A          TXA
  595  06:C839  09 30       ORA #$30
  596  06:C83B  8D 03 00    STA temp4
  597                     
  598  06:C83E  4C 53 C8    JMP .checkKeepWhite
  599                       
  600  06:C841            .storeBottomVals:
  601                     
  602  06:C841  8A          TXA
  603  06:C842  09 00       ORA #$00
  604  06:C844  8D 01 00    STA temp2
  605  06:C847  8A          TXA
  606  06:C848  09 10       ORA #$10
  607  06:C84A  8D 02 00    STA temp3
  608  06:C84D  8A          TXA
  609  06:C84E  09 20       ORA #$20
  610  06:C850  8D 03 00    STA temp4
  611                       
  612  06:C853            .checkKeepWhite:
  613                       
  614  06:C853  B1 AD       LDA [puzzle_address],y
  615  06:C855  29 20       AND #$20
  616  06:C857  F0 05       BEQ .loadPalToPPUStr
  617                       
  618  06:C859  A9 30       LDA #$30
  619  06:C85B  8D 03 00    STA temp4
  620                       
  621                       
  622  06:C85E            .loadPalToPPUStr:
  623                       
  624                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C85E  A9 01       LDA #$01
       06:C860  8D 23 00    STA PPU_PendingWrite
       06:C863  A9 3F       LDA #$3F
       06:C865  20 C8 D0    JSR WriteToPPUString
       06:C868  A9 01       LDA #$01
       06:C86A  20 C8 D0    JSR WriteToPPUString
       06:C86D  A9 00       LDA #DRAW_HORIZONTAL
       06:C86F  20 C8 D0    JSR WriteToPPUString
       06:C872  A9 03       LDA #03 
       06:C874  20 C8 D0    JSR WriteToPPUString
                            
  625  06:C877  AD 01 00    LDA temp2
  626  06:C87A  20 C8 D0    JSR WriteToPPUString
  627  06:C87D  AD 02 00    LDA temp3
  628  06:C880  20 C8 D0    JSR WriteToPPUString
  629  06:C883  AD 03 00    LDA temp4
  630  06:C886  20 C8 D0    JSR WriteToPPUString
  631                       
  632  06:C889  A2 01       LDX #$01
  633  06:C88B            .copyLoop:
  634                       ;;also store in the copy 
  635  06:C88B  BD 00 00    LDA temp1, x
  636  06:C88E  9D 00 6C    STA Palette_Copy, x
  637  06:C891  E8          INX
  638  06:C892  E0 04       CPX #$04
  639  06:C894  D0 F5       BNE .copyLoop
  640                       
  641  06:C896  A0 00       LDY #$00
  642  06:C898  B1 AD       LDA [puzzle_address], y
  643  06:C89A  0A          ASL A
  644  06:C89B  AA          TAX
  645  06:C89C  BD FE D5    LDA ImageTitleLowerHalfPos, x
  646  06:C89F  8D B9 00    STA title_draw_address
  647  06:C8A2  E8          INX
  648  06:C8A3  BD FE D5    LDA ImageTitleLowerHalfPos, x
  649  06:C8A6  8D BA 00    STA title_draw_address+1
  650                       
  651  06:C8A9  20 59 D5    JSR DrawTitle
  652                       
  653  06:C8AC  EE 0F 00    INC mode_state
  654                     
  655  06:C8AF            .leave:
  656                      
  657  06:C8AF  60          RTS
  658                       
  659  06:C8B0            UpdateWaitInput:
  660                     
  661  06:C8B0  AD 1C 00    LDA gamepadPressed
  662  06:C8B3  F0 10       BEQ .leave
  663                       
  664  06:C8B5            .changeModeState:
  665  06:C8B5  A9 00       LDA #$00
  666  06:C8B7  8D 0A 00    STA time
  667  06:C8BA  8D 0B 00    STA scaledTime
  668  06:C8BD  A9 02       LDA #GAMEOVER_IDX
  669  06:C8BF  8D CF 00    STA targetGameMode
  670  06:C8C2  EE 0F 00    INC mode_state
  671                     
  672  06:C8C5            .leave:
  673                      
  674  06:C8C5  60          RTS
  675                       
  676  06:C8C6            UpdateGameFadeOut:
  677                     
  678  06:C8C6  AD 0A 00    LDA time
  679  06:C8C9  29 07       AND #$07
  680  06:C8CB  D0 1E       BNE .leave
  681                       ;;every 8 frames, decrement the palettes
  682  06:C8CD  20 45 D1    JSR FadeOutPalettes
  683  06:C8D0  B0 19       BCS .leave
  684                     
  685  06:C8D2            .changeModeState:
  686  06:C8D2  A9 00       LDA #$00
  687  06:C8D4  8D 0A 00    STA time
  688  06:C8D7  EE 0F 00    INC mode_state
  689                       
  690                       ;;don't need to turn all the sprites off, just need to
  691                       ;;clear them out   
  692  06:C8DA  A9 FF       LDA #$FF
  693  06:C8DC  A2 00       LDX #$00
  694  06:C8DE  20 69 C2    JSR SetSpriteImage
  695                       
  696  06:C8E1  A9 FF       LDA #$FF
  697  06:C8E3  A2 01       LDX #$01
  698  06:C8E5  20 69 C2    JSR SetSpriteImage
  699                       
  700  06:C8E8  20 10 D1    JSR TurnOnSprites     ;turn sprite rendering back on
  701                       
  702  06:C8EB            .leave:
  703  06:C8EB  60          RTS  
  704                     
  705  06:C8EC            UpdateGameExit:
  706                     
  707                       ;JSR famistudio_music_stop
  708  06:C8EC  AD 0A 00    LDA time
  709  06:C8EF  29 0F       AND #$0F
  710  06:C8F1  D0 13       BNE .leave
  711                     
  712  06:C8F3  A9 00       LDA #$00
  713  06:C8F5  8D 1F 00    STA PPU_ScrollX
  714  06:C8F8  8D 20 00    STA PPU_ScrollY
  715  06:C8FB  8D 21 00    STA PPU_ScrollNT
  716                       
  717  06:C8FE  AD CF 00    LDA targetGameMode
  718  06:C901  A2 00       LDX #$00
  719  06:C903  20 75 CE    JSR ChangeGameMode
  720  06:C906            .leave:
  721  06:C906  60          RTS
  722                       
  723  06:C907            MoveMouse:
  724                     
  725  06:C907  AD 00 00    LDA temp1                             ;horizontal move 
  726  06:C90A  0E 00 00    ASL temp1
  727  06:C90D  0E 00 00    ASL temp1
  728  06:C910  0E 00 00    ASL temp1
  729                       
  730  06:C913  AD 01 00    LDA temp2                             ;vertical move
  731  06:C916  0E 01 00    ASL temp2 
  732  06:C919  0E 01 00    ASL temp2
  733  06:C91C  0E 01 00    ASL temp2
  734                       
  735                       
  736  06:C91F  A0 00       LDY #$00
  737  06:C921  B1 AD       LDA [puzzle_address], y ;puzzle size 0 = 5, 1 = 10, 2 = 15  
  738  06:C923  0A          ASL A
  739  06:C924  AA          TAX
  740                     
  741  06:C925  AD CA 00    LDA mouse_index+1             ;horizontal index
  742  06:C928  29 10       AND #$10                              ;check clue flag
  743  06:C92A  8D 09 00    STA tempy                             ;store clue flag
  744  06:C92D  AD C9 00    LDA mouse_index               ;horizontal index
  745  06:C930  29 10       AND #$10                              ;check clue flag
  746  06:C932  8D 08 00    STA tempx                             ;store clue flag
  747                       
  748  06:C935  F0 0D       BEQ .puzzleHoriMin
  749  06:C937  A9 22       LDA #HORI_CLUE_MIN
  750  06:C939  8D 02 00    STA temp3 
  751  06:C93C  A9 6A       LDA #HORI_CLUE_MAX
  752  06:C93E  8D 03 00    STA temp4
  753  06:C941  4C 50 C9    JMP .checkHoriBorder
  754                       
  755  06:C944            .puzzleHoriMin:
  756  06:C944  BD 44 CC    LDA MouseMinimums, x
  757  06:C947  8D 02 00    STA temp3 
  758  06:C94A  BD 4A CC    LDA MouseMaximums, x
  759  06:C94D  8D 03 00    STA temp4
  760                       
  761  06:C950            .checkHoriBorder:
  762  06:C950  8A          TXA
  763  06:C951  48          PHA
  764                       
  765  06:C952  A9 00       LDA #$00
  766  06:C954  8D 06 00    STA temp7
  767                       
  768  06:C957  A2 03       LDX #SPRITE_XPOS
  769  06:C959  BD 00 02    LDA SPRITE_DATA, x
  770  06:C95C  18          CLC
  771  06:C95D  6D 00 00    ADC temp1
  772                       ;;check against borders
  773  06:C960  CD 02 00    CMP temp3
  774  06:C963  D0 18       BNE .checkHoriMax
  775                       ;;equal - check if mouse index is in clue area
  776  06:C965  8D 05 00    STA temp6
  777  06:C968  AD 08 00    LDA tempx
  778  06:C96B  0D 09 00    ORA tempy
  779  06:C96E  D0 27       BNE .moveVert
  780  06:C970  EE 06 00    INC temp7
  781  06:C973  AD 05 00    LDA temp6
  782  06:C976  18          CLC
  783  06:C977  6D 00 00    ADC temp1
  784  06:C97A  4C 94 C9    JMP .moveSpriteHori
  785                       
  786  06:C97D            .checkHoriMax:
  787  06:C97D  CD 03 00    CMP temp4
  788  06:C980  D0 12       BNE .moveSpriteHori
  789                       
  790  06:C982  8D 05 00    STA temp6
  791  06:C985  AD 08 00    LDA tempx
  792  06:C988  F0 0D       BEQ .moveVert
  793  06:C98A  EE 06 00    INC temp7
  794  06:C98D  AD 05 00    LDA temp6
  795  06:C990  18          CLC
  796  06:C991  6D 00 00    ADC temp1
  797                       
  798  06:C994            .moveSpriteHori:
  799  06:C994  9D 00 02    STA SPRITE_DATA, x
  800                     
  801  06:C997            .moveVert:
  802                     
  803  06:C997  68          PLA
  804  06:C998  AA          TAX
  805  06:C999  E8          INX
  806                       
  807  06:C99A  AD 09 00    LDA tempy
  808  06:C99D  F0 0D       BEQ .puzzleVertMin
  809  06:C99F  A9 12       LDA #VERT_CLUE_MIN
  810  06:C9A1  8D 02 00    STA temp3 
  811  06:C9A4  A9 5A       LDA #VERT_CLUE_MAX
  812  06:C9A6  8D 03 00    STA temp4
  813  06:C9A9  4C B8 C9    JMP .checkVertBorder
  814                       
  815  06:C9AC            .puzzleVertMin:
  816  06:C9AC  BD 44 CC    LDA MouseMinimums, x
  817  06:C9AF  8D 02 00    STA temp3
  818  06:C9B2  BD 4A CC    LDA MouseMaximums, x
  819  06:C9B5  8D 03 00    STA temp4
  820                     
  821                     
  822  06:C9B8            .checkVertBorder:
  823                     
  824  06:C9B8  A9 00       LDA #$00
  825  06:C9BA  8D 07 00    STA temp8
  826                     
  827  06:C9BD  A2 00       LDX #SPRITE_YPOS
  828  06:C9BF  BD 00 02    LDA SPRITE_DATA, x
  829  06:C9C2  18          CLC
  830  06:C9C3  6D 01 00    ADC temp2
  831                       ;;check against borders
  832  06:C9C6  CD 02 00    CMP temp3
  833  06:C9C9  D0 18       BNE .checkVertMax
  834                       ;;equal - check if mouse index is in clue area
  835  06:C9CB  8D 05 00    STA temp6
  836  06:C9CE  AD 09 00    LDA tempy
  837  06:C9D1  0D 08 00    ORA tempx
  838  06:C9D4  D0 27       BNE .leave
  839  06:C9D6  EE 07 00    INC temp8
  840  06:C9D9  AD 05 00    LDA temp6
  841  06:C9DC  18          CLC
  842  06:C9DD  6D 01 00    ADC temp2
  843  06:C9E0  4C FA C9    JMP .moveSpriteVert
  844                       
  845  06:C9E3            .checkVertMax:
  846  06:C9E3  CD 03 00    CMP temp4
  847  06:C9E6  D0 12       BNE .moveSpriteVert
  848  06:C9E8  8D 05 00    STA temp6
  849  06:C9EB  AD 09 00    LDA tempy
  850  06:C9EE  F0 0D       BEQ .leave
  851  06:C9F0  EE 07 00    INC temp8
  852  06:C9F3  AD 05 00    LDA temp6
  853  06:C9F6  18          CLC
  854  06:C9F7  6D 01 00    ADC temp2
  855                       
  856  06:C9FA            .moveSpriteVert:
  857  06:C9FA  9D 00 02    STA SPRITE_DATA, x
  858                     
  859  06:C9FD            .leave:
  860  06:C9FD  60          RTS
  861                             
  862  06:C9FE            UpdateMouseScreenPos:
  863                     
  864  06:C9FE  AD 06 00    LDA temp7
  865  06:CA01  F0 08       BEQ .skipHoriFlip
  866                       
  867  06:CA03  AD 08 00    LDA tempx
  868  06:CA06  49 10       EOR #$10
  869  06:CA08  8D 08 00    STA tempx
  870                       
  871  06:CA0B            .skipHoriFlip:
  872                     
  873  06:CA0B  AD 07 00    LDA temp8
  874  06:CA0E  F0 08       BEQ .skipVertFlip
  875                     
  876  06:CA10  AD 09 00    LDA tempy
  877  06:CA13  49 10       EOR #$10
  878  06:CA15  8D 09 00    STA tempy
  879                     
  880  06:CA18            .skipVertFlip:
  881                     
  882                     
  883  06:CA18  A2 00       LDX #$00
  884  06:CA1A  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  885  06:CA1D  4A          LSR A                                         ;0yyy yy..
  886  06:CA1E  4A          LSR A                                         ;00yy yyy.
  887  06:CA1F  4A          LSR A                                         ;000y yyyy
  888  06:CA20  8D 00 00    STA temp1
  889  06:CA23  8D CA 00    STA mouse_index+1                     ;vertical
  890  06:CA26  E8          INX
  891  06:CA27  E8          INX
  892  06:CA28  E8          INX   
  893  06:CA29  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  894  06:CA2C  29 F8       AND #$F8                       ;              ;  xxxx x000
  895  06:CA2E  8D 01 00    STA temp2                      ;      ;  
  896  06:CA31  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  897  06:CA34  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  898  06:CA37  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  899  06:CA3A  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  900  06:CA3D  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  901  06:CA40  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  902  06:CA43  AD 01 00    LDA temp2
  903  06:CA46  29 1F       AND #$1F
  904  06:CA48  8D C9 00    STA mouse_index                       ;horizontal
  905                       
  906  06:CA4B  AD C9 00    LDA mouse_index
  907  06:CA4E  38          SEC 
  908  06:CA4F  E9 0E       SBC #$0E
  909  06:CA51  0D 08 00    ORA tempx
  910  06:CA54  8D C9 00    STA mouse_index
  911                       
  912  06:CA57  AD CA 00    LDA mouse_index+1
  913  06:CA5A  38          SEC 
  914  06:CA5B  E9 0C       SBC #$0C
  915  06:CA5D  0D 09 00    ORA tempy
  916  06:CA60  8D CA 00    STA mouse_index+1
  917                       
  918                       ;subtract starting offsets for mouse index
  919                       
  920  06:CA63  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  921  06:CA66  09 60       ORA #$60                       ;              ;  0110 00yy
  922                       
  923  06:CA68  8D C8 00    STA mouse_location+1
  924  06:CA6B  AD 01 00    LDA temp2
  925  06:CA6E  8D C7 00    STA mouse_location
  926                       
  927  06:CA71            .leave:
  928  06:CA71  60          RTS
  929                       
  930  06:CA72            UpdateTimeDisplay:
  931                     
  932  06:CA72  AD 0B 00    LDA scaledTime
  933  06:CA75  C9 3C       CMP #60
  934  06:CA77  D0 48       BNE .leave
  935                       
  936  06:CA79  A9 00       LDA #$00
  937  06:CA7B  8D 0B 00    STA scaledTime
  938                       
  939  06:CA7E  EE 03 70    INC GameTime
  940  06:CA81  AD 03 70    LDA GameTime
  941  06:CA84  C9 0A       CMP #10
  942  06:CA86  D0 32       BNE .printTime
  943                       
  944  06:CA88  A9 00       LDA #$00
  945  06:CA8A  8D 03 70    STA GameTime
  946  06:CA8D  EE 04 70    INC GameTime+1
  947  06:CA90  AD 04 70    LDA GameTime+1
  948  06:CA93  C9 06       CMP #6
  949  06:CA95  D0 23       BNE .printTime
  950                       
  951  06:CA97  A9 00       LDA #$00
  952  06:CA99  8D 04 70    STA GameTime+1
  953  06:CA9C  EE 05 70    INC GameTime+2
  954  06:CA9F  AD 05 70    LDA GameTime+2
  955  06:CAA2  C9 0A       CMP #10
  956  06:CAA4  D0 14       BNE .printTime
  957                       
  958  06:CAA6  A9 00       LDA #$00
  959  06:CAA8  8D 05 70    STA GameTime+2
  960  06:CAAB  EE 06 70    INC GameTime+3
  961  06:CAAE  AD 06 70    LDA GameTime+3
  962  06:CAB1  C9 0A       CMP #10
  963  06:CAB3  D0 05       BNE .printTime
  964                       
  965  06:CAB5  A9 00       LDA #$00
  966  06:CAB7  8D 06 70    STA GameTime+3
  967                         
  968                       
  969  06:CABA            .printTime:
  970                     
  971  06:CABA  A9 20       LDA #HIGH(TIMER_LOC)
  972  06:CABC  A2 E5       LDX #LOW(TIMER_LOC)
  973                     
  974  06:CABE  20 98 D5    JSR ApplyGameTimeToPPUString
  975                       
  976                       
  977  06:CAC1            .leave: 
  978  06:CAC1  60          RTS  
  979                       
  980  06:CAC2            UpdatePause:
  981                     
  982                     ;;load screen
  983                     ;;update selection
  984                     ;; close - remove screen, then upause
  985                     ;; quit - jump to fade out
  986  06:CAC2  AD CC 00    LDA pauseState
  987  06:CAC5  20 46 CF    JSR Dynamic_Jump
  988                     
  989  06:CAC8            UpdatePauseJumpTable:  
  990                     
  991  06:CAC8  86 CB       .word ExitPause                       ;fail safe
  992  06:CACA  D0 CA       .word UpdateLoadPauseScreen
  993  06:CACC  EC CA       .word UpdatePauseScreen
  994  06:CACE  6A CB       .word UpdateUnloadPauseScreen
  995                       
  996  06:CAD0            UpdateLoadPauseScreen:
  997                       
  998  06:CAD0  20 6A D3    JSR LoadPauseScreen
  999  06:CAD3  AD C1 00    LDA clueOffsetShift
 1000  06:CAD6  C9 06       CMP #$06
 1001  06:CAD8  D0 11       BNE .leave
 1002                       
 1003  06:CADA            .changePauseState:
 1004                     
 1005  06:CADA  A9 60       LDA #PAUSE_YES
 1006  06:CADC  A2 01       LDX #$01
 1007  06:CADE  20 5E C2    JSR SetSpriteXPosition  
 1008  06:CAE1  A9 01       LDA #$01
 1009  06:CAE3  A2 01       LDX #$01
 1010  06:CAE5  20 69 C2    JSR SetSpriteImage
 1011                       
 1012  06:CAE8  EE CC 00    INC pauseState
 1013  06:CAEB            .leave:
 1014  06:CAEB  60          RTS
 1015                       
 1016  06:CAEC            UpdatePauseScreen:
 1017                       
 1018  06:CAEC  AD 1C 00    LDA gamepadPressed
 1019  06:CAEF  C9 08       CMP #GAMEPAD_START
 1020  06:CAF1  F0 29       BEQ .unPause
 1021  06:CAF3  C9 02       CMP #GAMEPAD_B
 1022  06:CAF5  F0 25       BEQ .unPause
 1023  06:CAF7  C9 01       CMP #GAMEPAD_A
 1024  06:CAF9  F0 4A       BEQ .checkA
 1025                       
 1026                       ;;update pointer
 1027                       
 1028  06:CAFB  AD 1C 00    LDA gamepadPressed
 1029  06:CAFE  29 C0       AND #GAMEPAD_HORI
 1030                       ;;binary system- left and right don't really matter, we'll just toggle the position
 1031  06:CB00  F0 67       BEQ .leave
 1032                       
 1033  06:CB02  A9 03       LDA #SPRITE_XPOS
 1034  06:CB04  A2 01       LDX #$01
 1035  06:CB06  20 80 C2    JSR GetSpriteData
 1036                       
 1037  06:CB09  C9 60       CMP #PAUSE_YES
 1038  06:CB0B  F0 05       BEQ .loadNo
 1039                       
 1040  06:CB0D  A9 60       LDA #PAUSE_YES
 1041  06:CB0F  4C 14 CB    JMP .setPosition
 1042                       
 1043  06:CB12            .loadNo:
 1044  06:CB12  A9 88       LDA #PAUSE_NO
 1045                     
 1046  06:CB14            .setPosition:
 1047                       
 1048  06:CB14  A2 01       LDX #$01
 1049  06:CB16  20 5E C2    JSR SetSpriteXPosition  
 1050                     
 1051  06:CB19  4C 69 CB    JMP .leave 
 1052                     
 1053  06:CB1C            .unPause:
 1054                     
 1055  06:CB1C  A9 00       LDA #$00
 1056  06:CB1E  8D C0 00    STA clueLineIndex
 1057  06:CB21  8D C1 00    STA clueOffsetShift
 1058                       
 1059  06:CB24  A9 FF       LDA #$FF
 1060  06:CB26  A2 01       LDX #$01
 1061  06:CB28  20 69 C2    JSR SetSpriteImage
 1062                     
 1063                       MACROGetLabelPointer $610A, pause_address
                          
       06:CB2B  A9 61             LDA #HIGH($610A)
       06:CB2D  A2 0A             LDX #LOW($610A)
                                  
       06:CB2F  8E B3 00          STX pause_address
       06:CB32  8D B4 00          STA pause_address+1
                                  
 1064                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:CB35  A9 21             LDA #HIGH($210A)
       06:CB37  A2 0A             LDX #LOW($210A)
                                  
       06:CB39  8E B7 00          STX pause_draw_address
       06:CB3C  8D B8 00          STA pause_draw_address+1
                                  
 1065                         
 1066  06:CB3F  EE CC 00    INC pauseState
 1067  06:CB42  4C 69 CB    JMP .leave
 1068                      
 1069  06:CB45            .checkA:
 1070                       
 1071  06:CB45  A9 03       LDA #SPRITE_XPOS
 1072  06:CB47  A2 01       LDX #$01
 1073  06:CB49  20 80 C2    JSR GetSpriteData
 1074                       
 1075  06:CB4C  C9 88       CMP #PAUSE_NO
 1076  06:CB4E  F0 CC       BEQ .unPause
 1077                        
 1078  06:CB50            .quit:
 1079                             
 1080  06:CB50  A9 01       LDA #$01
 1081  06:CB52  8D 00 70    STA hasContinue
 1082  06:CB55  A9 00       LDA #$00
 1083  06:CB57  8D CC 00    STA pauseState
 1084  06:CB5A  A9 00       LDA #$00
 1085  06:CB5C  8D 0A 00    STA time
 1086  06:CB5F  A9 02       LDA #GAMEOVER_IDX
 1087  06:CB61  8D CF 00    STA targetGameMode
 1088  06:CB64  A9 08       LDA #$08
 1089  06:CB66  8D 0F 00    STA mode_state
 1090                       
 1091  06:CB69            .leave:
 1092  06:CB69  60          RTS
 1093                       
 1094  06:CB6A            UpdateUnloadPauseScreen:
 1095                       
 1096  06:CB6A  20 B1 D3    JSR ClearPauseScreen
 1097  06:CB6D  AD C1 00    LDA clueOffsetShift
 1098  06:CB70  C9 06       CMP #$06
 1099  06:CB72  D0 11       BNE .leave
 1100  06:CB74            .changePauseState:
 1101                     
 1102  06:CB74  A9 02       LDA #$02
 1103  06:CB76  A2 00       LDX #$00
 1104  06:CB78  20 69 C2    JSR SetSpriteImage
 1105                       
 1106  06:CB7B  A9 03       LDA #GAMEPAD_AB
 1107  06:CB7D  8D CD 00    STA pauseInputLock 
 1108                       
 1109  06:CB80  A9 00       LDA #$00
 1110  06:CB82  8D CC 00    STA pauseState
 1111  06:CB85            .leave:
 1112  06:CB85  60          RTS
 1113                       
 1114  06:CB86            ExitPause:
 1115  06:CB86  60          RTS
 1116                       
 1117  06:CB87            CheckNewBestTime:
 1118                     
 1119                       ;let's say we already have the save data in the table address
 1120  06:CB87  A9 00       LDA #$00
 1121  06:CB89  8D D1 00    STA recordSet
 1122                       
 1123                       
 1124  06:CB8C  AD 08 70    LDA puzzle_index
 1125  06:CB8F  0A          ASL A
 1126  06:CB90  0A          ASL A
 1127  06:CB91  A8          TAY
 1128  06:CB92  B1 16       LDA [table_address], y
 1129  06:CB94  29 80       AND #$80
 1130  06:CB96  F0 2D       BEQ .updateTime
 1131                       ;MACROGetLabelPointer PuzzleSaveLocations, table_address
 1132                       ;LDA bank_index
 1133                       ;ASL A
 1134                       ;TAY
 1135                       ;JSR GetTableAtIndex
 1136                     
 1137  06:CB98  C8          INY 
 1138  06:CB99  C8          INY
 1139  06:CB9A  C8          INY   ;start at highest time loc
 1140  06:CB9B  AD 06 70    LDA GameTime+3
 1141  06:CB9E  D1 16       CMP [table_address], y
 1142  06:CBA0  90 23       BCC .updateTime
 1143  06:CBA2  88          DEY
 1144  06:CBA3  AD 05 70    LDA GameTime+2
 1145  06:CBA6  D1 16       CMP [table_address], y
 1146  06:CBA8  90 1B       BCC .updateTime
 1147  06:CBAA  88          DEY
 1148  06:CBAB  AD 04 70    LDA GameTime+1
 1149  06:CBAE  D1 16       CMP [table_address], y
 1150  06:CBB0  90 13       BCC .updateTime
 1151  06:CBB2  88          DEY
 1152  06:CBB3  B1 16       LDA [table_address], y
 1153  06:CBB5  29 0F       AND #$0F
 1154  06:CBB7  8D 00 00    STA temp1
 1155  06:CBBA  AD 03 70    LDA GameTime
 1156  06:CBBD  CD 00 00    CMP temp1
 1157  06:CBC0  90 03       BCC .updateTime
 1158  06:CBC2  4C C8 CB    JMP .leave
 1159                       
 1160  06:CBC5            .updateTime:
 1161                     
 1162  06:CBC5  EE D1 00    INC recordSet
 1163                       
 1164  06:CBC8            .leave:
 1165  06:CBC8  60          RTS
 1166                         
 1167                     
 1168  06:CBC9            CheckAgainstSolution:
 1169                       ;;take Y position, mult by 2 to get starting index in puzzle solution
 1170  06:CBC9  AD CA 00    LDA mouse_index+1
 1171                     ;;if the puzzle is a 5x5, we only have one byte per row, so no need to double this
 1172  06:CBCC  8D 00 00    STA temp1
 1173  06:CBCF  A0 00       LDY #$00
 1174  06:CBD1  B1 AD       LDA [puzzle_address], y
 1175  06:CBD3  F0 03       BEQ .skipDouble
 1176  06:CBD5  0E 00 00    ASL temp1
 1177  06:CBD8            .skipDouble:
 1178  06:CBD8  AD 00 00    LDA temp1
 1179  06:CBDB  18          CLC
 1180  06:CBDC  69 04       ADC #$04 ;; add to get past header
 1181  06:CBDE  8D 00 00    STA temp1
 1182                       
 1183                       ;;div X position by 8 to get the byte index
 1184  06:CBE1  AD C9 00    LDA mouse_index
 1185  06:CBE4  4A          LSR A
 1186  06:CBE5  4A          LSR A
 1187  06:CBE6  4A          LSR A
 1188  06:CBE7  F0 03       BEQ .getMask
 1189                       
 1190  06:CBE9  EE 00 00    INC temp1
 1191                       
 1192  06:CBEC            .getMask:
 1193                       
 1194  06:CBEC  AD C9 00    LDA mouse_index
 1195  06:CBEF  29 07       AND #$07
 1196  06:CBF1  AA          TAX
 1197  06:CBF2  A9 80       LDA #$80
 1198  06:CBF4  E0 00       CPX #$00
 1199  06:CBF6  F0 04       BEQ .storeMask
 1200                     
 1201  06:CBF8            .maskLoop:
 1202  06:CBF8  4A          LSR A
 1203  06:CBF9  CA          DEX
 1204  06:CBFA  D0 FC       BNE .maskLoop
 1205  06:CBFC            .storeMask:
 1206  06:CBFC  8D 01 00    STA temp2
 1207                     
 1208  06:CBFF  AC 00 00    LDY temp1
 1209  06:CC02  B1 AD       LDA [puzzle_address], y
 1210  06:CC04  2D 01 00    AND temp2
 1211  06:CC07  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
 1212                     
 1213  06:CC0A  A0 00       LDY #$00
 1214  06:CC0C  B1 C7       LDA [mouse_location], y
 1215  06:CC0E  8D 02 00    STA temp3
 1216  06:CC11  29 F0       AND #$F0
 1217  06:CC13  CD CB 00    CMP currentPaintTile
 1218  06:CC16  D0 01       BNE .diffTiles
 1219  06:CC18  60          RTS
 1220                       
 1221  06:CC19            .diffTiles:
 1222                       ;;tiles are different- check if the current tile is marked as a solution tile
 1223  06:CC19  C9 70       CMP #$70
 1224  06:CC1B  D0 0B       BNE .checkNewMark
 1225                       ;;if erasing a mark, check if the tile was part of the solution
 1226  06:CC1D  AD 00 00    LDA temp1
 1227  06:CC20  D0 18       BNE .antiMark
 1228  06:CC22  CE 02 70    DEC nonSolutionCount
 1229  06:CC25  4C 43 CC    JMP .leave
 1230                       
 1231  06:CC28            .checkNewMark:
 1232                     
 1233  06:CC28  AD CB 00    LDA currentPaintTile
 1234  06:CC2B  C9 70       CMP #$70
 1235  06:CC2D  D0 14       BNE .leave
 1236                       
 1237  06:CC2F  AD 00 00    LDA temp1
 1238  06:CC32  D0 0C       BNE .proMark
 1239  06:CC34  EE 02 70    INC nonSolutionCount 
 1240  06:CC37  4C 43 CC    JMP .leave 
 1241                       
 1242  06:CC3A            .antiMark:
 1243  06:CC3A  CE 01 70    DEC solutionCount
 1244  06:CC3D  4C 43 CC    JMP .leave
 1245  06:CC40            .proMark:   
 1246                       
 1247  06:CC40  EE 01 70    INC solutionCount
 1248  06:CC43            .leave:
 1249  06:CC43  60          RTS   
 1250                     
 1251                     ;hori, vert
 1252  06:CC44            MouseMinimums:
 1253  06:CC44  6A 5A       .db $6A, $5A
 1254  06:CC46  6A 5A       .db $6A, $5A
 1255  06:CC48  6A 5A       .db $6A, $5A
 1256  06:CC4A            MouseMaximums:
 1257  06:CC4A  9A 8A       .db $9A, $8A
 1258  06:CC4C  C2 B2       .db $C2, $B2
 1259  06:CC4E  EA DA       .db $EA, $DA
 1260                       
 1261           0012      VERT_CLUE_MIN = $12
 1262           0022      HORI_CLUE_MIN = $22
 1263           006A      HORI_CLUE_MAX = $6A
 1264           005A      VERT_CLUE_MAX = $5A
 1265                       
 1266  06:CC50            PuzzleScrollHori:
 1267  06:CC50  01 04 06    .db $01, $04, $06
 1268  06:CC53            PuzzleScrollVert:
 1269  06:CC53  01 03 05    .db $01, $03, $05
 1270                       
 1271  06:CC56            PuzzleHeaderSkips:
 1272                     
 1273  06:CC56  09 18 22    .db $09, $18, $22
 1274                       
 1275  06:CC59            PuzzleSaveLocations:
 1276  06:CC59  0A 70       .word puzzle_clear_bank0, puzzle_clear_bank1, puzzle_clear_bank2
       06:CC5B  76 70     
       06:CC5D  E2 70     
 1277                     
 1278                       
 1279           0060      PAUSE_YES = $60
 1280           0088      PAUSE_NO = $88
 1281                     
 1282                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   92                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:CC5F            UpdateGameOver:
    2                     
    3  06:CC5F  AD 10 00    LDA NMI_locks
    4  06:CC62  F0 01       BEQ .unlocked
    5                       
    6  06:CC64  60          RTS
    7                       
    8  06:CC65            .unlocked:
    9                     
   10  06:CC65  20 69 CC    JSR DoUpdateGameOver 
   11  06:CC68  60          RTS
   12                       
   13  06:CC69            DoUpdateGameOver:
   14                     
   15  06:CC69  AD 0F 00    LDA mode_state
   16  06:CC6C  20 46 CF    JSR Dynamic_Jump
   17                         
   18  06:CC6F            UpdateGameOverJumpTable:
   19                     
   20  06:CC6F  79 CC       .word UpdateGameOverInit
   21  06:CC71  BD CC       .word UpdateDrawMessage
   22  06:CC73  E2 CC       .word UpdateGameOverWaitInput
   23  06:CC75  8F CD       .word UpdateGameOverFadeOut
   24  06:CC77  A4 CD       .word UpdateGameOverExit
   25                       
   26  06:CC79            UpdateGameOverInit:
   27                     
   28                       ;load the hasContinue flag
   29                       ;choose the message to print based on the flag
   30                       
   31                       MACROGetLabelPointer EndScreens, table_address
                          
       06:CC79  A9 FC             LDA #HIGH(EndScreens)
       06:CC7B  A2 CA             LDX #LOW(EndScreens)
                                  
       06:CC7D  8E 16 00          STX table_address
       06:CC80  8D 17 00          STA table_address+1
                                  
   32  06:CC83  AD 00 70    LDA hasContinue
   33  06:CC86  0A          ASL A
   34  06:CC87  A8          TAY
   35  06:CC88  20 6C CF    JSR GetTableAtIndex
   36                       MACROGetPointer table_address, clues_address
                          
       06:CC8B  AD 16 00          LDA table_address
       06:CC8E  8D AF 00          STA clues_address
       06:CC91  AD 17 00          LDA table_address+1
       06:CC94  8D B0 00          STA clues_address+1
                          
   37                       
   38                       ;this gets us the pointer to the table- now we'll set up the starting draw address
   39  06:CC97  A0 00       LDY #$00
   40  06:CC99  B1 AF       LDA [clues_address], y
   41  06:CC9B  8D BD 00    STA clue_draw_address
   42  06:CC9E  C8          INY
   43  06:CC9F  B1 AF       LDA [clues_address], y
   44  06:CCA1  8D BE 00    STA clue_draw_address+1 
   45                     
   46  06:CCA4  AD AF 00    LDA clues_address
   47  06:CCA7  18          CLC
   48  06:CCA8  69 02       ADC #$02
   49  06:CCAA  8D AF 00    STA clues_address
   50  06:CCAD  AD B0 00    LDA clues_address+1
   51  06:CCB0  69 00       ADC #$00
   52  06:CCB2  8D B0 00    STA clues_address+1
   53                       
   54  06:CCB5  A9 00       LDA #$00
   55  06:CCB7  8D C0 00    STA clueLineIndex
   56                       ;;table address is now at the first string to draw
   57                         
   58  06:CCBA  EE 0F 00    INC mode_state
   59                     
   60                     ;no RTS, just update a line immediately
   61                     
   62  06:CCBD            UpdateDrawMessage:
   63                     
   64  06:CCBD  AD 00 70    LDA hasContinue
   65                       
   66  06:CCC0  F0 06       BEQ .drawClear
   67                       
   68  06:CCC2  20 1E CE    JSR DrawSaveText
   69                     
   70  06:CCC5  4C CB CC    JMP .checkLeave
   71                       
   72  06:CCC8            .drawClear
   73                     
   74  06:CCC8  20 B5 CD    JSR DrawClearText 
   75                       
   76  06:CCCB            .checkLeave:
   77  06:CCCB  90 14       BCC .leave
   78                     
   79  06:CCCD            .changeModeState:
   80                     
   81  06:CCCD  AD 00 70    LDA hasContinue
   82  06:CCD0  D0 07       BNE .skipSpriteSet
   83                       
   84  06:CCD2  A9 01       LDA #$01
   85  06:CCD4  A2 00       LDX #$00
   86  06:CCD6  20 69 C2    JSR SetSpriteImage
   87                       
   88  06:CCD9            .skipSpriteSet:
   89  06:CCD9  EE 0F 00    INC mode_state
   90  06:CCDC  A9 00       LDA #$00
   91  06:CCDE  8D 0A 00    STA time
   92  06:CCE1            .leave:
   93  06:CCE1  60          RTS
   94                       
   95                       
   96  06:CCE2            UpdateGameOverWaitInput:
   97                     
   98                       ;;if there was a record set, flash the time
   99  06:CCE2  AD D1 00    LDA recordSet
  100  06:CCE5  F0 03       BEQ .updateWait
  101  06:CCE7  20 44 CE    JSR FlashTime
  102                     
  103  06:CCEA            .updateWait:
  104  06:CCEA  AD 00 70    LDA hasContinue
  105  06:CCED  F0 06       BEQ .checkOption
  106                       
  107  06:CCEF  AD 1C 00    LDA gamepadPressed
  108  06:CCF2  D0 34       BNE .loadTitle
  109  06:CCF4            .leaveEarly:
  110  06:CCF4  60          RTS
  111                       
  112  06:CCF5            .checkOption:
  113  06:CCF5  AD 1C 00    LDA gamepadPressed
  114  06:CCF8  C9 01       CMP #GAMEPAD_A
  115  06:CCFA  F0 21       BEQ .checkA
  116                       
  117                       ;;update pointer
  118                       
  119  06:CCFC  AD 1C 00    LDA gamepadPressed
  120  06:CCFF  29 C0       AND #GAMEPAD_HORI
  121                       ;;binary system- left and right don't really matter, we'll just toggle the position
  122  06:CD01  F0 F1       BEQ .leaveEarly
  123                       
  124  06:CD03  A9 03       LDA #SPRITE_XPOS
  125  06:CD05  A2 00       LDX #$00
  126  06:CD07  20 80 C2    JSR GetSpriteData
  127                       
  128  06:CD0A  C9 58       CMP #GO_YES
  129  06:CD0C  F0 05       BEQ .loadNo
  130                       
  131  06:CD0E  A9 58       LDA #GO_YES
  132  06:CD10  4C 15 CD    JMP .setPosition
  133                       
  134  06:CD13            .loadNo:
  135  06:CD13  A9 80       LDA #GO_NO
  136                     
  137  06:CD15            .setPosition:
  138                       
  139  06:CD15  A2 00       LDX #$00
  140  06:CD17  20 5E C2    JSR SetSpriteXPosition  
  141                     
  142  06:CD1A  4C 8E CD    JMP .leave 
  143                       
  144  06:CD1D            .checkA:
  145                       
  146  06:CD1D  A9 03       LDA #SPRITE_XPOS
  147  06:CD1F  A2 00       LDX #$00
  148  06:CD21  20 80 C2    JSR GetSpriteData
  149                       
  150  06:CD24  C9 80       CMP #GO_NO
  151                       
  152                       ;no? go to main menu
  153                       ;yes? update puzzle index and go to game
  154                       ;if puzzle index is the last of the bank, return to menu anyways- we'll polish with a different message later
  155  06:CD26  D0 0D       BNE .loadNext
  156                       
  157                       ;load the title as the next screen
  158  06:CD28            .loadTitle:
  159  06:CD28  A9 00       LDA #TITLE_IDX
  160  06:CD2A  8D CF 00    STA targetGameMode
  161  06:CD2D  A9 00       LDA #$00
  162  06:CD2F  8D D0 00    STA targetScreenLoad
  163  06:CD32  4C 86 CD    JMP .changeModeState
  164                      
  165  06:CD35            .loadNext:  
  166                     
  167  06:CD35  EE 08 70    INC puzzle_index
  168  06:CD38  C9 28       CMP #$28
  169  06:CD3A  F0 EC       BEQ .loadTitle
  170                       
  171                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:CD3C  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:CD3E  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:CD40  8E 16 00          STX table_address
       06:CD43  8D 17 00          STA table_address+1
                                  
  172                       MACROGetDoubleIndex puzzle_index
                          
       06:CD46  AD 08 70          LDA puzzle_index
       06:CD49  0A                ASL A
       06:CD4A  A8                TAY
                                  
  173  06:CD4B  20 6C CF    JSR GetTableAtIndex
  174                       MACROGetPointer table_address, puzzle_address
                          
       06:CD4E  AD 16 00          LDA table_address
       06:CD51  8D AD 00          STA puzzle_address
       06:CD54  AD 17 00          LDA table_address+1
       06:CD57  8D AE 00          STA puzzle_address+1
                          
  175                       
  176                       MACROGetLabelPointer NAMES_TABLE, table_address
                          
       06:CD5A  A9 A0             LDA #HIGH(NAMES_TABLE)
       06:CD5C  A2 36             LDX #LOW(NAMES_TABLE)
                                  
       06:CD5E  8E 16 00          STX table_address
       06:CD61  8D 17 00          STA table_address+1
                                  
  177                       MACROGetDoubleIndex puzzle_index
                          
       06:CD64  AD 08 70          LDA puzzle_index
       06:CD67  0A                ASL A
       06:CD68  A8                TAY
                                  
  178  06:CD69  20 6C CF    JSR GetTableAtIndex
  179                       MACROGetPointer table_address, title_address
                          
       06:CD6C  AD 16 00          LDA table_address
       06:CD6F  8D B1 00          STA title_address
       06:CD72  AD 17 00          LDA table_address+1
       06:CD75  8D B2 00          STA title_address+1
                          
  180                     
  181  06:CD78  A9 01       LDA #GAME_IDX
  182  06:CD7A  8D CF 00    STA targetGameMode
  183                       
  184  06:CD7D  A0 00       LDY #$00
  185  06:CD7F  B1 AD       LDA [puzzle_address], y
  186  06:CD81  09 20       ORA #%00100000
  187  06:CD83  8D D0 00    STA targetScreenLoad
  188                     
  189  06:CD86            .changeModeState:
  190                     
  191  06:CD86  A9 00       LDA #$00
  192  06:CD88  8D 0A 00    STA time
  193  06:CD8B  EE 0F 00    INC mode_state
  194  06:CD8E            .leave:
  195  06:CD8E  60          RTS
  196                     
  197  06:CD8F            UpdateGameOverFadeOut:
  198                     
  199  06:CD8F  AD 0A 00    LDA time
  200  06:CD92  29 07       AND #$07
  201  06:CD94  D0 0D       BNE .leave
  202                       ;;every 8 frames, decrement the palettes
  203  06:CD96  20 45 D1    JSR FadeOutPalettes
  204  06:CD99  B0 08       BCS .leave
  205                     
  206  06:CD9B            .changeModeState:
  207  06:CD9B  A9 00       LDA #$00
  208  06:CD9D  8D 0A 00    STA time
  209  06:CDA0  EE 0F 00    INC mode_state
  210  06:CDA3            .leave:
  211  06:CDA3  60          RTS
  212                     
  213  06:CDA4            UpdateGameOverExit:
  214                     
  215  06:CDA4  AD 0A 00    LDA time
  216  06:CDA7  29 0F       AND #$0F
  217  06:CDA9  D0 09       BNE .leave
  218                     
  219  06:CDAB  AD CF 00    LDA targetGameMode
  220  06:CDAE  AE D0 00    LDX targetScreenLoad
  221  06:CDB1  20 75 CE    JSR ChangeGameMode
  222                       
  223  06:CDB4            .leave:
  224  06:CDB4  60          RTS
  225                       
  226  06:CDB5            DrawClearText:
  227                     
  228                       ;;for the clear, we draw multiple lines
  229                       ;;table address location is the print loation
  230                       MACROAddPPUStringEntryTablePtr clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, clues_address
                           
       06:CDB5  A9 01       LDA #$01
       06:CDB7  8D 23 00    STA PPU_PendingWrite
       06:CDBA  AD BE 00    LDA clue_draw_address+1
       06:CDBD  20 C8 D0    JSR WriteToPPUString
       06:CDC0  AD BD 00    LDA clue_draw_address
       06:CDC3  20 C8 D0    JSR WriteToPPUString
       06:CDC6  A9 20       LDA #$20
       06:CDC8  09 00       ORA #DRAW_HORIZONTAL
       06:CDCA  20 C8 D0    JSR WriteToPPUString
       06:CDCD  AD AF 00    LDA clues_address
       06:CDD0  20 C8 D0    JSR WriteToPPUString
       06:CDD3  AD B0 00    LDA clues_address+1
       06:CDD6  20 C8 D0    JSR WriteToPPUString
                           
  231  06:CDD9  EE C0 00    INC clueLineIndex
  232  06:CDDC  AD C0 00    LDA clueLineIndex
  233  06:CDDF  C9 02       CMP #$02
  234  06:CDE1  F0 07       BEQ .printTime
  235  06:CDE3  C9 04       CMP #$04
  236  06:CDE5  F0 35       BEQ .finish
  237  06:CDE7  4C F1 CD    JMP .updateClueAddress
  238                       
  239  06:CDEA            .printTime:
  240                     
  241  06:CDEA  A9 21       LDA #$21
  242  06:CDEC  A2 31       LDX #$31  
  243  06:CDEE  20 98 D5    JSR ApplyGameTimeToPPUString
  244                     
  245  06:CDF1            .updateClueAddress:
  246  06:CDF1  AD BD 00    LDA clue_draw_address
  247  06:CDF4  18          CLC
  248  06:CDF5  69 40       ADC #$40
  249  06:CDF7  8D BD 00    STA clue_draw_address
  250  06:CDFA  AD BE 00    LDA clue_draw_address+1
  251  06:CDFD  69 00       ADC #$00
  252  06:CDFF  8D BE 00    STA clue_draw_address+1
  253                       
  254  06:CE02  A0 00       LDY #$00
  255  06:CE04  B1 AF       LDA [clues_address],y
  256  06:CE06  AA          TAX
  257  06:CE07  E8          INX
  258  06:CE08  8A          TXA
  259  06:CE09  18          CLC
  260  06:CE0A  6D AF 00    ADC clues_address
  261  06:CE0D  8D AF 00    STA clues_address
  262  06:CE10  AD B0 00    LDA clues_address+1
  263  06:CE13  69 00       ADC #$00
  264  06:CE15  8D B0 00    STA clues_address+1
  265                       
  266  06:CE18  18          CLC
  267  06:CE19  4C 1D CE    JMP .leave
  268  06:CE1C            .finish:
  269                     
  270  06:CE1C  38          SEC
  271  06:CE1D            .leave
  272  06:CE1D  60          RTS
  273                       
  274  06:CE1E            DrawSaveText:
  275                     
  276                       MACROAddPPUStringEntryTablePtr clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, clues_address
                           
       06:CE1E  A9 01       LDA #$01
       06:CE20  8D 23 00    STA PPU_PendingWrite
       06:CE23  AD BE 00    LDA clue_draw_address+1
       06:CE26  20 C8 D0    JSR WriteToPPUString
       06:CE29  AD BD 00    LDA clue_draw_address
       06:CE2C  20 C8 D0    JSR WriteToPPUString
       06:CE2F  A9 20       LDA #$20
       06:CE31  09 00       ORA #DRAW_HORIZONTAL
       06:CE33  20 C8 D0    JSR WriteToPPUString
       06:CE36  AD AF 00    LDA clues_address
       06:CE39  20 C8 D0    JSR WriteToPPUString
       06:CE3C  AD B0 00    LDA clues_address+1
       06:CE3F  20 C8 D0    JSR WriteToPPUString
                           
  277  06:CE42  38          SEC
  278  06:CE43  60          RTS
  279                      
  280  06:CE44            FlashTime:
  281                     
  282  06:CE44  AD 0A 00    LDA time
  283  06:CE47  29 03       AND #$03
  284  06:CE49  D0 27       BNE .leave
  285                       
  286                       MACROAddPPUStringEntryRawData #$3F, #$02, #DRAW_HORIZONTAL, #$01
                          
       06:CE4B  A9 01       LDA #$01
       06:CE4D  8D 23 00    STA PPU_PendingWrite
       06:CE50  A9 3F       LDA #$3F
       06:CE52  20 C8 D0    JSR WriteToPPUString
       06:CE55  A9 02       LDA #$02
       06:CE57  20 C8 D0    JSR WriteToPPUString
       06:CE5A  A9 00       LDA #DRAW_HORIZONTAL
       06:CE5C  20 C8 D0    JSR WriteToPPUString
       06:CE5F  A9 01       LDA #$01 
       06:CE61  20 C8 D0    JSR WriteToPPUString
                            
  287  06:CE64  AD 0A 00    LDA time
  288  06:CE67  4A          LSR A
  289  06:CE68  4A          LSR A
  290  06:CE69  29 01       AND #$01
  291  06:CE6B  AA          TAX
  292  06:CE6C  BD 73 CE    LDA FlashColors, x
  293  06:CE6F  20 C8 D0    JSR WriteToPPUString
  294                      
  295  06:CE72            .leave
  296  06:CE72  60          RTS 
  297                     
  298  06:CE73            FlashColors:
  299                     
  300  06:CE73  2C 16       .db $2C, $16
  301                     
  302                        
  303                     
  304           0058      GO_YES = $58
  305           0080      GO_NO = $80
#[1]   Picross.asm
   93                       
   94                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   95                     ;;     Routines             ;;
   96                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   97                     
   98                     
#[2]   Routines/Common/GameModeRoutines.asm
   99                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:CE75            ChangeGameMode:
    2                       ;A - game mode index
    3                       ;X - high nibble: palette start flag, low nibble: screen index
    4  06:CE75  8D 0E 00    STA game_mode
    5  06:CE78  8E 0D 00    STX mode_loadFlags
    6  06:CE7B  A9 00       LDA #$00
    7  06:CE7D  8D 0F 00    STA mode_state
    8  06:CE80  20 DC D0    JSR ClearPPUString
    9  06:CE83  20 87 CE    JSR LoadGameModeScreen
   10  06:CE86  60          RTS
   11                       
   12  06:CE87            LoadGameModeScreen:
   13                     
   14                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:CE87  AD 10 00    LDA NMI_locks
       06:CE8A  09 01       ORA #BGLOAD_NMI_LOCK
       06:CE8C  8D 10 00    STA NMI_locks
                                  
   15                       
   16  06:CE8F  A9 00       LDA #$00
   17  06:CE91  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   18                     
   19  06:CE94  20 C2 CE    JSR LoadGameModeBackground
   20  06:CE97  20 23 CF    JSR LoadGameModeSprites
   21                     
   22                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:CE9A  A9 01       LDA #BGLOAD_NMI_LOCK
       06:CE9C  49 FF       EOR #$FF
       06:CE9E  2D 10 00    AND NMI_locks  
       06:CEA1  8D 10 00    STA NMI_locks
                          
   23                     
   24                       
   25                       ;; load the CHR bank for this mode
   26  06:CEA4  20 AF D1    JSR ResetMapper
   27                       ;;remember, we're loading the SECOND set in each chr bank
   28                       ;;so we'll take the index from the game mode chr table and add one mult 2
   29  06:CEA7  AE 0E 00    LDX game_mode
   30  06:CEAA  BD 40 CF    LDA gameModeInitCHRROMB, x
   31  06:CEAD  0A          ASL A
   32  06:CEAE  18          CLC 
   33  06:CEAF  69 01       ADC #$01
   34  06:CEB1  20 D4 D1    JSR LoadCHRBankB
   35                       
   36  06:CEB4  20 AF D1    JSR ResetMapper
   37  06:CEB7  AE 0E 00    LDX game_mode
   38  06:CEBA  BD 43 CF    LDA gameModeInitCHRROMA, x
   39  06:CEBD  0A          ASL A
   40  06:CEBE  20 C9 D1    JSR LoadCHRBankA
   41                       
   42                       
   43                       
   44  06:CEC1  60          RTS
   45                       
   46  06:CEC2            LoadGameModeBackground:
   47                             
   48                       MACROGetDoubleIndex game_mode
                          
       06:CEC2  AD 0E 00          LDA game_mode
       06:CEC5  0A                ASL A
       06:CEC6  A8                TAY
                                  
   49  06:CEC7  8C 00 00    STY temp1
   50                             
   51                       MACROGetLabelPointer Palettes, table_address
                          
       06:CECA  A9 E0             LDA #HIGH(Palettes)
       06:CECC  A2 00             LDX #LOW(Palettes)
                                  
       06:CECE  8E 16 00          STX table_address
       06:CED1  8D 17 00          STA table_address+1
                                  
   52  06:CED4  20 6C CF    JSR GetTableAtIndex
   53                     
   54  06:CED7  20 79 CF    JSR LoadFullPaletteFromTable
   55                             
   56  06:CEDA  AC 00 00    LDY temp1
   57  06:CEDD  AD 0D 00    LDA mode_loadFlags
   58  06:CEE0  29 40       AND #%01000000 ; copy from saved screen
   59  06:CEE2  F0 0D       BEQ .dontUseSaveCopy
   60                       MACROGetLabelPointer SaveScreen_Copy, table_address
                          
       06:CEE4  A9 68             LDA #HIGH(SaveScreen_Copy)
       06:CEE6  A2 00             LDX #LOW(SaveScreen_Copy)
                                  
       06:CEE8  8E 16 00          STX table_address
       06:CEEB  8D 17 00          STA table_address+1
                                  
   61  06:CEEE  4C 08 CF    JMP .loadTable
   62                       
   63  06:CEF1            .dontUseSaveCopy:
   64                       MACROGetLabelPointer NameTables, table_address
                          
       06:CEF1  A9 E0             LDA #HIGH(NameTables)
       06:CEF3  A2 06             LDX #LOW(NameTables)
                                  
       06:CEF5  8E 16 00          STX table_address
       06:CEF8  8D 17 00          STA table_address+1
                                  
   65  06:CEFB  20 6C CF    JSR GetTableAtIndex
   66  06:CEFE  AD 0D 00    LDA mode_loadFlags
   67  06:CF01  29 0F       AND #$0F
   68  06:CF03  0A          ASL A
   69  06:CF04  A8          TAY
   70  06:CF05  20 6C CF    JSR GetTableAtIndex
   71                             
   72  06:CF08            .loadTable:
   73  06:CF08  A9 00       LDA #$00
   74  06:CF0A  20 A8 CF    JSR LoadFullBackgroundFromTable
   75                       
   76  06:CF0D  AC 00 00    LDY temp1
   77                       MACROGetLabelPointer NameTables2, table_address
                          
       06:CF10  A9 E0             LDA #HIGH(NameTables2)
       06:CF12  A2 0C             LDX #LOW(NameTables2)
                                  
       06:CF14  8E 16 00          STX table_address
       06:CF17  8D 17 00          STA table_address+1
                                  
   78  06:CF1A  20 6C CF    JSR GetTableAtIndex
   79                       
   80  06:CF1D  A9 01       LDA #$01
   81  06:CF1F  20 A8 CF    JSR LoadFullBackgroundFromTable
   82                       
   83  06:CF22  60          RTS
   84                       
   85  06:CF23            LoadGameModeSprites:
   86                     
   87                       MACROGetDoubleIndex game_mode  
                          
       06:CF23  AD 0E 00          LDA game_mode
       06:CF26  0A                ASL A
       06:CF27  A8                TAY
                                  
   88                       MACROGetLabelPointer Sprites, table_address
                          
       06:CF28  A9 FD             LDA #HIGH(Sprites)
       06:CF2A  A2 28             LDX #LOW(Sprites)
                                  
       06:CF2C  8E 16 00          STX table_address
       06:CF2F  8D 17 00          STA table_address+1
                                  
   89  06:CF32  20 6C CF    JSR GetTableAtIndex
   90  06:CF35  A0 00       LDY #$00
   91  06:CF37  B1 16       LDA [table_address],y
   92  06:CF39  EE 16 00    INC table_address
   93  06:CF3C  20 B1 D0    JSR LoadSprites_impl
   94                       
   95  06:CF3F  60          RTS
   96                       
   97  06:CF40            gameModeInitCHRROMB:
   98  06:CF40  00 02 02          .db $00, $02, $02
   99  06:CF43            gameModeInitCHRROMA:
  100  06:CF43  00 02 02          .db $00, $02, $02
  101                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
  100                       .include "Routines/Utils/PointerUtils.asm"
    1  06:CF46            Dynamic_Jump:
    2                     
    3  06:CF46  0A          ASL A                                 ;; double the index passed into A
    4  06:CF47  8E 08 00    STX tempx
    5  06:CF4A  8C 09 00    STY tempy
    6  06:CF4D  A8          TAY
    7  06:CF4E  C8          INY  
    8  06:CF4F  68          PLA
    9  06:CF50  8D 18 00    STA jump_address
   10  06:CF53  68          PLA 
   11  06:CF54  8D 19 00    STA jump_address+1            
   12  06:CF57  B1 18       LDA [jump_address], y
   13  06:CF59  AA          TAX
   14  06:CF5A  C8          INY
   15  06:CF5B  B1 18       LDA [jump_address], y
   16  06:CF5D  8E 18 00    STX jump_address
   17  06:CF60  8D 19 00    STA jump_address+1
   18  06:CF63  AE 08 00    LDX tempx
   19  06:CF66  AC 09 00    LDY tempy
   20  06:CF69  6C 18 00    JMP [jump_address]
   21                       
   22  06:CF6C            GetTableAtIndex:
   23                     
   24  06:CF6C  B1 16             LDA [table_address], y
   25  06:CF6E  AA                TAX
   26  06:CF6F  C8                INY
   27  06:CF70  B1 16             LDA [table_address], y
   28                             
   29  06:CF72            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:CF72  8E 16 00          STX table_address
   33  06:CF75  8D 17 00          STA table_address+1
   34  06:CF78  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
  101                       .include "Routines/Utils/PPUUtils.asm"
    1  06:CF79            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:CF79  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:CF7C  A9 3F       LDA #HIGH($3F00)
       06:CF7E  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:CF81  A9 00       LDA #LOW($3F00)
       06:CF83  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:CF86  A0 00       LDY #$00              ; start out at 0
    5  06:CF88  A2 00       LDX #$00
    6  06:CF8A            .loop:
    7  06:CF8A  B1 16       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:CF8C  9D 00 6C    STA Palette_Copy, x
    9  06:CF8F  48          PHA 
   10  06:CF90  AD 0D 00    LDA mode_loadFlags
   11  06:CF93  29 10       AND #$10
   12  06:CF95  D0 04       BNE .setBlack
   13  06:CF97  68          PLA 
   14  06:CF98  4C 9E CF    JMP .setPPUData
   15  06:CF9B            .setBlack:
   16                     
   17  06:CF9B  68          PLA 
   18  06:CF9C  A9 0F       LDA #$0F
   19                       
   20  06:CF9E            .setPPUData:
   21  06:CF9E  8D 07 20    STA PPU_DATA            ; write to PPU
   22  06:CFA1  C8          INY                   ; X = X + 1
   23  06:CFA2  E8          INX
   24  06:CFA3  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   25  06:CFA5  D0 E3       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   26  06:CFA7  60          RTS
   27                     
   28  06:CFA8            LoadFullBackgroundFromTable:
   29                     
   30                         ;;use A as an index for which nametable to write to
   31  06:CFA8  20 FC D0          JSR SetNametableFromIndex
   32  06:CFAB  8A                TXA
   33  06:CFAC  4A                LSR A
   34  06:CFAD  29 01             AND #$01
   35  06:CFAF  D0 17             BNE .copyScreenB
   36                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:CFB1  A9 60             LDA #HIGH(Screen_Copy)
       06:CFB3  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:CFB5  8E 12 00          STX pointer_address
       06:CFB8  8D 13 00          STA pointer_address+1
                                  
   37                             MACROGetLabelPointer SaveScreen_Copy, pointerB_address
                          
       06:CFBB  A9 68             LDA #HIGH(SaveScreen_Copy)
       06:CFBD  A2 00             LDX #LOW(SaveScreen_Copy)
                                  
       06:CFBF  8E 14 00          STX pointerB_address
       06:CFC2  8D 15 00          STA pointerB_address+1
                                  
   38  06:CFC5  4C DB CF          JMP .setCounters
   39                             
   40  06:CFC8            .copyScreenB:
   41                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:CFC8  A9 64             LDA #HIGH(ScreenB_Copy)
       06:CFCA  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:CFCC  8E 12 00          STX pointer_address
       06:CFCF  8D 13 00          STA pointer_address+1
                                  
   42  06:CFD2  AD 0D 00          LDA mode_loadFlags
   43  06:CFD5  2D 00 00          AND $%11011111
   44  06:CFD8  8D 0D 00          STA mode_loadFlags ;kill the copy flag, just in case
   45                             
   46                             ;;set pointer
   47                             ;; set counters
   48  06:CFDB            .setCounters:
   49  06:CFDB  A0 00             LDY #$00
   50  06:CFDD  A2 00             LDX #$00
   51                             
   52                             ;;start loop
   53                     
   54  06:CFDF            .outerloop:
   55                     
   56  06:CFDF            .innerloop:
   57                     
   58  06:CFDF  B1 16             LDA [table_address], y
   59  06:CFE1  8D 07 20          STA PPU_DATA
   60  06:CFE4  91 12             STA [pointer_address],y
   61  06:CFE6  AD 0D 00      LDA mode_loadFlags
   62  06:CFE9  29 20         AND #%00100000      ;check copy flag
   63  06:CFEB  F0 04             BEQ .skipSaveCopy
   64  06:CFED  B1 16         LDA [table_address], y
   65  06:CFEF  91 14             STA [pointerB_address],y
   66                     
   67  06:CFF1            .skipSaveCopy:
   68  06:CFF1  C8                INY
   69  06:CFF2  C0 00             CPY #$00
   70  06:CFF4  D0 E9             BNE .innerloop
   71                     
   72  06:CFF6  EE 13 00          INC pointer_address+1
   73  06:CFF9  EE 17 00          INC table_address+1
   74  06:CFFC  EE 15 00          INC pointerB_address+1
   75                             
   76  06:CFFF  E8                INX
   77  06:D000  E0 04             CPX #$04
   78  06:D002  D0 DB             BNE .outerloop
   79  06:D004  60                RTS
   80                             
   81                     
   82           0000      DATA_LEN = temp1
   83           0001      WRITE_SETTINGS = temp2
   84                             
   85  06:D005            ProcessPPUString:
   86                     
   87  06:D005  AD 23 00          LDA PPU_PendingWrite
   88  06:D008  D0 01             BNE .continueProcess
   89  06:D00A  60                RTS
   90                             
   91  06:D00B            .continueProcess:
   92  06:D00B  A0 00             LDY #$00
   93                             
   94  06:D00D  A9 25             LDA #LOW(PPU_String)
   95  06:D00F  8D 12 00          STA pointer_address
   96  06:D012  A9 00             LDA #HIGH(PPU_String)
   97  06:D014  8D 13 00          STA pointer_address + 1
   98                     
   99  06:D017            .outerloop:
  100  06:D017  AD 02 20          LDA PPU_STATUS
  101  06:D01A  B1 12             LDA [pointer_address], y
  102  06:D01C  F0 79             BEQ .finish
  103  06:D01E  8D 06 20          STA PPU_ADDR
  104  06:D021  C8                INY
  105  06:D022  B1 12             LDA [pointer_address], y
  106  06:D024  8D 06 20          STA PPU_ADDR
  107  06:D027  C8            INY 
  108  06:D028  B1 12             LDA [pointer_address], y
  109  06:D02A  8D 01 00          STA WRITE_SETTINGS
  110  06:D02D  C8                INY
  111                             
  112  06:D02E  AD 00 20          LDA PPU_CTRL
  113  06:D031  29 FB             AND #$FB
  114  06:D033  8D 00 20          STA PPU_CTRL
  115                             
  116  06:D036  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
  117  06:D039  29 80             AND #%10000000
  118  06:D03B  F0 06             BEQ .checkRepeat
  119  06:D03D  0D 00 20          ORA PPU_CTRL 
  120  06:D040  8D 00 20          STA PPU_CTRL 
  121                             
  122                             
  123  06:D043            .checkRepeat:
  124  06:D043  AD 01 00    LDA WRITE_SETTINGS
  125  06:D046  29 40       AND #%01000000
  126  06:D048  F0 19       BEQ .checkTable
  127                       
  128  06:D04A  AD 01 00    LDA WRITE_SETTINGS
  129  06:D04D  29 3F       AND #$3F
  130  06:D04F  8D 00 00    STA DATA_LEN
  131                       ;;the usual data length byte is now the repeatable byte
  132  06:D052  A2 00       LDX #$00
  133                       
  134  06:D054            .repeatLoop:
  135  06:D054  B1 12       LDA [pointer_address], y
  136  06:D056  8D 07 20    STA PPU_DATA
  137  06:D059  E8          INX 
  138  06:D05A  EC 00 00    CPX DATA_LEN
  139  06:D05D  D0 F5       BNE .repeatLoop
  140  06:D05F  C8          INY
  141  06:D060  4C 17 D0    JMP .outerloop
  142                             
  143  06:D063            .checkTable:
  144  06:D063  AD 01 00          LDA WRITE_SETTINGS
  145  06:D066  29 20             AND #%00100000
  146  06:D068  F0 16             BEQ .rawData
  147                             
  148  06:D06A  B1 12             LDA [pointer_address], y
  149  06:D06C  8D 16 00          STA table_address
  150  06:D06F  C8                INY 
  151  06:D070  B1 12             LDA [pointer_address], y
  152  06:D072  8D 17 00          STA table_address + 1
  153  06:D075  C8                INY
  154  06:D076  98                TYA 
  155  06:D077  48                PHA
  156  06:D078  20 9B D0          JSR WriteToPPUFromTable
  157  06:D07B  68                PLA
  158  06:D07C  A8                TAY
  159  06:D07D  4C 17 D0          JMP .outerloop
  160                             
  161  06:D080            .rawData:
  162                     
  163  06:D080  B1 12             LDA [pointer_address], y
  164  06:D082  C8                INY
  165  06:D083  8D 00 00          STA DATA_LEN
  166                     
  167  06:D086  A2 00             LDX #$00
  168                     
  169  06:D088            .innerloop:
  170                             
  171  06:D088  B1 12             LDA [pointer_address], y
  172  06:D08A  8D 07 20          STA PPU_DATA
  173  06:D08D  C8                INY
  174  06:D08E  E8                INX
  175  06:D08F  EC 00 00          CPX DATA_LEN
  176  06:D092  D0 F4             BNE .innerloop
  177  06:D094  4C 17 D0          JMP .outerloop
  178                             
  179  06:D097            .finish:
  180  06:D097  20 DC D0          JSR ClearPPUString
  181  06:D09A            .leave:
  182  06:D09A  60                RTS
  183                             
  184  06:D09B            WriteToPPUFromTable:
  185  06:D09B  A0 00             LDY #$00
  186  06:D09D  B1 16             LDA [table_address], y
  187  06:D09F  C8                INY
  188  06:D0A0  8D 00 00          STA DATA_LEN
  189  06:D0A3            .innerloop:
  190  06:D0A3  B1 16             LDA [table_address], y
  191  06:D0A5  8D 07 20          STA PPU_DATA
  192  06:D0A8  C8                INY
  193  06:D0A9  CC 00 00          CPY DATA_LEN
  194  06:D0AC  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  195  06:D0AE  F0 F3             BEQ .innerloop
  196  06:D0B0  60                RTS
  197                       
  198  06:D0B1            LoadSprites_impl:
  199                       ;;A will be the amount of sprites to load
  200  06:D0B1  8D 00 00    STA DATA_LEN
  201  06:D0B4  0E 00 00    ASL DATA_LEN
  202  06:D0B7  0E 00 00    ASL DATA_LEN
  203                       
  204  06:D0BA  A0 00       LDY #$00              ; start at 0
  205                       
  206  06:D0BC            .loop:
  207  06:D0BC  B1 16       LDA [table_address], y; load data from address (sprites +  x)
  208  06:D0BE  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  209  06:D0C1  C8          INY                   ; X = X + 1
  210  06:D0C2  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  211  06:D0C5  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  212                                             ; if compare was equal to 16, keep going down   
  213  06:D0C7  60          RTS
  214                     
  215                     
  216  06:D0C8            WriteToPPUString:
  217                     
  218  06:D0C8  AE 24 00          LDX PPU_StringIdx
  219  06:D0CB  E0 4F             CPX #PPU_STRINGMAX
  220  06:D0CD  F0 0C             BEQ .finish
  221                             
  222  06:D0CF  9D 25 00          STA PPU_String, x
  223  06:D0D2  EE 24 00          INC PPU_StringIdx
  224  06:D0D5  E8                INX
  225  06:D0D6  A9 00             LDA #$00
  226  06:D0D8  9D 25 00          STA PPU_String, x
  227                                     
  228  06:D0DB            .finish:
  229  06:D0DB  60                RTS
  230                     
  231  06:D0DC            ClearPPUString:
  232                             
  233  06:D0DC  A9 00             LDA #$00
  234  06:D0DE  8D 24 00          STA PPU_StringIdx
  235  06:D0E1  8D 25 00          STA PPU_String
  236  06:D0E4  8D 23 00          STA PPU_PendingWrite
  237  06:D0E7  60                RTS
  238                     
  239  06:D0E8            DetectSprite0:
  240  06:D0E8            WaitNotSprite0:
  241  06:D0E8  AD 02 20    lda PPU_STATUS
  242  06:D0EB  29 40       and #SPRITE_0_MASK
  243  06:D0ED  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  244                     
  245  06:D0EF            WaitSprite0:
  246  06:D0EF  AD 02 20    lda $2002
  247  06:D0F2  29 40       and #SPRITE_0_MASK
  248  06:D0F4  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  249                     
  250  06:D0F6  A2 05       ldx #$05                              ;do a scanline wait
  251  06:D0F8            WaitScanline:
  252  06:D0F8  CA          dex
  253  06:D0F9  D0 FD       bne WaitScanline
  254  06:D0FB  60          RTS
  255                     
  256                     
  257  06:D0FC            SetNametableFromIndex:
  258                     
  259  06:D0FC  48          PHA
  260  06:D0FD  AD 02 20    LDA PPU_STATUS
  261  06:D100  68          PLA
  262  06:D101  0A          ASL A
  263  06:D102  AA          TAX
  264  06:D103  BD 98 D1    LDA NameTableMemList+1, x
  265  06:D106  8D 06 20    STA PPU_ADDR
  266  06:D109  BD 97 D1    LDA NameTableMemList, x
  267  06:D10C  8D 06 20    STA PPU_ADDR
  268  06:D10F  60          RTS
  269                       
  270  06:D110            TurnOnSprites:
  271                      
  272  06:D110  AD 1E 00    LDA PPU_Mask
  273  06:D113  09 10       ORA #%00010000
  274  06:D115  8D 1E 00    STA PPU_Mask
  275  06:D118  60          RTS
  276                       
  277  06:D119            TurnOffSprites:
  278                       
  279  06:D119  AD 1E 00    LDA PPU_Mask
  280  06:D11C  29 EF       AND #%11101111
  281  06:D11E  8D 1E 00    STA PPU_Mask
  282  06:D121  60          RTS
  283                     
  284  06:D122            UpdatePPUControl:
  285                     
  286  06:D122  AD 1D 00    LDA PPU_Control
  287  06:D125  29 FC       AND #$FC
  288  06:D127  0D 22 00    ORA PPU_NT
  289  06:D12A  8D 00 20    STA PPU_CTRL
  290  06:D12D  AD 1E 00    LDA PPU_Mask
  291  06:D130  8D 01 20    STA PPU_MASK
  292  06:D133  60          RTS
  293                       
  294  06:D134            InitPPUControl:
  295                       
  296                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  297                       ; enable sprites, enable background, no clipping on left side
  298  06:D134  A9 90       LDA #%10010000
  299  06:D136  8D 00 20    STA PPU_CTRL
  300  06:D139  8D 1D 00    STA PPU_Control
  301  06:D13C  A9 1E       LDA #%00011110
  302  06:D13E  8D 01 20    STA PPU_MASK
  303  06:D141  8D 1E 00    STA PPU_Mask
  304  06:D144  60          RTS
  305                       
  306  06:D145            FadeOutPalettes:
  307                     
  308                     ;;take the current values, and decrement the lower nibbles
  309                     ;;we can access from the palette copy 
  310                     ;;we'll make this fade out one level per call
  311                     ;;once all the palettes are blacked out we'll return true, so we'll keep the carry flag as a return result
  312                     
  313                     ;;go through the palette copy, decrement, make a raw data PPU string and add all the bytes into it
  314                     ;;for any palette color already in the 0x range, change it to 0f to get black
  315                     
  316                       MACROGetLabelPointer Palette_Copy, table_address
                          
       06:D145  A9 6C             LDA #HIGH(Palette_Copy)
       06:D147  A2 00             LDX #LOW(Palette_Copy)
                                  
       06:D149  8E 16 00          STX table_address
       06:D14C  8D 17 00          STA table_address+1
                                  
  317                     ;;palette copy address is now X accessable
  318                     
  319  06:D14F  A0 00       LDY #$00
  320                       MACROAddPPUStringEntryRawData #$3F, #$00, #DRAW_HORIZONTAL, #$20  
                          
       06:D151  A9 01       LDA #$01
       06:D153  8D 23 00    STA PPU_PendingWrite
       06:D156  A9 3F       LDA #$3F
       06:D158  20 C8 D0    JSR WriteToPPUString
       06:D15B  A9 00       LDA #$00
       06:D15D  20 C8 D0    JSR WriteToPPUString
       06:D160  A9 00       LDA #DRAW_HORIZONTAL
       06:D162  20 C8 D0    JSR WriteToPPUString
       06:D165  A9 20       LDA #$20 
       06:D167  20 C8 D0    JSR WriteToPPUString
                            
  321                     
  322  06:D16A  A9 00       LDA #$00
  323  06:D16C  8D 00 00    STA temp1
  324                       
  325  06:D16F            .loop:
  326                     
  327  06:D16F  B1 16       LDA [table_address], y
  328  06:D171  C9 0F       CMP #$0F
  329  06:D173  F0 15       BEQ .addToString
  330  06:D175  C9 10       CMP #$10
  331  06:D177  90 0D       BCC .setBlack
  332                       
  333  06:D179  A9 80       LDA #$80
  334  06:D17B  8D 00 00    STA temp1
  335                       
  336  06:D17E  B1 16       LDA [table_address], y
  337  06:D180  38          SEC
  338  06:D181  E9 10       SBC #$10
  339  06:D183  4C 88 D1    JMP .setColor
  340                     
  341  06:D186            .setBlack:
  342                     
  343  06:D186  A9 0F       LDA #$0F
  344                     
  345  06:D188            .setColor:
  346  06:D188  91 16       STA [table_address], y
  347                     
  348  06:D18A            .addToString:
  349                     
  350  06:D18A  20 C8 D0    JSR WriteToPPUString
  351                     
  352  06:D18D            .incY:
  353                       
  354  06:D18D  C8          INY
  355  06:D18E  C0 20       CPY #$20
  356  06:D190  D0 DD       BNE .loop
  357                     
  358  06:D192  0E 00 00    ASL temp1     ;get carry out, if we have one
  359                     
  360  06:D195  60          RTS
  361                       
  362  06:D196            FadeInPalettes:
  363                     
  364                     ;;need to be able to store off a target palette first
  365                     ;;we can use the palette copy we make during the game mode change as the target
  366  06:D196  60          RTS
  367                     
  368  06:D197            NameTableMemList:
  369  06:D197  00 20       .word $2000, $2400, $2800, $2C00
       06:D199  00 24     
       06:D19B  00 28     
       06:D19D  00 2C     
  370  06:D19F            PalettesMemList:
  371  06:D19F  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:D1A1  04 3F     
       06:D1A3  08 3F     
       06:D1A5  0C 3F     
  372  06:D1A7  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:D1A9  14 3F     
       06:D1AB  18 3F     
       06:D1AD  1C 3F     
  373                       
  374           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
  102                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:D1AF            ResetMapper:
    7  06:D1AF  EE AF D1    inc ResetMapper
    8  06:D1B2  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:D1B3            SetMapperControls:
   23                       ;;A = controls
   24  06:D1B3  AA          TAX
   25  06:D1B4  A9 80       LDA #MAPPERCONTROL
   26  06:D1B6  8D A6 00    STA mapper_address+1
   27  06:D1B9  8A          TXA
   28  06:D1BA  20 DF D1    JSR SendMapperCommand
   29  06:D1BD  60          RTS
   30                     
   31  06:D1BE            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:D1BE  AA                TAX
   35  06:D1BF  A9 E0             LDA #PRGBANK
   36  06:D1C1  8D A6 00          STA mapper_address+1
   37  06:D1C4  8A                TXA
   38  06:D1C5  20 DF D1          JSR SendMapperCommand
   39  06:D1C8  60                RTS
   40                             
   41  06:D1C9            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:D1C9  AA                TAX
   44  06:D1CA  A9 A0             LDA #CHRBANK1
   45  06:D1CC  8D A6 00          STA mapper_address+1
   46  06:D1CF  8A                TXA
   47  06:D1D0  20 DF D1          JSR SendMapperCommand
   48  06:D1D3  60                RTS
   49                             
   50  06:D1D4            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:D1D4  AA                TAX
   53  06:D1D5  A9 C0             LDA #CHRBANK2
   54  06:D1D7  8D A6 00          STA mapper_address+1
   55  06:D1DA  8A                TXA
   56  06:D1DB  20 DF D1          JSR SendMapperCommand
   57  06:D1DE  60                RTS
   58                             
   59  06:D1DF            SendMapperCommand:
   60                     
   61  06:D1DF  A0 00             LDY #$00
   62                             
   63  06:D1E1  91 A5             STA [mapper_address], y
   64  06:D1E3  4A                LSR A
   65  06:D1E4  91 A5             STA [mapper_address], y
   66  06:D1E6  4A                LSR A
   67  06:D1E7  91 A5             STA [mapper_address], y
   68  06:D1E9  4A                LSR A 
   69  06:D1EA  91 A5             STA [mapper_address], y
   70  06:D1EC  4A                LSR A
   71  06:D1ED  91 A5             STA [mapper_address], y
   72                             
   73  06:D1EF  60                RTS
   74                             
   75  06:D1F0            ResetBanks:
   76                     
   77  06:D1F0  20 AF D1          JSR ResetMapper
   78  06:D1F3  A9 00             LDA #$00
   79  06:D1F5  20 BE D1          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:D1F8  20 AF D1          JSR ResetMapper
   83  06:D1FB  A9 00             LDA #$00
   84  06:D1FD  20 C9 D1          JSR LoadCHRBankA
   85  06:D200  A9 01             LDA #$01
   86  06:D202  20 D4 D1          JSR LoadCHRBankB
   87  06:D205  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
  103                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:D206            PopulateClues:
    2                       
    3  06:D206  A0 00       LDY #$00
    4  06:D208  B1 AD       LDA [puzzle_address], y
    5  06:D20A  AA          TAX
    6  06:D20B  BD F5 D5    LDA PuzzleSizes, x
    7  06:D20E  8D 00 00    STA temp1
    8                       
    9  06:D211            .getByte:
   10  06:D211  AC BF 00    LDY clueTableIndex
   11  06:D214  B1 AF       LDA [clues_address], y
   12  06:D216  D0 07       BNE .checkNewLine
   13  06:D218  EE BF 00    INC clueTableIndex
   14  06:D21B  A9 00       LDA #$00
   15  06:D21D  F0 39       BEQ .drawClue
   16                       ;was 0, set up a draw
   17  06:D21F            .checkNewLine
   18  06:D21F  C9 FF       CMP #$FF
   19  06:D221  D0 18       BNE .getClue
   20                       
   21                       ;;was FF- need to inc stuff
   22  06:D223  EE BF 00    INC clueTableIndex
   23  06:D226  A9 00       LDA #$00
   24  06:D228  8D C6 00    STA clueParity
   25                       
   26  06:D22B  EE C0 00    INC clueLineIndex
   27  06:D22E  AD C0 00    LDA clueLineIndex
   28  06:D231  CD 00 00    CMP temp1
   29                       ;CMP #$01
   30  06:D234  F0 28       BEQ .leave    ;carry will be set
   31                       
   32  06:D236  20 F5 D2    JSR CreateOffsetFromIndex
   33                      
   34  06:D239  D0 D6       BNE .getByte
   35                       
   36  06:D23B            .getClue:
   37                       ;;clues go from high nibble to low nibble
   38  06:D23B  48          PHA 
   39  06:D23C  AD C6 00    LDA clueParity
   40  06:D23F  D0 0A       BNE .getSecondClue
   41  06:D241  EE C6 00    INC clueParity
   42  06:D244  68          PLA
   43  06:D245  4A          LSR A
   44  06:D246  4A          LSR A
   45  06:D247  4A          LSR A
   46  06:D248  4A          LSR A         ;move clue over to lower nibble
   47  06:D249  D0 0D       BNE .drawClue
   48                       
   49  06:D24B            .getSecondClue:
   50                     
   51  06:D24B  CE C6 00    DEC clueParity
   52  06:D24E  EE BF 00    INC clueTableIndex
   53  06:D251  68          PLA 
   54  06:D252  29 0F       AND #$0F
   55  06:D254  D0 02       BNE .drawClue
   56                       ;;if 0, skip
   57  06:D256  F0 B9       BEQ .getByte
   58                      
   59  06:D258            .drawClue:
   60                       
   61  06:D258  09 40       ORA #$40
   62  06:D25A  20 5F D2    JSR WriteClueByteToPPUString
   63  06:D25D  18          CLC
   64                       
   65  06:D25E            .leave:
   66  06:D25E  60          RTS
   67                       
   68  06:D25F            WriteClueByteToPPUString:
   69                     
   70  06:D25F  8D 00 00    STA temp1 ;store off the tile value
   71                     
   72                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:D262  A9 01       LDA #$01
       06:D264  8D 23 00    STA PPU_PendingWrite
       06:D267  AD BE 00    LDA clue_draw_address+1
       06:D26A  20 C8 D0    JSR WriteToPPUString
       06:D26D  AD BD 00    LDA clue_draw_address
       06:D270  20 C8 D0    JSR WriteToPPUString
       06:D273  A9 00       LDA #DRAW_HORIZONTAL
       06:D275  20 C8 D0    JSR WriteToPPUString
       06:D278  A9 01       LDA #$01 
       06:D27A  20 C8 D0    JSR WriteToPPUString
                            
   73  06:D27D  AD 00 00    LDA temp1
   74  06:D280  20 C8 D0    JSR WriteToPPUString
   75                       
   76                       ;;also copy to ... copy
   77  06:D283  AD BD 00    LDA clue_draw_address
   78  06:D286  8D B5 00    STA copy_address
   79  06:D289  AD BE 00    LDA clue_draw_address+1
   80  06:D28C  29 0F       AND #$0F
   81  06:D28E  09 60       ORA #$60
   82  06:D290  8D B6 00    STA copy_address+1
   83  06:D293  AD 00 00    LDA temp1
   84  06:D296  A0 00       LDY #$00
   85  06:D298  91 B5       STA [copy_address],y
   86  06:D29A  AD B6 00    LDA copy_address+1
   87  06:D29D  18          CLC
   88  06:D29E  69 08       ADC #$08
   89  06:D2A0  8D B6 00    STA copy_address+1
   90  06:D2A3  AD 00 00    LDA temp1
   91  06:D2A6  91 B5       STA [copy_address],y
   92                       
   93  06:D2A8  AD C2 00    LDA clueDrawAdd
   94  06:D2AB  20 D2 D2    JSR SubFromClueDrawAddress
   95                         
   96  06:D2AE  60          RTS
   97                       
   98  06:D2AF            ResetClueDrawAddress:
   99                     
  100                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:D2AF  AD BB 00          LDA clue_start_address
       06:D2B2  8D BD 00          STA clue_draw_address
       06:D2B5  AD BC 00          LDA clue_start_address+1
       06:D2B8  8D BE 00          STA clue_draw_address+1
                          
  101                       
  102  06:D2BB  60          RTS
  103                       
  104  06:D2BC            AddToClueDrawAddress:
  105                     
  106  06:D2BC  8D 00 00    STA temp1
  107                       
  108  06:D2BF  AD BD 00    LDA clue_draw_address
  109  06:D2C2  18          CLC
  110  06:D2C3  6D 00 00    ADC temp1
  111  06:D2C6  8D BD 00    STA clue_draw_address
  112  06:D2C9  AD BE 00    LDA clue_draw_address+1
  113  06:D2CC  69 00       ADC #$00
  114  06:D2CE  8D BE 00    STA clue_draw_address+1
  115                       
  116  06:D2D1  60          RTS
  117                         
  118  06:D2D2            SubFromClueDrawAddress:
  119                     
  120  06:D2D2  8D 00 00    STA temp1
  121                       
  122  06:D2D5  AD BD 00    LDA clue_draw_address
  123  06:D2D8  38          SEC
  124  06:D2D9  ED 00 00    SBC temp1
  125  06:D2DC  8D BD 00    STA clue_draw_address
  126  06:D2DF  AD BE 00    LDA clue_draw_address+1
  127  06:D2E2  E9 00       SBC #$00
  128  06:D2E4  8D BE 00    STA clue_draw_address+1
  129                       
  130  06:D2E7  60          RTS
  131                       
  132  06:D2E8            AddToClueDrawAddressHi:
  133                     
  134  06:D2E8  8D 00 00    STA temp1
  135                       
  136  06:D2EB  AD BE 00    LDA clue_draw_address+1
  137  06:D2EE  6D 00 00    ADC temp1
  138  06:D2F1  8D BE 00    STA clue_draw_address+1
  139                       
  140  06:D2F4  60          RTS
  141                       
  142  06:D2F5            CreateOffsetFromIndex:
  143                     
  144                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  145  06:D2F5  AD C0 00    LDA clueLineIndex
  146  06:D2F8  8D C3 00    STA clueDrawOffset
  147  06:D2FB  A9 00       LDA #$00
  148  06:D2FD  8D C4 00    STA clueDrawOffset+1
  149                       
  150  06:D300  AD C1 00    LDA clueOffsetShift   
  151  06:D303  F0 0E       BEQ .addOffset
  152                       
  153  06:D305  A2 00       LDX #$00
  154                       
  155  06:D307            .loopShift:
  156  06:D307  0E C3 00    ASL clueDrawOffset
  157  06:D30A  2E C4 00    ROL clueDrawOffset+1
  158  06:D30D  E8          INX
  159  06:D30E  EC C1 00    CPX clueOffsetShift
  160  06:D311  D0 F4       BNE .loopShift
  161                       
  162  06:D313            .addOffset:
  163                       
  164  06:D313  20 AF D2    JSR ResetClueDrawAddress
  165  06:D316  AD C3 00    LDA clueDrawOffset
  166  06:D319  20 BC D2    JSR AddToClueDrawAddress 
  167  06:D31C  AD C4 00    LDA clueDrawOffset+1
  168  06:D31F  20 E8 D2    JSR AddToClueDrawAddressHi
  169                       
  170  06:D322  60          RTS  
  171                       
  172  06:D323            ClearPuzzle:
  173                     
  174                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  175                      
  176                       MACROGetLabelPointer ClearLineDefs, table_address
                          
       06:D323  A9 D5             LDA #HIGH(ClearLineDefs)
       06:D325  A2 D7             LDX #LOW(ClearLineDefs)
                                  
       06:D327  8E 16 00          STX table_address
       06:D32A  8D 17 00          STA table_address+1
                                  
  177                     
  178  06:D32D  AC C0 00    LDY clueLineIndex
  179  06:D330  B1 16       LDA [table_address], y
  180  06:D332  8D 00 00    STA temp1
  181                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:D335  A9 01       LDA #$01
       06:D337  8D 23 00    STA PPU_PendingWrite
       06:D33A  AD BE 00    LDA clue_draw_address+1
       06:D33D  20 C8 D0    JSR WriteToPPUString
       06:D340  AD BD 00    LDA clue_draw_address
       06:D343  20 C8 D0    JSR WriteToPPUString
       06:D346  A9 40       LDA #$40
       06:D348  09 00       ORA #DRAW_HORIZONTAL
       06:D34A  0D 00 00    ORA temp1
       06:D34D  20 C8 D0    JSR WriteToPPUString
       06:D350  A9 24       LDA #$24
       06:D352  20 C8 D0    JSR WriteToPPUString
                            
  182                       ;;no need to load anything else
  183                       
  184  06:D355  AD BD 00    LDA clue_draw_address
  185  06:D358  18          CLC
  186  06:D359  69 20       ADC #32
  187  06:D35B  8D BD 00    STA clue_draw_address
  188  06:D35E  AD BE 00    LDA clue_draw_address+1
  189  06:D361  69 00       ADC #$00
  190  06:D363  8D BE 00    STA clue_draw_address+1
  191                       
  192  06:D366  EE C0 00    INC clueLineIndex
  193  06:D369  60          RTS
  194                       
  195  06:D36A            LoadPauseScreen:
  196                     
  197                     ;;use clue indexes again
  198                     ;;we want to draw one line at a time
  199                     ;;we have control codes, but those don't matter since we have to build ou the strings before hand
  200                     
  201                     ;load pause table
  202                     ;there are 6 lines of 13 tiles
  203                     ;one byte for the 6 lines, one byte to keep track of our index
  204                       ;STA clueLineIndex 
  205                       ;STA clueOffsetShift
  206                     
  207                     ;;pause_address has the table we want
  208                     ;;pause_draw_address will be the draw location
  209                     
  210                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:D36A  A9 01       LDA #$01
       06:D36C  8D 23 00    STA PPU_PendingWrite
       06:D36F  AD B8 00    LDA pause_draw_address+1
       06:D372  20 C8 D0    JSR WriteToPPUString
       06:D375  AD B7 00    LDA pause_draw_address
       06:D378  20 C8 D0    JSR WriteToPPUString
       06:D37B  A9 00       LDA #DRAW_HORIZONTAL
       06:D37D  20 C8 D0    JSR WriteToPPUString
       06:D380  A9 0D       LDA #13 
       06:D382  20 C8 D0    JSR WriteToPPUString
                            
  211                     
  212  06:D385  A2 00       LDX #$00
  213  06:D387  AC C0 00    LDY clueLineIndex
  214  06:D38A            .loop:
  215                      
  216  06:D38A  8A          TXA
  217  06:D38B  48          PHA
  218  06:D38C  B1 B3       LDA [pause_address],y
  219  06:D38E  20 C8 D0    JSR WriteToPPUString
  220  06:D391  68          PLA
  221  06:D392  AA          TAX
  222  06:D393  C8          INY
  223  06:D394  E8          INX 
  224  06:D395  E0 0D       CPX #13
  225  06:D397  D0 F1       BNE .loop
  226                       
  227  06:D399  8C C0 00    STY clueLineIndex
  228                       
  229  06:D39C  AD B7 00    LDA pause_draw_address
  230  06:D39F  18          CLC
  231  06:D3A0  69 20       ADC #$20
  232  06:D3A2  8D B7 00    STA pause_draw_address
  233  06:D3A5  AD B8 00    LDA pause_draw_address+1
  234  06:D3A8  69 00       ADC #$00
  235  06:D3AA  8D B8 00    STA pause_draw_address+1
  236                       
  237  06:D3AD  EE C1 00    INC clueOffsetShift
  238  06:D3B0  60          RTS
  239                       
  240                       
  241                     
  242                     
  243  06:D3B1            ClearPauseScreen:  
  244                     
  245                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:D3B1  A9 01       LDA #$01
       06:D3B3  8D 23 00    STA PPU_PendingWrite
       06:D3B6  AD B8 00    LDA pause_draw_address+1
       06:D3B9  20 C8 D0    JSR WriteToPPUString
       06:D3BC  AD B7 00    LDA pause_draw_address
       06:D3BF  20 C8 D0    JSR WriteToPPUString
       06:D3C2  A9 00       LDA #DRAW_HORIZONTAL
       06:D3C4  20 C8 D0    JSR WriteToPPUString
       06:D3C7  A9 0D       LDA #13 
       06:D3C9  20 C8 D0    JSR WriteToPPUString
                            
  246                     
  247  06:D3CC  A2 00       LDX #$00
  248  06:D3CE  A0 00       LDY #$00
  249  06:D3D0            .loop:
  250                      
  251  06:D3D0  8A          TXA
  252  06:D3D1  48          PHA
  253  06:D3D2  B1 B3       LDA [pause_address],y
  254  06:D3D4  20 C8 D0    JSR WriteToPPUString
  255  06:D3D7  68          PLA
  256  06:D3D8  AA          TAX
  257  06:D3D9  C8          INY
  258  06:D3DA  E8          INX 
  259  06:D3DB  E0 0D       CPX #13
  260  06:D3DD  D0 F1       BNE .loop
  261                       
  262                       
  263  06:D3DF  AD B7 00    LDA pause_draw_address
  264  06:D3E2  18          CLC
  265  06:D3E3  69 20       ADC #$20
  266  06:D3E5  8D B7 00    STA pause_draw_address
  267  06:D3E8  AD B8 00    LDA pause_draw_address+1
  268  06:D3EB  69 00       ADC #$00
  269  06:D3ED  8D B8 00    STA pause_draw_address+1
  270                       
  271  06:D3F0  AD B3 00    LDA pause_address
  272  06:D3F3  18          CLC
  273  06:D3F4  69 20       ADC #$20
  274  06:D3F6  8D B3 00    STA pause_address
  275  06:D3F9  AD B4 00    LDA pause_address+1
  276  06:D3FC  69 00       ADC #$00
  277  06:D3FE  8D B4 00    STA pause_address+1
  278                       
  279  06:D401  EE C1 00    INC clueOffsetShift
  280  06:D404  60         RTS
  281  06:D405            DrawImage:
  282                     
  283                       ;;we have clueTableIndex, which should be at the image bytes now
  284                       ;;clue line index will keep track of our place in a byte
  285                        
  286  06:D405  A9 00       LDA #$00
  287  06:D407  8D 00 00    STA temp1
  288  06:D40A  8D 01 00    STA temp2
  289  06:D40D  8D 02 00    STA temp3
  290  06:D410  8D 03 00    STA temp4
  291  06:D413  8D 05 00    STA temp6
  292                       
  293  06:D416  A9 04       LDA #$04
  294  06:D418  8D 04 00    STA temp5
  295                       
  296  06:D41B  A0 00       LDY #$00
  297  06:D41D  B1 AD       LDA [puzzle_address], y
  298  06:D41F  AA          TAX
  299  06:D420  BD F5 D5    LDA PuzzleSizes, x
  300  06:D423  8D 06 00    STA temp7
  301  06:D426  BD F8 D5    LDA PuzzleImageSizes, x
  302  06:D429  8D 07 00    STA temp8
  303  06:D42C  4A          LSR A
  304  06:D42D  4A          LSR A
  305  06:D42E  8D 09 00    STA tempy
  306  06:D431  AD 07 00    LDA temp8
  307  06:D434  29 03       AND #$03
  308  06:D436  F0 03       BEQ .skipAdd1
  309  06:D438  EE 09 00    INC tempy  
  310  06:D43B            .skipAdd1:
  311  06:D43B  BD FB D5    LDA ImageDrawWrapOffsets, x
  312  06:D43E  8D 08 00    STA tempx
  313                       
  314  06:D441  AC BF 00    LDY clueTableIndex
  315  06:D444  B1 AF       LDA [clues_address], y
  316                     
  317  06:D446  0A          ASL A
  318  06:D447  2E 00 00    ROL temp1
  319  06:D44A  0A          ASL A
  320  06:D44B  2E 00 00    ROL temp1
  321  06:D44E  0A          ASL A
  322  06:D44F  2E 01 00    ROL temp2
  323  06:D452  0A          ASL A
  324  06:D453  2E 01 00    ROL temp2
  325  06:D456  0A          ASL A
  326  06:D457  2E 02 00    ROL temp3
  327  06:D45A  0A          ASL A
  328  06:D45B  2E 02 00    ROL temp3
  329  06:D45E  0A          ASL A
  330  06:D45F  2E 03 00    ROL temp4
  331  06:D462  0A          ASL A
  332  06:D463  2E 03 00    ROL temp4
  333                       
  334                     
  335  06:D466  A2 00       LDX #$00
  336  06:D468            .moveUpTiles:
  337  06:D468  BD 00 00    LDA temp1, x
  338  06:D46B  09 24       ORA #$24
  339  06:D46D  9D 00 00    STA temp1, x
  340  06:D470  E8          INX
  341  06:D471  E0 04       CPX #$04
  342  06:D473  D0 F3       BNE .moveUpTiles
  343                       
  344                       
  345  06:D475  AD C1 00    LDA clueOffsetShift
  346  06:D478  18          CLC
  347  06:D479  69 04       ADC #$04
  348                     
  349  06:D47B  8D C1 00    STA clueOffsetShift
  350                       ;;clue offset shift + 4, check if we went over puzle row length
  351  06:D47E  38          SEC
  352  06:D47F  ED 06 00    SBC temp7 ;;subtract 15
  353  06:D482  90 12       BCC .makeStrings
  354  06:D484  F0 10       BEQ .makeStrings
  355                       
  356  06:D486  8D C1 00    STA clueOffsetShift ;loop offset over
  357  06:D489  8D 05 00    STA temp6 ; length of second string
  358  06:D48C  AD 04 00    LDA temp5
  359  06:D48F  38          SEC
  360  06:D490  ED 05 00    SBC temp6 
  361  06:D493  8D 04 00    STA temp5 ;length of first string 
  362                       
  363  06:D496            .makeStrings:
  364                       
  365  06:D496  A2 00       LDX #$00
  366                       
  367  06:D498  AD 04 00    LDA temp5
  368  06:D49B  F0 51       BEQ .makeSecondString
  369  06:D49D  8A          TXA
  370  06:D49E  48          PHA
  371                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp5
                          
       06:D49F  A9 01       LDA #$01
       06:D4A1  8D 23 00    STA PPU_PendingWrite
       06:D4A4  AD BE 00    LDA clue_draw_address+1
       06:D4A7  20 C8 D0    JSR WriteToPPUString
       06:D4AA  AD BD 00    LDA clue_draw_address
       06:D4AD  20 C8 D0    JSR WriteToPPUString
       06:D4B0  A9 00       LDA #DRAW_HORIZONTAL
       06:D4B2  20 C8 D0    JSR WriteToPPUString
       06:D4B5  AD 04 00    LDA temp5 
       06:D4B8  20 C8 D0    JSR WriteToPPUString
                            
  372  06:D4BB  68          PLA
  373  06:D4BC  AA          TAX
  374                       
  375  06:D4BD            .firstStringLoop:
  376                       
  377  06:D4BD  8A          TXA 
  378  06:D4BE  48          PHA
  379  06:D4BF  BD 00 00    LDA temp1, x
  380  06:D4C2  20 C8 D0    JSR WriteToPPUString
  381                       
  382  06:D4C5  EE C0 00    INC clueLineIndex
  383  06:D4C8  AD C0 00    LDA clueLineIndex
  384  06:D4CB  CD 07 00    CMP temp8
  385  06:D4CE  D0 04       BNE .continueLoop
  386  06:D4D0  68          PLA 
  387  06:D4D1  4C 55 D5    JMP .leave
  388                       
  389  06:D4D4            .continueLoop:
  390  06:D4D4  68          PLA
  391  06:D4D5  AA          TAX
  392  06:D4D6  E8          INX
  393  06:D4D7  EC 04 00    CPX temp5
  394  06:D4DA  D0 E1       BNE .firstStringLoop
  395                       
  396  06:D4DC  AD BD 00    LDA clue_draw_address
  397  06:D4DF  18          CLC
  398  06:D4E0  6D 04 00    ADC temp5
  399  06:D4E3  8D BD 00    STA clue_draw_address
  400  06:D4E6  AD BE 00    LDA clue_draw_address+1
  401  06:D4E9  69 00       ADC #$00
  402  06:D4EB  8D BE 00    STA clue_draw_address+1
  403                       
  404  06:D4EE            .makeSecondString:
  405                     
  406  06:D4EE  AD 05 00    LDA temp6
  407  06:D4F1  F0 62       BEQ .leave
  408                       
  409                       ;;loop draw address to next line
  410  06:D4F3  AD BD 00    LDA clue_draw_address
  411  06:D4F6  18          CLC
  412  06:D4F7  6D 08 00    ADC tempx
  413  06:D4FA  8D BD 00    STA clue_draw_address
  414  06:D4FD  AD BE 00    LDA clue_draw_address+1
  415  06:D500  69 00       ADC #$00
  416  06:D502  8D BE 00    STA clue_draw_address+1
  417  06:D505  8A          TXA
  418  06:D506  48          PHA
  419                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp6
                          
       06:D507  A9 01       LDA #$01
       06:D509  8D 23 00    STA PPU_PendingWrite
       06:D50C  AD BE 00    LDA clue_draw_address+1
       06:D50F  20 C8 D0    JSR WriteToPPUString
       06:D512  AD BD 00    LDA clue_draw_address
       06:D515  20 C8 D0    JSR WriteToPPUString
       06:D518  A9 00       LDA #DRAW_HORIZONTAL
       06:D51A  20 C8 D0    JSR WriteToPPUString
       06:D51D  AD 05 00    LDA temp6 
       06:D520  20 C8 D0    JSR WriteToPPUString
                            
  420  06:D523  68          PLA 
  421  06:D524  AA          TAX
  422                       
  423  06:D525            .secondStringLoop:
  424                     
  425  06:D525  8A          TXA
  426  06:D526  48          PHA 
  427  06:D527  BD 00 00    LDA temp1, x
  428  06:D52A  20 C8 D0    JSR WriteToPPUString
  429                       
  430  06:D52D  EE C0 00    INC clueLineIndex
  431  06:D530  AD C0 00    LDA clueLineIndex
  432  06:D533  CD 07 00    CMP temp8
  433  06:D536  D0 04       BNE .continueSecondLoop
  434                       
  435  06:D538  68          PLA 
  436  06:D539  4C 55 D5    JMP .leave
  437                       
  438  06:D53C            .continueSecondLoop:
  439  06:D53C  68          PLA
  440  06:D53D  AA          TAX
  441  06:D53E  E8          INX
  442  06:D53F  E0 04       CPX #$04
  443  06:D541  D0 E2       BNE .secondStringLoop
  444                       
  445  06:D543  AD BD 00    LDA clue_draw_address
  446  06:D546  18          CLC
  447  06:D547  6D 05 00    ADC temp6
  448  06:D54A  8D BD 00    STA clue_draw_address
  449  06:D54D  AD BE 00    LDA clue_draw_address+1
  450  06:D550  69 00       ADC #$00
  451  06:D552  8D BE 00    STA clue_draw_address+1
  452                       
  453  06:D555            .leave:
  454  06:D555  EE BF 00    INC clueTableIndex
  455  06:D558  60          RTS
  456                       
  457  06:D559            DrawTitle:
  458                     
  459                       ;; title draw address is stored ahead of time, along with title address
  460                       ;; we can use temp1 - 8 to handle this
  461  06:D559  A0 00       LDY #$00
  462  06:D55B  B1 B1       LDA [title_address],y
  463  06:D55D  4A          LSR A
  464  06:D55E  8D 09 00    STA tempy
  465                       
  466  06:D561  AD B9 00    LDA title_draw_address
  467  06:D564  38          SEC 
  468  06:D565  ED 09 00    SBC tempy
  469  06:D568  8D B9 00    STA title_draw_address
  470  06:D56B  AD BA 00    LDA title_draw_address+1
  471  06:D56E  E9 00       SBC #$00
  472  06:D570  8D BA 00    STA title_draw_address+1
  473                       
  474                       MACROAddPPUStringEntryTablePtr title_draw_address+1, title_draw_address, #DRAW_HORIZONTAL, title_address
                           
       06:D573  A9 01       LDA #$01
       06:D575  8D 23 00    STA PPU_PendingWrite
       06:D578  AD BA 00    LDA title_draw_address+1
       06:D57B  20 C8 D0    JSR WriteToPPUString
       06:D57E  AD B9 00    LDA title_draw_address
       06:D581  20 C8 D0    JSR WriteToPPUString
       06:D584  A9 20       LDA #$20
       06:D586  09 00       ORA #DRAW_HORIZONTAL
       06:D588  20 C8 D0    JSR WriteToPPUString
       06:D58B  AD B1 00    LDA title_address
       06:D58E  20 C8 D0    JSR WriteToPPUString
       06:D591  AD B2 00    LDA title_address+1
       06:D594  20 C8 D0    JSR WriteToPPUString
                           
  475                       
  476  06:D597            .leave:
  477  06:D597  60          RTS
  478                       
  479  06:D598            ApplyGameTimeToPPUString:
  480                     
  481  06:D598  8D 00 00    STA temp1
  482  06:D59B  8E 01 00    STX temp2
  483                     
  484                       MACROAddPPUStringEntryRawData temp1, temp2, #DRAW_HORIZONTAL, #$05
                          
       06:D59E  A9 01       LDA #$01
       06:D5A0  8D 23 00    STA PPU_PendingWrite
       06:D5A3  AD 00 00    LDA temp1
       06:D5A6  20 C8 D0    JSR WriteToPPUString
       06:D5A9  AD 01 00    LDA temp2
       06:D5AC  20 C8 D0    JSR WriteToPPUString
       06:D5AF  A9 00       LDA #DRAW_HORIZONTAL
       06:D5B1  20 C8 D0    JSR WriteToPPUString
       06:D5B4  A9 05       LDA #$05 
       06:D5B6  20 C8 D0    JSR WriteToPPUString
                            
  485  06:D5B9  AD 06 70    LDA GameTime+3
  486  06:D5BC  20 C8 D0    JSR WriteToPPUString
  487  06:D5BF  AD 05 70    LDA GameTime+2
  488  06:D5C2  20 C8 D0    JSR WriteToPPUString
  489  06:D5C5  A9 61       LDA #$61
  490  06:D5C7  20 C8 D0    JSR WriteToPPUString
  491  06:D5CA  AD 04 70    LDA GameTime+1
  492  06:D5CD  20 C8 D0    JSR WriteToPPUString
  493  06:D5D0  AD 03 70    LDA GameTime
  494  06:D5D3  20 C8 D0    JSR WriteToPPUString
  495                       
  496  06:D5D6  60          RTS
  497                     
  498  06:D5D7            ClearLineDefs:
  499                     
  500  06:D5D7  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:D5DA  20 20 20  
       06:D5DD  20 20 20  
       06:D5E0  20 20     
  501  06:D5E2  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:D5E5  0D 0D 0D  
       06:D5E8  0D 0D 0D  
       06:D5EB  0D 0D 0D  
       06:D5EE  0D 0D 0D  
       06:D5F1  0D 0D     
  502  06:D5F3  20 20       .db $20, $20
  503                       
  504  06:D5F5            PuzzleSizes:
  505                       
  506  06:D5F5  05 0A 0F    .db $05, $0A, $0F
  507                       
  508  06:D5F8            PuzzleImageSizes:
  509                     
  510                       ;.db $05, $0A, $0F
  511  06:D5F8  19 64 E1    .db $19, $64, $E1
  512                       
  513  06:D5FB            ImageDrawWrapOffsets:
  514                     
  515  06:D5FB  1B 16 11    .db $1B, $16, $11
  516                      
  517  06:D5FE            ImageTitleLowerHalfPos:
  518                      
  519  06:D5FE  70 22       .word $2270, $2313, $23B5
       06:D600  13 23     
       06:D602  B5 23     
#[1]   Picross.asm
  104                       
  105                       
  106                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  107                     ;;     NMI                  ;;
  108                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  109                     
#[2]   Routines/Common/NMI.asm
  110                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:D604            NMI:
    3                     
    4  06:D604  48          PHA                              ;protect the registers
    5  06:D605  8A          TXA
    6  06:D606  48          PHA
    7  06:D607  98          TYA
    8  06:D608  48          PHA
    9                       
   10  06:D609            nmi_started:
   11  06:D609  A9 00       LDA #$00
   12  06:D60B  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:D60E  A9 02       LDA #$02
   14  06:D610  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:D613  AD 10 00    LDA NMI_locks
   17  06:D616  F0 03       BEQ update_controllers
   18  06:D618  4C 8A D6    JMP WakeUp
   19                     
   20  06:D61B            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:D61B  8A            TXA
    3  06:D61C  48                PHA
    4  06:D61D  98                TYA
    5  06:D61E  48                PHA
    6                     
    7  06:D61F  A2 00             LDX #$00
    8                     
    9  06:D621            GamePadCheck:
   10  06:D621  A9 01             LDA #$01        ;load 1
   11  06:D623  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:D626  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:D627  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:D62A  A9 80             LDA #$80
   18  06:D62C  8D 1A 00          STA gamepad
   19                     
   20  06:D62F            ReadControllerABytesLoop:
   21  06:D62F  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:D632  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:D634  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:D636  6E 1A 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:D639  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:D63B  AD 1B 00          LDA gamepadLast
   31  06:D63E  49 FF             EOR #$FF
   32  06:D640  2D 1A 00          AND gamepad
   33  06:D643  8D 1C 00          STA gamepadPressed
   34                             
   35                             
   36  06:D646  AD 1A 00          LDA gamepad
   37  06:D649  8D 1B 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:D64C  68                PLA
   41  06:D64D  A8                TAY
   42  06:D64E  68                PLA
   43  06:D64F  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:D650  20 05 D0    JSR ProcessPPUString
   25                       
   26                       
   27  06:D653  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:D655  8D 05 20    STA PPU_SCROLL
   29  06:D658  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:D65B  20 22 D1    JSR UpdatePPUControl
   34                     
   35  06:D65E            NMIUpdate:
   36                     
   37  06:D65E  20 7E D6    JSR StateNMIUpdate
   38                       
   39  06:D661  AD 1D 00    LDA PPU_Control
   40  06:D664  29 FC       AND #$FC
   41  06:D666  0D 21 00    ORA PPU_ScrollNT
   42  06:D669  8D 00 20    STA PPU_CTRL
   43                       
   44  06:D66C  AD 1F 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:D66F  8D 05 20    STA PPU_SCROLL
   46  06:D672  AD 20 00    LDA PPU_ScrollY
   47  06:D675  8D 05 20    STA PPU_SCROLL
   48                       
   49  06:D678  20 33 D7    jsr sound_play_frame 
   50  06:D67B  4C 8A D6    JMP WakeUp
   51                     
   52  06:D67E            StateNMIUpdate:
   53                     
   54                       MACROCallDynamicJump game_mode
                          
       06:D67E  AD 0E 00    LDA game_mode
       06:D681  20 46 CF    JSR Dynamic_Jump
                                  
   55                     
   56  06:D684            NMIJumpTable:
   57                     
   58  06:D684  95 D6       .word UpdateTitleNMI
   59  06:D686  99 D6       .word UpdateGameNMI
   60  06:D688  9A D6       .word UpdateGameOverNMI
   61                     
   62  06:D68A            WakeUp:
   63  06:D68A  A9 00       LDA #$00
   64  06:D68C  8D 0C 00    STA sleeping
   65                       
   66  06:D68F  68          PLA             ;restore the registers
   67  06:D690  A8          TAY 
   68  06:D691  68          PLA
   69  06:D692  AA          TAX
   70  06:D693  68          PLA
   71                     
   72  06:D694  40          RTI             ; return from interrupt
   73                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   74                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:D695            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:D695  20 E8 D0    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:D698  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:D699            UpdateGameNMI:
    2  06:D699  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   76                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:D69A            UpdateGameOverNMI:
    2  06:D69A  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
  111                       
  112                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  113                     ;;    AUDIO                 ;;
  114                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#[2]   External/sound_engine.asm
  115                         .include "External/sound_engine.asm"
    1           0000      SQUARE_1 = $00 ;these are channel constants
    2           0001      SQUARE_2 = $01
    3           0002      TRIANGLE = $02
    4           0003      NOISE = $03
    5                     
    6           0000      MUSIC_SQ1 = $00 ;these are stream # constants
    7           0001      MUSIC_SQ2 = $01 ;stream # is used to index into variables
    8           0002      MUSIC_TRI = $02
    9           0003      MUSIC_NOI = $03
   10           0004      SFX_1     = $04
   11           0005      SFX_2     = $05
   12                     
   13           0300          .rsset $0300 ;sound engine variables will be on the $0300 page of RAM
   14                         
   15           0300      sound_disable_flag  .rs 1   ;a flag variable that keeps track of whether the sound engine is disabled or not. 
   16           0301      sound_temp1 .rs 1           ;temporary variables
   17           0302      sound_temp2 .rs 1
   18           0303      sound_sq1_old .rs 1  ;the last value written to $4003
   19           0304      sound_sq2_old .rs 1  ;the last value written to $4007
   20           0305      soft_apu_ports .rs 16
   21                     
   22                     ;reserve 6 bytes, one for each stream
   23           0315      stream_curr_sound .rs 6     ;current song/sfx loaded
   24           031B      stream_status .rs 6         ;status byte.   bit0: (1: stream enabled; 0: stream disabled)
   25           0321      stream_channel .rs 6        ;what channel is this stream playing on?
   26           0327      stream_ptr_LO .rs 6         ;low byte of pointer to data stream
   27           032D      stream_ptr_HI .rs 6         ;high byte of pointer to data stream
   28           0333      stream_ve .rs 6             ;current volume envelope
   29           0339      stream_ve_index .rs 6       ;current position within the volume envelope
   30           033F      stream_vol_duty .rs 6       ;stream volume/duty settings
   31           0345      stream_note_LO .rs 6        ;low 8 bits of period for the current note on a stream
   32           034B      stream_note_HI .rs 6        ;high 3 bits of period for the current note on a stream 
   33           0351      stream_tempo .rs 6          ;the value to add to our ticker total each frame
   34           0357      stream_ticker_total .rs 6   ;our running ticker total.
   35           035D      stream_note_length_counter .rs 6
   36           0363      stream_note_length .rs 6
   37           0369      stream_loop1 .rs 6          ;loop counter
   38           036F      stream_note_offset .rs 6
   39                         
   40  06:D69B            sound_init:
   41  06:D69B  A9 0F         lda #$0F
   42  06:D69D  8D 15 40      sta $4015   ;enable Square 1, Square 2, Triangle and Noise channels
   43                         
   44  06:D6A0  A9 00         lda #$00
   45  06:D6A2  8D 00 03      sta sound_disable_flag  ;clear disable flag
   46                         ;later, if we have other variables we want to initialize, we will do that here.
   47  06:D6A5  A9 FF         lda #$FF
   48  06:D6A7  8D 03 03      sta sound_sq1_old   ;initializing these to $FF ensures that the first notes of the first song isn't skipped
   49  06:D6AA  8D 04 03      sta sound_sq2_old
   50  06:D6AD            se_silence:
   51  06:D6AD  A9 30         lda #$30
   52  06:D6AF  8D 05 03      sta soft_apu_ports      ;set Square 1 volume to 0
   53  06:D6B2  8D 09 03      sta soft_apu_ports+4    ;set Square 2 volume to 0
   54  06:D6B5  8D 11 03      sta soft_apu_ports+12   ;set Noise volume to 0
   55  06:D6B8  A9 80         lda #$80
   56  06:D6BA  8D 0D 03      sta soft_apu_ports+8     ;silence Triangle
   57                     
   58  06:D6BD  60            rts
   59                         
   60  06:D6BE            sound_disable:
   61  06:D6BE  A9 00         lda #$00
   62  06:D6C0  8D 15 40      sta $4015   ;disable all channels
   63  06:D6C3  A9 01         lda #$01
   64  06:D6C5  8D 00 03      sta sound_disable_flag  ;set disable flag
   65  06:D6C8  60            rts
   66                         
   67                     ;-------------------------------------
   68                     ; load_sound will prepare the sound engine to play a song or sfx.
   69                     ;   input:
   70                     ;       A: song/sfx number to play
   71  06:D6C9            sound_load:
   72  06:D6C9  8D 01 03      sta sound_temp1         ;save song number
   73  06:D6CC  0A            asl a                   ;multiply by 2.  We are indexing into a table of pointers (words)
   74  06:D6CD  A8            tay
   75  06:D6CE  B9 07 D9      lda song_headers, y     ;setup the pointer to our song header
   76  06:D6D1  8D D2 00      sta sound_ptr
   77  06:D6D4  B9 08 D9      lda song_headers+1, y
   78  06:D6D7  8D D3 00      sta sound_ptr+1
   79                         
   80  06:D6DA  A0 00         ldy #$00
   81  06:D6DC  B1 D2         lda [sound_ptr], y      ;read the first byte: # streams
   82  06:D6DE  8D 02 03      sta sound_temp2         ;store in a temp variable.  We will use this as a loop counter: how many streams to read stream headers for
   83  06:D6E1  C8            iny
   84  06:D6E2            .loop:
   85  06:D6E2  B1 D2         lda [sound_ptr], y      ;stream number
   86  06:D6E4  AA            tax                     ;stream number acts as our variable index
   87  06:D6E5  C8            iny
   88                         
   89  06:D6E6  B1 D2         lda [sound_ptr], y      ;status byte.  1= enable, 0=disable
   90  06:D6E8  9D 1B 03      sta stream_status, x
   91  06:D6EB  F0 39         beq .next_stream        ;if status byte is 0, stream disabled, so we are done
   92  06:D6ED  C8            iny
   93                         
   94  06:D6EE  B1 D2         lda [sound_ptr], y      ;channel number
   95  06:D6F0  9D 21 03      sta stream_channel, x
   96  06:D6F3  C8            iny
   97                         
   98  06:D6F4  B1 D2         lda [sound_ptr], y      ;initial duty and volume settings
   99  06:D6F6  9D 3F 03      sta stream_vol_duty, x
  100  06:D6F9  C8            iny
  101                         
  102  06:D6FA  B1 D2         lda [sound_ptr], y
  103  06:D6FC  9D 33 03      sta stream_ve, x
  104  06:D6FF  C8            iny
  105                         
  106  06:D700  B1 D2         lda [sound_ptr], y      ;pointer to stream data.  Little endian, so low byte first
  107  06:D702  9D 27 03      sta stream_ptr_LO, x
  108  06:D705  C8            iny
  109                         
  110  06:D706  B1 D2         lda [sound_ptr], y
  111  06:D708  9D 2D 03      sta stream_ptr_HI, x
  112  06:D70B  C8            iny
  113                         
  114  06:D70C  B1 D2         lda [sound_ptr], y
  115  06:D70E  9D 51 03      sta stream_tempo, x
  116                         
  117  06:D711  A9 A0         lda #$A0
  118  06:D713  9D 57 03      sta stream_ticker_total, x
  119                         
  120  06:D716  A9 01         lda #$01
  121  06:D718  9D 5D 03      sta stream_note_length_counter,x
  122                         
  123  06:D71B  A9 00         lda #$00
  124  06:D71D  9D 39 03      sta stream_ve_index, x
  125  06:D720  9D 69 03      sta stream_loop1, x
  126  06:D723  9D 6F 03      sta stream_note_offset, x
  127  06:D726            .next_stream:
  128  06:D726  C8            iny
  129                         
  130  06:D727  AD 01 03      lda sound_temp1         ;song number
  131  06:D72A  9D 15 03      sta stream_curr_sound, x
  132                         
  133  06:D72D  CE 02 03      dec sound_temp2         ;our loop counter
  134  06:D730  D0 B0         bne .loop
  135  06:D732  60            rts
  136                     
  137                     ;--------------------------
  138                     ; sound_play_frame advances the sound engine by one frame
  139  06:D733            sound_play_frame:
  140  06:D733  AD 00 03      lda sound_disable_flag
  141  06:D736  D0 31         bne .done   ;if disable flag is set, don't advance a frame
  142                     
  143  06:D738  20 AD D6      jsr se_silence  ;silence all channels.  se_set_apu will set volume later for all channels that are enabled.
  144                                         ;the purpose of this subroutine call is to silence channels that aren't used by any streams.
  145  06:D73B  A2 00         ldx #$00
  146  06:D73D            .loop:
  147  06:D73D  BD 1B 03      lda stream_status, x
  148  06:D740  29 01         and #$01    ;check whether the stream is active
  149  06:D742  F0 1D         beq .endloop  ;if the stream isn't active, skip it
  150                         
  151                         ;add the tempo to the ticker total.  If there is a FF-> 0 transition, there is a tick
  152  06:D744  BD 57 03      lda stream_ticker_total, x
  153  06:D747  18            clc
  154  06:D748  7D 51 03      adc stream_tempo, x
  155  06:D74B  9D 57 03      sta stream_ticker_total, x
  156  06:D74E  90 0E         bcc .set_buffer    ;carry clear = no tick.  if no tick, we are done with this stream
  157                         
  158  06:D750  DE 5D 03      dec stream_note_length_counter, x   ;else there is a tick. decrement the note length counter
  159  06:D753  D0 09         bne .set_buffer    ;if counter is non-zero, our note isn't finished playing yet
  160  06:D755  BD 63 03      lda stream_note_length, x   ;else our note is finished. reload the note length counter
  161  06:D758  9D 5D 03      sta stream_note_length_counter, x
  162                         
  163  06:D75B  20 6A D7      jsr se_fetch_byte   ;read the next byte from the data stream
  164                         
  165  06:D75E            .set_buffer:
  166  06:D75E  20 2B D8      jsr se_set_temp_ports   ;copy the current stream's sound data for the current frame into our temporary APU vars (soft_apu_ports)
  167  06:D761            .endloop:
  168  06:D761  E8            inx
  169  06:D762  E0 06         cpx #$06
  170  06:D764  D0 D7         bne .loop
  171  06:D766  20 A2 D8      jsr se_set_apu      ;copy the temporary APU variables (soft_apu_ports) to the real APU ports ($4000, $4001, etc)
  172  06:D769            .done:
  173  06:D769  60            rts
  174                     
  175                     ;--------------------------
  176                     ; se_fetch_byte reads one byte from a sound data stream and handles it
  177                     ;   input: 
  178                     ;       X: stream number    
  179  06:D76A            se_fetch_byte:
  180  06:D76A  BD 27 03      lda stream_ptr_LO, x
  181  06:D76D  8D D2 00      sta sound_ptr
  182  06:D770  BD 2D 03      lda stream_ptr_HI, x
  183  06:D773  8D D3 00      sta sound_ptr+1
  184                         
  185  06:D776  A0 00         ldy #$00
  186  06:D778            .fetch:
  187  06:D778  B1 D2         lda [sound_ptr], y
  188  06:D77A  10 26         bpl .note                ;if < #$80, it's a Note
  189  06:D77C  C9 A0         cmp #$A0
  190  06:D77E  90 0C         bcc .note_length         ;else if < #$A0, it's a Note Length
  191  06:D780            .opcode:                     ;else it's an opcode
  192                         ;do Opcode stuff
  193  06:D780  20 10 D8      jsr se_opcode_launcher
  194  06:D783  C8            iny                      ;next position in the data stream
  195  06:D784  BD 1B 03      lda stream_status, x
  196  06:D787  29 01         and #%00000001
  197  06:D789  D0 ED         bne .fetch               ;after our opcode is done, grab another byte unless the stream is disabled
  198  06:D78B  60            rts                      ; in which case we quit  (explained below)
  199  06:D78C            .note_length:
  200                         ;do note length stuff
  201  06:D78C  29 7F         and #%01111111          ;chop off bit7
  202  06:D78E  8C 01 03      sty sound_temp1         ;save Y because we are about to destroy it
  203  06:D791  A8            tay
  204  06:D792  B9 6D DA      lda note_length_table, y    ;get the note length count value
  205  06:D795  9D 63 03      sta stream_note_length, x
  206  06:D798  9D 5D 03      sta stream_note_length_counter, x   ;stick it in our note length counter
  207  06:D79B  AC 01 03      ldy sound_temp1         ;restore Y
  208  06:D79E  C8            iny                     ;set index to next byte in the stream
  209  06:D79F  4C 78 D7      jmp .fetch              ;fetch another byte
  210  06:D7A2            .note:
  211                         ;do Note stuff
  212  06:D7A2  8D 02 03      sta sound_temp2
  213  06:D7A5  BD 21 03      lda stream_channel, x
  214  06:D7A8  C9 03         cmp #NOISE
  215  06:D7AA  D0 06         bne .not_noise
  216  06:D7AC  20 E4 D7      jsr se_do_noise
  217  06:D7AF  4C D0 D7      jmp .reset_ve
  218  06:D7B2            .not_noise:
  219  06:D7B2  AD 02 03      lda sound_temp2
  220  06:D7B5  8C 01 03      sty sound_temp1     ;save our index into the data stream
  221  06:D7B8  18            clc
  222  06:D7B9  7D 6F 03      adc stream_note_offset, x   ;add note offset
  223  06:D7BC  0A            asl a
  224  06:D7BD  A8            tay
  225  06:D7BE  B9 AF D9      lda note_table, y
  226  06:D7C1  9D 45 03      sta stream_note_LO, x
  227  06:D7C4  B9 B0 D9      lda note_table+1, y
  228  06:D7C7  9D 4B 03      sta stream_note_HI, x
  229  06:D7CA  AC 01 03      ldy sound_temp1     ;restore data stream index
  230                         
  231                         ;check if it's a rest and modify the status flag appropriately
  232  06:D7CD  20 FA D7      jsr se_check_rest
  233  06:D7D0            .reset_ve:    
  234  06:D7D0  A9 00         lda #$00
  235  06:D7D2  9D 39 03      sta stream_ve_index, x  
  236  06:D7D5            .update_pointer:
  237  06:D7D5  C8            iny
  238  06:D7D6  98            tya
  239  06:D7D7  18            clc
  240  06:D7D8  7D 27 03      adc stream_ptr_LO, x
  241  06:D7DB  9D 27 03      sta stream_ptr_LO, x
  242  06:D7DE  90 03         bcc .end
  243  06:D7E0  FE 2D 03      inc stream_ptr_HI, x
  244  06:D7E3            .end:
  245  06:D7E3  60            rts
  246                     
  247  06:D7E4            se_do_noise:
  248  06:D7E4  AD 02 03      lda sound_temp2
  249  06:D7E7  29 10         and #%00010000
  250  06:D7E9  F0 08         beq .mode0
  251  06:D7EB  AD 02 03      lda sound_temp2
  252  06:D7EE  09 80         ora #%10000000      ;set bit 7 to set mode1
  253  06:D7F0  8D 02 03      sta sound_temp2
  254  06:D7F3            .mode0:
  255  06:D7F3  AD 02 03      lda sound_temp2
  256  06:D7F6  9D 45 03      sta stream_note_LO, x
  257  06:D7F9  60            rts
  258                     ;--------------------------------------------------
  259                     ; se_check_rest will read a byte from the data stream and
  260                     ;       determine if it is a rest or not.  It will set or clear the current
  261                     ;       stream's rest flag accordingly.
  262                     ;       input:
  263                     ;           X: stream number
  264                     ;           Y: data stream index
  265  06:D7FA            se_check_rest:
  266  06:D7FA  B1 D2         lda [sound_ptr], y  ;read the note byte again
  267  06:D7FC  C9 5E         cmp #rest
  268  06:D7FE  D0 07         bne .not_rest
  269  06:D800  BD 1B 03      lda stream_status, x
  270  06:D803  09 02         ora #%00000010  ;set the rest bit in the status byte
  271  06:D805  D0 05         bne .store  ;this will always branch.  bne is cheaper than a jmp.
  272  06:D807            .not_rest:
  273  06:D807  BD 1B 03      lda stream_status, x
  274  06:D80A  29 FD         and #%11111101  ;clear the rest bit in the status byte
  275  06:D80C            .store:
  276  06:D80C  9D 1B 03      sta stream_status, x
  277  06:D80F  60            rts
  278                         
  279                     ;-----------------------------------------
  280                     ; se_opcode_launcher will read an address from the opcode jump table and indirect jump there.
  281                     ;    input: A: opcode byte
  282                     ;               Y: data stream position
  283                     ;               X: stream number
  284  06:D810            se_opcode_launcher:
  285  06:D810  8C 01 03      sty sound_temp1         ;save y register, because we are about to destroy it
  286  06:D813  38            sec
  287  06:D814  E9 A0         sbc #$A0                ;turn our opcode byte into a table index by subtracting $A0
  288  06:D816  0A            asl a                   ;multiply by 2 because we index into a table of addresses (words)
  289  06:D817  A8            tay
  290  06:D818  B9 19 D9      lda sound_opcodes, y    ;get low byte of subroutine address
  291  06:D81B  8D D4 00      sta sound_ptr2
  292  06:D81E  B9 1A D9      lda sound_opcodes+1, y  ;get high byte
  293  06:D821  8D D5 00      sta sound_ptr2+1
  294  06:D824  AC 01 03      ldy sound_temp1         ;restore our y register
  295  06:D827  C8            iny                     ;set to next position in data stream (assume an argument)
  296  06:D828  6C D4 00      jmp [sound_ptr2]           ;indirect jump to our opcode subroutine    
  297                         
  298                     ;----------------------------------------------------
  299                     ; se_set_temp_ports will copy a stream's sound data to the temporary apu variables
  300                     ;      input:
  301                     ;           X: stream number
  302  06:D82B            se_set_temp_ports:
  303  06:D82B  BD 21 03      lda stream_channel, x
  304  06:D82E  0A            asl a
  305  06:D82F  0A            asl a
  306  06:D830  A8            tay
  307                         
  308  06:D831  20 46 D8      jsr se_set_stream_volume
  309                         
  310  06:D834  A9 08         lda #$08
  311  06:D836  99 06 03      sta soft_apu_ports+1, y     ;sweep
  312                         
  313  06:D839  BD 45 03      lda stream_note_LO, x
  314  06:D83C  99 07 03      sta soft_apu_ports+2, y     ;period LO
  315                         
  316  06:D83F  BD 4B 03      lda stream_note_HI, x
  317  06:D842  99 08 03      sta soft_apu_ports+3, y     ;period HI
  318                     
  319  06:D845  60            rts    
  320                     
  321                     ;----------------------------------
  322                     ;    
  323  06:D846            se_set_stream_volume:
  324  06:D846  8C 01 03      sty sound_temp1             ;save our index into soft_apu_ports (we are about to destroy y)
  325                         
  326  06:D849  BD 33 03      lda stream_ve, x            ;which volume envelope?
  327  06:D84C  0A            asl a                       ;multiply by 2 because we are indexing into a table of addresses (words)
  328  06:D84D  A8            tay
  329  06:D84E  B9 7B DA      lda volume_envelopes, y     ;get the low byte of the address from the pointer table
  330  06:D851  8D D2 00      sta sound_ptr               ;put it into our pointer variable
  331  06:D854  B9 7C DA      lda volume_envelopes+1, y   ;get the high byte of the address
  332  06:D857  8D D3 00      sta sound_ptr+1
  333                         
  334  06:D85A            .read_ve:
  335  06:D85A  BC 39 03      ldy stream_ve_index, x      ;our current position within the volume envelope.
  336  06:D85D  B1 D2         lda [sound_ptr], y          ;grab the value.
  337  06:D85F  C9 FF         cmp #$FF
  338  06:D861  D0 06         bne .set_vol                ;if not FF, set the volume
  339  06:D863  DE 39 03      dec stream_ve_index, x      ;else if FF, go back one and read again
  340  06:D866  4C 5A D8      jmp .read_ve                ;  FF essentially tells us to repeat the last
  341                                                     ;  volume value for the remainder of the note
  342  06:D869            .set_vol:
  343  06:D869  8D 02 03      sta sound_temp2             ;save our new volume value (about to destroy A)
  344                         
  345  06:D86C  E0 02         cpx #TRIANGLE               
  346  06:D86E  D0 09         bne .squares                ;if not triangle channel, go ahead
  347  06:D870  AD 02 03      lda sound_temp2
  348  06:D873  D0 04         bne .squares                ;else if volume not zero, go ahead (treat same as squares)
  349  06:D875  A9 80         lda #$80
  350  06:D877  30 08         bmi .store_vol              ;else silence the channel with #$80
  351  06:D879            .squares:
  352  06:D879  BD 3F 03      lda stream_vol_duty, x      ;get current vol/duty settings
  353  06:D87C  29 F0         and #$F0                    ;zero out the old volume
  354  06:D87E  0D 02 03      ora sound_temp2             ;OR our new volume in.
  355                     
  356  06:D881            .store_vol:
  357  06:D881  AC 01 03      ldy sound_temp1             ;get our index into soft_apu_ports
  358  06:D884  99 05 03      sta soft_apu_ports, y       ;store the volume in our temp port
  359  06:D887  FE 39 03      inc stream_ve_index, x      ;set our volume envelop index to the next position
  360                     
  361  06:D88A            .rest_check:
  362                         ;check the rest flag. if set, overwrite volume with silence value 
  363  06:D88A  BD 1B 03      lda stream_status, x
  364  06:D88D  29 02         and #%00000010
  365  06:D88F  F0 10         beq .done                   ;if clear, no rest, so quit
  366  06:D891  BD 21 03      lda stream_channel, x
  367  06:D894  C9 02         cmp #TRIANGLE               ;if triangle, silence with #$80
  368  06:D896  F0 04         beq .tri                    ;else, silence with #$30
  369  06:D898  A9 30         lda #$30        
  370  06:D89A  D0 02         bne .store                  ;this always branches.  bne is cheaper than a jmp
  371  06:D89C            .tri:
  372  06:D89C  A9 80         lda #$80
  373  06:D89E            .store:    
  374  06:D89E  99 05 03      sta soft_apu_ports, y
  375  06:D8A1            .done:
  376  06:D8A1  60            rts   
  377                         
  378                     ;--------------------------
  379                     ; se_set_apu copies the temporary RAM ports to the APU ports
  380  06:D8A2            se_set_apu:
  381  06:D8A2            .square1:
  382  06:D8A2  AD 05 03      lda soft_apu_ports+0
  383  06:D8A5  8D 00 40      sta $4000
  384  06:D8A8  AD 06 03      lda soft_apu_ports+1
  385  06:D8AB  8D 01 40      sta $4001
  386  06:D8AE  AD 07 03      lda soft_apu_ports+2
  387  06:D8B1  8D 02 40      sta $4002
  388  06:D8B4  AD 08 03      lda soft_apu_ports+3
  389  06:D8B7  CD 03 03      cmp sound_sq1_old       ;compare to last write
  390  06:D8BA  F0 06         beq .square2            ;don't write this frame if they were equal
  391  06:D8BC  8D 03 40      sta $4003
  392  06:D8BF  8D 03 03      sta sound_sq1_old       ;save the value we just wrote to $4003
  393  06:D8C2            .square2:
  394  06:D8C2  AD 09 03      lda soft_apu_ports+4
  395  06:D8C5  8D 04 40      sta $4004
  396  06:D8C8  AD 0A 03      lda soft_apu_ports+5
  397  06:D8CB  8D 05 40      sta $4005
  398  06:D8CE  AD 0B 03      lda soft_apu_ports+6
  399  06:D8D1  8D 06 40      sta $4006
  400  06:D8D4  AD 0C 03      lda soft_apu_ports+7
  401  06:D8D7  CD 04 03      cmp sound_sq2_old
  402  06:D8DA  F0 06         beq .triangle
  403  06:D8DC  8D 07 40      sta $4007
  404  06:D8DF  8D 04 03      sta sound_sq2_old       ;save the value we just wrote to $4007
  405  06:D8E2            .triangle:
  406  06:D8E2  AD 0D 03      lda soft_apu_ports+8
  407  06:D8E5  8D 08 40      sta $4008
  408  06:D8E8  AD 0F 03      lda soft_apu_ports+10   ;there is no $4009, so we skip it
  409  06:D8EB  8D 0A 40      sta $400A
  410  06:D8EE  AD 10 03      lda soft_apu_ports+11
  411  06:D8F1  8D 0B 40      sta $400B
  412  06:D8F4            .noise:
  413  06:D8F4  AD 11 03      lda soft_apu_ports+12
  414  06:D8F7  8D 0C 40      sta $400C
  415  06:D8FA  AD 13 03      lda soft_apu_ports+14   ;there is no $400D, so we skip it
  416  06:D8FD  8D 0E 40      sta $400E
  417  06:D900  AD 14 03      lda soft_apu_ports+15
  418  06:D903  8D 0F 40      sta $400F
  419  06:D906  60            rts
  420                         
  421                         
  422           0009      NUM_SONGS = $09 ;if you add a new song, change this number.    
  423                                     ;the main asm file checks this number in its song_up and song_down subroutines
  424                                     ;to determine when to wrap around.
  425                     
  426                     ;this is our pointer table.  Each entry is a pointer to a song header                
  427  06:D907            song_headers:
  428  06:D907  F8 DA         .word song0_header  ;this is a silence song.  See song0.i for more details
  429  06:D909  05 DB         .word song1_header  ;The Guardian Legend Boss song
  430  06:D90B  57 DC         .word song2_header  ;a sound effect.  Try playing it over the other songs.
  431  06:D90D  64 DC         .word song3_header  ;Dragon Warrior overland song
  432  06:D90F  E3 DC         .word song4_header  ;a new song taking advantage of note lengths and rests
  433  06:D911  9C DD         .word song5_header  ;another sound effect played at a very fast tempo.
  434  06:D913  B1 DD         .word song6_header
  435  06:D915  AC DE         .word song7_header
  436  06:D917  C1 DE         .word song8_header
  437                         
#[3]   External/sound_opcodes.asm
  438                         .include "External/sound_opcodes.asm"    ;our opcode subroutines, jump table and aliases
    1                     ;these are aliases to use in the sound data.
    2           00A0      endsound = $A0
    3           00A1      loop = $A1
    4           00A2      volume_envelope = $A2
    5           00A3      duty = $A3
    6           00A4      set_loop1_counter = $A4
    7           00A5      loop1 = $A5
    8           00A6      set_note_offset = $A6
    9           00A7      adjust_note_offset = $A7
   10           00A8      transpose = $A8
   11                     
   12                     ;-----------------------------------------------------------------------
   13                     ;this is our JUMP TABLE!
   14  06:D919            sound_opcodes:
   15  06:D919  2B D9         .word se_op_endsound            ;$A0
   16  06:D91B  44 D9         .word se_op_infinite_loop       ;$A1
   17  06:D91D  5B D9         .word se_op_change_ve           ;$A2
   18  06:D91F  66 D9         .word se_op_duty                ;$A3
   19  06:D921  6C D9         .word se_op_set_loop1_counter   ;$A4
   20  06:D923  72 D9         .word se_op_loop1               ;$A5
   21  06:D925  7F D9         .word se_op_set_note_offset     ;$A6
   22  06:D927  85 D9         .word se_op_adjust_note_offset  ;$A7
   23  06:D929  8F D9         .word se_op_transpose           ;$A8
   24                         ;etc, 1 entry per subroutine
   25                     
   26                         
   27                     ;-----------------------------------------------------------------
   28                     ; these are the actual opcode subroutines
   29  06:D92B            se_op_endsound:
   30  06:D92B  BD 1B 03      lda stream_status, x    ;end of stream, so disable it and silence
   31  06:D92E  29 FE         and #%11111110
   32  06:D930  9D 1B 03      sta stream_status, x    ;clear enable flag in status byte
   33                         
   34  06:D933  BD 21 03      lda stream_channel, x
   35  06:D936  C9 02         cmp #TRIANGLE
   36  06:D938  F0 04         beq .silence_tri        ;triangle is silenced differently from squares and noise
   37  06:D93A  A9 30         lda #$30                ;squares and noise silenced with #$30
   38  06:D93C  D0 02         bne .silence            ; (this will always branch.  bne is cheaper than a jmp)
   39  06:D93E            .silence_tri:
   40  06:D93E  A9 80         lda #$80                ;triangle silenced with #$80
   41  06:D940            .silence:
   42  06:D940  9D 3F 03      sta stream_vol_duty, x  ;store silence value in the stream's volume variable.
   43                     
   44  06:D943  60            rts
   45                         
   46  06:D944            se_op_infinite_loop:
   47  06:D944  B1 D2         lda [sound_ptr], y      ;read ptr LO from the data stream
   48  06:D946  9D 27 03      sta stream_ptr_LO, x    ;update our data stream position
   49  06:D949  C8            iny
   50  06:D94A  B1 D2         lda [sound_ptr], y      ;read ptr HI from the data stream
   51  06:D94C  9D 2D 03      sta stream_ptr_HI, x    ;update our data stream position
   52                         
   53  06:D94F  8D D3 00      sta sound_ptr+1         ;update the pointer to reflect the new position.
   54  06:D952  BD 27 03      lda stream_ptr_LO, x
   55  06:D955  8D D2 00      sta sound_ptr
   56  06:D958  A0 FF         ldy #$FF                ;after opcodes return, we do an iny.  Since we reset  
   57                                                 ;the stream buffer position, we will want y to start out at 0 again.
   58  06:D95A  60            rts
   59                         
   60  06:D95B            se_op_change_ve:
   61  06:D95B  B1 D2         lda [sound_ptr], y      ;read the argument
   62  06:D95D  9D 33 03      sta stream_ve, x        ;store it in our volume envelope variable
   63  06:D960  A9 00         lda #$00
   64  06:D962  9D 39 03      sta stream_ve_index, x  ;reset volume envelope index to the beginning
   65  06:D965  60            rts
   66                         
   67  06:D966            se_op_duty:
   68  06:D966  B1 D2         lda [sound_ptr], y
   69  06:D968  9D 3F 03      sta stream_vol_duty, x
   70  06:D96B  60            rts
   71                         
   72  06:D96C            se_op_set_loop1_counter:
   73  06:D96C  B1 D2         lda [sound_ptr], y      ;read the argument (# times to loop)
   74  06:D96E  9D 69 03      sta stream_loop1, x     ;store it in the loop counter variable
   75  06:D971  60            rts
   76                         
   77  06:D972            se_op_loop1:
   78  06:D972  DE 69 03      dec stream_loop1, x     ;decrement the counter
   79  06:D975  BD 69 03      lda stream_loop1, x
   80  06:D978  F0 03         beq .last_iteration     ;if zero, we are done looping
   81  06:D97A  4C 44 D9      jmp se_op_infinite_loop ;if not zero, jump back
   82  06:D97D            .last_iteration:
   83  06:D97D  C8            iny                     ;skip the first byte of the address argument
   84                                                 ; the second byte will be skipped automatically upon return
   85                                                 ; (see se_fetch_byte after "jsr se_opcode_launcher")
   86  06:D97E  60            rts
   87                         
   88  06:D97F            se_op_set_note_offset:
   89  06:D97F  B1 D2         lda [sound_ptr], y          ;read the argument
   90  06:D981  9D 6F 03      sta stream_note_offset, x      ;set the note offset.
   91  06:D984  60            rts
   92                         
   93  06:D985            se_op_adjust_note_offset:
   94  06:D985  B1 D2         lda [sound_ptr], y          ;read the argument (what value to add)
   95  06:D987  18            clc
   96  06:D988  7D 6F 03      adc stream_note_offset, x   ;add it to the current offset
   97  06:D98B  9D 6F 03      sta stream_note_offset, x   ;and save.
   98  06:D98E  60            rts
   99                         
  100  06:D98F            se_op_transpose:
  101  06:D98F  B1 D2         lda [sound_ptr], y          ;read low byte of the pointer to our lookup table
  102  06:D991  8D D4 00      sta sound_ptr2              ;store it in a new pointer variable
  103  06:D994  C8            iny
  104  06:D995  B1 D2         lda [sound_ptr], y          ;read high byte of pointer to table
  105  06:D997  8D D5 00      sta sound_ptr2+1
  106                         
  107  06:D99A  8C 01 03      sty sound_temp1             ;save y because we are about to destroy it
  108  06:D99D  BD 69 03      lda stream_loop1, x         ;get loop counter, put it in Y
  109  06:D9A0  A8            tay                         ;   this will be our index into the lookup table
  110  06:D9A1  88            dey                         ;subtract 1 because indexes start from 0.
  111                         
  112  06:D9A2  B1 D4         lda [sound_ptr2], y         ;read a value from the table.
  113  06:D9A4  18            clc
  114  06:D9A5  7D 6F 03      adc stream_note_offset, x   ;add it to the note offset
  115  06:D9A8  9D 6F 03      sta stream_note_offset, x
  116                         
  117  06:D9AB  AC 01 03      ldy sound_temp1             ;restore Y
  118  06:D9AE  60            rts
#[2]   External/sound_engine.asm
#[3]   External/note_table.i
  439                         .include "External/note_table.i" ;period lookup table for notes
    1                     ;NTSC Period Lookup Table.  Thanks Celius!
    2                     ;http://www.freewebs.com/the_bott/NotesTableNTSC.txt
    3  06:D9AF            note_table:
    4  06:D9AF  F1 07         .word                                                                $07F1, $0780, $0713 ; A1-B1 ($00-$02)
       06:D9B1  80 07     
       06:D9B3  13 07     
    5  06:D9B5  AD 06         .word $06AD, $064D, $05F3, $059D, $054D, $0500, $04B8, $0475, $0435, $03F8, $03BF, $0389 ; C2-B2 ($03-$0E)
       06:D9B7  4D 06     
       06:D9B9  F3 05     
       06:D9BB  9D 05     
       06:D9BD  4D 05     
       06:D9BF  00 05     
       06:D9C1  B8 04     
       06:D9C3  75 04     
       06:D9C5  35 04     
       06:D9C7  F8 03     
       06:D9C9  BF 03     
       06:D9CB  89 03     
    6  06:D9CD  56 03         .word $0356, $0326, $02F9, $02CE, $02A6, $027F, $025C, $023A, $021A, $01FB, $01DF, $01C4 ; C3-B3 ($0F-$1A)
       06:D9CF  26 03     
       06:D9D1  F9 02     
       06:D9D3  CE 02     
       06:D9D5  A6 02     
       06:D9D7  7F 02     
       06:D9D9  5C 02     
       06:D9DB  3A 02     
       06:D9DD  1A 02     
       06:D9DF  FB 01     
       06:D9E1  DF 01     
       06:D9E3  C4 01     
    7  06:D9E5  AB 01         .word $01AB, $0193, $017C, $0167, $0151, $013F, $012D, $011C, $010C, $00FD, $00EF, $00E2 ; C4-B4 ($1B-$26)
       06:D9E7  93 01     
       06:D9E9  7C 01     
       06:D9EB  67 01     
       06:D9ED  51 01     
       06:D9EF  3F 01     
       06:D9F1  2D 01     
       06:D9F3  1C 01     
       06:D9F5  0C 01     
       06:D9F7  FD 00     
       06:D9F9  EF 00     
       06:D9FB  E2 00     
    8  06:D9FD  D2 00         .word $00D2, $00C9, $00BD, $00B3, $00A9, $009F, $0096, $008E, $0086, $007E, $0077, $0070 ; C5-B5 ($27-$32)
       06:D9FF  C9 00     
       06:DA01  BD 00     
       06:DA03  B3 00     
       06:DA05  A9 00     
       06:DA07  9F 00     
       06:DA09  96 00     
       06:DA0B  8E 00     
       06:DA0D  86 00     
       06:DA0F  7E 00     
       06:DA11  77 00     
       06:DA13  70 00     
    9  06:DA15  6A 00         .word $006A, $0064, $005E, $0059, $0054, $004F, $004B, $0046, $0042, $003F, $003B, $0038 ; C6-B6 ($33-$3E)
       06:DA17  64 00     
       06:DA19  5E 00     
       06:DA1B  59 00     
       06:DA1D  54 00     
       06:DA1F  4F 00     
       06:DA21  4B 00     
       06:DA23  46 00     
       06:DA25  42 00     
       06:DA27  3F 00     
       06:DA29  3B 00     
       06:DA2B  38 00     
   10  06:DA2D  34 00         .word $0034, $0031, $002F, $002C, $0029, $0027, $0025, $0023, $0021, $001F, $001D, $001B ; C7-B7 ($3F-$4A)
       06:DA2F  31 00     
       06:DA31  2F 00     
       06:DA33  2C 00     
       06:DA35  29 00     
       06:DA37  27 00     
       06:DA39  25 00     
       06:DA3B  23 00     
       06:DA3D  21 00     
       06:DA3F  1F 00     
       06:DA41  1D 00     
       06:DA43  1B 00     
   11  06:DA45  1A 00         .word $001A, $0018, $0017, $0015, $0014, $0013, $0012, $0011, $0010, $000F, $000E, $000D ; C8-B8 ($4B-$56)
       06:DA47  18 00     
       06:DA49  17 00     
       06:DA4B  15 00     
       06:DA4D  14 00     
       06:DA4F  13 00     
       06:DA51  12 00     
       06:DA53  11 00     
       06:DA55  10 00     
       06:DA57  0F 00     
       06:DA59  0E 00     
       06:DA5B  0D 00     
   12  06:DA5D  0C 00         .word $000C, $000C, $000B, $000A, $000A, $0009, $0008                                    ; C9-F#9 ($57-$5D)
       06:DA5F  0C 00     
       06:DA61  0B 00     
       06:DA63  0A 00     
       06:DA65  0A 00     
       06:DA67  09 00     
       06:DA69  08 00     
   13  06:DA6B  00 00         .word $0000 ;rest
   14                     
   15                     ;Note: octaves in music traditionally start at C, not A    
   16           0000      A1 = $00    ;the "1" means Octave 1
   17           0001      As1 = $01   ;the "s" means "sharp"
   18           0001      Bb1 = $01   ;the "b" means "flat"  A# == Bb, so same value
   19           0002      B1 = $02
   20                     
   21           0003      C2 = $03
   22           0004      Cs2 = $04
   23           0004      Db2 = $04
   24           0005      D2 = $05
   25           0006      Ds2 = $06
   26           0006      Eb2 = $06
   27           0007      E2 = $07
   28           0008      F2 = $08
   29           0009      Fs2 = $09
   30           0009      Gb2 = $09
   31           000A      G2 = $0A
   32           000B      Gs2 = $0B
   33           000B      Ab2 = $0B
   34           000C      A2 = $0C
   35           000D      As2 = $0D
   36           000D      Bb2 = $0D
   37           000E      B2 = $0E
   38                     
   39           000F      C3 = $0F
   40           0010      Cs3 = $10
   41           0010      Db3 = $10
   42           0011      D3 = $11
   43           0012      Ds3 = $12
   44           0012      Eb3 = $12
   45           0013      E3 = $13
   46           0014      F3 = $14
   47           0015      Fs3 = $15
   48           0015      Gb3 = $15
   49           0016      G3 = $16
   50           0017      Gs3 = $17
   51           0017      Ab3 = $17
   52           0018      A3 = $18
   53           0019      As3 = $19
   54           0019      Bb3 = $19
   55           001A      B3 = $1a
   56                     
   57           001B      C4 = $1b
   58           001C      Cs4 = $1c
   59           001C      Db4 = $1c
   60           001D      D4 = $1d
   61           001E      Ds4 = $1e
   62           001E      Eb4 = $1e
   63           001F      E4 = $1f
   64           0020      F4 = $20
   65           0021      Fs4 = $21
   66           0021      Gb4 = $21
   67           0022      G4 = $22
   68           0023      Gs4 = $23
   69           0023      Ab4 = $23
   70           0024      A4 = $24
   71           0025      As4 = $25
   72           0025      Bb4 = $25
   73           0026      B4 = $26
   74                     
   75           0027      C5 = $27
   76           0028      Cs5 = $28
   77           0028      Db5 = $28
   78           0029      D5 = $29
   79           002A      Ds5 = $2a
   80           002A      Eb5 = $2a
   81           002B      E5 = $2b
   82           002C      F5 = $2c
   83           002D      Fs5 = $2d
   84           002D      Gb5 = $2d
   85           002E      G5 = $2e
   86           002F      Gs5 = $2f
   87           002F      Ab5 = $2f
   88           0030      A5 = $30
   89           0031      As5 = $31
   90           0031      Bb5 = $31
   91           0032      B5 = $32
   92                     
   93           0033      C6 = $33
   94           0034      Cs6 = $34
   95           0034      Db6 = $34
   96           0035      D6 = $35
   97           0036      Ds6 = $36
   98           0036      Eb6 = $36
   99           0037      E6 = $37
  100           0038      F6 = $38
  101           0039      Fs6 = $39
  102           0039      Gb6 = $39
  103           003A      G6 = $3a
  104           003B      Gs6 = $3b
  105           003B      Ab6 = $3b
  106           003C      A6 = $3c
  107           003D      As6 = $3d
  108           003D      Bb6 = $3d
  109           003E      B6 = $3e
  110                     
  111           003F      C7 = $3f
  112           0040      Cs7 = $40
  113           0040      Db7 = $40
  114           0041      D7 = $41
  115           0042      Ds7 = $42
  116           0042      Eb7 = $42
  117           0043      E7 = $43
  118           0044      F7 = $44
  119           0045      Fs7 = $45
  120           0045      Gb7 = $45
  121           0046      G7 = $46
  122           0047      Gs7 = $47
  123           0047      Ab7 = $47
  124           0048      A7 = $48
  125           0049      As7 = $49
  126           0049      Bb7 = $49
  127           004A      B7 = $4a
  128                     
  129           004B      C8 = $4b
  130           004C      Cs8 = $4c
  131           004C      Db8 = $4c
  132           004D      D8 = $4d
  133           004E      Ds8 = $4e
  134           004E      Eb8 = $4e
  135           004F      E8 = $4f
  136           0050      F8 = $50
  137           0051      Fs8 = $51
  138           0051      Gb8 = $51
  139           0052      G8 = $52
  140           0053      Gs8 = $53
  141           0053      Ab8 = $53
  142           0054      A8 = $54
  143           0055      As8 = $55
  144           0055      Bb8 = $55
  145           0056      B8 = $56
  146                     
  147           0057      C9 = $57
  148           0058      Cs9 = $58
  149           0058      Db9 = $58
  150           0059      D9 = $59
  151           005A      Ds9 = $5a
  152           005A      Eb9 = $5a
  153           005B      E9 = $5b
  154           005C      F9 = $5c
  155           005D      Fs9 = $5d
  156           005D      Gb9 = $5d
  157                     
  158           005E      rest = $5e
#[2]   External/sound_engine.asm
#[3]   External/note_length_table.i
  440                         .include "External/note_length_table.i"
    1                     ;note length constants (aliases)
    2           0080      thirtysecond = $80
    3           0081      sixteenth = $81
    4           0082      eighth = $82
    5           0083      quarter = $83
    6           0084      half = $84
    7           0085      whole = $85
    8           0086      d_sixteenth = $86
    9           0087      d_eighth = $87
   10           0088      d_quarter = $88
   11           0089      d_half = $89
   12           008A      d_whole = $8A   ;don't forget we are counting in hex
   13           008B      t_quarter = $8B
   14           008C      five_eighths =$8C
   15           008D      five_sixteenths=$8D
   16                     
   17  06:DA6D            note_length_table:
   18  06:DA6D  01            .byte $01   ;32nd note
   19  06:DA6E  02            .byte $02   ;16th note
   20  06:DA6F  04            .byte $04   ;8th note
   21  06:DA70  08            .byte $08   ;quarter note
   22  06:DA71  10            .byte $10   ;half note
   23  06:DA72  20            .byte $20   ;whole note
   24                                   ;---dotted notes
   25  06:DA73  03            .byte $03   ;dotted 16th note
   26  06:DA74  06            .byte $06   ;dotted 8th note
   27  06:DA75  0C            .byte $0C   ;dotted quarter note
   28  06:DA76  18            .byte $18   ;dotted half note
   29  06:DA77  30            .byte $30   ;dotted whole note?
   30                                   ;---other
   31  06:DA78  07            .byte $07   ;modified quarter to fit after d_sixteenth triplets
   32  06:DA79  14            .byte $14   ;2 quarters plus an 8th
   33  06:DA7A  0A            .byte $0A
#[2]   External/sound_engine.asm
#[3]   External/vol_envelopes.i
  441                         .include "External/vol_envelopes.i"
    1  06:DA7B            volume_envelopes:
    2  06:DA7B  8F DA         .word se_ve_1
    3  06:DA7D  97 DA         .word se_ve_2
    4  06:DA7F  AE DA         .word se_ve_3
    5  06:DA81  C3 DA         .word se_ve_tgl_1
    6  06:DA83  CB DA         .word se_ve_tgl_2
    7  06:DA85  D6 DA         .word se_battlekid_loud
    8  06:DA87  DC DA         .word se_battlekid_loud_long
    9  06:DA89  E2 DA         .word se_battlekid_soft
   10  06:DA8B  E8 DA         .word se_battlekid_soft_long
   11  06:DA8D  EE DA         .word se_drum_decay
   12                         
   13  06:DA8F            se_ve_1:
   14  06:DA8F  0F 0E 0D      .byte $0F, $0E, $0D, $0C, $09, $05, $00
       06:DA92  0C 09 05  
       06:DA95  00        
   15  06:DA96  FF            .byte $FF
   16  06:DA97            se_ve_2:
   17  06:DA97  01 01 02      .byte $01, $01, $02, $02, $03, $03, $04, $04, $07, $07
       06:DA9A  02 03 03  
       06:DA9D  04 04 07  
       06:DAA0  07        
   18  06:DAA1  08 08 0A      .byte $08, $08, $0A, $0A, $0C, $0C, $0D, $0D, $0E, $0E
       06:DAA4  0A 0C 0C  
       06:DAA7  0D 0D 0E  
       06:DAAA  0E        
   19  06:DAAB  0F 0F         .byte $0F, $0F
   20  06:DAAD  FF            .byte $FF
   21  06:DAAE            se_ve_3:
   22  06:DAAE  0D 0D 0D      .byte $0D, $0D, $0D, $0C, $0B, $00, $00, $00, $00, $00
       06:DAB1  0C 0B 00  
       06:DAB4  00 00 00  
       06:DAB7  00        
   23  06:DAB8  00 00 00      .byte $00, $00, $00, $00, $06, $06, $06, $05, $04, $00
       06:DABB  00 06 06  
       06:DABE  06 05 04  
       06:DAC1  00        
   24  06:DAC2  FF            .byte $FF
   25                         
   26  06:DAC3            se_ve_tgl_1:
   27  06:DAC3  0F 0B 09      .byte $0F, $0B, $09, $08, $07, $06, $00
       06:DAC6  08 07 06  
       06:DAC9  00        
   28  06:DACA  FF            .byte $FF
   29                         
   30  06:DACB            se_ve_tgl_2:
   31  06:DACB  0B 0B 0A      .byte $0B, $0B, $0A, $09, $08, $07, $06, $06, $06, $05
       06:DACE  09 08 07  
       06:DAD1  06 06 06  
       06:DAD4  05        
   32  06:DAD5  FF            .byte $FF
   33                         
   34                         
   35  06:DAD6            se_battlekid_loud:
   36  06:DAD6  0F 0E 0C      .byte $0f, $0e, $0c, $0a, $00
       06:DAD9  0A 00     
   37  06:DADB  FF            .byte $FF
   38                         
   39  06:DADC            se_battlekid_loud_long:
   40  06:DADC  0F 0E 0C      .byte $0f, $0e, $0c, $0a, $09
       06:DADF  0A 09     
   41  06:DAE1  FF            .byte $FF
   42                         
   43  06:DAE2            se_battlekid_soft:
   44  06:DAE2  09 08 06      .byte $09, $08, $06, $04, $00
       06:DAE5  04 00     
   45  06:DAE7  FF            .byte $FF
   46                         
   47  06:DAE8            se_battlekid_soft_long:
   48  06:DAE8  09 08 06      .byte $09, $08, $06, $04, $03
       06:DAEB  04 03     
   49  06:DAED  FF            .byte $FF
   50                         
   51  06:DAEE            se_drum_decay:
   52  06:DAEE  0E 09 08      .byte $0E, $09, $08, $06, $04, $03, $02, $01, $00
       06:DAF1  06 04 03  
       06:DAF4  02 01 00  
   53  06:DAF7  FF            .byte $FF
   54                         
   55           0000      ve_short_staccato = $00
   56           0001      ve_fade_in = $01
   57           0002      ve_blip_echo = $02
   58           0003      ve_tgl_1 = $03
   59           0004      ve_tgl_2 = $04
   60           0005      ve_battlekid_1 = $05
   61           0006      ve_battlekid_1b = $06
   62           0007      ve_battlekid_2 = $07
   63           0008      ve_battlekid_2b = $08
   64           0009      ve_drum_decay = $09
#[2]   External/sound_engine.asm
#[3]   External/song0.i
  442                         .include "External/song0.i"  ;holds the data for song 0 (header and data streams)
    1                     ;silence song.  disables all streams
    2                     
    3  06:DAF8            song0_header:
    4  06:DAF8  06            .byte 6          ;6 streams
    5                         
    6  06:DAF9  00            .byte MUSIC_SQ1
    7  06:DAFA  00            .byte $00
    8                         
    9  06:DAFB  01            .byte MUSIC_SQ2
   10  06:DAFC  00            .byte $00
   11                         
   12  06:DAFD  02            .byte MUSIC_TRI
   13  06:DAFE  00            .byte $00
   14                         
   15  06:DAFF  03            .byte MUSIC_NOI
   16  06:DB00  00            .byte $00
   17                         
   18  06:DB01  04            .byte SFX_1
   19  06:DB02  00            .byte $00
   20                         
   21  06:DB03  05            .byte SFX_2
   22  06:DB04  00            .byte $00
#[2]   External/sound_engine.asm
#[3]   External/song1.i
  443                         .include "External/song1.i"  ;holds the data for song 1
    1  06:DB05            song1_header:
    2  06:DB05  04            .byte $04           ;4 streams
    3                         
    4  06:DB06  00            .byte MUSIC_SQ1     ;which stream
    5  06:DB07  01            .byte $01           ;status byte (stream enabled)
    6  06:DB08  00            .byte SQUARE_1      ;which channel
    7  06:DB09  70            .byte $70           ;initial duty (01)
    8  06:DB0A  03            .byte ve_tgl_1      ;volume envelope
    9  06:DB0B  26 DB         .word song1_square1 ;pointer to stream
   10  06:DB0D  53            .byte $53           ;tempo
   11                         
   12  06:DB0E  01            .byte MUSIC_SQ2     ;which stream
   13  06:DB0F  01            .byte $01           ;status byte (stream enabled)
   14  06:DB10  01            .byte SQUARE_2      ;which channel
   15  06:DB11  B0            .byte $B0           ;initial duty (10)
   16  06:DB12  04            .byte ve_tgl_2      ;volume envelope
   17  06:DB13  48 DB         .word song1_square2 ;pointer to stream
   18  06:DB15  53            .byte $53           ;tempo
   19                         
   20  06:DB16  02            .byte MUSIC_TRI     ;which stream
   21  06:DB17  01            .byte $01           ;status byte (stream enabled)
   22  06:DB18  02            .byte TRIANGLE      ;which channel
   23  06:DB19  80            .byte $80           ;initial volume (on)
   24  06:DB1A  04            .byte ve_tgl_2      ;volume envelope
   25  06:DB1B  C7 DB         .word song1_tri     ;pointer to stream
   26  06:DB1D  53            .byte $53           ;tempo
   27                         
   28  06:DB1E  03            .byte MUSIC_NOI     ;which stream
   29  06:DB1F  01            .byte $01           ;enabled
   30  06:DB20  03            .byte NOISE     
   31  06:DB21  30            .byte $30           ;initial duty_vol
   32  06:DB22  09            .byte ve_drum_decay ;volume envelope
   33  06:DB23  44 DC         .word song1_noise   ;pointer to stream
   34  06:DB25  53            .byte $53           ;tempo
   35                     
   36                         
   37  06:DB26            song1_square1:
   38  06:DB26                song1_square1:
   39  06:DB26  82            .byte eighth
   40  06:DB27  A4 0E         .byte set_loop1_counter, 14             ;repeat 14 times
   41  06:DB29            .loop:
   42  06:DB29  0C 0C 0C      .byte A2, A2, A2, A3, A2, A3, A2, A3
       06:DB2C  18 0C 18  
       06:DB2F  0C 18     
   43  06:DB31  A8            .byte transpose                         ;the transpose opcode take a 2-byte argument
   44  06:DB32  3A DB         .word .lookup_table                     ;which is the address of the lookup table
   45                         
   46  06:DB34  A5            .byte loop1                             ;finite loop (14 times)
   47  06:DB35  29 DB         .word .loop
   48                         
   49  06:DB37  A1            .byte loop                              ;infinite loop
   50  06:DB38  26 DB         .word song1_square1
   51                         
   52  06:DB3A            .lookup_table:
   53  06:DB3A  02 FF FF      .byte 2, -1, -1, -1, -1, -1, -2
       06:DB3D  FF FF FF  
       06:DB40  FE        
   54  06:DB41  FF FF 00      .byte -1, -1, 0, -1, 8, -8, 8       ;14 entries long, reverse order
       06:DB44  FF 08 F8  
       06:DB47  08        
   55                     
   56                     
   57                         
   58  06:DB48            song1_square2:
   59  06:DB48  81            .byte sixteenth
   60  06:DB49  5E            .byte rest    ;offset for delay effect
   61  06:DB4A  82            .byte eighth
   62  06:DB4B            .loop_point:
   63  06:DB4B  5E            .byte rest
   64  06:DB4C  24 27 26      .byte A4, C5, B4, C5, A4, C5, B4, C5
       06:DB4F  27 24 27  
       06:DB52  26 27     
   65  06:DB54  24 27 26      .byte A4, C5, B4, C5, A4, C5, B4, C5
       06:DB57  27 24 27  
       06:DB5A  26 27     
   66  06:DB5C  24 27 26      .byte A4, C5, B4, C5, A4, C5, B4, C5
       06:DB5F  27 24 27  
       06:DB62  26 27     
   67  06:DB64  24 27 26      .byte A4, C5, B4, C5, A4, C5, B4, C5
       06:DB67  27 24 27  
       06:DB6A  26 27     
   68  06:DB6C  23 26 24      .byte Ab4, B4, A4, B4, Ab4, B4, A4, B4
       06:DB6F  26 23 26  
       06:DB72  24 26     
   69  06:DB74  26 2B 29      .byte B4, E5, D5, E5, B4, E5, D5, E5
       06:DB77  2B 26 2B  
       06:DB7A  29 2B     
   70  06:DB7C  24 2A 27      .byte A4, Eb5, C5, Eb5, A4, Eb5, C5, Eb5
       06:DB7F  2A 24 2A  
       06:DB82  27 2A     
   71  06:DB84  24 29 28      .byte A4, D5, Db5, D5, A4, D5, Db5, D5
       06:DB87  29 24 29  
       06:DB8A  28 29     
   72  06:DB8C  24 27 2C      .byte A4, C5, F5, A5, C6, A5, F5, C5
       06:DB8F  30 33 30  
       06:DB92  2C 27     
   73  06:DB94  21 26 2A      .byte Gb4, B4, Eb5, Gb5, B5, Gb5, Eb5, B4
       06:DB97  2D 32 2D  
       06:DB9A  2A 26     
   74  06:DB9C  20 25 29      .byte F4, Bb4, D5, F5, Gs5, F5, D5, As4
       06:DB9F  2C 2F 2C  
       06:DBA2  29 25     
   75  06:DBA4  1F 24 28      .byte E4, A4, Cs5, E5, A5, E5, sixteenth, Cs5, rest
       06:DBA7  2B 30 2B  
       06:DBAA  81 28 5E  
   76  06:DBAD  82            .byte eighth
   77  06:DBAE  1E 23 27      .byte Ds4, Gs4, C5, Ds5, Gs5, Ds5, C5, Gs4
       06:DBB1  2A 2F 2A  
       06:DBB4  27 23     
   78  06:DBB6  81            .byte sixteenth
   79  06:DBB7  22 21 22      .byte G4, Fs4, G4, Fs4, G4, Fs4, G4, Fs4
       06:DBBA  21 22 21  
       06:DBBD  22 21     
   80  06:DBBF  82            .byte eighth
   81  06:DBC0  22 26 29      .byte G4, B4, D5, G5
       06:DBC3  2E        
   82  06:DBC4  A1            .byte loop
   83  06:DBC5  4B DB         .word .loop_point
   84                         
   85  06:DBC7            song1_tri:
   86  06:DBC7  82            .byte eighth
   87  06:DBC8  30 33 32      .byte A5, C6, B5, C6, A5, C6, B5, C6 ;triangle data
       06:DBCB  33 30 33  
       06:DBCE  32 33     
   88  06:DBD0  30 33 32      .byte A5, C6, B5, C6, A5, C6, B5, C6
       06:DBD3  33 30 33  
       06:DBD6  32 33     
   89  06:DBD8  30 33 32      .byte A5, C6, B5, C6, A5, C6, B5, C6
       06:DBDB  33 30 33  
       06:DBDE  32 33     
   90  06:DBE0  30 33 32      .byte A5, C6, B5, C6, A5, C6, B5, C6
       06:DBE3  33 30 33  
       06:DBE6  32 33     
   91  06:DBE8  2F 32 30      .byte Ab5, B5, A5, B5, Ab5, B5, A5, B5
       06:DBEB  32 2F 32  
       06:DBEE  30 32     
   92  06:DBF0  32 37 35      .byte B5, E6, D6, E6, B5, E6, D6, E6
       06:DBF3  37 32 37  
       06:DBF6  35 37     
   93  06:DBF8  30 36 33      .byte A5, Eb6, C6, Eb6, A5, Eb6, C6, Eb6
       06:DBFB  36 30 36  
       06:DBFE  33 36     
   94  06:DC00  30 35 34      .byte A5, D6, Db6, D6, A5, D6, Db6, D6
       06:DC03  35 30 35  
       06:DC06  34 35     
   95  06:DC08  30 33 38      .byte A5, C6, F6, A6, C7, A6, F6, C6
       06:DC0B  3C 3F 3C  
       06:DC0E  38 33     
   96  06:DC10  2D 32 36      .byte Gb5, B5, Eb6, Gb6, B6, Gb6, Eb6, B5
       06:DC13  39 3E 39  
       06:DC16  36 32     
   97  06:DC18  2C 31 35      .byte F5, Bb5, D6, F6, Gs6, F6, D6, As5
       06:DC1B  38 3B 38  
       06:DC1E  35 31     
   98  06:DC20  2B 30 34      .byte E5, A5, Cs6, E6, A6, E6, Cs6, A5
       06:DC23  37 3C 37  
       06:DC26  34 30     
   99  06:DC28  2A 2F 33      .byte Ds5, Gs5, C6, Ds6, Gs6, Ds6, C6, Gs5
       06:DC2B  36 3B 36  
       06:DC2E  33 2F     
  100  06:DC30  81            .byte sixteenth
  101  06:DC31  2E 2D 2E      .byte G5, Fs5, G5, Fs5, G5, Fs5, G5, Fs5
       06:DC34  2D 2E 2D  
       06:DC37  2E 2D     
  102  06:DC39  2E 32 35      .byte G5, B5, D6, G6, B5, D6, B6, D7
       06:DC3C  3A 32 35  
       06:DC3F  3E 41     
  103  06:DC41  A1            .byte loop
  104  06:DC42  C7 DB         .word song1_tri
  105                         
  106  06:DC44            song1_noise:
  107  06:DC44  82 04         .byte eighth, $04
  108  06:DC46  81 04 04      .byte sixteenth, $04, $04, $04
       06:DC49  04        
  109  06:DC4A  87 04         .byte d_eighth, $04
  110  06:DC4C  81 04 04      .byte sixteenth, $04, $04, $04, $04
       06:DC4F  04 04     
  111  06:DC51  82 04 04      .byte eighth, $04, $04
  112  06:DC54  A1            .byte loop
  113  06:DC55  44 DC         .word song1_noise
#[2]   External/sound_engine.asm
#[3]   External/song2.i
  444                         .include "External/song2.i"
    1  06:DC57            song2_header:
    2  06:DC57  01            .byte $01           ;1 stream
    3                         
    4  06:DC58  04            .byte SFX_1         ;which stream
    5  06:DC59  01            .byte $01           ;status byte (stream enabled)
    6  06:DC5A  01            .byte SQUARE_2      ;which channel
    7  06:DC5B  70            .byte $70           ;duty (01)
    8  06:DC5C  06            .byte ve_battlekid_1b  ;volume envelope
    9  06:DC5D  60 DC         .word song2_square2 ;pointer to stream
   10  06:DC5F  80            .byte $80           ;tempo
   11                         
   12                         
   13  06:DC60            song2_square2:
   14  06:DC60  82 11 05      .byte eighth, D3, D2
   15  06:DC63  A0            .byte endsound
#[2]   External/sound_engine.asm
#[3]   External/song3.i
  445                         .include "External/song3.i"
    1  06:DC64            song3_header:
    2  06:DC64  04            .byte $04           ;4 streams
    3                         
    4  06:DC65  00            .byte MUSIC_SQ1     ;which stream
    5  06:DC66  01            .byte $01           ;status byte (stream enabled)
    6  06:DC67  00            .byte SQUARE_1      ;which channel
    7  06:DC68  B0            .byte $B0           ;initial duty (10)
    8  06:DC69  03            .byte ve_tgl_1      ;volume envelope
    9  06:DC6A  79 DC         .word song3_square1 ;pointer to stream
   10  06:DC6C  40            .byte $40           ;tempo
   11                         
   12  06:DC6D  01            .byte MUSIC_SQ2     ;which stream
   13  06:DC6E  00            .byte $00           ;status byte (stream disabled)
   14                         
   15  06:DC6F  02            .byte MUSIC_TRI     ;which stream
   16  06:DC70  01            .byte $01           ;status byte (stream enabled)
   17  06:DC71  02            .byte TRIANGLE      ;which channel
   18  06:DC72  81            .byte $81           ;initial volume (on)
   19  06:DC73  04            .byte ve_tgl_2      ;volume envelope
   20  06:DC74  BD DC         .word song3_tri     ;pointer to stream
   21  06:DC76  40            .byte $40           ;tempo
   22                         
   23  06:DC77  03            .byte MUSIC_NOI     ;which stream
   24  06:DC78  00            .byte $00           ;disabled.  Our load routine will skip the
   25                                             ;   rest of the reads if the status byte is 0.
   26                                             ;   We are disabling Noise because we haven't covered it yet.
   27                         
   28  06:DC79            song3_square1:
   29  06:DC79  82            .byte eighth
   30  06:DC7A  1D 24 20      .byte D4, A4, F4, A4, D4, B4, G4, B4
       06:DC7D  24 1D 26  
       06:DC80  22 26     
   31  06:DC82  1D 27 24      .byte D4, C5, A4, C5, D4, As4, F4, As4
       06:DC85  27 1D 25  
       06:DC88  20 25     
   32  06:DC8A  1F 24 1F      .byte E4, A4, E4, A4, D4, A4, Fs4, A4
       06:DC8D  24 1D 24  
       06:DC90  21 24     
   33  06:DC92  1D 24 21      .byte D4, A4, Fs4, A4, G4, As4, A4, C5
       06:DC95  24 22 25  
       06:DC98  24 27     
   34  06:DC9A  1D 27 24      .byte D4, C5, A4, C5, D4, B4, G4, B4
       06:DC9D  27 1D 26  
       06:DCA0  22 26     
   35  06:DCA2  1D 26 22      .byte D4, B4, G4, B4, D4, As4, Gs4, As4
       06:DCA5  26 1D 25  
       06:DCA8  23 25     
   36  06:DCAA  1C 24 1F      .byte Cs4, A4, E4, A4, D4, A4, E4, A4
       06:DCAD  24 1D 24  
       06:DCB0  1F 24     
   37  06:DCB2  1C 24 1F      .byte Cs4, A4, E4, A4, B3, A4, Cs4, A4
       06:DCB5  24 1A 24  
       06:DCB8  1C 24     
   38  06:DCBA  A1            .byte loop
   39  06:DCBB  79 DC         .word song3_square1
   40                             
   41  06:DCBD            song3_tri:
   42  06:DCBD  83 35 3C      .byte quarter, D6, A6, d_half, G6
       06:DCC0  89 3A     
   43  06:DCC2  82 38 37      .byte eighth, F6, E6, quarter, D6
       06:DCC5  83 35     
   44  06:DCC7  82 33 31      .byte eighth, C6, As5, C6, A5
       06:DCCA  33 30     
   45  06:DCCC  83 37 8A      .byte quarter, E6, d_whole, D6
       06:DCCF  35        
   46  06:DCD0  83 3C 3F      .byte quarter, A6, C7, d_half, B6
       06:DCD3  89 3E     
   47  06:DCD5  82 3A 38      .byte eighth, G6, F6, quarter, E6
       06:DCD8  83 37     
   48  06:DCDA  82 38 3A      .byte eighth, F6, G6, whole, A6, A6
       06:DCDD  85 3C 3C  
   49  06:DCE0  A1            .byte loop
   50  06:DCE1  BD DC         .word song3_tri
#[2]   External/sound_engine.asm
#[3]   External/song4.i
  446                         .include "External/song4.i"
    1  06:DCE3            song4_header:
    2  06:DCE3  04            .byte $04           ;4 streams
    3                         
    4  06:DCE4  00            .byte MUSIC_SQ1     ;which stream
    5  06:DCE5  01            .byte $01           ;status byte (stream enabled)
    6  06:DCE6  00            .byte SQUARE_1      ;which channel
    7  06:DCE7  B0            .byte $B0           ;initial duty (10)
    8  06:DCE8  06            .byte ve_battlekid_1b  ;volume envelope
    9  06:DCE9  04 DD         .word song4_square1 ;pointer to stream
   10  06:DCEB  60            .byte $60           ;tempo
   11                         
   12  06:DCEC  01            .byte MUSIC_SQ2     ;which stream
   13  06:DCED  01            .byte $01           ;status byte (stream enabled)
   14  06:DCEE  01            .byte SQUARE_2      ;which channel
   15  06:DCEF  30            .byte $30           ;initial duty (00)
   16  06:DCF0  00            .byte ve_short_staccato ;volume envelope
   17  06:DCF1  3D DD         .word song4_square2 ;pointer to stream
   18  06:DCF3  60            .byte $60           ;tempo
   19                         
   20  06:DCF4  02            .byte MUSIC_TRI     ;which stream
   21  06:DCF5  01            .byte $01           ;status byte (stream enabled)
   22  06:DCF6  02            .byte TRIANGLE      ;which channel
   23  06:DCF7  81            .byte $81           ;initial volume (on)
   24  06:DCF8  06            .byte ve_battlekid_1b  ;volume envelope
   25  06:DCF9  61 DD         .word song4_tri     ;pointer to stream
   26  06:DCFB  60            .byte $60           ;tempo
   27                         
   28  06:DCFC  03            .byte MUSIC_NOI     ;which stream
   29  06:DCFD  01            .byte $01
   30  06:DCFE  03            .byte NOISE
   31  06:DCFF  1E            .byte 30
   32  06:DD00  09            .byte ve_drum_decay
   33  06:DD01  81 DD         .word song4_noise
   34  06:DD03  60            .byte $60
   35                                             
   36  06:DD04            song4_square1:
   37  06:DD04  84 1F 83      .byte half, E4, quarter, G4, eighth, Fs4, E4, d_sixteenth, Eb4, E4, Fs4, t_quarter, rest, half, rest
       06:DD07  22 82 21  
       06:DD0A  1F 86 1E  
       06:DD0D  1F 21 8B  
       06:DD10  5E 84 5E  
   38  06:DD13  21 83 24      .byte       Fs4, quarter, A4, eighth, G4, Fs4, d_sixteenth, E4, Fs4, G4, t_quarter, rest, half, rest
       06:DD16  82 22 21  
       06:DD19  86 1F 21  
       06:DD1C  22 8B 5E  
       06:DD1F  84 5E     
   39  06:DD21  22 83 26      .byte       G4, quarter, B4, eighth, A4, G4, quarter, A4, B4, C5, eighth, B4, A4
       06:DD24  82 24 22  
       06:DD27  83 24 26  
       06:DD2A  27 82 26  
       06:DD2D  24        
   40  06:DD2E  26 24 22      .byte       B4, A4, G4, Fs4, Eb4, E4, Fs4, G4, Fs4, E4, d_half, rest
       06:DD31  21 1E 1F  
       06:DD34  21 22 21  
       06:DD37  1F 89 5E  
   41  06:DD3A  A1            .byte loop
   42  06:DD3B  04 DD         .word song4_square1
   43                         
   44  06:DD3D            song4_square2:
   45  06:DD3D  83            .byte quarter
   46  06:DD3E  13 1A 1A      .byte E3, B3, B3, B3, B2, Fs3, Fs3, Fs3
       06:DD41  1A 0E 15  
       06:DD44  15 15     
   47  06:DD46  15 18 18      .byte Fs3, A3, A3, A3, B2, E3, E3, E3
       06:DD49  18 0E 13  
       06:DD4C  13 13     
   48  06:DD4E  13 1A 1A      .byte E3, B3, B3, B3, B3, A3, G3, Fs3
       06:DD51  1A 1A 18  
       06:DD54  16 15     
   49  06:DD56  13 1A 18      .byte E3, B3, A3, Fs3, E3, E3, E3, E3;d_half, rest
       06:DD59  15 13 13  
       06:DD5C  13 13     
   50  06:DD5E  A1            .byte loop
   51  06:DD5F  3D DD         .word song4_square2
   52                         
   53  06:DD61            song4_tri:
   54  06:DD61  84 1F 22      .byte half, E4, G4, B3, Eb4
       06:DD64  1A 1E     
   55  06:DD66  21 24 1A      .byte Fs4, A4, B3, E4
       06:DD69  1F        
   56  06:DD6A  22 26 83      .byte G4, B4, quarter, A4, B4, half, C5
       06:DD6D  24 26 84  
       06:DD70  27        
   57  06:DD71  82 1F 21      .byte eighth, E4, Fs4, G4, A4, B3, C4, D4, Eb4, A3, E4, d_half, rest
       06:DD74  22 24 1A  
       06:DD77  1B 1D 1E  
       06:DD7A  18 1F 89  
       06:DD7D  5E        
   58  06:DD7E  A1            .byte loop
   59  06:DD7F  61 DD         .word song4_tri
   60                         
   61  06:DD81            song4_noise:
   62  06:DD81  A4 03         .byte set_loop1_counter, 3
   63  06:DD83            .loop_point:
   64  06:DD83  84 0D 07      .byte half, $0D, $07, $0D
       06:DD86  0D        
   65  06:DD87  83 07 15      .byte quarter, $07, $15
   66  06:DD8A  A5            .byte loop1
   67  06:DD8B  83 DD         .word .loop_point
   68  06:DD8D  83 0D 0D      .byte quarter, $0D, $0D, $07, $07
       06:DD90  07 07     
   69  06:DD92  89 05         .byte d_half, $05
   70  06:DD94  81 12 13      .byte sixteenth, $12, $13, $14, $15
       06:DD97  14 15     
   71  06:DD99  A1            .byte loop
   72  06:DD9A  81 DD         .word song4_noise
#[2]   External/sound_engine.asm
#[3]   External/song5.i
  447                         .include "External/song5.i"
    1  06:DD9C            song5_header:
    2  06:DD9C  01            .byte $01           ;1 stream
    3                         
    4  06:DD9D  04            .byte SFX_1         ;which stream
    5  06:DD9E  01            .byte $01           ;status byte (stream enabled)
    6  06:DD9F  01            .byte SQUARE_2      ;which channel
    7  06:DDA0  70            .byte $70           ;initial duty (01)
    8  06:DDA1  00            .byte ve_short_staccato ;volume envelope
    9  06:DDA2  A5 DD         .word song5_square2 ;pointer to stream
   10  06:DDA4  FF            .byte $FF           ;tempo..very fast tempo
   11                         
   12                         
   13  06:DDA5            song5_square2:
   14  06:DDA5  80 1B 4D      .byte thirtysecond, C4, D8, C5, D7, C6, D6, C7, D5, C8, D8 ;some random notes played very fast
       06:DDA8  27 41 33  
       06:DDAB  35 3F 29  
       06:DDAE  4B 4D     
   15  06:DDB0  A0            .byte endsound
#[2]   External/sound_engine.asm
#[3]   External/song6.i
  448                         .include "External/song6.i"
    1                     ;Battle Kid theme.  Original by Sivak
    2                     
    3  06:DDB1            song6_header:
    4  06:DDB1  04            .byte $04           ;4 streams
    5                         
    6  06:DDB2  00            .byte MUSIC_SQ1     ;which stream
    7  06:DDB3  01            .byte $01           ;status byte (stream enabled)
    8  06:DDB4  00            .byte SQUARE_1      ;which channel
    9  06:DDB5  30            .byte $30           ;initial duty (01)
   10  06:DDB6  05            .byte ve_battlekid_1      ;volume envelope
   11  06:DDB7  D2 DD         .word song6_square1 ;pointer to stream
   12  06:DDB9  4C            .byte $4C           ;tempo
   13                         
   14  06:DDBA  01            .byte MUSIC_SQ2     ;which stream
   15  06:DDBB  01            .byte $01           ;status byte (stream enabled)
   16  06:DDBC  01            .byte SQUARE_2      ;which channel
   17  06:DDBD  30            .byte $30           ;initial duty (10)
   18  06:DDBE  07            .byte ve_battlekid_2      ;volume envelope
   19  06:DDBF  28 DE         .word song6_square2 ;pointer to stream
   20  06:DDC1  4C            .byte $4C           ;tempo
   21                         
   22  06:DDC2  02            .byte MUSIC_TRI     ;which stream
   23  06:DDC3  01            .byte $01           ;status byte (stream enabled)
   24  06:DDC4  02            .byte TRIANGLE      ;which channel
   25  06:DDC5  80            .byte $80           ;initial volume (on)
   26  06:DDC6  00            .byte ve_short_staccato    ;volume envelope
   27  06:DDC7  80 DE         .word song6_tri     ;pointer to stream
   28  06:DDC9  4C            .byte $4C           ;tempo
   29                         
   30  06:DDCA  03            .byte MUSIC_NOI     ;which stream
   31  06:DDCB  01            .byte $01
   32  06:DDCC  03            .byte NOISE
   33  06:DDCD  30            .byte $30
   34  06:DDCE  09            .byte ve_drum_decay
   35  06:DDCF  95 DE         .word song6_noise
   36  06:DDD1  4C            .byte $4C
   37                         
   38  06:DDD2            song6_square1:
   39  06:DDD2  81            .byte sixteenth
   40  06:DDD3  A4 0D         .byte set_loop1_counter, 13
   41  06:DDD5            .intro_loop:
   42  06:DDD5  18 1B 1F      .byte A3, C4, E4, A4 
       06:DDD8  24        
   43  06:DDD9  A5            .byte loop1
   44  06:DDDA  D5 DD         .word .intro_loop
   45  06:DDDC  18 1F 13      .byte A3, E4, E3, E2
       06:DDDF  07        
   46                         
   47  06:DDE0  A3 B0         .byte duty, $B0
   48  06:DDE2  A2 06         .byte volume_envelope, ve_battlekid_1b
   49  06:DDE4  83 1F 13      .byte quarter, E4, E3
   50                         
   51  06:DDE7  A3 70         .byte duty, $70
   52  06:DDE9  8C 18         .byte five_eighths, A3
   53  06:DDEB  82 1A 1B      .byte eighth, B3, C4, D4
       06:DDEE  1D        
   54  06:DDEF  81 1E         .byte sixteenth, Ds4
   55  06:DDF1  8D 1F         .byte five_sixteenths, E4 ;original probably uses a slide effect.  I fake it here with odd note lengths
   56  06:DDF3  88 18         .byte d_quarter, A3
   57  06:DDF5  83 1D         .byte quarter, D4
   58  06:DDF7  8C 18         .byte five_eighths, A3
   59  06:DDF9  82 1A 1B      .byte eighth, B3, C4, D4, C4, B3, A3
       06:DDFC  1D 1B 1A  
       06:DDFF  18        
   60  06:DE00  83 16 13      .byte quarter, G3, E3
   61  06:DE03  82 1A         .byte eighth, B3
   62                         
   63  06:DE05  8C 18         .byte five_eighths, A3
   64  06:DE07  82 1A 1B      .byte eighth, B3, C4, D4
       06:DE0A  1D        
   65  06:DE0B  81 1E         .byte sixteenth, Ds4
   66  06:DE0D  8D 1F         .byte five_sixteenths, E4
   67  06:DE0F  88 18         .byte d_quarter, A3
   68  06:DE11  83 1D         .byte quarter, D4
   69  06:DE13  8C 18         .byte five_eighths, A3
   70  06:DE15  82 1A 1B      .byte eighth, B3, C4, D4, C4, B3, A3
       06:DE18  1D 1B 1A  
       06:DE1B  18        
   71  06:DE1C  83 1F 13      .byte quarter, E4, E3
   72  06:DE1F  82 13         .byte eighth, E3
   73                         
   74  06:DE21  A3 30         .byte duty, $30
   75  06:DE23  A2 05         .byte volume_envelope, ve_battlekid_1
   76                         
   77  06:DE25  A1            .byte loop
   78  06:DE26  D2 DD         .word song6_square1
   79                         
   80  06:DE28            song6_square2:
   81  06:DE28  81            .byte sixteenth
   82  06:DE29  5E            .byte rest
   83  06:DE2A            .loop_point:
   84  06:DE2A  A4 0D         .byte set_loop1_counter, 13
   85  06:DE2C            .intro_loop:
   86  06:DE2C  18 1B 1F      .byte A3, C4, E4, A4 
       06:DE2F  24        
   87  06:DE30  A5            .byte loop1
   88  06:DE31  2C DE         .word .intro_loop
   89  06:DE33  18 1F 13      .byte A3, E4, E3, E2
       06:DE36  07        
   90                         
   91  06:DE37  A3 B0         .byte duty, $B0
   92  06:DE39  A2 08         .byte volume_envelope, ve_battlekid_2b
   93  06:DE3B  83 1F 13      .byte quarter, E4, E3
   94                         
   95  06:DE3E  A3 70         .byte duty, $70
   96  06:DE40  8C 18         .byte five_eighths, A3
   97  06:DE42  82 1A 1B      .byte eighth, B3, C4, D4
       06:DE45  1D        
   98  06:DE46  81 1E         .byte sixteenth, Ds4
   99  06:DE48  8D 1F         .byte five_sixteenths, E4
  100  06:DE4A  88 18         .byte d_quarter, A3
  101  06:DE4C  83 1D         .byte quarter, D4
  102  06:DE4E  8C 18         .byte five_eighths, A3
  103  06:DE50  82 1A 1B      .byte eighth, B3, C4, D4, C4, B3, A3
       06:DE53  1D 1B 1A  
       06:DE56  18        
  104  06:DE57  83 16 13      .byte quarter, G3, E3
  105  06:DE5A  82 1A         .byte eighth, B3
  106                         
  107  06:DE5C  8C 18         .byte five_eighths, A3
  108  06:DE5E  82 1A 1B      .byte eighth, B3, C4, D4
       06:DE61  1D        
  109  06:DE62  81 1E         .byte sixteenth, Ds4
  110  06:DE64  8D 1F         .byte five_sixteenths, E4
  111  06:DE66  88 18         .byte d_quarter, A3
  112  06:DE68  83 1D         .byte quarter, D4
  113  06:DE6A  8C 18         .byte five_eighths, A3
  114  06:DE6C  82 1A 1B      .byte eighth, B3, C4, D4, C4, B3, A3
       06:DE6F  1D 1B 1A  
       06:DE72  18        
  115  06:DE73  83 1F 13      .byte quarter, E4, E3
  116  06:DE76  82 13         .byte eighth, E3
  117                         
  118  06:DE78  A3 30         .byte duty, $30
  119  06:DE7A  A2 07         .byte volume_envelope, ve_battlekid_2
  120  06:DE7C  81            .byte sixteenth
  121  06:DE7D  A1            .byte loop
  122  06:DE7E  2A DE         .word .loop_point
  123                         
  124  06:DE80            song6_tri:
  125  06:DE80  82            .byte eighth
  126  06:DE81  A4 04         .byte set_loop1_counter, 4              ;repeat 4 times
  127  06:DE83            .loop:
  128  06:DE83  18 18 24      .byte A3, A3, A4, A4, A3, A3, A4, A4    ;series of notes to repeat
       06:DE86  24 18 18  
       06:DE89  24 24     
  129  06:DE8B  A7 FE         .byte adjust_note_offset, -2            ;go down a step
  130  06:DE8D  A5            .byte loop1
  131  06:DE8E  83 DE         .word .loop
  132                         
  133  06:DE90  A6 00         .byte set_note_offset, 0                ;after 4 repeats, reset note offset to 0.
  134  06:DE92  A1            .byte loop                              ;infinite loop
  135  06:DE93  80 DE         .word song6_tri                         
  136                         ;21 bytes
  137                         
  138  06:DE95            song6_noise:
  139  06:DE95  A4 03         .byte set_loop1_counter, 3
  140  06:DE97            .loop_point1:
  141  06:DE97  83 01 03      .byte quarter, $01, $03, $01
       06:DE9A  01        
  142  06:DE9B  82 03 05      .byte eighth, $03, $05
  143  06:DE9E  A5            .byte loop1
  144  06:DE9F  97 DE         .word .loop_point1
  145  06:DEA1  82 01 02      .byte eighth, $01, $02, $03, $03 
       06:DEA4  03 03     
  146  06:DEA6  83 07 07      .byte quarter, $07, $07
  147  06:DEA9  A1            .byte loop
  148  06:DEAA  95 DE         .word song6_noise
#[2]   External/sound_engine.asm
#[3]   External/song7.i
  449                         .include "External/song7.i"
    1  06:DEAC            song7_header:
    2  06:DEAC  01            .byte $01           ;1 stream
    3                         
    4  06:DEAD  04            .byte SFX_1         ;which stream
    5  06:DEAE  01            .byte $01           ;status byte (stream enabled)
    6  06:DEAF  01            .byte SQUARE_2      ;which channel
    7  06:DEB0  70            .byte $70           ;initial duty (01)
    8  06:DEB1  00            .byte ve_short_staccato ;volume envelope
    9  06:DEB2  B5 DE         .word song7_square2 ;pointer to stream
   10  06:DEB4  FF            .byte $FF           ;tempo..very fast tempo
   11                     
   12                     
   13  06:DEB5            song7_square2:
   14  06:DEB5  A4 08         .byte set_loop1_counter, $08    ;repeat 8 times
   15  06:DEB7            .loop:
   16  06:DEB7  80 41 35      .byte thirtysecond, D7, D6, G6      ;play two D notes at different octaves
       06:DEBA  3A        
   17  06:DEBB  A7 FC         .byte adjust_note_offset, -4     ;go down 2 steps
   18  06:DEBD  A5            .byte loop1
   19  06:DEBE  B7 DE         .word .loop
   20  06:DEC0  A0            .byte endsound
#[2]   External/sound_engine.asm
#[3]   External/song8.i
  450                         .include "External/song8.i"
    1  06:DEC1            song8_header:
    2  06:DEC1  04            .byte 4
    3                         
    4  06:DEC2  00            .byte MUSIC_SQ1
    5  06:DEC3  00            .byte 0
    6                         
    7  06:DEC4  01            .byte MUSIC_SQ2
    8  06:DEC5  00            .byte 0
    9                         
   10  06:DEC6  02            .byte MUSIC_TRI
   11  06:DEC7  00            .byte 0
   12                         
   13  06:DEC8  03            .byte MUSIC_NOI
   14  06:DEC9  01            .byte $01
   15  06:DECA  03            .byte NOISE
   16  06:DECB  30            .byte $30
   17  06:DECC  04            .byte ve_tgl_2
   18  06:DECD  D0 DE         .word song8_noise
   19  06:DECF  4C            .byte $4C
   20                         
   21  06:DED0            song8_noise:
   22  06:DED0  84            .byte half                  ;first play through as half notes
   23  06:DED1  A4 02         .byte set_loop1_counter, 2  ;play two times
   24  06:DED3            .loop_point:
   25  06:DED3  00 01 02      .byte $00, $01, $02, $03, $04, $05, $06, $07, $08
       06:DED6  03 04 05  
       06:DED9  06 07 08  
   26  06:DEDC  09 0A 0B      .byte $09, $0A, $0B, $0C, $0D, $0E, $0F
       06:DEDF  0C 0D 0E  
       06:DEE2  0F        
   27  06:DEE3  10 11 12      .byte $10, $11, $12, $13, $14, $15, $16, $17, $18
       06:DEE6  13 14 15  
       06:DEE9  16 17 18  
   28  06:DEEC  19 1A 1B      .byte $19, $1A, $1B, $1C, $1D, $1E, $1F
       06:DEEF  1C 1D 1E  
       06:DEF2  1F        
   29  06:DEF3  A2 09         .byte volume_envelope, ve_drum_decay        ;change to 7-frame decay volume envelope
   30  06:DEF5  83            .byte quarter                               ;play quarter notes
   31  06:DEF6  A5            .byte loop1                                 ;repeat
   32  06:DEF7  D3 DE         .word .loop_point
   33  06:DEF9  A0            .byte endsound
#[2]   External/sound_engine.asm
#[1]   Picross.asm
  116                     ;;**************************;;
  117                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  118                     ;;       PRG ROM DATA       ;;
  119                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  120                     ;;**************************;; 
  121                       
  122           0007        .bank 7
  123           E000        .org $E000
  124                     
#[2]   NameTables/Tables.asm
  125                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  1C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  3C E0     
       07:E004  5C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  12 E0       .word Title_Screens, Game_Screens, GameOver_Screens
       07:E008  14 E0     
       07:E00A  1A E0     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  7C E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  7C F8     
       07:E010  7C F8     
   12                       
   13  07:E012            Title_Screens:
   14                     
   15  07:E012  7C E0       .word Title_Screen
   16                       
   17  07:E014            Game_Screens:
   18                     
   19  07:E014  7C E8       .word Game_5, Game_10, Game_15
       07:E016  7C EC     
       07:E018  7C F0     
   20                       
   21  07:E01A            GameOver_Screens:
   22                     
   23  07:E01A  7C F4       .word GameOver_Screen
   24                     
   25  07:E01C            Title_Palette:
   26                     
   27  07:E01C              .incbin "NameTables/Title_PAL.pal"
   28  07:E02C              .incbin "NameTables/Title_PAL.pal"
   29                       
   30  07:E03C            Game_Palette:
   31                     
   32  07:E03C              .incbin "NameTables/Game_PAL.pal"
   33  07:E04C              .incbin "NameTables/Game_PAL.pal"
   34                       
   35  07:E05C            GameOver_Palette:
   36                     
   37  07:E05C              .incbin "NameTables/GameOver_PAL.pal"
   38  07:E06C              .incbin "NameTables/GameOver_PAL.pal"
   39                       
   40  07:E07C            Title_Screen:
   41                     
   42  07:E07C              .incbin "NameTables/Title_NT.nam"
   43                       
   44  07:E47C            Title_Second:
   45                     
   46  07:E47C              .incbin "NameTables/Title_PuzzMen_NT.nam"
   47                       
   48  07:E87C            Game_5: 
   49                     
   50  07:E87C              .incbin "NameTables/Game_NT_5.nam"
   51                       
   52  07:EC7C            Game_10:
   53  07:EC7C              .incbin "NameTables/Game_NT_10.nam"
   54                       
   55  07:F07C            Game_15:
   56  07:F07C              .incbin "NameTables/Game_NT.nam"
   57                       
   58  07:F47C            GameOver_Screen:
   59                     
   60  07:F47C              .incbin "NameTables/GameOver_NT.nam"
   61                       
   62  07:F87C            Blank_Screen:
   63                     
   64  07:F87C              .incbin "NameTables/Blank_NT.nam"
   65                     
   66  07:FC7C            Pause_Menu:
   67  07:FC7C  28 2A 2A    .db $28,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$29
       07:FC7F  2A 2A 2A  
       07:FC82  2A 2A 2A  
       07:FC85  2A 2A 2A  
       07:FC88  29        
   68  07:FC89  2B 24 1C    .db $2b,$24,$1c,$0a,$1f,$0e,$62,$0e,$21,$12,$1d,$24,$3b
       07:FC8C  0A 1F 0E  
       07:FC8F  62 0E 21  
       07:FC92  12 1D 24  
       07:FC95  3B        
   69  07:FC96  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FC99  24 24 24  
       07:FC9C  24 24 24  
       07:FC9F  24 24 24  
       07:FCA2  3B        
   70  07:FCA3  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FCA6  24 24 24  
       07:FCA9  24 24 24  
       07:FCAC  24 24 24  
       07:FCAF  3B        
   71  07:FCB0  2B 24 24    .db $2b,$24,$24,$22,$0e,$1c,$24,$24,$17,$18,$24,$24,$3b
       07:FCB3  22 0E 1C  
       07:FCB6  24 24 17  
       07:FCB9  18 24 24  
       07:FCBC  3B        
   72  07:FCBD  38 3A 3A    .db $38,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$39
       07:FCC0  3A 3A 3A  
       07:FCC3  3A 3A 3A  
       07:FCC6  3A 3A 3A  
       07:FCC9  39        
   73                     
   74  07:FCCA            EndScreens:
   75                     
   76  07:FCCA  CE FC       .word PuzzleClearLines, PuzzleSavedLines
       07:FCCC  FD FC     
   77                       
   78  07:FCCE            PuzzleClearLines:
   79                     
   80  07:FCCE  EA 20       .db $EA, $20
   81  07:FCD0  0D 19 1E    .db $0D, $19,$1e,$23,$23,$15,$0e,$24,$0c,$15,$0e,$0a,$1b,$64
       07:FCD3  23 23 15  
       07:FCD6  0E 24 0C  
       07:FCD9  15 0E 0A  
       07:FCDC  1B 64     
   82  07:FCDE  07 1D 12    .db $07, $1d,$12,$16,$0e,$61,$24,$24 ;print the time here as a separate call, similar to how it's printed in update game at 2131
       07:FCE1  16 0E 61  
       07:FCE4  24 24     
   83  07:FCE6  0C 17 0E    .db $0C, $17,$0e,$21,$1d,$24,$19,$1e,$23,$23,$15,$0e,$63
       07:FCE9  21 1D 24  
       07:FCEC  19 1E 23  
       07:FCEF  23 15 0E  
       07:FCF2  63        
   84  07:FCF3  09 24 24    .db $09, $24,$24,$22,$0e,$1c,$24,$24,$17,$18
       07:FCF6  22 0E 1C  
       07:FCF9  24 24 17  
       07:FCFC  18        
   85                     
   86  07:FCFD            PuzzleSavedLines:
   87                       
   88  07:FCFD  2A 21       .db $2A, $21 
   89  07:FCFF  0D 19 1E    .db $0D, $19,$1e,$23,$23,$15,$0e,$24,$1c,$0a,$1f,$0e,$0d,$64
       07:FD02  23 23 15  
       07:FD05  0E 24 1C  
       07:FD08  0A 1F 0E  
       07:FD0B  0D 64     
   90                       
   91  07:FD0D            SelectDefaultName:
   92                      
   93  07:FD0D  47 26       .db $47, $26 
   94  07:FD0F  10 63 63    .db $10, $63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63
       07:FD12  63 63 63  
       07:FD15  63 63 63  
       07:FD18  63 63 63  
       07:FD1B  63 63 63  
       07:FD1E  63 63     
   95                     
   96  07:FD20            SelectDefaultTime:
   97                     
   98  07:FD20  8F 26       .db $8F, $26 
   99  07:FD22            DefaultTimeString:
  100  07:FD22  05 60 60    .db $05, $60,$60,$61,$60,$60
       07:FD25  61 60 60  
  101                     
  102                     
  103                      
  104                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  126                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:FD28            Sprites:
   38  07:FD28  2E FD             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:FD2A  37 FD     
       07:FD2C  40 FD     
   39                     
   40  07:FD2E            Title_Sprites:
   41  07:FD2E  02            .db $02
   42  07:FD2F  85 00 00          .db $85,$00,$00,$E8
       07:FD32  E8        
   43  07:FD33  A0 01 00          .db $A0,$01,$00,$60
       07:FD36  60        
   44  07:FD37            Game_Sprites:
   45  07:FD37  02            .db $02
   46  07:FD38  62 02 03          .db $62,$02,$03,$72
       07:FD3B  72        
   47  07:FD3C  5F FF 00          .db $5F,$FF,$00,$60
       07:FD3F  60        
   48  07:FD40            GameOver_Sprites:
   49  07:FD40  01                .db $01
   50  07:FD41  67 FF 00          .db $67,$FF,$00,$58
       07:FD44  58        
#[1]   Picross.asm
  127                     
  128           FFFA        .org $FFFA     ;first of the three vectors starts here
  129  07:FFFA  04 D6       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  130                                        ;processor will jump to the label NMI:
  131  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  132                                        ;to the label RESET:
  133  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  134                       
  135                     ;;**************************;;
  136                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  137                     ;;      CHR ROM DATA        ;;
  138                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  139                     ;;**************************;; 
  140                       
  141           0008        .bank 8
  142           0000        .org $0000
  143  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  144                       
  145           0009        .bank 9
  146           0000        .org $0000
  147  09:0000              .incbin "CHRROM/Bank1.chr"
  148                       
  149           000A        .bank 10
  150           0000        .org $0000
  151  0A:0000              .incbin "CHRROM/Bank2.chr"
  152                       
  153           000B        .bank 11
  154           0000        .org $0000
  155  0B:0000              .incbin "CHRROM/Bank3.chr"
