#[1]   Picross.asm
   11                     
   12                     ;;;; Variables and Macros ;;;;
   13                     
#[2]   Defines/Defines.asm
   14                       .include "Defines/Defines.asm"
    1                     ;; define 0 page stuff here, and SRAM stuff if we have it
    2                     
    3           0000        .rsset $0000
#[3]   Defines/GeneralVars.asm
    4                       .include "Defines/GeneralVars.asm"
    1           0000      temp1                   .rs 1
    2           0001      temp2                   .rs 1
    3           0002      temp3                   .rs 1
    4           0003      temp4                   .rs 1
    5           0004      temp5                   .rs 1
    6           0005      temp6                   .rs 1
    7           0006      temp7                   .rs 1
    8           0007      temp8                   .rs 1
    9           0008      tempx                   .rs 1
   10           0009      tempy                   .rs 1
   11           000A      time                    .rs 1
   12           000B      scaledTime              .rs 1
   13           000C      sleeping                .rs 1
   14           000D      mode_loadFlags  .rs 1
   15                     ;;0rcb xxxx
   16                     ;;r = read from save copy 
   17                     ;;c = write to save copy
   18           000E      game_mode               .rs 1
   19           000F      mode_state              .rs 1
   20           0010      NMI_locks               .rs 1
   21           0011      game_locks              .rs 1
   22           0012      pointer_address .rs 2
   23           0014      pointerB_address .rs 2
   24           0016      table_address   .rs 2
   25           0018      jump_address    .rs 2
   26                     
   27                     ;game modes
   28           0000      TITLE_IDX = $00
   29           0001      GAME_IDX = $01
   30           0002      GAMEOVER_IDX = $02
   31                     
   32                     ;locks for input and rendering
   33           0001      BGLOAD_NMI_LOCK = %00000001
   34           0001      EFFECT_GAME_LOCK = %00000001
   35                     
   36                     
   37                     
#[2]   Defines/Defines.asm
#[3]   Defines/ControllerVars.asm
    5                       .include "Defines/ControllerVars.asm"
    1           0010      GAMEPAD_UP = $10
    2           0020      GAMEPAD_DOWN = $20
    3           0040      GAMEPAD_LEFT = $40
    4           0080      GAMEPAD_RIGHT = $80
    5           0001      GAMEPAD_A = $01
    6           0002      GAMEPAD_B = $02
    7           0004      GAMEPAD_SELECT = $04
    8           0008      GAMEPAD_START = $08
    9                     
   10           00C0      GAMEPAD_HORI = $C0
   11           0030      GAMEPAD_VERT = $30
   12           00F0      GAMEPAD_MOVE = $F0
   13                     
   14           0003      GAMEPAD_AB = $03
   15                     
   16           0009      GAMEPAD_CONFIRM = $09
   17                     
   18           001A      gamepad                 .rs 1
   19           001B      gamepadLast     .rs 1
   20           001C      gamepadPressed  .rs 1
#[2]   Defines/Defines.asm
#[3]   Defines/PPUVariables.asm
    6                       .include "Defines/PPUVariables.asm"
    1           001D      PPU_Control                     .rs 1
    2           001E      PPU_Mask                        .rs 1
    3           001F      PPU_ScrollX                     .rs 1
    4           0020      PPU_ScrollY                     .rs 1
    5           0021      PPU_ScrollNT            .rs 1   ;first two bits
    6           0022      PPU_NT                          .rs 1
    7                     
    8           0023      PPU_PendingWrite        .rs 1
    9           0024      PPU_StringIdx           .rs 1
   10           0025      PPU_String                      .rs 128
   11                     
   12           004F      PPU_STRINGMAX = $4F ;up to size of a full nametable, I think
   13                     
   14           0000      SPRITE_YPOS = $00
   15           0001      SPRITE_ID   = $01
   16           0003      SPRITE_XPOS = $03
   17           0200      SPRITE_DATA = $0200
   18                     
   19           2000      PPU_CTRL = $2000
   20           2001      PPU_MASK = $2001
   21           2002      PPU_STATUS = $2002
   22           2003      OAM_LO = $2003
   23           2004      OAM_DATA = $2004
   24           2005      PPU_SCROLL = $2005
   25           2006      PPU_ADDR = $2006
   26           2007      PPU_DATA = $2007
   27           4014      OAM_HI = $4014
   28                     
   29           0080      DRAW_VERTICAL = $80
   30           0000      DRAW_HORIZONTAL = $00
   31                     
   32           0040      SPRITE_0_MASK = %01000000
#[2]   Defines/Defines.asm
#[3]   Defines/MapperVars.asm
    7                       .include "Defines/MapperVars.asm"
    1           00A5      mapper_address  .rs 2
    2           00A7      currentCHRBankA .rs 1
    3           00A8      currentCHRBankB .rs 1
    4           00A9      currentPRGBank  .rs 1
    5           00AA      mapperDebugVar  .rs 1
    6                     
    7                     
#[2]   Defines/Defines.asm
#[3]   Defines/TitleVariables.asm
    8                       .include "Defines/TitleVariables.asm"
    1                     
#[2]   Defines/Defines.asm
#[3]   Defines/GameVariables.asm
    9                       .include "Defines/GameVariables.asm"
    1           A000      PUZZLE_TABLE = $A000
    2           A01B      NAMES_TABLE = $A01B
    3           A036      SPRITES_TABLE = $A036
    4                     
    5           00AB      tempBank                        .rs 1
    6           00AC      tempPuzz                        .rs 1
    7           00AD      puzzle_address          .rs 2
    8           00AF      clues_address           .rs 2
    9           00B1      pause_address           .rs 2
   10           00B3      copy_address        .rs 2
   11           00B5      pause_draw_address  .rs 2
   12           00B7      clue_start_address      .rs 2
   13           00B9      clue_draw_address       .rs 2
   14           00BB      clueTableIndex          .rs 1
   15           00BC      clueLineIndex           .rs 1
   16           00BD      clueOffsetShift         .rs 1
   17           00BE      clueDrawAdd                     .rs 1
   18           00BF      clueDrawOffset          .rs 2
   19           00C1      clueDrawDecSize         .rs 1
   20           00C2      clueParity                      .rs 1
   21           00C3      mouse_location          .rs 2
   22           00C5      mouse_index                     .rs 2
   23           00C7      currentPaintTile        .rs 1
   24           00C8      pauseState                      .rs 1
   25           00C9      pauseInputLock          .rs 1
   26           00CA      holdTimer                       .rs 1
   27           00CB      targetGameMode          .rs 1
   28           00CC      targetScreenLoad        .rs 1
   29           00CD      recordSet                       .rs 1
#[2]   Defines/Defines.asm
   10                     ;; 0100 is the stack
   11                     ;; 0200 is sprite ram
   12           0300        .rsset $0300
   13           0400        .rsset $0400
   14           0500        .rsset $0500
   15           0600        .rsset $0600
   16           0700        .rsset $0700
   17           6000        .rsset $6000
#[3]   Defines/ScreenStateVariables.asm
   18                       .include "Defines/ScreenStateVariables.asm"
    1           6000      Screen_Copy             .rs 1024
    2           6400      ScreenB_Copy    .rs 1024
    3           6800      SaveScreen_Copy .rs 1024
    4           6C00      Palette_Copy    .rs 32
#[2]   Defines/Defines.asm
   19           7000        .rsset $7000
#[3]   Defines/SaveVariables.asm
   20                       .include "Defines/SaveVariables.asm"
    1           7000      hasContinue .rs 1
    2           7001      solutionCount           .rs 1
    3           7002      nonSolutionCount        .rs 1
    4           7003      GameTime                        .rs 4   ;in order - second, ten second, minute, 10 minute - max out at 99 minutes
    5           7007      bank_index      .rs 1
    6           7008      puzzle_index .rs 1
    7                     ;we can save these for the continue
    8                     ;on a continue- we just need to load the back ground as it was
    9                     ;we'll save out data for the puzzles- just need to know if it's 1) complete and 2) the time
   10                     ;we can do that in 4 bytes each, so 324 bytes
   11           7009      puzzle_clear_bank0 .rs 108
   12           7075      puzzle_clear_bank1 .rs 108
   13           70E1      puzzle_clear_bank2 .rs 108
   14                     
#[2]   Defines/Defines.asm
   21                     
#[1]   Picross.asm
#[2]   Macros/Macros.asm
   15                       .include "Macros/Macros.asm"
    1                             ;; include list of macros here
    2                             
#[3]   Macros/PPUMacros.asm
    3                             .include "Macros/PPUMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetPPUControl .macro
    6                     
    7                       LDA #\1  ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
    8                       STA PPU_CTRL
    9                       LDA #\2   ; enable sprites, enable background, no clipping on left side
   10                       STA PPU_MASK
   11                             
   12                       .endm
   13                       
   14                     MACROSetPPUAddress .macro
   15                     
   16                       LDA PPU_STATUS             ; read PPU status to reset the high/low latch
   17                       LDA #HIGH(\1)
   18                       STA PPU_ADDR            ; write the high byte of $2000 address
   19                       LDA #LOW(\1)
   20                       STA PPU_ADDR           ; write the low byte of $2000 address
   21                       
   22                       .endm
   23                         
   24                     
   25                     MACROAddPPUStringEntryRawData .macro
   26                     
   27                       LDA #$01
   28                       STA PPU_PendingWrite
   29                       LDA \1
   30                       JSR WriteToPPUString
   31                       LDA \2
   32                       JSR WriteToPPUString
   33                       LDA \3
   34                       JSR WriteToPPUString
   35                       LDA \4 
   36                       JSR WriteToPPUString
   37                       
   38                       .endm
   39                     
   40                     MACROAddPPUStringEntryRepeat .macro
   41                     
   42                       LDA #$01
   43                       STA PPU_PendingWrite
   44                       LDA \1
   45                       JSR WriteToPPUString
   46                       LDA \2
   47                       JSR WriteToPPUString
   48                       LDA #$40
   49                       ORA \3
   50                       ORA \4
   51                       JSR WriteToPPUString
   52                       LDA \5
   53                       JSR WriteToPPUString
   54                       
   55                       .endm
   56                       
   57                     MACROAddPPUStringEntryTable .macro
   58                      
   59                       LDA #$01
   60                       STA PPU_PendingWrite
   61                       LDA \1
   62                       JSR WriteToPPUString
   63                       LDA \2
   64                       JSR WriteToPPUString
   65                       LDA #$20
   66                       ORA \3
   67                       JSR WriteToPPUString
   68                       LDA #LOW(\4)
   69                       JSR WriteToPPUString
   70                       LDA #HIGH(\4)
   71                       JSR WriteToPPUString
   72                      
   73                       .endm
   74                     
   75                     MACROAddPPUStringEntryTablePtr .macro
   76                      
   77                       LDA #$01
   78                       STA PPU_PendingWrite
   79                       LDA \1
   80                       JSR WriteToPPUString
   81                       LDA \2
   82                       JSR WriteToPPUString
   83                       LDA #$20
   84                       ORA \3
   85                       JSR WriteToPPUString
   86                       LDA \4
   87                       JSR WriteToPPUString
   88                       LDA \4+1
   89                       JSR WriteToPPUString
   90                      
   91                       .endm
   92                     
#[2]   Macros/Macros.asm
#[3]   Macros/CallDynamicJump.asm
    4                             .include "Macros/CallDynamicJump.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROCallDynamicJump .macro
    6                     
    7                       LDA \1
    8                       JSR Dynamic_Jump
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetDoubleIndex.asm
    5                             .include "Macros/GetDoubleIndex.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = index to double
    3                     ;; all registers clobbered, as well as table_address
    4                     MACROGetDoubleIndex .macro
    5                     
    6                             LDA \1
    7                             ASL A
    8                             TAY
    9                             
   10                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/GetLabelPointer.asm
    6                             .include "Macros/GetLabelPointer.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = label we want address of
    3                     ;; \2 = address to store address to
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROGetLabelPointer .macro
    6                     
    7                             LDA #HIGH(\1)
    8                             LDX #LOW(\1)
    9                             
   10                             STX \2
   11                             STA \2+1
   12                             
   13                       .endm
   14                       
   15                     MACROGetPointer .macro
   16                     
   17                             LDA \1
   18                             STA \2
   19                             LDA \1+1
   20                             STA \2+1
   21                     
   22                       .endm
#[2]   Macros/Macros.asm
#[3]   Macros/FlagMacros.asm
    7                             .include "Macros/FlagMacros.asm"
    1                     ;;macro to load a full name table
    2                     ;; \1 = address to set
    3                     ;; \2 = flags to set
    4                     ;; all registers clobbered, as well as table_address
    5                     MACROSetFlags .macro
    6                     
    7                       LDA \1
    8                       ORA #\2
    9                       STA \1
   10                             
   11                       .endm
   12                       
   13                     MACROClearFlags .macro
   14                     
   15                       LDA #\2
   16                       EOR #$FF
   17                       AND \1  
   18                       STA \1
   19                     
   20                       .endm
#[2]   Macros/Macros.asm
#[1]   Picross.asm
   16                     
   17                     ;;**************************;;
   18                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   19                     ;;       PRG ROM            ;;
   20                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   21                     ;;**************************;; 
   22                     
#[2]   Banks/Bank0.asm
   23                       .include "Banks/Bank0.asm"
    1                     
    2                     
    3           0000        .bank 0
    4           8000        .org $8000
    5                       
#[3]   Puzzles/house.asm
    6                       .include "Puzzles/house.asm" 
    1  00:8000            house:
    2  00:8000  02 82 00    .db $02, $82, $00, $21
       00:8003  21        
    3  00:8004  01 E0 0F    .db $01, $E0, $0F, $00, $78, $36, $C1, $08, $03, $80, $E7, $CE, $ED, $EE, $47, $44, $47, $44, $FF, $FE, $FF, $FE, $FF, $FE, $AB, $AA, $03, $80, $FF, $FE
       00:8007  00 78 36  
       00:800A  C1 08 03  
       00:800D  80 E7 CE  
       00:8010  ED EE 47  
       00:8013  44 47 44  
       00:8016  FF FE FF  
       00:8019  FE FF FE  
       00:801C  AB AA 03  
       00:801F  80 FF FE  
    4  00:8022  14 21 FF    .db $14, $21, $FF, $17, $20, $FF, $14, $21, $FF, $13, $10, $FF, $14, $12, $FF, $17, $10, $FF, $82, $10, $FF, $C2, $FF, $63, $10, $FF, $17, $10, $FF, $14, $11, $10, $FF, $13, $10, $FF, $14, $21, $FF, $17, $10, $FF, $14, $21, $FF
       00:8025  17 20 FF  
       00:8028  14 21 FF  
       00:802B  13 10 FF  
       00:802E  14 12 FF  
       00:8031  17 10 FF  
       00:8034  82 10 FF  
       00:8037  C2 FF 63  
       00:803A  10 FF 17  
       00:803D  10 FF 14  
       00:8040  11 10 FF  
       00:8043  13 10 FF  
       00:8046  14 21 FF  
       00:8049  17 10 FF  
       00:804C  14 21 FF  
    5  00:804F  40 FF 40    .db $40, $FF, $40, $FF, $22, $40, $FF, $11, $20, $FF, $30, $FF, $35, $30, $FF, $34, $23, $FF, $11, $31, $FF, $11, $31, $FF, $F0, $FF, $F0, $FF, $F0, $FF, $11, $13, $11, $10, $FF, $30, $FF, $F0, $FF
       00:8052  FF 22 40  
       00:8055  FF 11 20  
       00:8058  FF 30 FF  
       00:805B  35 30 FF  
       00:805E  34 23 FF  
       00:8061  11 31 FF  
       00:8064  11 31 FF  
       00:8067  F0 FF F0  
       00:806A  FF F0 FF  
       00:806D  11 13 11  
       00:8070  10 FF 30  
       00:8073  FF F0 FF  
    6  00:8076            houseImage:
    7  00:8076  AA AB FE   .db $AA, $AB, $FE, $AA, $AB, $FE, $AA, $AB, $FE, $AA, $FB, $FE, $AA, $2A, $BA, $AA, $A3, $2A, $A9, $5A, $3F, $29, $54, $63, $3F, $24, $62, $AF, $CE, $A2, $8A, $BF, $3A, $89, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $55, $77, $75, $77, $77, $FF, $D5, $FF, $F5, $55, $55, $55, $40, $FF
       00:8079  AA AB FE  
       00:807C  AA AB FE  
       00:807F  AA FB FE  
       00:8082  AA 2A BA  
       00:8085  AA A3 2A  
       00:8088  A9 5A 3F  
       00:808B  29 54 63  
       00:808E  3F 24 62  
       00:8091  AF CE A2  
       00:8094  8A BF 3A  
       00:8097  89 55 55  
       00:809A  55 55 55  
       00:809D  55 55 55  
       00:80A0  55 55 55  
       00:80A3  77 75 77  
       00:80A6  77 FF D5  
       00:80A9  FF F5 55  
       00:80AC  55 55 40  
       00:80AF  FF        
    8  00:80B0            houseName:
    9  00:80B0  05 11 18    .db $05, $11, $18, $1E, $1C, $0E, $FF
       00:80B3  1E 1C 0E  
       00:80B6  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test.asm
    7                       .include "Puzzles/test.asm"
    1  00:80B7            test:
    2  00:80B7  02 01 00    .db $02, $01, $00, $00
       00:80BA  00        
    3  00:80BB  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:80BE  00 00 00  
       00:80C1  00 00 00  
       00:80C4  00 00 00  
       00:80C7  00 00 00  
       00:80CA  00 00 00  
       00:80CD  00 00 00  
       00:80D0  00 00 00  
       00:80D3  00 00 00  
       00:80D6  00 00 00  
    4  00:80D9  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80DC  FF 00 FF  
       00:80DF  00 FF 00  
       00:80E2  FF 00 FF  
       00:80E5  00 FF 00  
       00:80E8  FF 00 FF  
       00:80EB  00 FF 00  
       00:80EE  FF 00 FF  
       00:80F1  00 FF 00  
       00:80F4  FF 00 FF  
    5  00:80F7  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:80FA  FF 00 FF  
       00:80FD  00 FF 00  
       00:8100  FF 00 FF  
       00:8103  00 FF 00  
       00:8106  FF 00 FF  
       00:8109  00 FF 00  
       00:810C  FF 00 FF  
       00:810F  00 FF 00  
       00:8112  FF 00 FF  
    6  00:8115            testImage:
    7  00:8115  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8118  1B 1B 1B  
       00:811B  1B 1B 1B  
       00:811E  1B 1B 1B  
       00:8121  1B 1B 1B  
       00:8124  1B 1B 1B  
       00:8127  1B 1B 1B  
       00:812A  1B 1B 1B  
       00:812D  1B 1B 1B  
       00:8130  1B 1B 1B  
       00:8133  1B 1B 1B  
       00:8136  1B 1B 1B  
       00:8139  1B 1B 1B  
       00:813C  1B 1B 1B  
       00:813F  1B 1B 1B  
       00:8142  1B 1B 1B  
       00:8145  1B 1B 1B  
       00:8148  1B 1B 1B  
       00:814B  1B 1B 00  
       00:814E  FF        
    8  00:814F            testName:
    9  00:814F  04 1D 0E    .db $04, $1D, $0E, $1C, $1D, $FF
       00:8152  1C 1D FF  
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test5.asm
    8                       .include "Puzzles/test5.asm"
    1  00:8155            test5:
    2  00:8155  00 01 00    .db $00, $01, $00, $32
       00:8158  32        
    3  00:8159  80 00 00    .db $80, $00, $00, $00, $00
       00:815C  00 00     
    4  00:815E  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:8161  FF 00 FF  
       00:8164  00 FF 00  
       00:8167  FF        
    5  00:8168  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:816B  FF 00 FF  
       00:816E  00 FF 00  
       00:8171  FF        
    6  00:8172            test5Image:
    7  00:8172  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $00, $FF
       00:8175  1B 1B 1B  
       00:8178  00 FF     
    8  00:817A            test5Name:
    9  00:817A  05 1D 0E    .db $05, $1D, $0E, $1C, $1D, $05, $FF
       00:817D  1C 1D 05  
       00:8180  FF        
#[2]   Banks/Bank0.asm
#[3]   Puzzles/test10.asm
    9                       .include "Puzzles/test10.asm"
    1  00:8181            test10:
    2  00:8181  01 01 00    .db $01, $01, $00, $16
       00:8184  16        
    3  00:8185  80 00 00    .db $80, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
       00:8188  00 00 00  
       00:818B  00 00 00  
       00:818E  00 00 00  
       00:8191  00 00 00  
       00:8194  00 00 00  
       00:8197  00 00     
    4  00:8199  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:819C  FF 00 FF  
       00:819F  00 FF 00  
       00:81A2  FF 00 FF  
       00:81A5  00 FF 00  
       00:81A8  FF 00 FF  
       00:81AB  00 FF     
    5  00:81AD  10 FF 00    .db $10, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF, $00, $FF
       00:81B0  FF 00 FF  
       00:81B3  00 FF 00  
       00:81B6  FF 00 FF  
       00:81B9  00 FF 00  
       00:81BC  FF 00 FF  
       00:81BF  00 FF     
    6  00:81C1            test10Image:
    7  00:81C1  1B 1B 1B   .db $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $1B, $FF
       00:81C4  1B 1B 1B  
       00:81C7  1B 1B 1B  
       00:81CA  1B 1B 1B  
       00:81CD  1B 1B 1B  
       00:81D0  1B 1B 1B  
       00:81D3  1B 1B 1B  
       00:81D6  1B 1B 1B  
       00:81D9  1B FF     
    8  00:81DB            test10Name:
    9  00:81DB  06 1D 0E    .db $06, $1D, $0E, $1C, $1D, $01, $00, $FF
       00:81DE  1C 1D 01  
       00:81E1  00 FF     
#[2]   Banks/Bank0.asm
   10                     
   11           0001        .bank 1
   12           A000        .org $A000
   13                     ;puzzles
   14  01:A000  55 81       .word test5, test10, test, test, test, test, test, test, test
       01:A002  81 81     
       01:A004  B7 80     
       01:A006  B7 80     
       01:A008  B7 80     
       01:A00A  B7 80     
       01:A00C  B7 80     
       01:A00E  B7 80     
       01:A010  B7 80     
   15  01:A012  00 80       .word house, test, test, test, test, test, test, test, test
       01:A014  B7 80     
       01:A016  B7 80     
       01:A018  B7 80     
       01:A01A  B7 80     
       01:A01C  B7 80     
       01:A01E  B7 80     
       01:A020  B7 80     
       01:A022  B7 80     
   16  01:A024  00 80       .word house, test, test, test, test, test, test, test, test
       01:A026  B7 80     
       01:A028  B7 80     
       01:A02A  B7 80     
       01:A02C  B7 80     
       01:A02E  B7 80     
       01:A030  B7 80     
       01:A032  B7 80     
       01:A034  B7 80     
   17                     ;puzzle names
   18  01:A036  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A038  4F 81     
       01:A03A  4F 81     
       01:A03C  4F 81     
       01:A03E  4F 81     
       01:A040  4F 81     
       01:A042  4F 81     
       01:A044  4F 81     
       01:A046  4F 81     
   19  01:A048  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A04A  4F 81     
       01:A04C  4F 81     
       01:A04E  4F 81     
       01:A050  4F 81     
       01:A052  4F 81     
       01:A054  4F 81     
       01:A056  4F 81     
       01:A058  4F 81     
   20  01:A05A  B0 80       .word houseName, testName, testName, testName, testName, testName, testName, testName, testName
       01:A05C  4F 81     
       01:A05E  4F 81     
       01:A060  4F 81     
       01:A062  4F 81     
       01:A064  4F 81     
       01:A066  4F 81     
       01:A068  4F 81     
       01:A06A  4F 81     
   21                     ;puzzle sprites
   22  01:A06C  00 00 00    .db $00, $00, $00, $00
       01:A06F  00        
   23  01:A070  00 00 00    .db $00, $00, $00, $00
       01:A073  00        
   24  01:A074  00 00 00    .db $00, $00, $00, $00
       01:A077  00        
   25  01:A078  00 00 00    .db $00, $00, $00, $00
       01:A07B  00        
   26  01:A07C  00 00 00    .db $00, $00, $00, $00
       01:A07F  00        
   27  01:A080  00 00 00    .db $00, $00, $00, $00
       01:A083  00        
   28  01:A084  00 00 00    .db $00, $00, $00, $00
       01:A087  00        
   29  01:A088  00 00 00    .db $00, $00, $00, $00
       01:A08B  00        
   30  01:A08C  00 00 00    .db $00, $00, $00, $00
       01:A08F  00        
   31  01:A090  00 00 00    .db $00, $00, $00, $00
       01:A093  00        
   32  01:A094  00 00 00    .db $00, $00, $00, $00
       01:A097  00        
   33  01:A098  00 00 00    .db $00, $00, $00, $00
       01:A09B  00        
   34  01:A09C  00 00 00    .db $00, $00, $00, $00
       01:A09F  00        
   35  01:A0A0  00 00 00    .db $00, $00, $00, $00
       01:A0A3  00        
   36  01:A0A4  00 00 00    .db $00, $00, $00, $00
       01:A0A7  00        
   37  01:A0A8  00 00 00    .db $00, $00, $00, $00
       01:A0AB  00        
   38  01:A0AC  00 00 00    .db $00, $00, $00, $00
       01:A0AF  00        
   39  01:A0B0  00 00 00    .db $00, $00, $00, $00
       01:A0B3  00        
   40  01:A0B4  00 00 00    .db $00, $00, $00, $00
       01:A0B7  00        
   41  01:A0B8  00 00 00    .db $00, $00, $00, $00
       01:A0BB  00        
   42  01:A0BC  00 00 00    .db $00, $00, $00, $00
       01:A0BF  00        
   43  01:A0C0  00 00 00    .db $00, $00, $00, $00
       01:A0C3  00        
   44  01:A0C4  00 00 00    .db $00, $00, $00, $00
       01:A0C7  00        
   45  01:A0C8  00 00 00    .db $00, $00, $00, $00
       01:A0CB  00        
   46  01:A0CC  00 00 00    .db $00, $00, $00, $00
       01:A0CF  00        
   47  01:A0D0  00 00 00    .db $00, $00, $00, $00
       01:A0D3  00        
   48  01:A0D4  00 00 00    .db $00, $00, $00, $00
       01:A0D7  00        
   49                       
   50                       
   51           BFFA        .org $BFFA     ;first of the three vectors starts here
   52  01:BFFA  F4 D3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   53                                        ;processor will jump to the label NMI:
   54  01:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   55                                        ;to the label RESET:
   56  01:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank1.asm
   24                       .include "Banks/Bank1.asm"
    1           0002        .bank 2
    2           8000        .org $8000
    3                       
#[3]   Puzzles/frog.asm
    4                       .include "Puzzles/frog.asm"
    1  02:8000            frog:
    2  02:8000  02 62 00    .db $02, $62, $00, $19
       02:8003  19        
    3  02:8004  00 00 00    .db $00, $00, $00, $00, $18, $30, $24, $48, $2C, $68, $1F, $F0, $3F, $F8, $7F, $FC, $7F, $FC, $60, $0C, $33, $98, $18, $30, $0F, $E0, $3C, $78, $78, $3C
       02:8007  00 18 30  
       02:800A  24 48 2C  
       02:800D  68 1F F0  
       02:8010  3F F8 7F  
       02:8013  FC 7F FC  
       02:8016  60 0C 33  
       02:8019  98 18 30  
       02:801C  0F E0 3C  
       02:801F  78 78 3C  
    4  02:8022  00 FF 13    .db $00, $FF, $13, $FF, $25, $20, $FF, $22, $41, $FF, $45, $10, $FF, $26, $FF, $11, $40, $FF, $11, $40, $FF, $11, $40, $FF, $26, $FF, $45, $10, $FF, $22, $41, $FF, $25, $20, $FF, $13, $FF, $00, $FF
       02:8025  FF 25 20  
       02:8028  FF 22 41  
       02:802B  FF 45 10  
       02:802E  FF 26 FF  
       02:8031  11 40 FF  
       02:8034  11 40 FF  
       02:8037  11 40 FF  
       02:803A  26 FF 45  
       02:803D  10 FF 22  
       02:8040  41 FF 25  
       02:8043  20 FF 13  
       02:8046  FF 00 FF  
    5  02:8049  00 FF 00    .db $00, $FF, $00, $FF, $22, $FF, $11, $11, $FF, $12, $21, $FF, $90, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $22, $FF, $23, $20, $FF, $22, $FF, $70, $FF, $44, $FF, $44, $FF
       02:804C  FF 22 FF  
       02:804F  11 11 FF  
       02:8052  12 21 FF  
       02:8055  90 FF B0  
       02:8058  FF D0 FF  
       02:805B  D0 FF 22  
       02:805E  FF 23 20  
       02:8061  FF 22 FF  
       02:8064  70 FF 44  
       02:8067  FF 44 FF  
    6  02:806A            frogImage:
    7  02:806A  55 55 55   .db $55, $55, $55, $55, $55, $55, $55, $55, $69, $55, $A5, $56, $F9, $5B, $E5, $5B, $25, $63, $95, $5A, $AA, $A9, $55, $AA, $22, $A9, $5A, $AA, $AA, $A9, $6A, $AA, $AA, $A5, $A0, $00, $02, $95, $A0, $54, $29, $55, $A0, $02, $95, $55, $AA, $A9, $55, $6A, $BF, $AA, $56, $AB, $FF, $AA, $40, $FF
       02:806D  55 55 55  
       02:8070  55 55 69  
       02:8073  55 A5 56  
       02:8076  F9 5B E5  
       02:8079  5B 25 63  
       02:807C  95 5A AA  
       02:807F  A9 55 AA  
       02:8082  22 A9 5A  
       02:8085  AA AA A9  
       02:8088  6A AA AA  
       02:808B  A5 A0 00  
       02:808E  02 95 A0  
       02:8091  54 29 55  
       02:8094  A0 02 95  
       02:8097  55 AA A9  
       02:809A  55 6A BF  
       02:809D  AA 56 AB  
       02:80A0  FF AA 40  
       02:80A3  FF        
    8  02:80A4            frogName:
    9  02:80A4  04 0F 1B    .db $04, $0F, $1B, $18, $10, $FF
       02:80A7  18 10 FF  
#[2]   Banks/Bank1.asm
    5                     
    6           0003        .bank 3
    7           A000        .org $A000
    8                      
    9                     ;puzzles
   10  03:A000  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A002  00 80     
       03:A004  00 80     
       03:A006  00 80     
       03:A008  00 80     
       03:A00A  00 80     
       03:A00C  00 80     
       03:A00E  00 80     
       03:A010  00 80     
   11  03:A012  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A014  00 80     
       03:A016  00 80     
       03:A018  00 80     
       03:A01A  00 80     
       03:A01C  00 80     
       03:A01E  00 80     
       03:A020  00 80     
       03:A022  00 80     
   12  03:A024  00 80       .word frog, frog, frog, frog, frog, frog, frog, frog, frog
       03:A026  00 80     
       03:A028  00 80     
       03:A02A  00 80     
       03:A02C  00 80     
       03:A02E  00 80     
       03:A030  00 80     
       03:A032  00 80     
       03:A034  00 80     
   13                     ;puzzle names
   14  03:A036  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A038  A4 80     
       03:A03A  A4 80     
       03:A03C  A4 80     
       03:A03E  A4 80     
       03:A040  A4 80     
       03:A042  A4 80     
       03:A044  A4 80     
       03:A046  A4 80     
   15  03:A048  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A04A  A4 80     
       03:A04C  A4 80     
       03:A04E  A4 80     
       03:A050  A4 80     
       03:A052  A4 80     
       03:A054  A4 80     
       03:A056  A4 80     
       03:A058  A4 80     
   16  03:A05A  A4 80       .word frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName, frogName
       03:A05C  A4 80     
       03:A05E  A4 80     
       03:A060  A4 80     
       03:A062  A4 80     
       03:A064  A4 80     
       03:A066  A4 80     
       03:A068  A4 80     
       03:A06A  A4 80     
   17                     ;puzzle sprites
   18  03:A06C  00 00 00    .db $00, $00, $00, $00
       03:A06F  00        
   19  03:A070  00 00 00    .db $00, $00, $00, $00
       03:A073  00        
   20  03:A074  00 00 00    .db $00, $00, $00, $00
       03:A077  00        
   21  03:A078  00 00 00    .db $00, $00, $00, $00
       03:A07B  00        
   22  03:A07C  00 00 00    .db $00, $00, $00, $00
       03:A07F  00        
   23  03:A080  00 00 00    .db $00, $00, $00, $00
       03:A083  00        
   24  03:A084  00 00 00    .db $00, $00, $00, $00
       03:A087  00        
   25  03:A088  00 00 00    .db $00, $00, $00, $00
       03:A08B  00        
   26  03:A08C  00 00 00    .db $00, $00, $00, $00
       03:A08F  00        
   27  03:A090  00 00 00    .db $00, $00, $00, $00
       03:A093  00        
   28  03:A094  00 00 00    .db $00, $00, $00, $00
       03:A097  00        
   29  03:A098  00 00 00    .db $00, $00, $00, $00
       03:A09B  00        
   30  03:A09C  00 00 00    .db $00, $00, $00, $00
       03:A09F  00        
   31  03:A0A0  00 00 00    .db $00, $00, $00, $00
       03:A0A3  00        
   32  03:A0A4  00 00 00    .db $00, $00, $00, $00
       03:A0A7  00        
   33  03:A0A8  00 00 00    .db $00, $00, $00, $00
       03:A0AB  00        
   34  03:A0AC  00 00 00    .db $00, $00, $00, $00
       03:A0AF  00        
   35  03:A0B0  00 00 00    .db $00, $00, $00, $00
       03:A0B3  00        
   36  03:A0B4  00 00 00    .db $00, $00, $00, $00
       03:A0B7  00        
   37  03:A0B8  00 00 00    .db $00, $00, $00, $00
       03:A0BB  00        
   38  03:A0BC  00 00 00    .db $00, $00, $00, $00
       03:A0BF  00        
   39  03:A0C0  00 00 00    .db $00, $00, $00, $00
       03:A0C3  00        
   40  03:A0C4  00 00 00    .db $00, $00, $00, $00
       03:A0C7  00        
   41  03:A0C8  00 00 00    .db $00, $00, $00, $00
       03:A0CB  00        
   42  03:A0CC  00 00 00    .db $00, $00, $00, $00
       03:A0CF  00        
   43  03:A0D0  00 00 00    .db $00, $00, $00, $00
       03:A0D3  00        
   44  03:A0D4  00 00 00    .db $00, $00, $00, $00
       03:A0D7  00        
   45                       
   46                       
   47           BFFA        .org $BFFA     ;first of the three vectors starts here
   48  03:BFFA  F4 D3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   49                                        ;processor will jump to the label NMI:
   50  03:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   51                                        ;to the label RESET:
   52  03:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
#[2]   Banks/Bank2.asm
   25                       .include "Banks/Bank2.asm"
    1           0004        .bank 4
    2           8000        .org $8000
    3                       
#[3]   Puzzles/cat.asm
    4                       .include "Puzzles/cat.asm"
    1  04:8000            cat:
    2  04:8000  02 7E 00    .db $02, $7E, $00, $2B
       04:8003  2B        
    3  04:8004  00 00 0C    .db $00, $00, $0C, $60, $1E, $F0, $3E, $F8, $3F, $F8, $7F, $FC, $7F, $FC, $47, $C4, $7B, $BC, $7F, $FC, $7C, $7C, $76, $DC, $39, $38, $1F, $F0, $00, $00
       04:8007  60 1E F0  
       04:800A  3E F8 3F  
       04:800D  F8 7F FC  
       04:8010  7F FC 47  
       04:8013  C4 7B BC  
       04:8016  7F FC 7C  
       04:8019  7C 76 DC  
       04:801C  39 38 1F  
       04:801F  F0 00 00  
    4  04:8022  00 FF 70    .db $00, $FF, $70, $FF, $54, $FF, $65, $FF, $23, $60, $FF, $13, $70, $FF, $11, $80, $FF, $26, $FF, $11, $80, $FF, $13, $70, $FF, $23, $60, $FF, $65, $FF, $54, $FF, $70, $FF, $00, $FF
       04:8025  FF 54 FF  
       04:8028  65 FF 23  
       04:802B  60 FF 13  
       04:802E  70 FF 11  
       04:8031  80 FF 26  
       04:8034  FF 11 80  
       04:8037  FF 13 70  
       04:803A  FF 23 60  
       04:803D  FF 65 FF  
       04:8040  54 FF 70  
       04:8043  FF 00 FF  
    5  04:8046  00 FF 22    .db $00, $FF, $22, $FF, $44, $FF, $55, $FF, $B0, $FF, $D0, $FF, $D0, $FF, $15, $10, $FF, $43, $40, $FF, $D0, $FF, $55, $FF, $32, $23, $FF, $31, $30, $FF, $90, $FF, $00, $FF
       04:8049  FF 44 FF  
       04:804C  55 FF B0  
       04:804F  FF D0 FF  
       04:8052  D0 FF 15  
       04:8055  10 FF 43  
       04:8058  40 FF D0  
       04:805B  FF 55 FF  
       04:805E  32 23 FF  
       04:8061  31 30 FF  
       04:8064  90 FF 00  
       04:8067  FF        
    6  04:8068            catImage:
    7  04:8068  55 55 55   .db $55, $55, $55, $55, $56, $95, $A5, $55, $6A, $9A, $A5, $56, $AA, $6A, $A5, $5A, $AA, $AA, $95, $AA, $66, $6A, $96, $AA, $9A, $AA, $58, $0A, $E8, $09, $6A, $8F, $CA, $A5, $9A, $FF, $E9, $96, $AF, $57, $EA, $59, $CF, $7C, $D9, $5F, $C3, $0F, $D5, $5F, $FF, $FD, $55, $55, $55, $55, $40, $FF
       04:806B  55 56 95  
       04:806E  A5 55 6A  
       04:8071  9A A5 56  
       04:8074  AA 6A A5  
       04:8077  5A AA AA  
       04:807A  95 AA 66  
       04:807D  6A 96 AA  
       04:8080  9A AA 58  
       04:8083  0A E8 09  
       04:8086  6A 8F CA  
       04:8089  A5 9A FF  
       04:808C  E9 96 AF  
       04:808F  57 EA 59  
       04:8092  CF 7C D9  
       04:8095  5F C3 0F  
       04:8098  D5 5F FF  
       04:809B  FD 55 55  
       04:809E  55 55 40  
       04:80A1  FF        
    8  04:80A2            catName:
    9  04:80A2  03 0C 0A    .db $03, $0C, $0A, $1D, $FF
       04:80A5  1D FF     
#[2]   Banks/Bank2.asm
    5                     
    6           0005        .bank 5
    7           A000        .org $A000
    8                       
    9                     ;puzzles
   10  05:A000  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A002  00 80     
       05:A004  00 80     
       05:A006  00 80     
       05:A008  00 80     
       05:A00A  00 80     
       05:A00C  00 80     
       05:A00E  00 80     
       05:A010  00 80     
   11  05:A012  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat 
       05:A014  00 80     
       05:A016  00 80     
       05:A018  00 80     
       05:A01A  00 80     
       05:A01C  00 80     
       05:A01E  00 80     
       05:A020  00 80     
       05:A022  00 80     
   12  05:A024  00 80       .word cat, cat, cat, cat, cat, cat, cat, cat, cat
       05:A026  00 80     
       05:A028  00 80     
       05:A02A  00 80     
       05:A02C  00 80     
       05:A02E  00 80     
       05:A030  00 80     
       05:A032  00 80     
       05:A034  00 80     
   13                     ;puzzle names
   14  05:A036  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A038  A2 80     
       05:A03A  A2 80     
       05:A03C  A2 80     
       05:A03E  A2 80     
       05:A040  A2 80     
       05:A042  A2 80     
       05:A044  A2 80     
       05:A046  A2 80     
   15  05:A048  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName 
       05:A04A  A2 80     
       05:A04C  A2 80     
       05:A04E  A2 80     
       05:A050  A2 80     
       05:A052  A2 80     
       05:A054  A2 80     
       05:A056  A2 80     
       05:A058  A2 80     
   16  05:A05A  A2 80       .word catName, catName, catName, catName, catName, catName, catName, catName, catName
       05:A05C  A2 80     
       05:A05E  A2 80     
       05:A060  A2 80     
       05:A062  A2 80     
       05:A064  A2 80     
       05:A066  A2 80     
       05:A068  A2 80     
       05:A06A  A2 80     
   17                     ;puzzle sprites
   18  05:A06C  00 00 00    .db $00, $00, $00, $00
       05:A06F  00        
   19  05:A070  00 00 00    .db $00, $00, $00, $00
       05:A073  00        
   20  05:A074  00 00 00    .db $00, $00, $00, $00
       05:A077  00        
   21  05:A078  00 00 00    .db $00, $00, $00, $00
       05:A07B  00        
   22  05:A07C  00 00 00    .db $00, $00, $00, $00
       05:A07F  00        
   23  05:A080  00 00 00    .db $00, $00, $00, $00
       05:A083  00        
   24  05:A084  00 00 00    .db $00, $00, $00, $00
       05:A087  00        
   25  05:A088  00 00 00    .db $00, $00, $00, $00
       05:A08B  00        
   26  05:A08C  00 00 00    .db $00, $00, $00, $00
       05:A08F  00        
   27  05:A090  00 00 00    .db $00, $00, $00, $00
       05:A093  00        
   28  05:A094  00 00 00    .db $00, $00, $00, $00
       05:A097  00        
   29  05:A098  00 00 00    .db $00, $00, $00, $00
       05:A09B  00        
   30  05:A09C  00 00 00    .db $00, $00, $00, $00
       05:A09F  00        
   31  05:A0A0  00 00 00    .db $00, $00, $00, $00
       05:A0A3  00        
   32  05:A0A4  00 00 00    .db $00, $00, $00, $00
       05:A0A7  00        
   33  05:A0A8  00 00 00    .db $00, $00, $00, $00
       05:A0AB  00        
   34  05:A0AC  00 00 00    .db $00, $00, $00, $00
       05:A0AF  00        
   35  05:A0B0  00 00 00    .db $00, $00, $00, $00
       05:A0B3  00        
   36  05:A0B4  00 00 00    .db $00, $00, $00, $00
       05:A0B7  00        
   37  05:A0B8  00 00 00    .db $00, $00, $00, $00
       05:A0BB  00        
   38  05:A0BC  00 00 00    .db $00, $00, $00, $00
       05:A0BF  00        
   39  05:A0C0  00 00 00    .db $00, $00, $00, $00
       05:A0C3  00        
   40  05:A0C4  00 00 00    .db $00, $00, $00, $00
       05:A0C7  00        
   41  05:A0C8  00 00 00    .db $00, $00, $00, $00
       05:A0CB  00        
   42  05:A0CC  00 00 00    .db $00, $00, $00, $00
       05:A0CF  00        
   43  05:A0D0  00 00 00    .db $00, $00, $00, $00
       05:A0D3  00        
   44  05:A0D4  00 00 00    .db $00, $00, $00, $00
       05:A0D7  00        
   45                     
   46           BFFA        .org $BFFA     ;first of the three vectors starts here
   47  05:BFFA  F4 D3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
   48                                        ;processor will jump to the label NMI:
   49  05:BFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
   50                                        ;to the label RESET:
   51  05:BFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
#[1]   Picross.asm
   26                     
   27           0006        .bank 6
   28           C000        .org $C000 
   29                     
   30                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   31                     ;;     Initialization       ;;
   32                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   33                     
#[2]   Routines/Common/Init.asm
   34                       .include "Routines/Common/Init.asm"
    1  06:C000            RESET:
    2  06:C000  78          SEI          ; disable IRQs
    3  06:C001  D8          CLD          ; disable decimal mode
    4  06:C002  A2 40       LDX #$40
    5  06:C004  8E 17 40    STX $4017    ; disable APU frame IRQ
    6  06:C007  A2 FF       LDX #$FF
    7  06:C009  9A          TXS          ; Set up stack
    8  06:C00A  E8          INX          ; now X = 0
    9  06:C00B  8E 00 20    STX $2000    ; disable NMI
   10  06:C00E  8E 01 20    STX $2001    ; disable rendering
   11  06:C011  8E 10 40    STX $4010    ; disable DMC IRQs
   12                     
   13  06:C014            vblankwait1:       ; First wait for vblank to make sure PPU is ready
   14  06:C014  2C 02 20    BIT $2002
   15  06:C017  10 FB       BPL vblankwait1
   16                     
   17  06:C019            clrmem:
   18  06:C019  A9 00       LDA #$00
   19  06:C01B  9D 00 00    STA $0000, x
   20  06:C01E  9D 00 01    STA $0100, x
   21  06:C021  9D 00 03    STA $0300, x
   22  06:C024  9D 00 04    STA $0400, x
   23  06:C027  9D 00 05    STA $0500, x
   24  06:C02A  9D 00 06    STA $0600, x
   25  06:C02D  9D 00 07    STA $0700, x
   26  06:C030  A9 FE       LDA #$FE
   27  06:C032  9D 00 02    STA $0200, x
   28  06:C035  E8          INX
   29  06:C036  D0 E1       BNE clrmem
   30                        
   31  06:C038  20 F2 CF    JSR ResetMapper
   32  06:C03B  A9 1E       LDA #$1E ; vertical mirroring, fixed $C000, 8 KB CHR pages
   33  06:C03D  20 F6 CF    JSR SetMapperControls
   34                       
   35  06:C040  20 33 D0    JSR ResetBanks
   36                       
   37  06:C043            vblankwait2:      ; Second wait for vblank, PPU is ready after this
   38  06:C043  2C 02 20    BIT $2002
   39  06:C046  10 FB       BPL vblankwait2
#[1]   Picross.asm
   35                     
   36  06:C048  A9 00       LDA #TITLE_IDX
   37  06:C04A  A2 00       LDX #$00
   38  06:C04C  20 B8 CC    JSR ChangeGameMode
   39  06:C04F  20 77 CF    JSR InitPPUControl
   40                       
   41                     
   42                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   43                     ;;     Main Program         ;;
   44                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   45                     
   46  06:C052            Forever:
   47                     
   48  06:C052  EE 0C 00    INC sleeping
   49                     
   50  06:C055            .loop
   51  06:C055  AD 0C 00    LDA sleeping
   52  06:C058  D0 FB       BNE .loop
   53                     
   54  06:C05A  EE 0A 00    INC time  
   55  06:C05D  AD C8 00    LDA pauseState
   56  06:C060  D0 03       BNE .skipScaleUpdate
   57  06:C062  EE 0B 00    INC scaledTime
   58  06:C065            .skipScaleUpdate:
   59  06:C065  20 6B C0    JSR GameLoop
   60                     
   61                     
   62  06:C068  4C 52 C0    JMP Forever     ;jump back to Forever, infinite loop
   63                       
   64                     ;; dynamic jump table
   65                     
   66  06:C06B            GameLoop:
   67                     
   68                       MACROCallDynamicJump game_mode
                          
       06:C06B  AD 0E 00    LDA game_mode
       06:C06E  20 89 CD    JSR Dynamic_Jump
                                  
   69                       ;; we'll pop the return address here as the table index, so 
   70                       ;; the routine we pick will return us to whatever called Game Loop
   71                       ;; when it returns
   72                     
   73  06:C071            GameLoopJumpTable:
   74                     
   75  06:C071  77 C0       .word UpdateTitle
   76  06:C073  C0 C3       .word UpdateGame
   77  06:C075  BE CA       .word UpdateGameOver
   78                       
   79                     
   80                       ;;RTS is called in the subroutine
   81                     
   82                       
#[2]   Routines/Game_States/UpdateTitle.asm
   83                       .include "Routines/Game_States/UpdateTitle.asm"
    1  06:C077            UpdateTitle:
    2                     
    3  06:C077  AD 10 00    LDA NMI_locks
    4  06:C07A  F0 01       BEQ .unlocked
    5                       
    6  06:C07C  60          RTS
    7                       
    8  06:C07D            .unlocked:
    9                     
   10  06:C07D  20 81 C0    JSR DoUpdateTitle  
   11  06:C080  60          RTS
   12                       
   13  06:C081            DoUpdateTitle:
   14                     
   15  06:C081  AD 0F 00    LDA mode_state
   16  06:C084  20 89 CD    JSR Dynamic_Jump
   17                         
   18  06:C087            UpdateTitleJumpTable:
   19                     
   20  06:C087  93 C0       .word UpdateTitleInit
   21  06:C089  C9 C0       .word UpdateBankSelection
   22  06:C08B  FA C0       .word UpdateScroll
   23  06:C08D  23 C1       .word UpdatePuzzleSelection
   24  06:C08F  7E C1       .word UpdateScrollBack
   25  06:C091  9D C1       .word UpdateTitleExit
   26                     
   27                       
   28                     ;;title should have two steps- the bank selection and the puzzle selection
   29                     ;;top half of screen can be used as the title screen, and the bottom half will have the selectable options
   30                     ;;
   31                     ;;starting options list: BANK 0, BANK 1, BANK 2
   32                     ;;select one, then scroll over to the right, with numbers for puzzles 
   33                     
   34  06:C093            UpdateTitleInit:
   35                     
   36  06:C093  20 53 CF    JSR TurnOnSprites
   37                       
   38  06:C096  AD 00 70    LDA hasContinue
   39  06:C099  F0 20       BEQ .skipContinueText
   40                       MACROAddPPUStringEntryTable #$2B, #$4D, #DRAW_HORIZONTAL, ContinueText
                           
       06:C09B  A9 01       LDA #$01
       06:C09D  8D 23 00    STA PPU_PendingWrite
       06:C0A0  A9 2B       LDA #$2B
       06:C0A2  20 0B CF    JSR WriteToPPUString
       06:C0A5  A9 4D       LDA #$4D
       06:C0A7  20 0B CF    JSR WriteToPPUString
       06:C0AA  A9 20       LDA #$20
       06:C0AC  09 00       ORA #DRAW_HORIZONTAL
       06:C0AE  20 0B CF    JSR WriteToPPUString
       06:C0B1  A9 B7       LDA #LOW(ContinueText)
       06:C0B3  20 0B CF    JSR WriteToPPUString
       06:C0B6  A9 C3       LDA #HIGH(ContinueText)
       06:C0B8  20 0B CF    JSR WriteToPPUString
                           
   41                       
   42  06:C0BB            .skipContinueText:
   43                       
   44  06:C0BB  A9 00       LDA #$00
   45  06:C0BD  8D C5 00    STA mouse_index
   46  06:C0C0  A9 00       LDA #$00
   47  06:C0C2  8D C6 00    STA mouse_index+1
   48                     
   49  06:C0C5            .changeModeState:
   50                     
   51  06:C0C5  EE 0F 00    INC mode_state
   52  06:C0C8            .leave:
   53  06:C0C8  60          RTS
   54                       
   55  06:C0C9            UpdateBankSelection:
   56                     
   57  06:C0C9  20 5B C2    JSR UpdateBankPointer
   58                       
   59  06:C0CC  AD 1C 00    LDA gamepadPressed
   60  06:C0CF  29 01       AND #GAMEPAD_A
   61  06:C0D1  F0 26       BEQ .leave
   62                       
   63  06:C0D3            .changeModeState:
   64                       
   65  06:C0D3  AD C5 00    LDA mouse_index
   66  06:C0D6  C9 03       CMP #$03
   67  06:C0D8  D0 0F       BNE .setBank
   68                       
   69  06:C0DA  EE 0F 00    INC mode_state
   70  06:C0DD  EE 0F 00    INC mode_state
   71  06:C0E0  EE 0F 00    INC mode_state
   72                       
   73                       ;;load bank
   74  06:C0E3  20 19 C3    JSR LoadBank
   75                       
   76  06:C0E6  4C F3 C0    JMP .goToNext
   77                       
   78  06:C0E9            .setBank:
   79  06:C0E9  8D AB 00    STA tempBank
   80  06:C0EC  A9 FF       LDA #$FF
   81  06:C0EE  A2 01       LDX #$01
   82  06:C0F0  20 3D C2    JSR SetSpriteImage
   83                     
   84  06:C0F3            .goToNext:
   85  06:C0F3  EE 0F 00    INC mode_state
   86  06:C0F6  4C F9 C0    JMP .leave
   87                     
   88                     
   89  06:C0F9            .leave:
   90  06:C0F9  60          RTS
   91                       
   92  06:C0FA            UpdateScroll:
   93  06:C0FA  EE 1F 00    INC PPU_ScrollX
   94  06:C0FD  EE 1F 00    INC PPU_ScrollX
   95  06:C100  EE 1F 00    INC PPU_ScrollX
   96  06:C103  EE 1F 00    INC PPU_ScrollX
   97  06:C106  D0 1A       BNE .leave
   98  06:C108  AD 21 00    LDA PPU_ScrollNT
   99  06:C10B  49 01       EOR #%00000001
  100  06:C10D  8D 21 00    STA PPU_ScrollNT
  101                       
  102  06:C110            .changeModeState:
  103  06:C110  A9 01       LDA #$01
  104  06:C112  A2 01       LDX #$01
  105  06:C114  20 3D C2    JSR SetSpriteImage
  106  06:C117  20 FF C1    JSR InitPuzzlePointer
  107  06:C11A  EE 0F 00    INC mode_state
  108  06:C11D  A9 FF       LDA #$FF
  109  06:C11F  8D AC 00    STA tempPuzz
  110  06:C122            .leave:
  111  06:C122  60          RTS
  112                       
  113  06:C123            UpdatePuzzleSelection:
  114                     
  115  06:C123  20 AA C2    JSR UpdatePuzzlePointer
  116                       
  117  06:C126  AD C5 00    LDA mouse_index
  118  06:C129  0A          ASL A
  119  06:C12A  0A          ASL A
  120  06:C12B  0A          ASL A
  121  06:C12C  18          CLC
  122  06:C12D  6D C5 00    ADC mouse_index
  123  06:C130  6D C6 00    ADC mouse_index+1
  124  06:C133  CD AC 00    CMP tempPuzz
  125  06:C136  F0 06       BEQ .checkButtonPresses       ;no change
  126  06:C138  8D AC 00    STA tempPuzz
  127                       
  128  06:C13B  20 26 C3    JSR UpdatePuzzleInfo
  129                       
  130  06:C13E            .checkButtonPresses:
  131                     
  132  06:C13E  AD 1C 00    LDA gamepadPressed
  133  06:C141  29 02       AND #GAMEPAD_B
  134  06:C143  D0 10       BNE .changeToScrollBack
  135  06:C145  AD 1C 00    LDA gamepadPressed
  136  06:C148  29 09       AND #GAMEPAD_CONFIRM
  137  06:C14A  F0 31       BEQ .leave
  138                       
  139  06:C14C  EE 0F 00    INC mode_state
  140  06:C14F  EE 0F 00    INC mode_state
  141  06:C152  4C 7D C1    JMP .leave
  142                       
  143  06:C155            .changeToScrollBack:
  144                      
  145  06:C155  A9 FF       LDA #$FF
  146  06:C157  A2 01       LDX #$01
  147  06:C159  20 3D C2    JSR SetSpriteImage
  148  06:C15C  20 F7 C1    JSR InitBankPointer
  149  06:C15F  AD 07 70    LDA bank_index
  150  06:C162  8D C5 00    STA mouse_index
  151  06:C165  20 9D C2    JSR SetBankPointerFromIndex
  152                       
  153  06:C168  A9 00       LDA #$00
  154  06:C16A  8D 20 00    STA PPU_ScrollY
  155  06:C16D  A9 FC       LDA #$FC
  156  06:C16F  8D 1F 00    STA PPU_ScrollX
  157  06:C172  AD 21 00    LDA PPU_ScrollNT
  158  06:C175  29 FE       AND #$FE
  159  06:C177  8D 21 00    STA PPU_ScrollNT
  160                       
  161  06:C17A  EE 0F 00    INC mode_state
  162  06:C17D            .leave:
  163  06:C17D  60          RTS
  164                       
  165  06:C17E            UpdateScrollBack:
  166                     
  167  06:C17E  CE 1F 00    DEC PPU_ScrollX
  168  06:C181  CE 1F 00    DEC PPU_ScrollX
  169  06:C184  CE 1F 00    DEC PPU_ScrollX
  170  06:C187  CE 1F 00    DEC PPU_ScrollX
  171  06:C18A  D0 10       BNE .leave
  172                       
  173  06:C18C            .changeModeState:
  174                     
  175  06:C18C  A9 01       LDA #$01
  176  06:C18E  A2 01       LDX #$01
  177  06:C190  20 3D C2    JSR SetSpriteImage
  178  06:C193  CE 0F 00    DEC mode_state
  179  06:C196  CE 0F 00    DEC mode_state
  180  06:C199  CE 0F 00    DEC mode_state
  181                       
  182  06:C19C            .leave:
  183  06:C19C  60          RTS
  184                       
  185  06:C19D            UpdateTitleExit:
  186                     
  187                       ;;reset screen scroll
  188  06:C19D  A9 00       LDA #$00
  189  06:C19F  8D 1F 00    STA PPU_ScrollX
  190  06:C1A2  8D 21 00    STA PPU_ScrollNT
  191                       
  192  06:C1A5  A9 20       LDA #%00100000
  193  06:C1A7  8D 00 00    STA temp1
  194                       
  195  06:C1AA  AD C5 00    LDA mouse_index
  196  06:C1AD  C9 03       CMP #$03
  197  06:C1AF  D0 06       BNE .loadPuzzle
  198                       
  199  06:C1B1  0E 00 00    ASL temp1
  200  06:C1B4  4C CB C1    JMP .setupPuzzle
  201                       
  202  06:C1B7            .loadPuzzle:
  203                       ;; we can also pick out the puzzle index
  204                       ;; we have the mouse indexes - one vert, one hori
  205                       ;; take vert, mult by 9- alternatively, mult by 8, add index 
  206                       ;; IE - ind = 1, mult 8 = 8, add 1 = 9
  207                       ;; add X index
  208  06:C1B7  AD AB 00    LDA tempBank
  209  06:C1BA  8D 07 70    STA bank_index
  210  06:C1BD  20 19 C3    JSR LoadBank
  211                       
  212  06:C1C0  AD AC 00    LDA tempPuzz
  213  06:C1C3  8D 08 70    STA puzzle_index
  214  06:C1C6  A9 00       LDA #$00
  215  06:C1C8  8D 00 70    STA hasContinue
  216                     
  217                     
  218  06:C1CB            .setupPuzzle:
  219                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C1CB  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C1CD  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C1CF  8E 16 00          STX table_address
       06:C1D2  8D 17 00          STA table_address+1
                                  
  220                       MACROGetDoubleIndex puzzle_index
                          
       06:C1D5  AD 08 70          LDA puzzle_index
       06:C1D8  0A                ASL A
       06:C1D9  A8                TAY
                                  
  221  06:C1DA  20 AF CD    JSR GetTableAtIndex
  222                       MACROGetPointer table_address, puzzle_address
                          
       06:C1DD  AD 16 00          LDA table_address
       06:C1E0  8D AD 00          STA puzzle_address
       06:C1E3  AD 17 00          LDA table_address+1
       06:C1E6  8D AE 00          STA puzzle_address+1
                          
  223                     
  224  06:C1E9  A0 00       LDY #$00
  225  06:C1EB  B1 AD       LDA [puzzle_address], y
  226  06:C1ED  0D 00 00    ORA temp1
  227                       
  228  06:C1F0  AA          TAX
  229                       
  230                     
  231  06:C1F1  A9 01       LDA #GAME_IDX
  232  06:C1F3  20 B8 CC    JSR ChangeGameMode
  233                       
  234  06:C1F6            .leave
  235  06:C1F6  60          RTS
  236                       
  237  06:C1F7            InitBankPointer:
  238                     
  239  06:C1F7  A2 A0       LDX #$A0
  240  06:C1F9  A9 60       LDA #$60
  241  06:C1FB  20 12 C2    JSR InitPointer
  242                       
  243  06:C1FE  60          RTS  
  244                       
  245  06:C1FF            InitPuzzlePointer:
  246                       
  247  06:C1FF  A2 AE       LDX #$AE
  248  06:C201  A9 10       LDA #$10
  249  06:C203  20 12 C2    JSR InitPointer
  250                       
  251  06:C206  60          RTS
  252                     
  253  06:C207            ResetMouseIndex:
  254                     
  255  06:C207  A9 00       LDA #$00
  256  06:C209  8D C5 00    STA mouse_index
  257  06:C20C  A9 00       LDA #$00
  258  06:C20E  8D C6 00    STA mouse_index+1
  259  06:C211  60          RTS
  260                     
  261  06:C212            InitPointer:
  262                     
  263  06:C212  20 19 C2    JSR SetPointerPosition
  264  06:C215  20 07 C2    JSR ResetMouseIndex
  265  06:C218  60          RTS  
  266                       
  267  06:C219            SetPointerPosition:
  268                     
  269  06:C219  48          PHA
  270  06:C21A  8A          TXA
  271  06:C21B  A2 01       LDX #$01
  272  06:C21D  20 27 C2    JSR SetSpriteYPosition
  273  06:C220  68          PLA
  274  06:C221  A2 01       LDX #$01
  275  06:C223  20 32 C2    JSR SetSpriteXPosition
  276                      
  277  06:C226  60          RTS
  278                       
  279  06:C227            SetSpriteYPosition:
  280                       
  281  06:C227  48          PHA
  282  06:C228  A9 00       LDA #SPRITE_YPOS
  283  06:C22A  20 48 C2    JSR GetSpriteDataIndexInX
  284  06:C22D  68          PLA
  285  06:C22E  9D 00 02    STA SPRITE_DATA, x
  286  06:C231  60          RTS
  287                       
  288  06:C232            SetSpriteXPosition:  
  289                       
  290  06:C232  48          PHA
  291  06:C233  A9 03       LDA #SPRITE_XPOS
  292  06:C235  20 48 C2    JSR GetSpriteDataIndexInX
  293  06:C238  68          PLA
  294  06:C239  9D 00 02    STA SPRITE_DATA, x 
  295  06:C23C  60          RTS
  296                     
  297  06:C23D            SetSpriteImage:
  298                     
  299                     ;; A has sprite image index we want
  300                     ;; X has the sprite index
  301  06:C23D  48          PHA
  302  06:C23E  A9 01       LDA #SPRITE_ID
  303  06:C240  20 48 C2    JSR GetSpriteDataIndexInX
  304  06:C243  68          PLA
  305  06:C244  9D 00 02    STA SPRITE_DATA, x
  306  06:C247  60          RTS
  307                       
  308  06:C248            GetSpriteDataIndexInX:
  309                     
  310                       ;; A has data index we want to get
  311                       ;; X has sprite index
  312  06:C248  8D 02 00    STA temp3
  313  06:C24B  8A          TXA
  314  06:C24C  0A          ASL A
  315  06:C24D  0A          ASL A
  316  06:C24E  18          CLC
  317  06:C24F  6D 02 00    ADC temp3
  318  06:C252  AA          TAX
  319                       
  320  06:C253  60          RTS  
  321  06:C254            GetSpriteData:
  322                     
  323                       ;;A is data we want
  324                       ;;X is Sprite
  325  06:C254  20 48 C2    JSR GetSpriteDataIndexInX
  326  06:C257  BD 00 02    LDA SPRITE_DATA, x
  327  06:C25A  60          RTS
  328                       
  329  06:C25B            UpdateBankPointer:
  330                      
  331                       ;;bank pointer is 1D, will loop between 0->3
  332  06:C25B  AD 1C 00    LDA gamepadPressed
  333  06:C25E  D0 01       BNE .continue
  334  06:C260            .leaveEarly:
  335  06:C260  60          RTS
  336                       
  337  06:C261            .continue:
  338  06:C261  A9 00       LDA #$00
  339  06:C263  8D 00 00    STA temp1
  340                       
  341  06:C266  A9 02       LDA #$02
  342  06:C268  8D 01 00    STA temp2
  343                       
  344  06:C26B  AD 00 70    LDA hasContinue
  345  06:C26E  F0 05       BEQ .parseInputs
  346  06:C270  A9 03       LDA #$03
  347  06:C272  8D 01 00    STA temp2
  348                       
  349  06:C275            .parseInputs:
  350  06:C275  AD 1C 00    LDA gamepadPressed
  351  06:C278  29 30       AND #GAMEPAD_VERT
  352  06:C27A  F0 E4       BEQ .leaveEarly
  353  06:C27C  0A          ASL A
  354  06:C27D  0A          ASL A
  355  06:C27E            .checkDown:
  356  06:C27E  0A          ASL A
  357  06:C27F  90 03       BCC .checkUp
  358  06:C281  EE 00 00    INC temp1
  359  06:C284            .checkUp:
  360  06:C284  0A          ASL A
  361  06:C285  90 03       BCC .move
  362  06:C287  CE 00 00    DEC temp1
  363  06:C28A            .move:
  364                       
  365  06:C28A  AD C5 00    LDA mouse_index
  366  06:C28D  18          CLC
  367  06:C28E  6D 00 00    ADC temp1
  368  06:C291  CD 01 00    CMP temp2
  369  06:C294  F0 04       BEQ .skipMod
  370  06:C296  90 02       BCC .skipMod
  371  06:C298  A9 00       LDA #$00
  372  06:C29A            .skipMod:
  373  06:C29A  8D C5 00    STA mouse_index
  374                       ;; mult mouse_index by 16
  375  06:C29D            SetBankPointerFromIndex:
  376                     
  377  06:C29D  0A          ASL A
  378  06:C29E  0A          ASL A
  379  06:C29F  0A          ASL A
  380  06:C2A0  0A          ASL A
  381  06:C2A1  18          CLC
  382  06:C2A2  69 A0       ADC #$A0
  383  06:C2A4  A2 01       LDX #$01
  384  06:C2A6  20 27 C2    JSR SetSpriteYPosition
  385                     
  386  06:C2A9            .leave:
  387                       
  388  06:C2A9  60          RTS
  389                       
  390  06:C2AA            UpdatePuzzlePointer:
  391                     
  392                       ;;puzzle pointer is 2D, will loop between 0-9 and 0-2
  393  06:C2AA  AD 1C 00    LDA gamepadPressed
  394  06:C2AD  F0 69       BEQ .leave 
  395                       
  396  06:C2AF  A9 00       LDA #$00
  397  06:C2B1  8D 00 00    STA temp1
  398  06:C2B4  8D 01 00    STA temp2
  399                       
  400  06:C2B7            .parseInputs:
  401  06:C2B7  AD 1C 00    LDA gamepadPressed
  402  06:C2BA  29 F0       AND #GAMEPAD_MOVE
  403  06:C2BC  F0 5A       BEQ .leave
  404  06:C2BE  0A          ASL A
  405  06:C2BF  90 03       BCC .checkLeft
  406  06:C2C1  EE 00 00    INC temp1
  407  06:C2C4            .checkLeft:
  408  06:C2C4  0A          ASL A
  409  06:C2C5  90 03       BCC .checkDown
  410  06:C2C7  CE 00 00    DEC temp1
  411  06:C2CA            .checkDown:
  412  06:C2CA  0A          ASL A
  413  06:C2CB  90 03       BCC .checkUp
  414  06:C2CD  EE 01 00    INC temp2
  415  06:C2D0            .checkUp:
  416  06:C2D0  0A          ASL A
  417  06:C2D1  90 03       BCC .move
  418  06:C2D3  CE 01 00    DEC temp2
  419                       
  420  06:C2D6            .move:
  421                     
  422  06:C2D6  AD C5 00    LDA mouse_index
  423  06:C2D9  18          CLC
  424  06:C2DA  6D 01 00    ADC temp2
  425  06:C2DD  C9 02       CMP #$02
  426  06:C2DF  F0 04       BEQ .skipYMod
  427  06:C2E1  90 02       BCC .skipYMod
  428  06:C2E3  A9 00       LDA #$00
  429  06:C2E5            .skipYMod:
  430  06:C2E5  8D C5 00    STA mouse_index
  431                       ;; mult mouse_index by 16
  432  06:C2E8  0A          ASL A
  433  06:C2E9  0A          ASL A
  434  06:C2EA  0A          ASL A
  435  06:C2EB  0A          ASL A
  436  06:C2EC  18          CLC
  437  06:C2ED  69 AE       ADC #$AE
  438  06:C2EF  A2 01       LDX #$01
  439  06:C2F1  20 27 C2    JSR SetSpriteYPosition
  440                       
  441  06:C2F4  AD C6 00    LDA mouse_index+1
  442  06:C2F7  18          CLC
  443  06:C2F8  6D 00 00    ADC temp1
  444  06:C2FB  C9 08       CMP #$08
  445  06:C2FD  F0 04       BEQ .skipXMod
  446  06:C2FF  90 02       BCC .skipXMod
  447  06:C301  A9 00       LDA #$00
  448  06:C303            .skipXMod:
  449  06:C303  8D C6 00    STA mouse_index+1
  450                       ;; we need to move 3 tiles each- so index * 3 * 8,
  451  06:C306  18          CLC
  452  06:C307  6D C6 00    ADC mouse_index+1
  453  06:C30A  6D C6 00    ADC mouse_index+1
  454  06:C30D  0A          ASL A
  455  06:C30E  0A          ASL A
  456  06:C30F  0A          ASL A
  457  06:C310  18          CLC
  458  06:C311  69 10       ADC #$10
  459  06:C313  A2 01       LDX #$01
  460  06:C315  20 32 C2    JSR SetSpriteXPosition
  461                       
  462  06:C318            .leave:
  463                       
  464  06:C318  60          RTS
  465                     
  466  06:C319            LoadBank:
  467                     
  468                       ;;load bank
  469  06:C319  20 F2 CF    JSR ResetMapper
  470  06:C31C  AD 07 70    LDA bank_index
  471  06:C31F  8D A9 00    STA currentPRGBank
  472  06:C322  20 01 D0    JSR LoadPRGBank
  473  06:C325  60          RTS
  474                       
  475  06:C326            UpdatePuzzleInfo:
  476                     
  477                       MACROGetLabelPointer PuzzleSaveLocations, table_address
                          
       06:C326  A9 CA             LDA #HIGH(PuzzleSaveLocations)
       06:C328  A2 B8             LDX #LOW(PuzzleSaveLocations)
                                  
       06:C32A  8E 16 00          STX table_address
       06:C32D  8D 17 00          STA table_address+1
                                  
  478  06:C330  AD AB 00    LDA tempBank
  479  06:C333  0A          ASL A
  480  06:C334  A8          TAY
  481  06:C335  20 AF CD    JSR GetTableAtIndex
  482                       
  483                       ;;load title/time
  484                       ;;time first, we haven't done titles
  485  06:C338  A2 00       LDX #$00
  486  06:C33A  BD 20 FD    LDA SelectDefaultTime,x
  487  06:C33D  8D 01 00    STA temp2
  488  06:C340  E8          INX
  489  06:C341  BD 20 FD    LDA SelectDefaultTime,x
  490  06:C344  8D 00 00    STA temp1
  491                       
  492  06:C347  AD AC 00    LDA tempPuzz
  493  06:C34A  0A          ASL A
  494  06:C34B  0A          ASL A
  495  06:C34C  A8          TAY
  496  06:C34D  B1 16       LDA [table_address], y
  497  06:C34F  10 43       BPL .loadDefaultTime
  498                       
  499                       ;;time exists!
  500  06:C351  29 0F       AND #$0F
  501  06:C353  8D 02 00    STA temp3
  502  06:C356  C8          INY
  503  06:C357  C8          INY
  504  06:C358  C8          INY
  505                       MACROAddPPUStringEntryRawData temp1, temp2, #DRAW_HORIZONTAL, #$05
                          
       06:C359  A9 01       LDA #$01
       06:C35B  8D 23 00    STA PPU_PendingWrite
       06:C35E  AD 00 00    LDA temp1
       06:C361  20 0B CF    JSR WriteToPPUString
       06:C364  AD 01 00    LDA temp2
       06:C367  20 0B CF    JSR WriteToPPUString
       06:C36A  A9 00       LDA #DRAW_HORIZONTAL
       06:C36C  20 0B CF    JSR WriteToPPUString
       06:C36F  A9 05       LDA #$05 
       06:C371  20 0B CF    JSR WriteToPPUString
                            
  506  06:C374  B1 16       LDA [table_address], y
  507  06:C376  20 0B CF    JSR WriteToPPUString
  508  06:C379  88          DEY
  509  06:C37A  B1 16       LDA [table_address], y
  510  06:C37C  20 0B CF    JSR WriteToPPUString
  511  06:C37F  A9 61       LDA #$61
  512  06:C381  20 0B CF    JSR WriteToPPUString
  513  06:C384  88          DEY
  514  06:C385  B1 16       LDA [table_address], y
  515  06:C387  20 0B CF    JSR WriteToPPUString
  516  06:C38A  88          DEY
  517  06:C38B  AD 02 00    LDA temp3
  518  06:C38E  20 0B CF    JSR WriteToPPUString
  519  06:C391  4C B6 C3    JMP .leave
  520                      
  521  06:C394            .loadDefaultTime:
  522                       
  523                       MACROAddPPUStringEntryTable temp1, temp2, #DRAW_HORIZONTAL, DefaultTimeString
                           
       06:C394  A9 01       LDA #$01
       06:C396  8D 23 00    STA PPU_PendingWrite
       06:C399  AD 00 00    LDA temp1
       06:C39C  20 0B CF    JSR WriteToPPUString
       06:C39F  AD 01 00    LDA temp2
       06:C3A2  20 0B CF    JSR WriteToPPUString
       06:C3A5  A9 20       LDA #$20
       06:C3A7  09 00       ORA #DRAW_HORIZONTAL
       06:C3A9  20 0B CF    JSR WriteToPPUString
       06:C3AC  A9 22       LDA #LOW(DefaultTimeString)
       06:C3AE  20 0B CF    JSR WriteToPPUString
       06:C3B1  A9 FD       LDA #HIGH(DefaultTimeString)
       06:C3B3  20 0B CF    JSR WriteToPPUString
                           
  524  06:C3B6            .leave:
  525  06:C3B6  60          RTS
  526                       
  527  06:C3B7            ContinueText:
  528                     
  529  06:C3B7  08 0C 18    .db $08, $0C, $18, $17, $1D, $12, $17, $1E, $0E
       06:C3BA  17 1D 12  
       06:C3BD  17 1E 0E  
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGame.asm
   84                       .include "Routines/Game_States/UpdateGame.asm"
    1                     ;;VERT_CLUES = $206E
    2                     ;;HORI_CLUES = $2145
    3                     
    4           214E      VERT_CLUES = $214E
    5           218C      HORI_CLUES = $218C
    6           20A8      BANK_LEVEL = $20A8
    7           20E5      TIMER_LOC = $20E5
    8                     
    9           618E      MOUSE_START = $618E
   10                     
   11           0010      HOLD_TIME = $10
   12           0004      HOLD_FREQ = $04
   13                     
   14  06:C3C0            UpdateGame:
   15                     
   16  06:C3C0  AD 10 00    LDA NMI_locks
   17  06:C3C3  F0 01       BEQ .unlocked
   18                       
   19  06:C3C5  60          RTS
   20                       
   21  06:C3C6            .unlocked:
   22                     
   23  06:C3C6  20 CA C3    JSR DoUpdateGame
   24  06:C3C9  60          RTS
   25                       
   26  06:C3CA            DoUpdateGame:
   27                     
   28  06:C3CA  AD 0F 00    LDA mode_state
   29  06:C3CD  20 89 CD    JSR Dynamic_Jump
   30                       
   31  06:C3D0            UpdateGameJumpTable:
   32                     
   33  06:C3D0  E4 C3       .word UpdateGameInit
   34  06:C3D2  9F C4       .word UpdateDrawVertClues
   35  06:C3D4  C7 C4       .word UpdateDrawHoriClues
   36  06:C3D6  11 C5       .word UpdateGamePlay
   37  06:C3D8  27 C7       .word UpdateClearPuzzle
   38  06:C3DA  3A C7       .word UpdateMoveScreen
   39  06:C3DC  B3 C7       .word UpdateDrawImage
   40  06:C3DE  39 C8       .word UpdateWaitInput
   41  06:C3E0  4F C8       .word UpdateGameFadeOut
   42  06:C3E2  75 C8       .word UpdateGameExit
   43                     
   44  06:C3E4            UpdateGameInit:
   45                     
   46                       ;; get the puzzle table in the puzzle address
   47                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:C3E4  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:C3E6  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:C3E8  8E 16 00          STX table_address
       06:C3EB  8D 17 00          STA table_address+1
                                  
   48                       MACROGetDoubleIndex puzzle_index
                          
       06:C3EE  AD 08 70          LDA puzzle_index
       06:C3F1  0A                ASL A
       06:C3F2  A8                TAY
                                  
   49  06:C3F3  20 AF CD    JSR GetTableAtIndex
   50                       MACROGetPointer table_address, puzzle_address
                          
       06:C3F6  AD 16 00          LDA table_address
       06:C3F9  8D AD 00          STA puzzle_address
       06:C3FC  AD 17 00          LDA table_address+1
       06:C3FF  8D AE 00          STA puzzle_address+1
                          
   51                       MACROGetLabelPointer MOUSE_START, mouse_location
                          
       06:C402  A9 61             LDA #HIGH(MOUSE_START)
       06:C404  A2 8E             LDX #LOW(MOUSE_START)
                                  
       06:C406  8E C3 00          STX mouse_location
       06:C409  8D C4 00          STA mouse_location+1
                                  
   52                     
   53                       ;;for clues, we need to get past the header- for a 15x15 puzzle, that's 34 bytes ahead
   54  06:C40C  A0 00       LDY #$00
   55  06:C40E  B1 AD       LDA [puzzle_address], y
   56  06:C410  AA          TAX
   57  06:C411  BD B5 CA    LDA PuzzleHeaderSkips, x
   58  06:C414  8D 00 00    STA temp1
   59                       
   60  06:C417  AD AD 00    LDA puzzle_address
   61  06:C41A  18          CLC
   62  06:C41B  6D 00 00    ADC temp1
   63  06:C41E  8D AF 00    STA clues_address
   64  06:C421  A9 00       LDA #$00
   65  06:C423  6D AE 00    ADC puzzle_address+1
   66  06:C426  8D B0 00    STA clues_address+1
   67                     
   68  06:C429  A9 00       LDA #$00
   69  06:C42B  8D BB 00    STA clueTableIndex
   70  06:C42E  8D BC 00    STA clueLineIndex
   71  06:C431  8D C2 00    STA clueParity
   72  06:C434  8D BD 00    STA clueOffsetShift
   73  06:C437  8D C5 00    STA mouse_index
   74  06:C43A  8D C6 00    STA mouse_index+1
   75  06:C43D  8D C9 00    STA pauseInputLock 
   76                      
   77  06:C440  AD 00 70    LDA hasContinue
   78  06:C443  D0 14       BNE .skipSolutionReset
   79                       
   80  06:C445  A9 00       LDA #$00
   81  06:C447  8D 01 70    STA solutionCount
   82  06:C44A  8D 02 70    STA nonSolutionCount
   83  06:C44D  8D 03 70    STA GameTime
   84  06:C450  8D 04 70    STA GameTime+1
   85  06:C453  8D 05 70    STA GameTime+2
   86  06:C456  8D 06 70    STA GameTime+3
   87                       
   88  06:C459            .skipSolutionReset:     
   89                       
   90  06:C459  A9 20       LDA #$20
   91  06:C45B  8D BE 00    STA clueDrawAdd
   92                     
   93  06:C45E  A9 00       LDA #$00
   94  06:C460  8D 00 70    STA hasContinue  
   95                       
   96                       MACROGetLabelPointer VERT_CLUES, clue_start_address
                          
       06:C463  A9 21             LDA #HIGH(VERT_CLUES)
       06:C465  A2 4E             LDX #LOW(VERT_CLUES)
                                  
       06:C467  8E B7 00          STX clue_start_address
       06:C46A  8D B8 00          STA clue_start_address+1
                                  
   97  06:C46D  20 E4 D0    JSR ResetClueDrawAddress
   98                       
   99                       MACROAddPPUStringEntryRawData #HIGH(BANK_LEVEL), #LOW(BANK_LEVEL), #DRAW_HORIZONTAL, #$03
                          
       06:C470  A9 01       LDA #$01
       06:C472  8D 23 00    STA PPU_PendingWrite
       06:C475  A9 20       LDA #HIGH(BANK_LEVEL)
       06:C477  20 0B CF    JSR WriteToPPUString
       06:C47A  A9 A8       LDA #LOW(BANK_LEVEL)
       06:C47C  20 0B CF    JSR WriteToPPUString
       06:C47F  A9 00       LDA #DRAW_HORIZONTAL
       06:C481  20 0B CF    JSR WriteToPPUString
       06:C484  A9 03       LDA #$03 
       06:C486  20 0B CF    JSR WriteToPPUString
                            
  100  06:C489  AD 07 70    LDA bank_index
  101  06:C48C  20 0B CF    JSR WriteToPPUString
  102  06:C48F  A9 60       LDA #$60
  103  06:C491  20 0B CF    JSR WriteToPPUString
  104  06:C494  AE 08 70    LDX puzzle_index
  105  06:C497  E8          INX
  106  06:C498  8A          TXA 
  107  06:C499  20 0B CF    JSR WriteToPPUString
  108                       
  109  06:C49C  EE 0F 00    INC mode_state
  110                     
  111  06:C49F            UpdateDrawVertClues:
  112                       
  113  06:C49F  20 49 D0    JSR PopulateClues
  114  06:C4A2  90 22       BCC .leave
  115                       
  116  06:C4A4            .changeModeState:
  117                     
  118  06:C4A4  A9 00       LDA #$00
  119  06:C4A6  8D BC 00    STA clueLineIndex
  120  06:C4A9  8D C2 00    STA clueParity
  121                       
  122  06:C4AC  A9 05       LDA #$05
  123  06:C4AE  8D BD 00    STA clueOffsetShift
  124                       
  125  06:C4B1  A9 01       LDA #$01
  126  06:C4B3  8D BE 00    STA clueDrawAdd
  127                        
  128                       MACROGetLabelPointer HORI_CLUES, clue_start_address
                          
       06:C4B6  A9 21             LDA #HIGH(HORI_CLUES)
       06:C4B8  A2 8C             LDX #LOW(HORI_CLUES)
                                  
       06:C4BA  8E B7 00          STX clue_start_address
       06:C4BD  8D B8 00          STA clue_start_address+1
                                  
  129  06:C4C0  20 E4 D0    JSR ResetClueDrawAddress
  130                     
  131  06:C4C3  EE 0F 00    INC mode_state
  132  06:C4C6            .leave:
  133  06:C4C6  60          RTS
  134                       
  135  06:C4C7            UpdateDrawHoriClues:
  136                     
  137  06:C4C7  20 49 D0    JSR PopulateClues
  138  06:C4CA  90 44       BCC .leave
  139                     
  140  06:C4CC            .changeModeState:
  141  06:C4CC  20 53 CF    JSR TurnOnSprites
  142                       
  143                       ;;set the timer to 00
  144                       MACROAddPPUStringEntryRawData #HIGH(TIMER_LOC), #LOW(TIMER_LOC), #DRAW_HORIZONTAL, #$05
                          
       06:C4CF  A9 01       LDA #$01
       06:C4D1  8D 23 00    STA PPU_PendingWrite
       06:C4D4  A9 20       LDA #HIGH(TIMER_LOC)
       06:C4D6  20 0B CF    JSR WriteToPPUString
       06:C4D9  A9 E5       LDA #LOW(TIMER_LOC)
       06:C4DB  20 0B CF    JSR WriteToPPUString
       06:C4DE  A9 00       LDA #DRAW_HORIZONTAL
       06:C4E0  20 0B CF    JSR WriteToPPUString
       06:C4E3  A9 05       LDA #$05 
       06:C4E5  20 0B CF    JSR WriteToPPUString
                            
  145  06:C4E8  AD 06 70    LDA GameTime+3
  146  06:C4EB  20 0B CF    JSR WriteToPPUString
  147  06:C4EE  AD 05 70    LDA GameTime+2
  148  06:C4F1  20 0B CF    JSR WriteToPPUString
  149  06:C4F4  A9 61       LDA #$61
  150  06:C4F6  20 0B CF    JSR WriteToPPUString
  151  06:C4F9  AD 04 70    LDA GameTime+1
  152  06:C4FC  20 0B CF    JSR WriteToPPUString
  153  06:C4FF  AD 03 70    LDA GameTime
  154  06:C502  20 0B CF    JSR WriteToPPUString
  155                       
  156                       ;;reset time
  157  06:C505  A9 00       LDA #$00
  158  06:C507  8D 0A 00    STA time
  159  06:C50A  8D 0B 00    STA scaledTime
  160                       
  161  06:C50D  EE 0F 00    INC mode_state
  162  06:C510            .leave:
  163  06:C510  60          RTS
  164                       
  165  06:C511            UpdateGamePlay:
  166                         
  167  06:C511  AD C8 00    LDA pauseState
  168  06:C514  F0 04       BEQ .checkPause
  169  06:C516  20 9C C9    JSR UpdatePause
  170  06:C519  60          RTS
  171                       
  172  06:C51A            .checkPause:
  173                       
  174  06:C51A  AD 1C 00    LDA gamepadPressed
  175  06:C51D  29 08       AND #GAMEPAD_START
  176  06:C51F  F0 29       BEQ .updatePlay
  177  06:C521  A9 01       LDA #$01
  178  06:C523  8D C8 00    STA pauseState
  179  06:C526  A9 00       LDA #$00
  180  06:C528  8D BC 00    STA clueLineIndex 
  181  06:C52B  8D BD 00    STA clueOffsetShift   
  182                     
  183  06:C52E  A9 FF       LDA #$FF
  184  06:C530  A2 00       LDX #$00
  185  06:C532  20 3D C2    JSR SetSpriteImage
  186                     
  187                       ;;we need the pause screen table loaded
  188                       MACROGetLabelPointer Pause_Menu, pause_address
                          
       06:C535  A9 FC             LDA #HIGH(Pause_Menu)
       06:C537  A2 7C             LDX #LOW(Pause_Menu)
                                  
       06:C539  8E B1 00          STX pause_address
       06:C53C  8D B2 00          STA pause_address+1
                                  
  189                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:C53F  A9 21             LDA #HIGH($210A)
       06:C541  A2 0A             LDX #LOW($210A)
                                  
       06:C543  8E B5 00          STX pause_draw_address
       06:C546  8D B6 00          STA pause_draw_address+1
                                  
  190                       
  191                       
  192  06:C549  60          RTS
  193                     
  194  06:C54A            .updatePlay:
  195                     
  196  06:C54A  20 4C C9    JSR UpdateTimeDisplay
  197                             
  198  06:C54D  A9 00       LDA #$00
  199  06:C54F  8D 00 00    STA temp1
  200  06:C552  8D 01 00    STA temp2
  201  06:C555  8D 02 00    STA temp3
  202                       
  203  06:C558            .checkPressed:  
  204                     
  205  06:C558  AD 1C 00    LDA gamepadPressed
  206  06:C55B  29 F0       AND #GAMEPAD_MOVE
  207  06:C55D  F0 0B       BEQ .checkHeld
  208                       
  209  06:C55F  A9 10       LDA #HOLD_TIME
  210  06:C561  8D CA 00    STA holdTimer 
  211  06:C564  AD 1C 00    LDA gamepadPressed
  212  06:C567  4C 7E C5    JMP .parseInputs
  213                       
  214  06:C56A            .checkHeld:
  215                       
  216  06:C56A  AD 1A 00    LDA gamepad
  217  06:C56D  29 F0       AND #GAMEPAD_MOVE
  218  06:C56F  F0 2F       BEQ .checkPaintPress
  219                       
  220                       ;;decrement the hold timer
  221  06:C571  CE CA 00    DEC holdTimer
  222  06:C574  D0 2A       BNE .checkPaintPress
  223  06:C576  A9 04       LDA #HOLD_FREQ
  224  06:C578  8D CA 00    STA holdTimer
  225  06:C57B  AD 1A 00    LDA gamepad
  226                     
  227  06:C57E            .parseInputs:
  228                     
  229  06:C57E  29 F0       AND #GAMEPAD_MOVE
  230  06:C580  F0 1E       BEQ .checkPaintPress
  231  06:C582  0A          ASL A
  232  06:C583  90 03       BCC .checkLeft
  233  06:C585  EE 00 00    INC temp1
  234  06:C588            .checkLeft:
  235  06:C588  0A          ASL A
  236  06:C589  90 03       BCC .checkDown
  237  06:C58B  CE 00 00    DEC temp1
  238  06:C58E            .checkDown:
  239  06:C58E  0A          ASL A
  240  06:C58F  90 03       BCC .checkUp
  241  06:C591  EE 01 00    INC temp2
  242  06:C594            .checkUp:
  243  06:C594  0A          ASL A
  244  06:C595  90 03       BCC .move
  245  06:C597  CE 01 00    DEC temp2
  246                       
  247  06:C59A            .move:
  248                      
  249  06:C59A  20 90 C8    JSR MoveMouse
  250  06:C59D  20 F8 C8    JSR UpdateMouseScreenPos
  251                       
  252  06:C5A0            .checkPaintPress:
  253                     
  254  06:C5A0  AD 1C 00    LDA gamepadPressed
  255  06:C5A3  29 03       AND #GAMEPAD_AB
  256  06:C5A5  F0 41       BEQ .updatePaint
  257                       ;;A or B pressed, get current tile
  258                       
  259  06:C5A7  8D 00 00    STA temp1
  260                       
  261  06:C5AA  A0 00       LDY #$00
  262  06:C5AC  B1 C3       LDA [mouse_location], y
  263  06:C5AE  8D 01 00    STA temp2
  264                       
  265                         ;;A treats X and Clear as clear
  266                             ;;B treats mark and clear as clear
  267                             ;;clear->mark->x
  268                             
  269                     
  270  06:C5B1  C9 7C       CMP #$7C      ;check if this is a marked tile
  271  06:C5B3  B0 0F       BCS .getClearTile
  272                       ;;cleared tile- store off marked tile to paint with instead
  273                       ;;not a clear tile- a mark or an x - check A or B  
  274  06:C5B5  4E 00 00    LSR temp1
  275  06:C5B8  B0 05       BCS .getMarkTile
  276                       
  277  06:C5BA            .getXTile:
  278  06:C5BA  A9 80       LDA #$80
  279  06:C5BC  4C E2 C5    JMP .finishGetTile
  280                       
  281  06:C5BF            .getMarkTile:
  282  06:C5BF  A9 70       LDA #$70
  283  06:C5C1  4C E2 C5    JMP .finishGetTile
  284                     
  285  06:C5C4            .getClearTile:
  286                       
  287  06:C5C4  4E 00 00    LSR temp1
  288  06:C5C7  90 0A       BCC .checkB
  289  06:C5C9  AD 01 00    LDA temp2
  290  06:C5CC  C9 8C       CMP #$8C                      ;; check if in X tiles - will be if >=
  291  06:C5CE  90 0D       BCC .clearTile
  292  06:C5D0  4C BF C5    JMP .getMarkTile
  293                       
  294  06:C5D3            .checkB:
  295                       
  296  06:C5D3  AD 01 00   LDA temp2
  297  06:C5D6  C9 8C      CMP #$8C
  298  06:C5D8  B0 03      BCS .clearTile
  299  06:C5DA  4C BA C5   JMP .getXTile
  300                       
  301  06:C5DD            .clearTile:
  302  06:C5DD  A9 60       LDA #$60
  303  06:C5DF  4C E2 C5    JMP .finishGetTile
  304                       
  305  06:C5E2            .finishGetTile:
  306  06:C5E2  8D C7 00    STA currentPaintTile
  307  06:C5E5  4C FA C5    JMP .setTile
  308                     
  309                     ;;we'll keep a copy of the puzzle tiles in memory, since we can't easily access tiles in the PPU
  310                     ;;might be best to just keep an entire copy of the nametable instead of trying to index it and deal with 16 bit math
  311                     ;;we can load the nametable into memory as we draw it
  312                     
  313  06:C5E8            .updatePaint:
  314                     
  315  06:C5E8  AD 1A 00    LDA gamepad
  316  06:C5EB  29 03       AND #GAMEPAD_AB
  317  06:C5ED  D0 06       BNE .checkInputLock
  318                       
  319  06:C5EF  A9 00       LDA #$00
  320  06:C5F1  8D C9 00    STA pauseInputLock
  321                       
  322  06:C5F4            .leaveEarly:
  323  06:C5F4  60          RTS  
  324                     
  325  06:C5F5            .checkInputLock:
  326                     
  327                       ;;check if the input lock is on
  328  06:C5F5  2D C9 00    AND pauseInputLock
  329  06:C5F8  D0 FA       BNE .leaveEarly
  330                       
  331  06:C5FA            .setTile:
  332                       
  333                       ;;take Y position, mult by 2 to get starting index in puzzle solution
  334  06:C5FA  AD C6 00    LDA mouse_index+1
  335                     ;;if the puzzle is a 5x5, we only have one byte per row, so no need to double this
  336  06:C5FD  8D 00 00    STA temp1
  337  06:C600  A0 00       LDY #$00
  338  06:C602  B1 AD       LDA [puzzle_address], y
  339  06:C604  F0 03       BEQ .skipDouble
  340  06:C606  0E 00 00    ASL temp1
  341  06:C609            .skipDouble:
  342  06:C609  AD 00 00    LDA temp1
  343  06:C60C  18          CLC
  344  06:C60D  69 04       ADC #$04 ;; add to get past header
  345  06:C60F  8D 00 00    STA temp1
  346                       
  347                       ;;div X position by 8 to get the byte index
  348  06:C612  AD C5 00    LDA mouse_index
  349  06:C615  4A          LSR A
  350  06:C616  4A          LSR A
  351  06:C617  4A          LSR A
  352  06:C618  F0 03       BEQ .getMask
  353                       
  354  06:C61A  EE 00 00    INC temp1
  355                       
  356  06:C61D            .getMask:
  357                       
  358  06:C61D  AD C5 00    LDA mouse_index
  359  06:C620  29 07       AND #$07
  360  06:C622  AA          TAX
  361  06:C623  A9 80       LDA #$80
  362  06:C625  E0 00       CPX #$00
  363  06:C627  F0 04       BEQ .storeMask
  364                     
  365  06:C629            .maskLoop:
  366  06:C629  4A          LSR A
  367  06:C62A  CA          DEX
  368  06:C62B  D0 FC       BNE .maskLoop
  369  06:C62D            .storeMask:
  370  06:C62D  8D 01 00    STA temp2
  371                     
  372  06:C630  AC 00 00    LDY temp1
  373  06:C633  B1 AD       LDA [puzzle_address], y
  374  06:C635  2D 01 00    AND temp2
  375  06:C638  8D 00 00    STA temp1     ;get the 0/non zero solution flag 
  376                     
  377  06:C63B  A0 00       LDY #$00
  378  06:C63D  B1 C3       LDA [mouse_location], y
  379  06:C63F  8D 02 00    STA temp3
  380  06:C642  29 F0       AND #$F0
  381  06:C644  CD C7 00    CMP currentPaintTile
  382  06:C647  D0 01       BNE .diffTiles
  383  06:C649  60          RTS
  384                       
  385  06:C64A            .diffTiles:
  386                       ;;tiles are different- check if the current tile is marked as a solution tile
  387  06:C64A  C9 70       CMP #$70
  388  06:C64C  D0 0B       BNE .checkNewMark
  389                       ;;if erasing a mark, check if the tile was part of the solution
  390  06:C64E  AD 00 00    LDA temp1
  391  06:C651  D0 18       BNE .antiMark
  392  06:C653  CE 02 70    DEC nonSolutionCount
  393  06:C656  4C 74 C6    JMP .overwriteTile
  394                       
  395  06:C659            .checkNewMark:
  396                     
  397  06:C659  AD C7 00    LDA currentPaintTile
  398  06:C65C  C9 70       CMP #$70
  399  06:C65E  D0 14       BNE .overwriteTile
  400                       
  401  06:C660  AD 00 00    LDA temp1
  402  06:C663  D0 0C       BNE .proMark
  403  06:C665  EE 02 70    INC nonSolutionCount 
  404  06:C668  4C 74 C6    JMP .overwriteTile  
  405                       
  406  06:C66B            .antiMark:
  407  06:C66B  CE 01 70    DEC solutionCount
  408  06:C66E  4C 74 C6    JMP .overwriteTile
  409  06:C671            .proMark:   
  410                       
  411  06:C671  EE 01 70    INC solutionCount
  412                       
  413  06:C674            .overwriteTile:
  414                       ;;overwrite tile
  415  06:C674  AD 02 00    LDA temp3
  416  06:C677  29 0F       AND #$0F
  417  06:C679  0D C7 00    ORA currentPaintTile
  418  06:C67C  A0 00       LDY #$00
  419  06:C67E  91 C3       STA [mouse_location], y
  420  06:C680  8D 00 00    STA temp1
  421                       
  422  06:C683  AD C4 00    LDA mouse_location+1
  423  06:C686  29 3F       AND #$3F
  424  06:C688  8D 01 00    STA temp2
  425                         
  426                       MACROAddPPUStringEntryRawData temp2, mouse_location, #DRAW_HORIZONTAL, #$01
                          
       06:C68B  A9 01       LDA #$01
       06:C68D  8D 23 00    STA PPU_PendingWrite
       06:C690  AD 01 00    LDA temp2
       06:C693  20 0B CF    JSR WriteToPPUString
       06:C696  AD C3 00    LDA mouse_location
       06:C699  20 0B CF    JSR WriteToPPUString
       06:C69C  A9 00       LDA #DRAW_HORIZONTAL
       06:C69E  20 0B CF    JSR WriteToPPUString
       06:C6A1  A9 01       LDA #$01 
       06:C6A3  20 0B CF    JSR WriteToPPUString
                            
  427  06:C6A6  AD 00 00    LDA temp1
  428  06:C6A9  20 0B CF    JSR WriteToPPUString
  429                       
  430                       ;;also copy to save copy
  431  06:C6AC  AD C3 00    LDA mouse_location
  432  06:C6AF  8D B3 00    STA copy_address
  433  06:C6B2  AD C4 00    LDA mouse_location+1
  434  06:C6B5  29 0F       AND #$0F
  435  06:C6B7  09 60       ORA #$60
  436  06:C6B9  18          CLC
  437  06:C6BA  69 08       ADC #$08
  438  06:C6BC  8D B4 00    STA copy_address+1
  439                       
  440  06:C6BF  AD 00 00    LDA temp1
  441  06:C6C2  A0 00       LDY #$00
  442  06:C6C4  91 B3       STA [copy_address],y
  443                       
  444  06:C6C6            .checkSolution: 
  445                     
  446  06:C6C6  A0 01       LDY #$01
  447  06:C6C8  B1 AD       LDA [puzzle_address], y
  448  06:C6CA  CD 01 70    CMP solutionCount
  449  06:C6CD  D0 57       BNE .leave
  450  06:C6CF  AD 02 70    LDA nonSolutionCount
  451  06:C6D2  F0 03       BEQ .changeModeState
  452                       
  453  06:C6D4  4C 26 C7    JMP .leave
  454                       
  455                       ;;update the painting
  456  06:C6D7            .changeModeState:
  457                      
  458  06:C6D7  20 5C CF    JSR TurnOffSprites
  459                        
  460  06:C6DA  A9 00       LDA #$00
  461  06:C6DC  8D B9 00    STA clue_draw_address
  462  06:C6DF  8D BC 00    STA clueLineIndex
  463  06:C6E2  A9 20       LDA #$20
  464  06:C6E4  8D BA 00    STA clue_draw_address+1
  465                       
  466  06:C6E7  EE 0F 00    INC mode_state
  467                       
  468                       ;;the puzzle is solved, store the time and solved bit in memory
  469                       ;;if the puzzle was solved before, only update the time
  470                       
  471                       MACROGetLabelPointer PuzzleSaveLocations, table_address
                          
       06:C6EA  A9 CA             LDA #HIGH(PuzzleSaveLocations)
       06:C6EC  A2 B8             LDX #LOW(PuzzleSaveLocations)
                                  
       06:C6EE  8E 16 00          STX table_address
       06:C6F1  8D 17 00          STA table_address+1
                                  
  472  06:C6F4  AD 07 70    LDA bank_index
  473  06:C6F7  0A          ASL A
  474  06:C6F8  A8          TAY
  475  06:C6F9  20 AF CD    JSR GetTableAtIndex
  476                       
  477  06:C6FC  20 61 CA    JSR CheckNewBestTime
  478                       
  479  06:C6FF  AD CD 00    LDA recordSet
  480  06:C702  F0 22       BEQ .leave
  481                       
  482  06:C704  AD 08 70    LDA puzzle_index
  483  06:C707  0A          ASL A
  484  06:C708  0A          ASL A
  485  06:C709  A8          TAY
  486  06:C70A  AD 03 70    LDA GameTime
  487  06:C70D  09 80       ORA #$80
  488  06:C70F  91 16       STA [table_address], y
  489  06:C711  C8          INY
  490  06:C712  AD 04 70    LDA GameTime+1
  491  06:C715  91 16       STA [table_address], y
  492  06:C717  C8          INY
  493  06:C718  AD 05 70    LDA GameTime+2
  494  06:C71B  91 16       STA [table_address], y
  495  06:C71D  C8          INY
  496  06:C71E  AD 06 70    LDA GameTime+3
  497  06:C721  91 16       STA [table_address],y
  498  06:C723  4C 26 C7    JMP .leave
  499                       
  500  06:C726            .leave:
  501                      
  502  06:C726  60          RTS
  503                       
  504  06:C727            UpdateClearPuzzle:
  505                     
  506  06:C727  20 58 D1    JSR ClearPuzzle
  507  06:C72A  AD BC 00    LDA clueLineIndex
  508  06:C72D  C9 1E       CMP #30
  509  06:C72F  D0 08       BNE .leave
  510                       
  511  06:C731            .changeModeState:
  512                     
  513  06:C731  A9 00       LDA #$00
  514  06:C733  8D BC 00    STA clueLineIndex ;using this as a scroller
  515  06:C736  EE 0F 00    INC mode_state
  516                     
  517  06:C739            .leave:
  518                      
  519  06:C739  60          RTS
  520  06:C73A            UpdateMoveScreen:
  521                       
  522                       ;for 15x15, move 5 tiles left and 5 tiles up- let's do 1 at a time
  523                       ;we'll take the lower nibble of the clue line index as our scroll counter, and the higher nibble as the x/y flag
  524                       
  525  06:C73A  A0 00       LDY #$00
  526  06:C73C  B1 AD       LDA [puzzle_address], y
  527  06:C73E  AA          TAX
  528  06:C73F  BD AF CA    LDA PuzzleScrollHori, x
  529  06:C742  8D 00 00    STA temp1
  530  06:C745  BD B2 CA    LDA PuzzleScrollVert, x
  531  06:C748  8D 01 00    STA temp2
  532                       
  533  06:C74B  AD BC 00    LDA clueLineIndex
  534  06:C74E  29 10       AND #$10
  535  06:C750  D0 1E       BNE .scrollY
  536                       
  537                       ;;scroll X over
  538  06:C752  AD BC 00    LDA clueLineIndex
  539  06:C755  29 0F       AND #$0F
  540  06:C757  0A          ASL A
  541  06:C758  0A          ASL A
  542  06:C759  0A          ASL A ;mult by 8
  543  06:C75A  8D 1F 00    STA PPU_ScrollX
  544                       
  545  06:C75D  EE BC 00    INC clueLineIndex
  546  06:C760  AD BC 00    LDA clueLineIndex
  547  06:C763  CD 00 00    CMP temp1
  548  06:C766  D0 4A       BNE .leave
  549  06:C768  A9 10       LDA #$10
  550  06:C76A  8D BC 00    STA clueLineIndex
  551  06:C76D  4C B2 C7    JMP .leave
  552                       
  553  06:C770            .scrollY:
  554                     
  555  06:C770  AD BC 00    LDA clueLineIndex
  556  06:C773  29 0F       AND #$0F
  557  06:C775  0A          ASL A
  558  06:C776  0A          ASL A
  559  06:C777  0A          ASL A ;mult by 8
  560  06:C778  8D 20 00    STA PPU_ScrollY
  561                     
  562  06:C77B  EE BC 00    INC clueLineIndex
  563  06:C77E  AD BC 00    LDA clueLineIndex
  564  06:C781  29 0F       AND #$0F
  565  06:C783  CD 01 00    CMP temp2
  566  06:C786  D0 2A       BNE .leave
  567                       
  568  06:C788            .changeModeState:
  569                     
  570  06:C788  A9 8E       LDA #$8E
  571  06:C78A  8D B9 00    STA clue_draw_address
  572  06:C78D  A9 21       LDA #$21
  573  06:C78F  8D BA 00    STA clue_draw_address+1
  574                       
  575  06:C792  AD AF 00    LDA clues_address
  576  06:C795  18          CLC
  577  06:C796  6D BB 00    ADC clueTableIndex
  578  06:C799  8D AF 00    STA clues_address
  579  06:C79C  AD B0 00    LDA clues_address+1
  580  06:C79F  69 00       ADC #$00
  581  06:C7A1  8D B0 00    STA clues_address+1
  582                       
  583  06:C7A4  A9 00       LDA #$00
  584  06:C7A6  8D BB 00    STA clueTableIndex
  585  06:C7A9  8D BC 00    STA clueLineIndex
  586  06:C7AC  8D BD 00    STA clueOffsetShift
  587                     
  588  06:C7AF  EE 0F 00    INC mode_state
  589                     
  590  06:C7B2            .leave:
  591                      
  592  06:C7B2  60          RTS
  593  06:C7B3            UpdateDrawImage:
  594                     
  595                       ;run it twice for a faster draw
  596  06:C7B3  20 3A D2    JSR DrawImage
  597  06:C7B6  AD BB 00    LDA clueTableIndex
  598  06:C7B9  CD 09 00    CMP tempy
  599                       ;BEQ .changeModeState
  600                       
  601                       ;JSR DrawImage
  602                       ;LDA clueTableIndex
  603                       ;CMP tempy
  604  06:C7BC  D0 7A       BNE .leave
  605                       
  606  06:C7BE            .changeModeState:
  607                     
  608                       ;;do a palette draw
  609                       ;;puzzle address + 03 has the desired palette offset
  610                     
  611  06:C7BE  A0 03       LDY #$03
  612  06:C7C0  B1 AD       LDA [puzzle_address],y
  613  06:C7C2  29 0F       AND #$0F
  614  06:C7C4  AA          TAX
  615                       
  616  06:C7C5  B1 AD       LDA [puzzle_address],y
  617  06:C7C7  29 10       AND #$10
  618  06:C7C9  F0 15       BEQ .storeBottomVals
  619                       
  620  06:C7CB  8A          TXA
  621  06:C7CC  09 10       ORA #$10
  622  06:C7CE  8D 01 00    STA temp2
  623  06:C7D1  8A          TXA
  624  06:C7D2  09 20       ORA #$20
  625  06:C7D4  8D 02 00    STA temp3
  626  06:C7D7  8A          TXA
  627  06:C7D8  09 30       ORA #$30
  628  06:C7DA  8D 03 00    STA temp4
  629                     
  630  06:C7DD  4C F2 C7    JMP .checkKeepWhite
  631                       
  632  06:C7E0            .storeBottomVals:
  633                     
  634  06:C7E0  8A          TXA
  635  06:C7E1  09 00       ORA #$00
  636  06:C7E3  8D 01 00    STA temp2
  637  06:C7E6  8A          TXA
  638  06:C7E7  09 10       ORA #$10
  639  06:C7E9  8D 02 00    STA temp3
  640  06:C7EC  8A          TXA
  641  06:C7ED  09 20       ORA #$20
  642  06:C7EF  8D 03 00    STA temp4
  643                       
  644  06:C7F2            .checkKeepWhite:
  645                       
  646  06:C7F2  B1 AD       LDA [puzzle_address],y
  647  06:C7F4  29 20       AND #$20
  648  06:C7F6  F0 05       BEQ .loadPalToPPUStr
  649                       
  650  06:C7F8  A9 30       LDA #$30
  651  06:C7FA  8D 03 00    STA temp4
  652                       
  653                       
  654  06:C7FD            .loadPalToPPUStr:
  655                       
  656                       MACROAddPPUStringEntryRawData #$3F, #$01, #DRAW_HORIZONTAL, #03
                          
       06:C7FD  A9 01       LDA #$01
       06:C7FF  8D 23 00    STA PPU_PendingWrite
       06:C802  A9 3F       LDA #$3F
       06:C804  20 0B CF    JSR WriteToPPUString
       06:C807  A9 01       LDA #$01
       06:C809  20 0B CF    JSR WriteToPPUString
       06:C80C  A9 00       LDA #DRAW_HORIZONTAL
       06:C80E  20 0B CF    JSR WriteToPPUString
       06:C811  A9 03       LDA #03 
       06:C813  20 0B CF    JSR WriteToPPUString
                            
  657  06:C816  AD 01 00    LDA temp2
  658  06:C819  20 0B CF    JSR WriteToPPUString
  659  06:C81C  AD 02 00    LDA temp3
  660  06:C81F  20 0B CF    JSR WriteToPPUString
  661  06:C822  AD 03 00    LDA temp4
  662  06:C825  20 0B CF    JSR WriteToPPUString
  663                       
  664  06:C828  A2 01       LDX #$01
  665  06:C82A            .copyLoop:
  666                       ;;also store in the copy 
  667  06:C82A  BD 00 00    LDA temp1, x
  668  06:C82D  9D 00 6C    STA Palette_Copy, x
  669  06:C830  E8          INX
  670  06:C831  E0 04       CPX #$04
  671  06:C833  D0 F5       BNE .copyLoop
  672                       
  673                       
  674  06:C835  EE 0F 00    INC mode_state
  675                     
  676  06:C838            .leave:
  677                      
  678  06:C838  60          RTS
  679                       
  680  06:C839            UpdateWaitInput:
  681                     
  682  06:C839  AD 1C 00    LDA gamepadPressed
  683  06:C83C  F0 10       BEQ .leave
  684                       
  685  06:C83E            .changeModeState:
  686  06:C83E  A9 00       LDA #$00
  687  06:C840  8D 0A 00    STA time
  688  06:C843  8D 0B 00    STA scaledTime
  689  06:C846  A9 02       LDA #GAMEOVER_IDX
  690  06:C848  8D CB 00    STA targetGameMode
  691  06:C84B  EE 0F 00    INC mode_state
  692                     
  693  06:C84E            .leave:
  694                      
  695  06:C84E  60          RTS
  696                       
  697  06:C84F            UpdateGameFadeOut:
  698                     
  699  06:C84F  AD 0A 00    LDA time
  700  06:C852  29 07       AND #$07
  701  06:C854  D0 1E       BNE .leave
  702                       ;;every 8 frames, decrement the palettes
  703  06:C856  20 88 CF    JSR FadeOutPalettes
  704  06:C859  B0 19       BCS .leave
  705                     
  706  06:C85B            .changeModeState:
  707  06:C85B  A9 00       LDA #$00
  708  06:C85D  8D 0A 00    STA time
  709  06:C860  EE 0F 00    INC mode_state
  710                       
  711                       ;;don't need to turn all the sprites off, just need to
  712                       ;;clear them out   
  713  06:C863  A9 FF       LDA #$FF
  714  06:C865  A2 00       LDX #$00
  715  06:C867  20 3D C2    JSR SetSpriteImage
  716                       
  717  06:C86A  A9 FF       LDA #$FF
  718  06:C86C  A2 01       LDX #$01
  719  06:C86E  20 3D C2    JSR SetSpriteImage
  720                       
  721  06:C871  20 53 CF    JSR TurnOnSprites     ;turn sprite rendering back on
  722                       
  723  06:C874            .leave:
  724  06:C874  60          RTS  
  725                     
  726  06:C875            UpdateGameExit:
  727                     
  728  06:C875  AD 0A 00    LDA time
  729  06:C878  29 0F       AND #$0F
  730  06:C87A  D0 13       BNE .leave
  731                     
  732  06:C87C  A9 00       LDA #$00
  733  06:C87E  8D 1F 00    STA PPU_ScrollX
  734  06:C881  8D 20 00    STA PPU_ScrollY
  735  06:C884  8D 21 00    STA PPU_ScrollNT
  736                       
  737  06:C887  AD CB 00    LDA targetGameMode
  738  06:C88A  A2 00       LDX #$00
  739  06:C88C  20 B8 CC    JSR ChangeGameMode
  740  06:C88F            .leave:
  741  06:C88F  60          RTS
  742                       
  743  06:C890            MoveMouse:
  744                     
  745  06:C890  AD 00 00    LDA temp1
  746  06:C893  0E 00 00    ASL temp1
  747  06:C896  0E 00 00    ASL temp1
  748  06:C899  0E 00 00    ASL temp1
  749                       
  750  06:C89C  AD 01 00    LDA temp2
  751  06:C89F  0E 01 00    ASL temp2 
  752  06:C8A2  0E 01 00    ASL temp2
  753  06:C8A5  0E 01 00    ASL temp2
  754                       
  755  06:C8A8  A0 00       LDY #$00
  756  06:C8AA  B1 AD       LDA [puzzle_address], y ;puzzle size 0 = 5, 1 = 10, 2 = 15  
  757  06:C8AC  0A          ASL A
  758  06:C8AD  AA          TAX
  759  06:C8AE  BD A3 CA    LDA MouseMinimums, x
  760  06:C8B1  8D 02 00    STA temp3
  761  06:C8B4  BD A9 CA    LDA MouseMaximums, x
  762  06:C8B7  8D 03 00    STA temp4
  763  06:C8BA  8A          TXA
  764  06:C8BB  48          PHA
  765                       
  766  06:C8BC  A2 03       LDX #SPRITE_XPOS
  767  06:C8BE  BD 00 02    LDA SPRITE_DATA, x
  768  06:C8C1  18          CLC
  769  06:C8C2  6D 00 00    ADC temp1
  770                       ;;check against borders
  771  06:C8C5  CD 02 00    CMP temp3
  772  06:C8C8  F0 08       BEQ .moveVert 
  773  06:C8CA  CD 03 00    CMP temp4
  774  06:C8CD  F0 03       BEQ .moveVert
  775  06:C8CF  9D 00 02    STA SPRITE_DATA, x
  776                     
  777  06:C8D2            .moveVert:
  778                     
  779  06:C8D2  68          PLA
  780  06:C8D3  AA          TAX
  781  06:C8D4  E8          INX
  782  06:C8D5  BD A3 CA    LDA MouseMinimums, x
  783  06:C8D8  8D 02 00    STA temp3
  784  06:C8DB  BD A9 CA    LDA MouseMaximums, x
  785  06:C8DE  8D 03 00    STA temp4
  786                     
  787  06:C8E1  A2 00       LDX #SPRITE_YPOS
  788  06:C8E3  BD 00 02    LDA SPRITE_DATA, x
  789  06:C8E6  18          CLC
  790  06:C8E7  6D 01 00    ADC temp2
  791                       ;;check against borders
  792  06:C8EA  CD 02 00    CMP temp3
  793  06:C8ED  F0 08       BEQ .leave
  794  06:C8EF  CD 03 00    CMP temp4
  795  06:C8F2  F0 03       BEQ .leave
  796  06:C8F4  9D 00 02    STA SPRITE_DATA, x
  797                     
  798  06:C8F7            .leave:
  799  06:C8F7  60          RTS
  800                             
  801  06:C8F8            UpdateMouseScreenPos:
  802                     
  803  06:C8F8  A2 00       LDX #$00
  804  06:C8FA  BD 00 02    LDA SPRITE_DATA, x;ypos       ;yyyy y...
  805  06:C8FD  4A          LSR A                                         ;0yyy yy..
  806  06:C8FE  4A          LSR A                                         ;00yy yyy.
  807  06:C8FF  4A          LSR A                                         ;000y yyyy
  808  06:C900  8D 00 00    STA temp1
  809  06:C903  8D C6 00    STA mouse_index+1
  810  06:C906  E8          INX
  811  06:C907  E8          INX
  812  06:C908  E8          INX   
  813  06:C909  BD 00 02    LDA SPRITE_DATA, x ;xpos  ;  xxxx x...
  814  06:C90C  29 F8       AND #$F8                       ;              ;  xxxx x000
  815  06:C90E  8D 01 00    STA temp2                      ;      ;  
  816  06:C911  4E 00 00    LSR temp1                      ;              ;  0000 yyyy y
  817  06:C914  6E 01 00    ROR temp2                      ;      ;  yxxx xx00
  818  06:C917  4E 00 00    LSR temp1                      ;              ;  0000 0yyy y
  819  06:C91A  6E 01 00    ROR temp2                      ;              ;  yyxx xxx0
  820  06:C91D  4E 00 00    LSR temp1              ;              ;  0000 00yy y
  821  06:C920  6E 01 00    ROR temp2                      ;              ;  yyyx xxxx
  822  06:C923  AD 01 00    LDA temp2
  823  06:C926  29 1F       AND #$1F
  824  06:C928  8D C5 00    STA mouse_index
  825                       
  826  06:C92B  AD C5 00    LDA mouse_index
  827  06:C92E  38          SEC 
  828  06:C92F  E9 0E       SBC #$0E
  829  06:C931  8D C5 00    STA mouse_index
  830                       
  831  06:C934  AD C6 00    LDA mouse_index+1
  832  06:C937  38          SEC 
  833  06:C938  E9 0C       SBC #$0C
  834  06:C93A  8D C6 00    STA mouse_index+1
  835                       
  836                       ;subtract starting offsets for mouse index
  837                       
  838  06:C93D  AD 00 00    LDA temp1                      ;              ;  0000 00yy
  839  06:C940  09 60       ORA #$60                       ;              ;  0110 00yy
  840                       
  841  06:C942  8D C4 00    STA mouse_location+1
  842  06:C945  AD 01 00    LDA temp2
  843  06:C948  8D C3 00    STA mouse_location
  844                       
  845  06:C94B            .leave:
  846  06:C94B  60          RTS
  847                       
  848  06:C94C            UpdateTimeDisplay:
  849                     
  850  06:C94C  AD 0B 00    LDA scaledTime
  851  06:C94F  C9 3C       CMP #60
  852  06:C951  D0 48       BNE .leave
  853                       
  854  06:C953  A9 00       LDA #$00
  855  06:C955  8D 0B 00    STA scaledTime
  856                       
  857  06:C958  EE 03 70    INC GameTime
  858  06:C95B  AD 03 70    LDA GameTime
  859  06:C95E  C9 0A       CMP #10
  860  06:C960  D0 32       BNE .printTime
  861                       
  862  06:C962  A9 00       LDA #$00
  863  06:C964  8D 03 70    STA GameTime
  864  06:C967  EE 04 70    INC GameTime+1
  865  06:C96A  AD 04 70    LDA GameTime+1
  866  06:C96D  C9 06       CMP #6
  867  06:C96F  D0 23       BNE .printTime
  868                       
  869  06:C971  A9 00       LDA #$00
  870  06:C973  8D 04 70    STA GameTime+1
  871  06:C976  EE 05 70    INC GameTime+2
  872  06:C979  AD 05 70    LDA GameTime+2
  873  06:C97C  C9 0A       CMP #10
  874  06:C97E  D0 14       BNE .printTime
  875                       
  876  06:C980  A9 00       LDA #$00
  877  06:C982  8D 05 70    STA GameTime+2
  878  06:C985  EE 06 70    INC GameTime+3
  879  06:C988  AD 06 70    LDA GameTime+3
  880  06:C98B  C9 0A       CMP #10
  881  06:C98D  D0 05       BNE .printTime
  882                       
  883  06:C98F  A9 00       LDA #$00
  884  06:C991  8D 06 70    STA GameTime+3
  885                         
  886                       
  887  06:C994            .printTime:
  888                     
  889  06:C994  A9 20       LDA #HIGH(TIMER_LOC)
  890  06:C996  A2 E5       LDX #LOW(TIMER_LOC)
  891                     
  892  06:C998  20 8E D3    JSR ApplyGameTimeToPPUString
  893                       
  894                       
  895  06:C99B            .leave: 
  896  06:C99B  60          RTS  
  897                       
  898  06:C99C            UpdatePause:
  899                     
  900                     ;;load screen
  901                     ;;update selection
  902                     ;; close - remove screen, then upause
  903                     ;; quit - jump to fade out
  904  06:C99C  AD C8 00    LDA pauseState
  905  06:C99F  20 89 CD    JSR Dynamic_Jump
  906                     
  907  06:C9A2            UpdatePauseJumpTable:  
  908                     
  909  06:C9A2  60 CA       .word ExitPause                       ;fail safe
  910  06:C9A4  AA C9       .word UpdateLoadPauseScreen
  911  06:C9A6  C6 C9       .word UpdatePauseScreen
  912  06:C9A8  44 CA       .word UpdateUnloadPauseScreen
  913                       
  914  06:C9AA            UpdateLoadPauseScreen:
  915                       
  916  06:C9AA  20 9F D1    JSR LoadPauseScreen
  917  06:C9AD  AD BD 00    LDA clueOffsetShift
  918  06:C9B0  C9 06       CMP #$06
  919  06:C9B2  D0 11       BNE .leave
  920                       
  921  06:C9B4            .changePauseState:
  922                     
  923  06:C9B4  A9 60       LDA #PAUSE_YES
  924  06:C9B6  A2 01       LDX #$01
  925  06:C9B8  20 32 C2    JSR SetSpriteXPosition  
  926  06:C9BB  A9 01       LDA #$01
  927  06:C9BD  A2 01       LDX #$01
  928  06:C9BF  20 3D C2    JSR SetSpriteImage
  929                       
  930  06:C9C2  EE C8 00    INC pauseState
  931  06:C9C5            .leave:
  932  06:C9C5  60          RTS
  933                       
  934  06:C9C6            UpdatePauseScreen:
  935                       
  936  06:C9C6  AD 1C 00    LDA gamepadPressed
  937  06:C9C9  C9 08       CMP #GAMEPAD_START
  938  06:C9CB  F0 29       BEQ .unPause
  939  06:C9CD  C9 02       CMP #GAMEPAD_B
  940  06:C9CF  F0 25       BEQ .unPause
  941  06:C9D1  C9 01       CMP #GAMEPAD_A
  942  06:C9D3  F0 4A       BEQ .checkA
  943                       
  944                       ;;update pointer
  945                       
  946  06:C9D5  AD 1C 00    LDA gamepadPressed
  947  06:C9D8  29 C0       AND #GAMEPAD_HORI
  948                       ;;binary system- left and right don't really matter, we'll just toggle the position
  949  06:C9DA  F0 67       BEQ .leave
  950                       
  951  06:C9DC  A9 03       LDA #SPRITE_XPOS
  952  06:C9DE  A2 01       LDX #$01
  953  06:C9E0  20 54 C2    JSR GetSpriteData
  954                       
  955  06:C9E3  C9 60       CMP #PAUSE_YES
  956  06:C9E5  F0 05       BEQ .loadNo
  957                       
  958  06:C9E7  A9 60       LDA #PAUSE_YES
  959  06:C9E9  4C EE C9    JMP .setPosition
  960                       
  961  06:C9EC            .loadNo:
  962  06:C9EC  A9 88       LDA #PAUSE_NO
  963                     
  964  06:C9EE            .setPosition:
  965                       
  966  06:C9EE  A2 01       LDX #$01
  967  06:C9F0  20 32 C2    JSR SetSpriteXPosition  
  968                     
  969  06:C9F3  4C 43 CA    JMP .leave 
  970                     
  971  06:C9F6            .unPause:
  972                     
  973  06:C9F6  A9 00       LDA #$00
  974  06:C9F8  8D BC 00    STA clueLineIndex
  975  06:C9FB  8D BD 00    STA clueOffsetShift
  976                       
  977  06:C9FE  A9 FF       LDA #$FF
  978  06:CA00  A2 01       LDX #$01
  979  06:CA02  20 3D C2    JSR SetSpriteImage
  980                     
  981                       MACROGetLabelPointer $610A, pause_address
                          
       06:CA05  A9 61             LDA #HIGH($610A)
       06:CA07  A2 0A             LDX #LOW($610A)
                                  
       06:CA09  8E B1 00          STX pause_address
       06:CA0C  8D B2 00          STA pause_address+1
                                  
  982                       MACROGetLabelPointer $210A, pause_draw_address
                          
       06:CA0F  A9 21             LDA #HIGH($210A)
       06:CA11  A2 0A             LDX #LOW($210A)
                                  
       06:CA13  8E B5 00          STX pause_draw_address
       06:CA16  8D B6 00          STA pause_draw_address+1
                                  
  983                         
  984  06:CA19  EE C8 00    INC pauseState
  985  06:CA1C  4C 43 CA    JMP .leave
  986                      
  987  06:CA1F            .checkA:
  988                       
  989  06:CA1F  A9 03       LDA #SPRITE_XPOS
  990  06:CA21  A2 01       LDX #$01
  991  06:CA23  20 54 C2    JSR GetSpriteData
  992                       
  993  06:CA26  C9 88       CMP #PAUSE_NO
  994  06:CA28  F0 CC       BEQ .unPause
  995                        
  996  06:CA2A            .quit:
  997                             
  998  06:CA2A  A9 01       LDA #$01
  999  06:CA2C  8D 00 70    STA hasContinue
 1000  06:CA2F  A9 00       LDA #$00
 1001  06:CA31  8D C8 00    STA pauseState
 1002  06:CA34  A9 00       LDA #$00
 1003  06:CA36  8D 0A 00    STA time
 1004  06:CA39  A9 02       LDA #GAMEOVER_IDX
 1005  06:CA3B  8D CB 00    STA targetGameMode
 1006  06:CA3E  A9 08       LDA #$08
 1007  06:CA40  8D 0F 00    STA mode_state
 1008                       
 1009  06:CA43            .leave:
 1010  06:CA43  60          RTS
 1011                       
 1012  06:CA44            UpdateUnloadPauseScreen:
 1013                       
 1014  06:CA44  20 E6 D1    JSR ClearPauseScreen
 1015  06:CA47  AD BD 00    LDA clueOffsetShift
 1016  06:CA4A  C9 06       CMP #$06
 1017  06:CA4C  D0 11       BNE .leave
 1018  06:CA4E            .changePauseState:
 1019                     
 1020  06:CA4E  A9 02       LDA #$02
 1021  06:CA50  A2 00       LDX #$00
 1022  06:CA52  20 3D C2    JSR SetSpriteImage
 1023                       
 1024  06:CA55  A9 03       LDA #GAMEPAD_AB
 1025  06:CA57  8D C9 00    STA pauseInputLock 
 1026                       
 1027  06:CA5A  A9 00       LDA #$00
 1028  06:CA5C  8D C8 00    STA pauseState
 1029  06:CA5F            .leave:
 1030  06:CA5F  60          RTS
 1031                       
 1032  06:CA60            ExitPause:
 1033  06:CA60  60          RTS
 1034                       
 1035  06:CA61            CheckNewBestTime:
 1036                     
 1037                       ;let's say we already have the save data in the table address
 1038  06:CA61  A9 00       LDA #$00
 1039  06:CA63  8D CD 00    STA recordSet
 1040                       
 1041                       
 1042  06:CA66  AD 08 70    LDA puzzle_index
 1043  06:CA69  0A          ASL A
 1044  06:CA6A  0A          ASL A
 1045  06:CA6B  A8          TAY
 1046  06:CA6C  B1 16       LDA [table_address], y
 1047  06:CA6E  29 80       AND #$80
 1048  06:CA70  F0 2D       BEQ .updateTime
 1049                       ;MACROGetLabelPointer PuzzleSaveLocations, table_address
 1050                       ;LDA bank_index
 1051                       ;ASL A
 1052                       ;TAY
 1053                       ;JSR GetTableAtIndex
 1054                     
 1055  06:CA72  C8          INY 
 1056  06:CA73  C8          INY
 1057  06:CA74  C8          INY   ;start at highest time loc
 1058  06:CA75  AD 06 70    LDA GameTime+3
 1059  06:CA78  D1 16       CMP [table_address], y
 1060  06:CA7A  90 23       BCC .updateTime
 1061  06:CA7C  88          DEY
 1062  06:CA7D  AD 05 70    LDA GameTime+2
 1063  06:CA80  D1 16       CMP [table_address], y
 1064  06:CA82  90 1B       BCC .updateTime
 1065  06:CA84  88          DEY
 1066  06:CA85  AD 04 70    LDA GameTime+1
 1067  06:CA88  D1 16       CMP [table_address], y
 1068  06:CA8A  90 13       BCC .updateTime
 1069  06:CA8C  88          DEY
 1070  06:CA8D  B1 16       LDA [table_address], y
 1071  06:CA8F  29 0F       AND #$0F
 1072  06:CA91  8D 00 00    STA temp1
 1073  06:CA94  AD 03 70    LDA GameTime
 1074  06:CA97  CD 00 00    CMP temp1
 1075  06:CA9A  90 03       BCC .updateTime
 1076  06:CA9C  4C A2 CA    JMP .leave
 1077                       
 1078  06:CA9F            .updateTime:
 1079                     
 1080  06:CA9F  EE CD 00    INC recordSet
 1081                       
 1082  06:CAA2            .leave:
 1083  06:CAA2  60          RTS
 1084                         
 1085                     ;hori, vert
 1086  06:CAA3            MouseMinimums:
 1087  06:CAA3  6A 5A       .db $6A, $5A
 1088  06:CAA5  6A 5A       .db $6A, $5A
 1089  06:CAA7  6A 5A       .db $6A, $5A
 1090  06:CAA9            MouseMaximums:
 1091  06:CAA9  9A 8A       .db $9A, $8A
 1092  06:CAAB  C2 B2       .db $C2, $B2
 1093  06:CAAD  EA DA       .db $EA, $DA
 1094                       
 1095  06:CAAF            PuzzleScrollHori:
 1096  06:CAAF  01 04 06    .db $01, $04, $06
 1097  06:CAB2            PuzzleScrollVert:
 1098  06:CAB2  01 03 05    .db $01, $03, $05
 1099                       
 1100  06:CAB5            PuzzleHeaderSkips:
 1101                     
 1102  06:CAB5  09 18 22    .db $09, $18, $22
 1103                       
 1104  06:CAB8            PuzzleSaveLocations:
 1105  06:CAB8  09 70       .word puzzle_clear_bank0, puzzle_clear_bank1, puzzle_clear_bank2
       06:CABA  75 70     
       06:CABC  E1 70     
 1106                     
 1107                       
 1108           0060      PAUSE_YES = $60
 1109           0088      PAUSE_NO = $88
 1110                     
 1111                       
#[1]   Picross.asm
#[2]   Routines/Game_States/UpdateGameOver.asm
   85                       .include "Routines/Game_States/UpdateGameOver.asm"
    1  06:CABE            UpdateGameOver:
    2                     
    3  06:CABE  AD 10 00    LDA NMI_locks
    4  06:CAC1  F0 01       BEQ .unlocked
    5                       
    6  06:CAC3  60          RTS
    7                       
    8  06:CAC4            .unlocked:
    9                     
   10  06:CAC4  20 C8 CA    JSR DoUpdateGameOver 
   11  06:CAC7  60          RTS
   12                       
   13  06:CAC8            DoUpdateGameOver:
   14                     
   15  06:CAC8  AD 0F 00    LDA mode_state
   16  06:CACB  20 89 CD    JSR Dynamic_Jump
   17                         
   18  06:CACE            UpdateGameOverJumpTable:
   19                     
   20  06:CACE  D8 CA       .word UpdateGameOverInit
   21  06:CAD0  1C CB       .word UpdateDrawMessage
   22  06:CAD2  41 CB       .word UpdateGameOverWaitInput
   23  06:CAD4  D2 CB       .word UpdateGameOverFadeOut
   24  06:CAD6  E7 CB       .word UpdateGameOverExit
   25                       
   26  06:CAD8            UpdateGameOverInit:
   27                     
   28                       ;load the hasContinue flag
   29                       ;choose the message to print based on the flag
   30                       
   31                       MACROGetLabelPointer EndScreens, table_address
                          
       06:CAD8  A9 FC             LDA #HIGH(EndScreens)
       06:CADA  A2 CA             LDX #LOW(EndScreens)
                                  
       06:CADC  8E 16 00          STX table_address
       06:CADF  8D 17 00          STA table_address+1
                                  
   32  06:CAE2  AD 00 70    LDA hasContinue
   33  06:CAE5  0A          ASL A
   34  06:CAE6  A8          TAY
   35  06:CAE7  20 AF CD    JSR GetTableAtIndex
   36                       MACROGetPointer table_address, clues_address
                          
       06:CAEA  AD 16 00          LDA table_address
       06:CAED  8D AF 00          STA clues_address
       06:CAF0  AD 17 00          LDA table_address+1
       06:CAF3  8D B0 00          STA clues_address+1
                          
   37                       
   38                       ;this gets us the pointer to the table- now we'll set up the starting draw address
   39  06:CAF6  A0 00       LDY #$00
   40  06:CAF8  B1 AF       LDA [clues_address], y
   41  06:CAFA  8D B9 00    STA clue_draw_address
   42  06:CAFD  C8          INY
   43  06:CAFE  B1 AF       LDA [clues_address], y
   44  06:CB00  8D BA 00    STA clue_draw_address+1 
   45                     
   46  06:CB03  AD AF 00    LDA clues_address
   47  06:CB06  18          CLC
   48  06:CB07  69 02       ADC #$02
   49  06:CB09  8D AF 00    STA clues_address
   50  06:CB0C  AD B0 00    LDA clues_address+1
   51  06:CB0F  69 00       ADC #$00
   52  06:CB11  8D B0 00    STA clues_address+1
   53                       
   54  06:CB14  A9 00       LDA #$00
   55  06:CB16  8D BC 00    STA clueLineIndex
   56                       ;;table address is now at the first string to draw
   57                         
   58  06:CB19  EE 0F 00    INC mode_state
   59                     
   60                     ;no RTS, just update a line immediately
   61                     
   62  06:CB1C            UpdateDrawMessage:
   63                     
   64  06:CB1C  AD 00 70    LDA hasContinue
   65                       
   66  06:CB1F  F0 06       BEQ .drawClear
   67                       
   68  06:CB21  20 61 CC    JSR DrawSaveText
   69                     
   70  06:CB24  4C 2A CB    JMP .checkLeave
   71                       
   72  06:CB27            .drawClear
   73                     
   74  06:CB27  20 F8 CB    JSR DrawClearText 
   75                       
   76  06:CB2A            .checkLeave:
   77  06:CB2A  90 14       BCC .leave
   78                     
   79  06:CB2C            .changeModeState:
   80                     
   81  06:CB2C  AD 00 70    LDA hasContinue
   82  06:CB2F  D0 07       BNE .skipSpriteSet
   83                       
   84  06:CB31  A9 01       LDA #$01
   85  06:CB33  A2 00       LDX #$00
   86  06:CB35  20 3D C2    JSR SetSpriteImage
   87                       
   88  06:CB38            .skipSpriteSet:
   89  06:CB38  EE 0F 00    INC mode_state
   90  06:CB3B  A9 00       LDA #$00
   91  06:CB3D  8D 0A 00    STA time
   92  06:CB40            .leave:
   93  06:CB40  60          RTS
   94                       
   95                       
   96  06:CB41            UpdateGameOverWaitInput:
   97                     
   98                       ;;if there was a record set, flash the time
   99  06:CB41  AD CD 00    LDA recordSet
  100  06:CB44  F0 03       BEQ .updateWait
  101  06:CB46  20 87 CC    JSR FlashTime
  102                     
  103  06:CB49            .updateWait:
  104  06:CB49  AD 00 70    LDA hasContinue
  105  06:CB4C  F0 08       BEQ .checkOption
  106                       
  107  06:CB4E  AD 1C 00    LDA gamepadPressed
  108  06:CB51  F0 7E       BEQ .leave
  109  06:CB53  4C 89 CB    JMP .loadTitle
  110                       
  111  06:CB56            .checkOption:
  112  06:CB56  AD 1C 00    LDA gamepadPressed
  113  06:CB59  C9 01       CMP #GAMEPAD_A
  114  06:CB5B  F0 21       BEQ .checkA
  115                       
  116                       ;;update pointer
  117                       
  118  06:CB5D  AD 1C 00    LDA gamepadPressed
  119  06:CB60  29 C0       AND #GAMEPAD_HORI
  120                       ;;binary system- left and right don't really matter, we'll just toggle the position
  121  06:CB62  F0 6D       BEQ .leave
  122                       
  123  06:CB64  A9 03       LDA #SPRITE_XPOS
  124  06:CB66  A2 00       LDX #$00
  125  06:CB68  20 54 C2    JSR GetSpriteData
  126                       
  127  06:CB6B  C9 58       CMP #GO_YES
  128  06:CB6D  F0 05       BEQ .loadNo
  129                       
  130  06:CB6F  A9 58       LDA #GO_YES
  131  06:CB71  4C 76 CB    JMP .setPosition
  132                       
  133  06:CB74            .loadNo:
  134  06:CB74  A9 80       LDA #GO_NO
  135                     
  136  06:CB76            .setPosition:
  137                       
  138  06:CB76  A2 00       LDX #$00
  139  06:CB78  20 32 C2    JSR SetSpriteXPosition  
  140                     
  141  06:CB7B  4C D1 CB    JMP .leave 
  142                       
  143  06:CB7E            .checkA:
  144                       
  145  06:CB7E  A9 03       LDA #SPRITE_XPOS
  146  06:CB80  A2 00       LDX #$00
  147  06:CB82  20 54 C2    JSR GetSpriteData
  148                       
  149  06:CB85  C9 80       CMP #GO_NO
  150                       
  151                       ;no? go to main menu
  152                       ;yes? update puzzle index and go to game
  153                       ;if puzzle index is the last of the bank, return to menu anyways- we'll polish with a different message later
  154  06:CB87  D0 0D       BNE .loadNext
  155                       
  156                       ;load the title as the next screen
  157  06:CB89            .loadTitle:
  158  06:CB89  A9 00       LDA #TITLE_IDX
  159  06:CB8B  8D CB 00    STA targetGameMode
  160  06:CB8E  A9 00       LDA #$00
  161  06:CB90  8D CC 00    STA targetScreenLoad
  162  06:CB93  4C C9 CB    JMP .changeModeState
  163                      
  164  06:CB96            .loadNext:  
  165                     
  166  06:CB96  EE 08 70    INC puzzle_index
  167  06:CB99  C9 28       CMP #$28
  168  06:CB9B  F0 EC       BEQ .loadTitle
  169                       
  170                       MACROGetLabelPointer PUZZLE_TABLE, table_address
                          
       06:CB9D  A9 A0             LDA #HIGH(PUZZLE_TABLE)
       06:CB9F  A2 00             LDX #LOW(PUZZLE_TABLE)
                                  
       06:CBA1  8E 16 00          STX table_address
       06:CBA4  8D 17 00          STA table_address+1
                                  
  171                       MACROGetDoubleIndex puzzle_index
                          
       06:CBA7  AD 08 70          LDA puzzle_index
       06:CBAA  0A                ASL A
       06:CBAB  A8                TAY
                                  
  172  06:CBAC  20 AF CD    JSR GetTableAtIndex
  173                       MACROGetPointer table_address, puzzle_address
                          
       06:CBAF  AD 16 00          LDA table_address
       06:CBB2  8D AD 00          STA puzzle_address
       06:CBB5  AD 17 00          LDA table_address+1
       06:CBB8  8D AE 00          STA puzzle_address+1
                          
  174                     
  175  06:CBBB  A9 01       LDA #GAME_IDX
  176  06:CBBD  8D CB 00    STA targetGameMode
  177                       
  178  06:CBC0  A0 00       LDY #$00
  179  06:CBC2  B1 AD       LDA [puzzle_address], y
  180  06:CBC4  09 20       ORA #%00100000
  181  06:CBC6  8D CC 00    STA targetScreenLoad
  182                     
  183  06:CBC9            .changeModeState:
  184                     
  185  06:CBC9  A9 00       LDA #$00
  186  06:CBCB  8D 0A 00    STA time
  187  06:CBCE  EE 0F 00    INC mode_state
  188  06:CBD1            .leave:
  189  06:CBD1  60          RTS
  190                     
  191  06:CBD2            UpdateGameOverFadeOut:
  192                     
  193  06:CBD2  AD 0A 00    LDA time
  194  06:CBD5  29 07       AND #$07
  195  06:CBD7  D0 0D       BNE .leave
  196                       ;;every 8 frames, decrement the palettes
  197  06:CBD9  20 88 CF    JSR FadeOutPalettes
  198  06:CBDC  B0 08       BCS .leave
  199                     
  200  06:CBDE            .changeModeState:
  201  06:CBDE  A9 00       LDA #$00
  202  06:CBE0  8D 0A 00    STA time
  203  06:CBE3  EE 0F 00    INC mode_state
  204  06:CBE6            .leave:
  205  06:CBE6  60          RTS
  206                     
  207  06:CBE7            UpdateGameOverExit:
  208                     
  209  06:CBE7  AD 0A 00    LDA time
  210  06:CBEA  29 0F       AND #$0F
  211  06:CBEC  D0 09       BNE .leave
  212                     
  213  06:CBEE  AD CB 00    LDA targetGameMode
  214  06:CBF1  AE CC 00    LDX targetScreenLoad
  215  06:CBF4  20 B8 CC    JSR ChangeGameMode
  216                       
  217  06:CBF7            .leave:
  218  06:CBF7  60          RTS
  219                       
  220  06:CBF8            DrawClearText:
  221                     
  222                       ;;for the clear, we draw multiple lines
  223                       ;;table address location is the print loation
  224                       MACROAddPPUStringEntryTablePtr clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, clues_address
                           
       06:CBF8  A9 01       LDA #$01
       06:CBFA  8D 23 00    STA PPU_PendingWrite
       06:CBFD  AD BA 00    LDA clue_draw_address+1
       06:CC00  20 0B CF    JSR WriteToPPUString
       06:CC03  AD B9 00    LDA clue_draw_address
       06:CC06  20 0B CF    JSR WriteToPPUString
       06:CC09  A9 20       LDA #$20
       06:CC0B  09 00       ORA #DRAW_HORIZONTAL
       06:CC0D  20 0B CF    JSR WriteToPPUString
       06:CC10  AD AF 00    LDA clues_address
       06:CC13  20 0B CF    JSR WriteToPPUString
       06:CC16  AD B0 00    LDA clues_address+1
       06:CC19  20 0B CF    JSR WriteToPPUString
                           
  225  06:CC1C  EE BC 00    INC clueLineIndex
  226  06:CC1F  AD BC 00    LDA clueLineIndex
  227  06:CC22  C9 02       CMP #$02
  228  06:CC24  F0 07       BEQ .printTime
  229  06:CC26  C9 04       CMP #$04
  230  06:CC28  F0 35       BEQ .finish
  231  06:CC2A  4C 34 CC    JMP .updateClueAddress
  232                       
  233  06:CC2D            .printTime:
  234                     
  235  06:CC2D  A9 21       LDA #$21
  236  06:CC2F  A2 31       LDX #$31  
  237  06:CC31  20 8E D3    JSR ApplyGameTimeToPPUString
  238                     
  239  06:CC34            .updateClueAddress:
  240  06:CC34  AD B9 00    LDA clue_draw_address
  241  06:CC37  18          CLC
  242  06:CC38  69 40       ADC #$40
  243  06:CC3A  8D B9 00    STA clue_draw_address
  244  06:CC3D  AD BA 00    LDA clue_draw_address+1
  245  06:CC40  69 00       ADC #$00
  246  06:CC42  8D BA 00    STA clue_draw_address+1
  247                       
  248  06:CC45  A0 00       LDY #$00
  249  06:CC47  B1 AF       LDA [clues_address],y
  250  06:CC49  AA          TAX
  251  06:CC4A  E8          INX
  252  06:CC4B  8A          TXA
  253  06:CC4C  18          CLC
  254  06:CC4D  6D AF 00    ADC clues_address
  255  06:CC50  8D AF 00    STA clues_address
  256  06:CC53  AD B0 00    LDA clues_address+1
  257  06:CC56  69 00       ADC #$00
  258  06:CC58  8D B0 00    STA clues_address+1
  259                       
  260  06:CC5B  18          CLC
  261  06:CC5C  4C 60 CC    JMP .leave
  262  06:CC5F            .finish:
  263                     
  264  06:CC5F  38          SEC
  265  06:CC60            .leave
  266  06:CC60  60          RTS
  267                       
  268  06:CC61            DrawSaveText:
  269                     
  270                       MACROAddPPUStringEntryTablePtr clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, clues_address
                           
       06:CC61  A9 01       LDA #$01
       06:CC63  8D 23 00    STA PPU_PendingWrite
       06:CC66  AD BA 00    LDA clue_draw_address+1
       06:CC69  20 0B CF    JSR WriteToPPUString
       06:CC6C  AD B9 00    LDA clue_draw_address
       06:CC6F  20 0B CF    JSR WriteToPPUString
       06:CC72  A9 20       LDA #$20
       06:CC74  09 00       ORA #DRAW_HORIZONTAL
       06:CC76  20 0B CF    JSR WriteToPPUString
       06:CC79  AD AF 00    LDA clues_address
       06:CC7C  20 0B CF    JSR WriteToPPUString
       06:CC7F  AD B0 00    LDA clues_address+1
       06:CC82  20 0B CF    JSR WriteToPPUString
                           
  271  06:CC85  38          SEC
  272  06:CC86  60          RTS
  273                      
  274  06:CC87            FlashTime:
  275                     
  276  06:CC87  AD 0A 00    LDA time
  277  06:CC8A  29 03       AND #$03
  278  06:CC8C  D0 27       BNE .leave
  279                       
  280                       MACROAddPPUStringEntryRawData #$3F, #$02, #DRAW_HORIZONTAL, #$01
                          
       06:CC8E  A9 01       LDA #$01
       06:CC90  8D 23 00    STA PPU_PendingWrite
       06:CC93  A9 3F       LDA #$3F
       06:CC95  20 0B CF    JSR WriteToPPUString
       06:CC98  A9 02       LDA #$02
       06:CC9A  20 0B CF    JSR WriteToPPUString
       06:CC9D  A9 00       LDA #DRAW_HORIZONTAL
       06:CC9F  20 0B CF    JSR WriteToPPUString
       06:CCA2  A9 01       LDA #$01 
       06:CCA4  20 0B CF    JSR WriteToPPUString
                            
  281  06:CCA7  AD 0A 00    LDA time
  282  06:CCAA  4A          LSR A
  283  06:CCAB  4A          LSR A
  284  06:CCAC  29 01       AND #$01
  285  06:CCAE  AA          TAX
  286  06:CCAF  BD B6 CC    LDA FlashColors, x
  287  06:CCB2  20 0B CF    JSR WriteToPPUString
  288                      
  289  06:CCB5            .leave
  290  06:CCB5  60          RTS 
  291                     
  292  06:CCB6            FlashColors:
  293                     
  294  06:CCB6  2C 16       .db $2C, $16
  295                     
  296                        
  297                     
  298           0058      GO_YES = $58
  299           0080      GO_NO = $80
#[1]   Picross.asm
   86                       
   87                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   88                     ;;     Routines             ;;
   89                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   90                     
   91                     
#[2]   Routines/Common/GameModeRoutines.asm
   92                       .include "Routines/Common/GameModeRoutines.asm"
    1  06:CCB8            ChangeGameMode:
    2                       ;A - game mode index
    3                       ;X - high nibble: palette start flag, low nibble: screen index
    4  06:CCB8  8D 0E 00    STA game_mode
    5  06:CCBB  8E 0D 00    STX mode_loadFlags
    6  06:CCBE  A9 00       LDA #$00
    7  06:CCC0  8D 0F 00    STA mode_state
    8  06:CCC3  20 1F CF    JSR ClearPPUString
    9  06:CCC6  20 CA CC    JSR LoadGameModeScreen
   10  06:CCC9  60          RTS
   11                       
   12  06:CCCA            LoadGameModeScreen:
   13                     
   14                       MACROSetFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:CCCA  AD 10 00    LDA NMI_locks
       06:CCCD  09 01       ORA #BGLOAD_NMI_LOCK
       06:CCCF  8D 10 00    STA NMI_locks
                                  
   15                       
   16  06:CCD2  A9 00       LDA #$00
   17  06:CCD4  8D 01 20    STA PPU_MASK    ; disable rendering- reenable on NMI when not updating
   18                     
   19  06:CCD7  20 05 CD    JSR LoadGameModeBackground
   20  06:CCDA  20 66 CD    JSR LoadGameModeSprites
   21                     
   22                       MACROClearFlags NMI_locks, BGLOAD_NMI_LOCK
                          
       06:CCDD  A9 01       LDA #BGLOAD_NMI_LOCK
       06:CCDF  49 FF       EOR #$FF
       06:CCE1  2D 10 00    AND NMI_locks  
       06:CCE4  8D 10 00    STA NMI_locks
                          
   23                     
   24                       
   25                       ;; load the CHR bank for this mode
   26  06:CCE7  20 F2 CF    JSR ResetMapper
   27                       ;;remember, we're loading the SECOND set in each chr bank
   28                       ;;so we'll take the index from the game mode chr table and add one mult 2
   29  06:CCEA  AE 0E 00    LDX game_mode
   30  06:CCED  BD 83 CD    LDA gameModeInitCHRROMB, x
   31  06:CCF0  0A          ASL A
   32  06:CCF1  18          CLC 
   33  06:CCF2  69 01       ADC #$01
   34  06:CCF4  20 17 D0    JSR LoadCHRBankB
   35                       
   36  06:CCF7  20 F2 CF    JSR ResetMapper
   37  06:CCFA  AE 0E 00    LDX game_mode
   38  06:CCFD  BD 86 CD    LDA gameModeInitCHRROMA, x
   39  06:CD00  0A          ASL A
   40  06:CD01  20 0C D0    JSR LoadCHRBankA
   41                       
   42                       
   43                       
   44  06:CD04  60          RTS
   45                       
   46  06:CD05            LoadGameModeBackground:
   47                             
   48                       MACROGetDoubleIndex game_mode
                          
       06:CD05  AD 0E 00          LDA game_mode
       06:CD08  0A                ASL A
       06:CD09  A8                TAY
                                  
   49  06:CD0A  8C 00 00    STY temp1
   50                             
   51                       MACROGetLabelPointer Palettes, table_address
                          
       06:CD0D  A9 E0             LDA #HIGH(Palettes)
       06:CD0F  A2 00             LDX #LOW(Palettes)
                                  
       06:CD11  8E 16 00          STX table_address
       06:CD14  8D 17 00          STA table_address+1
                                  
   52  06:CD17  20 AF CD    JSR GetTableAtIndex
   53                     
   54  06:CD1A  20 BC CD    JSR LoadFullPaletteFromTable
   55                             
   56  06:CD1D  AC 00 00    LDY temp1
   57  06:CD20  AD 0D 00    LDA mode_loadFlags
   58  06:CD23  29 40       AND #%01000000 ; copy from saved screen
   59  06:CD25  F0 0D       BEQ .dontUseSaveCopy
   60                       MACROGetLabelPointer SaveScreen_Copy, table_address
                          
       06:CD27  A9 68             LDA #HIGH(SaveScreen_Copy)
       06:CD29  A2 00             LDX #LOW(SaveScreen_Copy)
                                  
       06:CD2B  8E 16 00          STX table_address
       06:CD2E  8D 17 00          STA table_address+1
                                  
   61  06:CD31  4C 4B CD    JMP .loadTable
   62                       
   63  06:CD34            .dontUseSaveCopy:
   64                       MACROGetLabelPointer NameTables, table_address
                          
       06:CD34  A9 E0             LDA #HIGH(NameTables)
       06:CD36  A2 06             LDX #LOW(NameTables)
                                  
       06:CD38  8E 16 00          STX table_address
       06:CD3B  8D 17 00          STA table_address+1
                                  
   65  06:CD3E  20 AF CD    JSR GetTableAtIndex
   66  06:CD41  AD 0D 00    LDA mode_loadFlags
   67  06:CD44  29 0F       AND #$0F
   68  06:CD46  0A          ASL A
   69  06:CD47  A8          TAY
   70  06:CD48  20 AF CD    JSR GetTableAtIndex
   71                             
   72  06:CD4B            .loadTable:
   73  06:CD4B  A9 00       LDA #$00
   74  06:CD4D  20 EB CD    JSR LoadFullBackgroundFromTable
   75                       
   76  06:CD50  AC 00 00    LDY temp1
   77                       MACROGetLabelPointer NameTables2, table_address
                          
       06:CD53  A9 E0             LDA #HIGH(NameTables2)
       06:CD55  A2 0C             LDX #LOW(NameTables2)
                                  
       06:CD57  8E 16 00          STX table_address
       06:CD5A  8D 17 00          STA table_address+1
                                  
   78  06:CD5D  20 AF CD    JSR GetTableAtIndex
   79                       
   80  06:CD60  A9 01       LDA #$01
   81  06:CD62  20 EB CD    JSR LoadFullBackgroundFromTable
   82                       
   83  06:CD65  60          RTS
   84                       
   85  06:CD66            LoadGameModeSprites:
   86                     
   87                       MACROGetDoubleIndex game_mode  
                          
       06:CD66  AD 0E 00          LDA game_mode
       06:CD69  0A                ASL A
       06:CD6A  A8                TAY
                                  
   88                       MACROGetLabelPointer Sprites, table_address
                          
       06:CD6B  A9 FD             LDA #HIGH(Sprites)
       06:CD6D  A2 28             LDX #LOW(Sprites)
                                  
       06:CD6F  8E 16 00          STX table_address
       06:CD72  8D 17 00          STA table_address+1
                                  
   89  06:CD75  20 AF CD    JSR GetTableAtIndex
   90  06:CD78  A0 00       LDY #$00
   91  06:CD7A  B1 16       LDA [table_address],y
   92  06:CD7C  EE 16 00    INC table_address
   93  06:CD7F  20 F4 CE    JSR LoadSprites_impl
   94                       
   95  06:CD82  60          RTS
   96                       
   97  06:CD83            gameModeInitCHRROMB:
   98  06:CD83  00 02 02          .db $00, $02, $02
   99  06:CD86            gameModeInitCHRROMA:
  100  06:CD86  00 02 02          .db $00, $02, $02
  101                             
#[1]   Picross.asm
#[2]   Routines/Utils/PointerUtils.asm
   93                       .include "Routines/Utils/PointerUtils.asm"
    1  06:CD89            Dynamic_Jump:
    2                     
    3  06:CD89  0A          ASL A                                 ;; double the index passed into A
    4  06:CD8A  8E 08 00    STX tempx
    5  06:CD8D  8C 09 00    STY tempy
    6  06:CD90  A8          TAY
    7  06:CD91  C8          INY  
    8  06:CD92  68          PLA
    9  06:CD93  8D 18 00    STA jump_address
   10  06:CD96  68          PLA 
   11  06:CD97  8D 19 00    STA jump_address+1            
   12  06:CD9A  B1 18       LDA [jump_address], y
   13  06:CD9C  AA          TAX
   14  06:CD9D  C8          INY
   15  06:CD9E  B1 18       LDA [jump_address], y
   16  06:CDA0  8E 18 00    STX jump_address
   17  06:CDA3  8D 19 00    STA jump_address+1
   18  06:CDA6  AE 08 00    LDX tempx
   19  06:CDA9  AC 09 00    LDY tempy
   20  06:CDAC  6C 18 00    JMP [jump_address]
   21                       
   22  06:CDAF            GetTableAtIndex:
   23                     
   24  06:CDAF  B1 16             LDA [table_address], y
   25  06:CDB1  AA                TAX
   26  06:CDB2  C8                INY
   27  06:CDB3  B1 16             LDA [table_address], y
   28                             
   29  06:CDB5            SetTableAddress:
   30                             
   31                             ;;A is hi, X is lo
   32  06:CDB5  8E 16 00          STX table_address
   33  06:CDB8  8D 17 00          STA table_address+1
   34  06:CDBB  60                RTS
#[1]   Picross.asm
#[2]   Routines/Utils/PPUUtils.asm
   94                       .include "Routines/Utils/PPUUtils.asm"
    1  06:CDBC            LoadFullPaletteFromTable:
    2                     
    3                       MACROSetPPUAddress $3F00
                          
       06:CDBC  AD 02 20    LDA PPU_STATUS             ; read PPU status to reset the high/low latch
       06:CDBF  A9 3F       LDA #HIGH($3F00)
       06:CDC1  8D 06 20    STA PPU_ADDR            ; write the high byte of $2000 address
       06:CDC4  A9 00       LDA #LOW($3F00)
       06:CDC6  8D 06 20    STA PPU_ADDR           ; write the low byte of $2000 address
                            
    4  06:CDC9  A0 00       LDY #$00              ; start out at 0
    5  06:CDCB  A2 00       LDX #$00
    6  06:CDCD            .loop:
    7  06:CDCD  B1 16       LDA [table_address], y        ; load data from address (palette + the value in x)
    8  06:CDCF  9D 00 6C    STA Palette_Copy, x
    9  06:CDD2  48          PHA 
   10  06:CDD3  AD 0D 00    LDA mode_loadFlags
   11  06:CDD6  29 10       AND #$10
   12  06:CDD8  D0 04       BNE .setBlack
   13  06:CDDA  68          PLA 
   14  06:CDDB  4C E1 CD    JMP .setPPUData
   15  06:CDDE            .setBlack:
   16                     
   17  06:CDDE  68          PLA 
   18  06:CDDF  A9 0F       LDA #$0F
   19                       
   20  06:CDE1            .setPPUData:
   21  06:CDE1  8D 07 20    STA PPU_DATA            ; write to PPU
   22  06:CDE4  C8          INY                   ; X = X + 1
   23  06:CDE5  E8          INX
   24  06:CDE6  C0 20       CPY #$20              ; Compare X to hex $10, decimal 16 - copying 16 bytes = 4 sprites
   25  06:CDE8  D0 E3       BNE .loop  ; Branch to LoadPalettesLoop if compare was Not Equal to zero
   26  06:CDEA  60          RTS
   27                     
   28  06:CDEB            LoadFullBackgroundFromTable:
   29                     
   30                         ;;use A as an index for which nametable to write to
   31  06:CDEB  20 3F CF          JSR SetNametableFromIndex
   32  06:CDEE  8A                TXA
   33  06:CDEF  4A                LSR A
   34  06:CDF0  29 01             AND #$01
   35  06:CDF2  D0 17             BNE .copyScreenB
   36                             MACROGetLabelPointer Screen_Copy, pointer_address
                          
       06:CDF4  A9 60             LDA #HIGH(Screen_Copy)
       06:CDF6  A2 00             LDX #LOW(Screen_Copy)
                                  
       06:CDF8  8E 12 00          STX pointer_address
       06:CDFB  8D 13 00          STA pointer_address+1
                                  
   37                             MACROGetLabelPointer SaveScreen_Copy, pointerB_address
                          
       06:CDFE  A9 68             LDA #HIGH(SaveScreen_Copy)
       06:CE00  A2 00             LDX #LOW(SaveScreen_Copy)
                                  
       06:CE02  8E 14 00          STX pointerB_address
       06:CE05  8D 15 00          STA pointerB_address+1
                                  
   38  06:CE08  4C 1E CE          JMP .setCounters
   39                             
   40  06:CE0B            .copyScreenB:
   41                             MACROGetLabelPointer ScreenB_Copy, pointer_address
                          
       06:CE0B  A9 64             LDA #HIGH(ScreenB_Copy)
       06:CE0D  A2 00             LDX #LOW(ScreenB_Copy)
                                  
       06:CE0F  8E 12 00          STX pointer_address
       06:CE12  8D 13 00          STA pointer_address+1
                                  
   42  06:CE15  AD 0D 00          LDA mode_loadFlags
   43  06:CE18  2D 00 00          AND $%11011111
   44  06:CE1B  8D 0D 00          STA mode_loadFlags ;kill the copy flag, just in case
   45                             
   46                             ;;set pointer
   47                             ;; set counters
   48  06:CE1E            .setCounters:
   49  06:CE1E  A0 00             LDY #$00
   50  06:CE20  A2 00             LDX #$00
   51                             
   52                             ;;start loop
   53                     
   54  06:CE22            .outerloop:
   55                     
   56  06:CE22            .innerloop:
   57                     
   58  06:CE22  B1 16             LDA [table_address], y
   59  06:CE24  8D 07 20          STA PPU_DATA
   60  06:CE27  91 12             STA [pointer_address],y
   61  06:CE29  AD 0D 00      LDA mode_loadFlags
   62  06:CE2C  29 20         AND #%00100000      ;check copy flag
   63  06:CE2E  F0 04             BEQ .skipSaveCopy
   64  06:CE30  B1 16         LDA [table_address], y
   65  06:CE32  91 14             STA [pointerB_address],y
   66                     
   67  06:CE34            .skipSaveCopy:
   68  06:CE34  C8                INY
   69  06:CE35  C0 00             CPY #$00
   70  06:CE37  D0 E9             BNE .innerloop
   71                     
   72  06:CE39  EE 13 00          INC pointer_address+1
   73  06:CE3C  EE 17 00          INC table_address+1
   74  06:CE3F  EE 15 00          INC pointerB_address+1
   75                             
   76  06:CE42  E8                INX
   77  06:CE43  E0 04             CPX #$04
   78  06:CE45  D0 DB             BNE .outerloop
   79  06:CE47  60                RTS
   80                             
   81                     
   82           0000      DATA_LEN = temp1
   83           0001      WRITE_SETTINGS = temp2
   84                             
   85  06:CE48            ProcessPPUString:
   86                     
   87  06:CE48  AD 23 00          LDA PPU_PendingWrite
   88  06:CE4B  D0 01             BNE .continueProcess
   89  06:CE4D  60                RTS
   90                             
   91  06:CE4E            .continueProcess:
   92  06:CE4E  A0 00             LDY #$00
   93                             
   94  06:CE50  A9 25             LDA #LOW(PPU_String)
   95  06:CE52  8D 12 00          STA pointer_address
   96  06:CE55  A9 00             LDA #HIGH(PPU_String)
   97  06:CE57  8D 13 00          STA pointer_address + 1
   98                     
   99  06:CE5A            .outerloop:
  100  06:CE5A  AD 02 20          LDA PPU_STATUS
  101  06:CE5D  B1 12             LDA [pointer_address], y
  102  06:CE5F  F0 79             BEQ .finish
  103  06:CE61  8D 06 20          STA PPU_ADDR
  104  06:CE64  C8                INY
  105  06:CE65  B1 12             LDA [pointer_address], y
  106  06:CE67  8D 06 20          STA PPU_ADDR
  107  06:CE6A  C8            INY 
  108  06:CE6B  B1 12             LDA [pointer_address], y
  109  06:CE6D  8D 01 00          STA WRITE_SETTINGS
  110  06:CE70  C8                INY
  111                             
  112  06:CE71  AD 00 20          LDA PPU_CTRL
  113  06:CE74  29 FB             AND #$FB
  114  06:CE76  8D 00 20          STA PPU_CTRL
  115                             
  116  06:CE79  AD 01 00          LDA WRITE_SETTINGS      ;check horizontal or vertical write
  117  06:CE7C  29 80             AND #%10000000
  118  06:CE7E  F0 06             BEQ .checkRepeat
  119  06:CE80  0D 00 20          ORA PPU_CTRL 
  120  06:CE83  8D 00 20          STA PPU_CTRL 
  121                             
  122                             
  123  06:CE86            .checkRepeat:
  124  06:CE86  AD 01 00    LDA WRITE_SETTINGS
  125  06:CE89  29 40       AND #%01000000
  126  06:CE8B  F0 19       BEQ .checkTable
  127                       
  128  06:CE8D  AD 01 00    LDA WRITE_SETTINGS
  129  06:CE90  29 3F       AND #$3F
  130  06:CE92  8D 00 00    STA DATA_LEN
  131                       ;;the usual data length byte is now the repeatable byte
  132  06:CE95  A2 00       LDX #$00
  133                       
  134  06:CE97            .repeatLoop:
  135  06:CE97  B1 12       LDA [pointer_address], y
  136  06:CE99  8D 07 20    STA PPU_DATA
  137  06:CE9C  E8          INX 
  138  06:CE9D  EC 00 00    CPX DATA_LEN
  139  06:CEA0  D0 F5       BNE .repeatLoop
  140  06:CEA2  C8          INY
  141  06:CEA3  4C 5A CE    JMP .outerloop
  142                             
  143  06:CEA6            .checkTable:
  144  06:CEA6  AD 01 00          LDA WRITE_SETTINGS
  145  06:CEA9  29 20             AND #%00100000
  146  06:CEAB  F0 16             BEQ .rawData
  147                             
  148  06:CEAD  B1 12             LDA [pointer_address], y
  149  06:CEAF  8D 16 00          STA table_address
  150  06:CEB2  C8                INY 
  151  06:CEB3  B1 12             LDA [pointer_address], y
  152  06:CEB5  8D 17 00          STA table_address + 1
  153  06:CEB8  C8                INY
  154  06:CEB9  98                TYA 
  155  06:CEBA  48                PHA
  156  06:CEBB  20 DE CE          JSR WriteToPPUFromTable
  157  06:CEBE  68                PLA
  158  06:CEBF  A8                TAY
  159  06:CEC0  4C 5A CE          JMP .outerloop
  160                             
  161  06:CEC3            .rawData:
  162                     
  163  06:CEC3  B1 12             LDA [pointer_address], y
  164  06:CEC5  C8                INY
  165  06:CEC6  8D 00 00          STA DATA_LEN
  166                     
  167  06:CEC9  A2 00             LDX #$00
  168                     
  169  06:CECB            .innerloop:
  170                             
  171  06:CECB  B1 12             LDA [pointer_address], y
  172  06:CECD  8D 07 20          STA PPU_DATA
  173  06:CED0  C8                INY
  174  06:CED1  E8                INX
  175  06:CED2  EC 00 00          CPX DATA_LEN
  176  06:CED5  D0 F4             BNE .innerloop
  177  06:CED7  4C 5A CE          JMP .outerloop
  178                             
  179  06:CEDA            .finish:
  180  06:CEDA  20 1F CF          JSR ClearPPUString
  181  06:CEDD            .leave:
  182  06:CEDD  60                RTS
  183                             
  184  06:CEDE            WriteToPPUFromTable:
  185  06:CEDE  A0 00             LDY #$00
  186  06:CEE0  B1 16             LDA [table_address], y
  187  06:CEE2  C8                INY
  188  06:CEE3  8D 00 00          STA DATA_LEN
  189  06:CEE6            .innerloop:
  190  06:CEE6  B1 16             LDA [table_address], y
  191  06:CEE8  8D 07 20          STA PPU_DATA
  192  06:CEEB  C8                INY
  193  06:CEEC  CC 00 00          CPY DATA_LEN
  194  06:CEEF  90 F5             BCC .innerloop ;table should have the size in it, but since we count the byte count, we'll want to wait till we go over it
  195  06:CEF1  F0 F3             BEQ .innerloop
  196  06:CEF3  60                RTS
  197                       
  198  06:CEF4            LoadSprites_impl:
  199                       ;;A will be the amount of sprites to load
  200  06:CEF4  8D 00 00    STA DATA_LEN
  201  06:CEF7  0E 00 00    ASL DATA_LEN
  202  06:CEFA  0E 00 00    ASL DATA_LEN
  203                       
  204  06:CEFD  A0 00       LDY #$00              ; start at 0
  205                       
  206  06:CEFF            .loop:
  207  06:CEFF  B1 16       LDA [table_address], y; load data from address (sprites +  x)
  208  06:CF01  99 00 02    STA SPRITE_DATA, y    ; store into RAM address ($0200 + x)
  209  06:CF04  C8          INY                   ; X = X + 1
  210  06:CF05  CC 00 00    CPY DATA_LEN             ; Compare X to hex $10, decimal 16
  211  06:CF08  D0 F5       BNE .loop   ; Branch to LoadSpritesLoop if compare was Not Equal to zero
  212                                             ; if compare was equal to 16, keep going down   
  213  06:CF0A  60          RTS
  214                     
  215                     
  216  06:CF0B            WriteToPPUString:
  217                     
  218  06:CF0B  AE 24 00          LDX PPU_StringIdx
  219  06:CF0E  E0 4F             CPX #PPU_STRINGMAX
  220  06:CF10  F0 0C             BEQ .finish
  221                             
  222  06:CF12  9D 25 00          STA PPU_String, x
  223  06:CF15  EE 24 00          INC PPU_StringIdx
  224  06:CF18  E8                INX
  225  06:CF19  A9 00             LDA #$00
  226  06:CF1B  9D 25 00          STA PPU_String, x
  227                                     
  228  06:CF1E            .finish:
  229  06:CF1E  60                RTS
  230                     
  231  06:CF1F            ClearPPUString:
  232                             
  233  06:CF1F  A9 00             LDA #$00
  234  06:CF21  8D 24 00          STA PPU_StringIdx
  235  06:CF24  8D 25 00          STA PPU_String
  236  06:CF27  8D 23 00          STA PPU_PendingWrite
  237  06:CF2A  60                RTS
  238                     
  239  06:CF2B            DetectSprite0:
  240  06:CF2B            WaitNotSprite0:
  241  06:CF2B  AD 02 20    lda PPU_STATUS
  242  06:CF2E  29 40       and #SPRITE_0_MASK
  243  06:CF30  D0 F9       bne WaitNotSprite0   ; wait until sprite 0 not hit
  244                     
  245  06:CF32            WaitSprite0:
  246  06:CF32  AD 02 20    lda $2002
  247  06:CF35  29 40       and #SPRITE_0_MASK
  248  06:CF37  F0 F9       beq WaitSprite0      ; wait until sprite 0 is hit
  249                     
  250  06:CF39  A2 05       ldx #$05                              ;do a scanline wait
  251  06:CF3B            WaitScanline:
  252  06:CF3B  CA          dex
  253  06:CF3C  D0 FD       bne WaitScanline
  254  06:CF3E  60          RTS
  255                     
  256                     
  257  06:CF3F            SetNametableFromIndex:
  258                     
  259  06:CF3F  48          PHA
  260  06:CF40  AD 02 20    LDA PPU_STATUS
  261  06:CF43  68          PLA
  262  06:CF44  0A          ASL A
  263  06:CF45  AA          TAX
  264  06:CF46  BD DB CF    LDA NameTableMemList+1, x
  265  06:CF49  8D 06 20    STA PPU_ADDR
  266  06:CF4C  BD DA CF    LDA NameTableMemList, x
  267  06:CF4F  8D 06 20    STA PPU_ADDR
  268  06:CF52  60          RTS
  269                       
  270  06:CF53            TurnOnSprites:
  271                      
  272  06:CF53  AD 1E 00    LDA PPU_Mask
  273  06:CF56  09 10       ORA #%00010000
  274  06:CF58  8D 1E 00    STA PPU_Mask
  275  06:CF5B  60          RTS
  276                       
  277  06:CF5C            TurnOffSprites:
  278                       
  279  06:CF5C  AD 1E 00    LDA PPU_Mask
  280  06:CF5F  29 EF       AND #%11101111
  281  06:CF61  8D 1E 00    STA PPU_Mask
  282  06:CF64  60          RTS
  283                     
  284  06:CF65            UpdatePPUControl:
  285                     
  286  06:CF65  AD 1D 00    LDA PPU_Control
  287  06:CF68  29 FC       AND #$FC
  288  06:CF6A  0D 22 00    ORA PPU_NT
  289  06:CF6D  8D 00 20    STA PPU_CTRL
  290  06:CF70  AD 1E 00    LDA PPU_Mask
  291  06:CF73  8D 01 20    STA PPU_MASK
  292  06:CF76  60          RTS
  293                       
  294  06:CF77            InitPPUControl:
  295                       
  296                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
  297                       ; enable sprites, enable background, no clipping on left side
  298  06:CF77  A9 90       LDA #%10010000
  299  06:CF79  8D 00 20    STA PPU_CTRL
  300  06:CF7C  8D 1D 00    STA PPU_Control
  301  06:CF7F  A9 1E       LDA #%00011110
  302  06:CF81  8D 01 20    STA PPU_MASK
  303  06:CF84  8D 1E 00    STA PPU_Mask
  304  06:CF87  60          RTS
  305                       
  306  06:CF88            FadeOutPalettes:
  307                     
  308                     ;;take the current values, and decrement the lower nibbles
  309                     ;;we can access from the palette copy 
  310                     ;;we'll make this fade out one level per call
  311                     ;;once all the palettes are blacked out we'll return true, so we'll keep the carry flag as a return result
  312                     
  313                     ;;go through the palette copy, decrement, make a raw data PPU string and add all the bytes into it
  314                     ;;for any palette color already in the 0x range, change it to 0f to get black
  315                     
  316                       MACROGetLabelPointer Palette_Copy, table_address
                          
       06:CF88  A9 6C             LDA #HIGH(Palette_Copy)
       06:CF8A  A2 00             LDX #LOW(Palette_Copy)
                                  
       06:CF8C  8E 16 00          STX table_address
       06:CF8F  8D 17 00          STA table_address+1
                                  
  317                     ;;palette copy address is now X accessable
  318                     
  319  06:CF92  A0 00       LDY #$00
  320                       MACROAddPPUStringEntryRawData #$3F, #$00, #DRAW_HORIZONTAL, #$20  
                          
       06:CF94  A9 01       LDA #$01
       06:CF96  8D 23 00    STA PPU_PendingWrite
       06:CF99  A9 3F       LDA #$3F
       06:CF9B  20 0B CF    JSR WriteToPPUString
       06:CF9E  A9 00       LDA #$00
       06:CFA0  20 0B CF    JSR WriteToPPUString
       06:CFA3  A9 00       LDA #DRAW_HORIZONTAL
       06:CFA5  20 0B CF    JSR WriteToPPUString
       06:CFA8  A9 20       LDA #$20 
       06:CFAA  20 0B CF    JSR WriteToPPUString
                            
  321                     
  322  06:CFAD  A9 00       LDA #$00
  323  06:CFAF  8D 00 00    STA temp1
  324                       
  325  06:CFB2            .loop:
  326                     
  327  06:CFB2  B1 16       LDA [table_address], y
  328  06:CFB4  C9 0F       CMP #$0F
  329  06:CFB6  F0 15       BEQ .addToString
  330  06:CFB8  C9 10       CMP #$10
  331  06:CFBA  90 0D       BCC .setBlack
  332                       
  333  06:CFBC  A9 80       LDA #$80
  334  06:CFBE  8D 00 00    STA temp1
  335                       
  336  06:CFC1  B1 16       LDA [table_address], y
  337  06:CFC3  38          SEC
  338  06:CFC4  E9 10       SBC #$10
  339  06:CFC6  4C CB CF    JMP .setColor
  340                     
  341  06:CFC9            .setBlack:
  342                     
  343  06:CFC9  A9 0F       LDA #$0F
  344                     
  345  06:CFCB            .setColor:
  346  06:CFCB  91 16       STA [table_address], y
  347                     
  348  06:CFCD            .addToString:
  349                     
  350  06:CFCD  20 0B CF    JSR WriteToPPUString
  351                     
  352  06:CFD0            .incY:
  353                       
  354  06:CFD0  C8          INY
  355  06:CFD1  C0 20       CPY #$20
  356  06:CFD3  D0 DD       BNE .loop
  357                     
  358  06:CFD5  0E 00 00    ASL temp1     ;get carry out, if we have one
  359                     
  360  06:CFD8  60          RTS
  361                       
  362  06:CFD9            FadeInPalettes:
  363                     
  364                     ;;need to be able to store off a target palette first
  365                     ;;we can use the palette copy we make during the game mode change as the target
  366  06:CFD9  60          RTS
  367                     
  368  06:CFDA            NameTableMemList:
  369  06:CFDA  00 20       .word $2000, $2400, $2800, $2C00
       06:CFDC  00 24     
       06:CFDE  00 28     
       06:CFE0  00 2C     
  370  06:CFE2            PalettesMemList:
  371  06:CFE2  00 3F       .word $3F00, $3F04, $3F08, $3F0C
       06:CFE4  04 3F     
       06:CFE6  08 3F     
       06:CFE8  0C 3F     
  372  06:CFEA  10 3F       .word $3F10, $3F14, $3F18, $3F1C  
       06:CFEC  14 3F     
       06:CFEE  18 3F     
       06:CFF0  1C 3F     
  373                       
  374           0024      BLANK_TILE = $24
#[1]   Picross.asm
#[2]   Routines/Utils/MapperUtils.asm
   95                       .include "Routines/Utils/MapperUtils.asm"
    1           0080      MAPPERCONTROL = $80
    2           00A0      CHRBANK1 = $A0
    3           00C0      CHRBANK2 = $C0
    4           00E0      PRGBANK = $E0
    5                     
    6  06:CFF2            ResetMapper:
    7  06:CFF2  EE F2 CF    inc ResetMapper
    8  06:CFF5  60          RTS
    9                       
   10                     ;;now, set up the controls for the mapper
   11                     ;;4bit0
   12                     ;;-----
   13                     ;;CPPMM
   14                     ;;|||||
   15                     ;;|||++- Mirroring (0: one-screen, lower bank; 1: one-screen, upper bank;
   16                     ;;|||               2: vertical; 3: horizontal)
   17                     ;;|++--- PRG ROM bank mode (0, 1: switch 32 KB at $8000, ignoring low bit of bank number;
   18                     ;;|                         2: fix first bank at $8000 and switch 16 KB bank at $C000;
   19                     ;;|                         3: fix last bank at $C000 and switch 16 KB bank at $8000)
   20                     ;;+----- CHR ROM bank mode (0: switch 8 KB at a time; 1: switch two separate 4 KB banks)
   21                        
   22  06:CFF6            SetMapperControls:
   23                       ;;A = controls
   24  06:CFF6  AA          TAX
   25  06:CFF7  A9 80       LDA #MAPPERCONTROL
   26  06:CFF9  8D A6 00    STA mapper_address+1
   27  06:CFFC  8A          TXA
   28  06:CFFD  20 22 D0    JSR SendMapperCommand
   29  06:D000  60          RTS
   30                     
   31  06:D001            LoadPRGBank:
   32                     
   33                             ;;A is the desired PRG number
   34  06:D001  AA                TAX
   35  06:D002  A9 E0             LDA #PRGBANK
   36  06:D004  8D A6 00          STA mapper_address+1
   37  06:D007  8A                TXA
   38  06:D008  20 22 D0          JSR SendMapperCommand
   39  06:D00B  60                RTS
   40                             
   41  06:D00C            LoadCHRBankA:
   42                             ;;A is the desired CHR bank
   43  06:D00C  AA                TAX
   44  06:D00D  A9 A0             LDA #CHRBANK1
   45  06:D00F  8D A6 00          STA mapper_address+1
   46  06:D012  8A                TXA
   47  06:D013  20 22 D0          JSR SendMapperCommand
   48  06:D016  60                RTS
   49                             
   50  06:D017            LoadCHRBankB:
   51                             ;;A is the desired CHR bank
   52  06:D017  AA                TAX
   53  06:D018  A9 C0             LDA #CHRBANK2
   54  06:D01A  8D A6 00          STA mapper_address+1
   55  06:D01D  8A                TXA
   56  06:D01E  20 22 D0          JSR SendMapperCommand
   57  06:D021  60                RTS
   58                             
   59  06:D022            SendMapperCommand:
   60                     
   61  06:D022  A0 00             LDY #$00
   62                             
   63  06:D024  91 A5             STA [mapper_address], y
   64  06:D026  4A                LSR A
   65  06:D027  91 A5             STA [mapper_address], y
   66  06:D029  4A                LSR A
   67  06:D02A  91 A5             STA [mapper_address], y
   68  06:D02C  4A                LSR A 
   69  06:D02D  91 A5             STA [mapper_address], y
   70  06:D02F  4A                LSR A
   71  06:D030  91 A5             STA [mapper_address], y
   72                             
   73  06:D032  60                RTS
   74                             
   75  06:D033            ResetBanks:
   76                     
   77  06:D033  20 F2 CF          JSR ResetMapper
   78  06:D036  A9 00             LDA #$00
   79  06:D038  20 01 D0          JSR LoadPRGBank
   80                       
   81                             ;;as a test, load up the initial CHR banks
   82  06:D03B  20 F2 CF          JSR ResetMapper
   83  06:D03E  A9 00             LDA #$00
   84  06:D040  20 0C D0          JSR LoadCHRBankA
   85  06:D043  A9 01             LDA #$01
   86  06:D045  20 17 D0          JSR LoadCHRBankB
   87  06:D048  60                RTS
   88                             
   89                       
#[1]   Picross.asm
#[2]   Routines/Game_Routines/ScreenEffects.asm
   96                       .include "Routines/Game_Routines/ScreenEffects.asm"
    1  06:D049            PopulateClues:
    2                       
    3  06:D049  A0 00       LDY #$00
    4  06:D04B  B1 AD       LDA [puzzle_address], y
    5  06:D04D  AA          TAX
    6  06:D04E  BD EB D3    LDA PuzzleSizes, x
    7  06:D051  8D 00 00    STA temp1
    8                       
    9  06:D054            .getByte:
   10  06:D054  AC BB 00    LDY clueTableIndex
   11  06:D057  B1 AF       LDA [clues_address], y
   12  06:D059  D0 07       BNE .checkNewLine
   13  06:D05B  EE BB 00    INC clueTableIndex
   14  06:D05E  A9 00       LDA #$00
   15  06:D060  F0 39       BEQ .drawClue
   16                       ;was 0, set up a draw
   17  06:D062            .checkNewLine
   18  06:D062  C9 FF       CMP #$FF
   19  06:D064  D0 18       BNE .getClue
   20                       
   21                       ;;was FF- need to inc stuff
   22  06:D066  EE BB 00    INC clueTableIndex
   23  06:D069  A9 00       LDA #$00
   24  06:D06B  8D C2 00    STA clueParity
   25                       
   26  06:D06E  EE BC 00    INC clueLineIndex
   27  06:D071  AD BC 00    LDA clueLineIndex
   28  06:D074  CD 00 00    CMP temp1
   29                       ;CMP #$01
   30  06:D077  F0 28       BEQ .leave    ;carry will be set
   31                       
   32  06:D079  20 2A D1    JSR CreateOffsetFromIndex
   33                      
   34  06:D07C  D0 D6       BNE .getByte
   35                       
   36  06:D07E            .getClue:
   37                       ;;clues go from high nibble to low nibble
   38  06:D07E  48          PHA 
   39  06:D07F  AD C2 00    LDA clueParity
   40  06:D082  D0 0A       BNE .getSecondClue
   41  06:D084  EE C2 00    INC clueParity
   42  06:D087  68          PLA
   43  06:D088  4A          LSR A
   44  06:D089  4A          LSR A
   45  06:D08A  4A          LSR A
   46  06:D08B  4A          LSR A         ;move clue over to lower nibble
   47  06:D08C  D0 0D       BNE .drawClue
   48                       
   49  06:D08E            .getSecondClue:
   50                     
   51  06:D08E  CE C2 00    DEC clueParity
   52  06:D091  EE BB 00    INC clueTableIndex
   53  06:D094  68          PLA 
   54  06:D095  29 0F       AND #$0F
   55  06:D097  D0 02       BNE .drawClue
   56                       ;;if 0, skip
   57  06:D099  F0 B9       BEQ .getByte
   58                      
   59  06:D09B            .drawClue:
   60                       
   61  06:D09B  09 40       ORA #$40
   62  06:D09D  20 A2 D0    JSR WriteClueByteToPPUString
   63  06:D0A0  18          CLC
   64                       
   65  06:D0A1            .leave:
   66  06:D0A1  60          RTS
   67                       
   68  06:D0A2            WriteClueByteToPPUString:
   69                     
   70  06:D0A2  8D 00 00    STA temp1 ;store off the tile value
   71                     
   72                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, #$01
                          
       06:D0A5  A9 01       LDA #$01
       06:D0A7  8D 23 00    STA PPU_PendingWrite
       06:D0AA  AD BA 00    LDA clue_draw_address+1
       06:D0AD  20 0B CF    JSR WriteToPPUString
       06:D0B0  AD B9 00    LDA clue_draw_address
       06:D0B3  20 0B CF    JSR WriteToPPUString
       06:D0B6  A9 00       LDA #DRAW_HORIZONTAL
       06:D0B8  20 0B CF    JSR WriteToPPUString
       06:D0BB  A9 01       LDA #$01 
       06:D0BD  20 0B CF    JSR WriteToPPUString
                            
   73  06:D0C0  AD 00 00    LDA temp1
   74  06:D0C3  20 0B CF    JSR WriteToPPUString
   75                       
   76                       ;;also copy to ... copy
   77  06:D0C6  AD B9 00    LDA clue_draw_address
   78  06:D0C9  8D B3 00    STA copy_address
   79  06:D0CC  AD BA 00    LDA clue_draw_address+1
   80  06:D0CF  29 0F       AND #$0F
   81  06:D0D1  09 60       ORA #$60
   82  06:D0D3  8D B4 00    STA copy_address+1
   83  06:D0D6  AD 00 00    LDA temp1
   84  06:D0D9  A0 00       LDY #$00
   85  06:D0DB  91 B3       STA [copy_address],y
   86                       
   87  06:D0DD  AD BE 00    LDA clueDrawAdd
   88  06:D0E0  20 07 D1    JSR SubFromClueDrawAddress
   89                         
   90  06:D0E3  60          RTS
   91                       
   92  06:D0E4            ResetClueDrawAddress:
   93                     
   94                       MACROGetPointer clue_start_address, clue_draw_address
                          
       06:D0E4  AD B7 00          LDA clue_start_address
       06:D0E7  8D B9 00          STA clue_draw_address
       06:D0EA  AD B8 00          LDA clue_start_address+1
       06:D0ED  8D BA 00          STA clue_draw_address+1
                          
   95                       
   96  06:D0F0  60          RTS
   97                       
   98  06:D0F1            AddToClueDrawAddress:
   99                     
  100  06:D0F1  8D 00 00    STA temp1
  101                       
  102  06:D0F4  AD B9 00    LDA clue_draw_address
  103  06:D0F7  18          CLC
  104  06:D0F8  6D 00 00    ADC temp1
  105  06:D0FB  8D B9 00    STA clue_draw_address
  106  06:D0FE  AD BA 00    LDA clue_draw_address+1
  107  06:D101  69 00       ADC #$00
  108  06:D103  8D BA 00    STA clue_draw_address+1
  109                       
  110  06:D106  60          RTS
  111                         
  112  06:D107            SubFromClueDrawAddress:
  113                     
  114  06:D107  8D 00 00    STA temp1
  115                       
  116  06:D10A  AD B9 00    LDA clue_draw_address
  117  06:D10D  38          SEC
  118  06:D10E  ED 00 00    SBC temp1
  119  06:D111  8D B9 00    STA clue_draw_address
  120  06:D114  AD BA 00    LDA clue_draw_address+1
  121  06:D117  E9 00       SBC #$00
  122  06:D119  8D BA 00    STA clue_draw_address+1
  123                       
  124  06:D11C  60          RTS
  125                       
  126  06:D11D            AddToClueDrawAddressHi:
  127                     
  128  06:D11D  8D 00 00    STA temp1
  129                       
  130  06:D120  AD BA 00    LDA clue_draw_address+1
  131  06:D123  6D 00 00    ADC temp1
  132  06:D126  8D BA 00    STA clue_draw_address+1
  133                       
  134  06:D129  60          RTS
  135                       
  136  06:D12A            CreateOffsetFromIndex:
  137                     
  138                       ;;would be this, but we need to be able to go further- so we'll make a doulbe offset
  139  06:D12A  AD BC 00    LDA clueLineIndex
  140  06:D12D  8D BF 00    STA clueDrawOffset
  141  06:D130  A9 00       LDA #$00
  142  06:D132  8D C0 00    STA clueDrawOffset+1
  143                       
  144  06:D135  AD BD 00    LDA clueOffsetShift   
  145  06:D138  F0 0E       BEQ .addOffset
  146                       
  147  06:D13A  A2 00       LDX #$00
  148                       
  149  06:D13C            .loopShift:
  150  06:D13C  0E BF 00    ASL clueDrawOffset
  151  06:D13F  2E C0 00    ROL clueDrawOffset+1
  152  06:D142  E8          INX
  153  06:D143  EC BD 00    CPX clueOffsetShift
  154  06:D146  D0 F4       BNE .loopShift
  155                       
  156  06:D148            .addOffset:
  157                       
  158  06:D148  20 E4 D0    JSR ResetClueDrawAddress
  159  06:D14B  AD BF 00    LDA clueDrawOffset
  160  06:D14E  20 F1 D0    JSR AddToClueDrawAddress 
  161  06:D151  AD C0 00    LDA clueDrawOffset+1
  162  06:D154  20 1D D1    JSR AddToClueDrawAddressHi
  163                       
  164  06:D157  60          RTS  
  165                       
  166  06:D158            ClearPuzzle:
  167                     
  168                       ;we'll assume clue draw address has been set to the top of the 1st nametable
  169                      
  170                       MACROGetLabelPointer ClearLineDefs, table_address
                          
       06:D158  A9 D3             LDA #HIGH(ClearLineDefs)
       06:D15A  A2 CD             LDX #LOW(ClearLineDefs)
                                  
       06:D15C  8E 16 00          STX table_address
       06:D15F  8D 17 00          STA table_address+1
                                  
  171                     
  172  06:D162  AC BC 00    LDY clueLineIndex
  173  06:D165  B1 16       LDA [table_address], y
  174  06:D167  8D 00 00    STA temp1
  175                       MACROAddPPUStringEntryRepeat clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp1, #$24
                          
       06:D16A  A9 01       LDA #$01
       06:D16C  8D 23 00    STA PPU_PendingWrite
       06:D16F  AD BA 00    LDA clue_draw_address+1
       06:D172  20 0B CF    JSR WriteToPPUString
       06:D175  AD B9 00    LDA clue_draw_address
       06:D178  20 0B CF    JSR WriteToPPUString
       06:D17B  A9 40       LDA #$40
       06:D17D  09 00       ORA #DRAW_HORIZONTAL
       06:D17F  0D 00 00    ORA temp1
       06:D182  20 0B CF    JSR WriteToPPUString
       06:D185  A9 24       LDA #$24
       06:D187  20 0B CF    JSR WriteToPPUString
                            
  176                       ;;no need to load anything else
  177                       
  178  06:D18A  AD B9 00    LDA clue_draw_address
  179  06:D18D  18          CLC
  180  06:D18E  69 20       ADC #32
  181  06:D190  8D B9 00    STA clue_draw_address
  182  06:D193  AD BA 00    LDA clue_draw_address+1
  183  06:D196  69 00       ADC #$00
  184  06:D198  8D BA 00    STA clue_draw_address+1
  185                       
  186  06:D19B  EE BC 00    INC clueLineIndex
  187  06:D19E  60          RTS
  188                       
  189  06:D19F            LoadPauseScreen:
  190                     
  191                     ;;use clue indexes again
  192                     ;;we want to draw one line at a time
  193                     ;;we have control codes, but those don't matter since we have to build ou the strings before hand
  194                     
  195                     ;load pause table
  196                     ;there are 6 lines of 13 tiles
  197                     ;one byte for the 6 lines, one byte to keep track of our index
  198                       ;STA clueLineIndex 
  199                       ;STA clueOffsetShift
  200                     
  201                     ;;pause_address has the table we want
  202                     ;;pause_draw_address will be the draw location
  203                     
  204                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:D19F  A9 01       LDA #$01
       06:D1A1  8D 23 00    STA PPU_PendingWrite
       06:D1A4  AD B6 00    LDA pause_draw_address+1
       06:D1A7  20 0B CF    JSR WriteToPPUString
       06:D1AA  AD B5 00    LDA pause_draw_address
       06:D1AD  20 0B CF    JSR WriteToPPUString
       06:D1B0  A9 00       LDA #DRAW_HORIZONTAL
       06:D1B2  20 0B CF    JSR WriteToPPUString
       06:D1B5  A9 0D       LDA #13 
       06:D1B7  20 0B CF    JSR WriteToPPUString
                            
  205                     
  206  06:D1BA  A2 00       LDX #$00
  207  06:D1BC  AC BC 00    LDY clueLineIndex
  208  06:D1BF            .loop:
  209                      
  210  06:D1BF  8A          TXA
  211  06:D1C0  48          PHA
  212  06:D1C1  B1 B1       LDA [pause_address],y
  213  06:D1C3  20 0B CF    JSR WriteToPPUString
  214  06:D1C6  68          PLA
  215  06:D1C7  AA          TAX
  216  06:D1C8  C8          INY
  217  06:D1C9  E8          INX 
  218  06:D1CA  E0 0D       CPX #13
  219  06:D1CC  D0 F1       BNE .loop
  220                       
  221  06:D1CE  8C BC 00    STY clueLineIndex
  222                       
  223  06:D1D1  AD B5 00    LDA pause_draw_address
  224  06:D1D4  18          CLC
  225  06:D1D5  69 20       ADC #$20
  226  06:D1D7  8D B5 00    STA pause_draw_address
  227  06:D1DA  AD B6 00    LDA pause_draw_address+1
  228  06:D1DD  69 00       ADC #$00
  229  06:D1DF  8D B6 00    STA pause_draw_address+1
  230                       
  231  06:D1E2  EE BD 00    INC clueOffsetShift
  232  06:D1E5  60          RTS
  233                       
  234                       
  235                     
  236                     
  237  06:D1E6            ClearPauseScreen:  
  238                     
  239                       MACROAddPPUStringEntryRawData pause_draw_address+1, pause_draw_address, #DRAW_HORIZONTAL, #13
                          
       06:D1E6  A9 01       LDA #$01
       06:D1E8  8D 23 00    STA PPU_PendingWrite
       06:D1EB  AD B6 00    LDA pause_draw_address+1
       06:D1EE  20 0B CF    JSR WriteToPPUString
       06:D1F1  AD B5 00    LDA pause_draw_address
       06:D1F4  20 0B CF    JSR WriteToPPUString
       06:D1F7  A9 00       LDA #DRAW_HORIZONTAL
       06:D1F9  20 0B CF    JSR WriteToPPUString
       06:D1FC  A9 0D       LDA #13 
       06:D1FE  20 0B CF    JSR WriteToPPUString
                            
  240                     
  241  06:D201  A2 00       LDX #$00
  242  06:D203  A0 00       LDY #$00
  243  06:D205            .loop:
  244                      
  245  06:D205  8A          TXA
  246  06:D206  48          PHA
  247  06:D207  B1 B1       LDA [pause_address],y
  248  06:D209  20 0B CF    JSR WriteToPPUString
  249  06:D20C  68          PLA
  250  06:D20D  AA          TAX
  251  06:D20E  C8          INY
  252  06:D20F  E8          INX 
  253  06:D210  E0 0D       CPX #13
  254  06:D212  D0 F1       BNE .loop
  255                       
  256                       
  257  06:D214  AD B5 00    LDA pause_draw_address
  258  06:D217  18          CLC
  259  06:D218  69 20       ADC #$20
  260  06:D21A  8D B5 00    STA pause_draw_address
  261  06:D21D  AD B6 00    LDA pause_draw_address+1
  262  06:D220  69 00       ADC #$00
  263  06:D222  8D B6 00    STA pause_draw_address+1
  264                       
  265  06:D225  AD B1 00    LDA pause_address
  266  06:D228  18          CLC
  267  06:D229  69 20       ADC #$20
  268  06:D22B  8D B1 00    STA pause_address
  269  06:D22E  AD B2 00    LDA pause_address+1
  270  06:D231  69 00       ADC #$00
  271  06:D233  8D B2 00    STA pause_address+1
  272                       
  273  06:D236  EE BD 00    INC clueOffsetShift
  274  06:D239  60         RTS
  275  06:D23A            DrawImage:
  276                     
  277                       ;;we have clueTableIndex, which should be at the image bytes now
  278                       ;;clue line index will keep track of our place in a byte
  279                        
  280  06:D23A  A9 00       LDA #$00
  281  06:D23C  8D 00 00    STA temp1
  282  06:D23F  8D 01 00    STA temp2
  283  06:D242  8D 02 00    STA temp3
  284  06:D245  8D 03 00    STA temp4
  285  06:D248  8D 05 00    STA temp6
  286                       
  287  06:D24B  A9 04       LDA #$04
  288  06:D24D  8D 04 00    STA temp5
  289                       
  290  06:D250  A0 00       LDY #$00
  291  06:D252  B1 AD       LDA [puzzle_address], y
  292  06:D254  AA          TAX
  293  06:D255  BD EB D3    LDA PuzzleSizes, x
  294  06:D258  8D 06 00    STA temp7
  295  06:D25B  BD EE D3    LDA PuzzleImageSizes, x
  296  06:D25E  8D 07 00    STA temp8
  297  06:D261  4A          LSR A
  298  06:D262  4A          LSR A
  299  06:D263  8D 09 00    STA tempy
  300  06:D266  AD 07 00    LDA temp8
  301  06:D269  29 03       AND #$03
  302  06:D26B  F0 03       BEQ .skipAdd1
  303  06:D26D  EE 09 00    INC tempy  
  304  06:D270            .skipAdd1:
  305  06:D270  BD F1 D3    LDA ImageDrawWrapOffsets, x
  306  06:D273  8D 08 00    STA tempx
  307                       
  308  06:D276  AC BB 00    LDY clueTableIndex
  309  06:D279  B1 AF       LDA [clues_address], y
  310                     
  311  06:D27B  0A          ASL A
  312  06:D27C  2E 00 00    ROL temp1
  313  06:D27F  0A          ASL A
  314  06:D280  2E 00 00    ROL temp1
  315  06:D283  0A          ASL A
  316  06:D284  2E 01 00    ROL temp2
  317  06:D287  0A          ASL A
  318  06:D288  2E 01 00    ROL temp2
  319  06:D28B  0A          ASL A
  320  06:D28C  2E 02 00    ROL temp3
  321  06:D28F  0A          ASL A
  322  06:D290  2E 02 00    ROL temp3
  323  06:D293  0A          ASL A
  324  06:D294  2E 03 00    ROL temp4
  325  06:D297  0A          ASL A
  326  06:D298  2E 03 00    ROL temp4
  327                       
  328                     
  329  06:D29B  A2 00       LDX #$00
  330  06:D29D            .moveUpTiles:
  331  06:D29D  BD 00 00    LDA temp1, x
  332  06:D2A0  09 24       ORA #$24
  333  06:D2A2  9D 00 00    STA temp1, x
  334  06:D2A5  E8          INX
  335  06:D2A6  E0 04       CPX #$04
  336  06:D2A8  D0 F3       BNE .moveUpTiles
  337                       
  338                       
  339  06:D2AA  AD BD 00    LDA clueOffsetShift
  340  06:D2AD  18          CLC
  341  06:D2AE  69 04       ADC #$04
  342                     
  343  06:D2B0  8D BD 00    STA clueOffsetShift
  344                       ;;clue offset shift + 4, check if we went over puzle row length
  345  06:D2B3  38          SEC
  346  06:D2B4  ED 06 00    SBC temp7 ;;subtract 15
  347  06:D2B7  90 12       BCC .makeStrings
  348  06:D2B9  F0 10       BEQ .makeStrings
  349                       
  350  06:D2BB  8D BD 00    STA clueOffsetShift ;loop offset over
  351  06:D2BE  8D 05 00    STA temp6 ; length of second string
  352  06:D2C1  AD 04 00    LDA temp5
  353  06:D2C4  38          SEC
  354  06:D2C5  ED 05 00    SBC temp6 
  355  06:D2C8  8D 04 00    STA temp5 ;length of first string 
  356                       
  357  06:D2CB            .makeStrings:
  358                       
  359  06:D2CB  A2 00       LDX #$00
  360                       
  361  06:D2CD  AD 04 00    LDA temp5
  362  06:D2D0  F0 51       BEQ .makeSecondString
  363  06:D2D2  8A          TXA
  364  06:D2D3  48          PHA
  365                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp5
                          
       06:D2D4  A9 01       LDA #$01
       06:D2D6  8D 23 00    STA PPU_PendingWrite
       06:D2D9  AD BA 00    LDA clue_draw_address+1
       06:D2DC  20 0B CF    JSR WriteToPPUString
       06:D2DF  AD B9 00    LDA clue_draw_address
       06:D2E2  20 0B CF    JSR WriteToPPUString
       06:D2E5  A9 00       LDA #DRAW_HORIZONTAL
       06:D2E7  20 0B CF    JSR WriteToPPUString
       06:D2EA  AD 04 00    LDA temp5 
       06:D2ED  20 0B CF    JSR WriteToPPUString
                            
  366  06:D2F0  68          PLA
  367  06:D2F1  AA          TAX
  368                       
  369  06:D2F2            .firstStringLoop:
  370                       
  371  06:D2F2  8A          TXA 
  372  06:D2F3  48          PHA
  373  06:D2F4  BD 00 00    LDA temp1, x
  374  06:D2F7  20 0B CF    JSR WriteToPPUString
  375                       
  376  06:D2FA  EE BC 00    INC clueLineIndex
  377  06:D2FD  AD BC 00    LDA clueLineIndex
  378  06:D300  CD 07 00    CMP temp8
  379  06:D303  D0 04       BNE .continueLoop
  380  06:D305  68          PLA 
  381  06:D306  4C 8A D3    JMP .leave
  382                       
  383  06:D309            .continueLoop:
  384  06:D309  68          PLA
  385  06:D30A  AA          TAX
  386  06:D30B  E8          INX
  387  06:D30C  EC 04 00    CPX temp5
  388  06:D30F  D0 E1       BNE .firstStringLoop
  389                       
  390  06:D311  AD B9 00    LDA clue_draw_address
  391  06:D314  18          CLC
  392  06:D315  6D 04 00    ADC temp5
  393  06:D318  8D B9 00    STA clue_draw_address
  394  06:D31B  AD BA 00    LDA clue_draw_address+1
  395  06:D31E  69 00       ADC #$00
  396  06:D320  8D BA 00    STA clue_draw_address+1
  397                       
  398  06:D323            .makeSecondString:
  399                     
  400  06:D323  AD 05 00    LDA temp6
  401  06:D326  F0 62       BEQ .leave
  402                       
  403                       ;;loop draw address to next line
  404  06:D328  AD B9 00    LDA clue_draw_address
  405  06:D32B  18          CLC
  406  06:D32C  6D 08 00    ADC tempx
  407  06:D32F  8D B9 00    STA clue_draw_address
  408  06:D332  AD BA 00    LDA clue_draw_address+1
  409  06:D335  69 00       ADC #$00
  410  06:D337  8D BA 00    STA clue_draw_address+1
  411  06:D33A  8A          TXA
  412  06:D33B  48          PHA
  413                       MACROAddPPUStringEntryRawData clue_draw_address+1, clue_draw_address, #DRAW_HORIZONTAL, temp6
                          
       06:D33C  A9 01       LDA #$01
       06:D33E  8D 23 00    STA PPU_PendingWrite
       06:D341  AD BA 00    LDA clue_draw_address+1
       06:D344  20 0B CF    JSR WriteToPPUString
       06:D347  AD B9 00    LDA clue_draw_address
       06:D34A  20 0B CF    JSR WriteToPPUString
       06:D34D  A9 00       LDA #DRAW_HORIZONTAL
       06:D34F  20 0B CF    JSR WriteToPPUString
       06:D352  AD 05 00    LDA temp6 
       06:D355  20 0B CF    JSR WriteToPPUString
                            
  414  06:D358  68          PLA 
  415  06:D359  AA          TAX
  416                       
  417  06:D35A            .secondStringLoop:
  418                     
  419  06:D35A  8A          TXA
  420  06:D35B  48          PHA 
  421  06:D35C  BD 00 00    LDA temp1, x
  422  06:D35F  20 0B CF    JSR WriteToPPUString
  423                       
  424  06:D362  EE BC 00    INC clueLineIndex
  425  06:D365  AD BC 00    LDA clueLineIndex
  426  06:D368  CD 07 00    CMP temp8
  427  06:D36B  D0 04       BNE .continueSecondLoop
  428                       
  429  06:D36D  68          PLA 
  430  06:D36E  4C 8A D3    JMP .leave
  431                       
  432  06:D371            .continueSecondLoop:
  433  06:D371  68          PLA
  434  06:D372  AA          TAX
  435  06:D373  E8          INX
  436  06:D374  E0 04       CPX #$04
  437  06:D376  D0 E2       BNE .secondStringLoop
  438                       
  439  06:D378  AD B9 00    LDA clue_draw_address
  440  06:D37B  18          CLC
  441  06:D37C  6D 05 00    ADC temp6
  442  06:D37F  8D B9 00    STA clue_draw_address
  443  06:D382  AD BA 00    LDA clue_draw_address+1
  444  06:D385  69 00       ADC #$00
  445  06:D387  8D BA 00    STA clue_draw_address+1
  446                       
  447  06:D38A            .leave:
  448  06:D38A  EE BB 00    INC clueTableIndex
  449  06:D38D  60          RTS
  450                       
  451  06:D38E            ApplyGameTimeToPPUString:
  452                     
  453  06:D38E  8D 00 00    STA temp1
  454  06:D391  8E 01 00    STX temp2
  455                     
  456                       MACROAddPPUStringEntryRawData temp1, temp2, #DRAW_HORIZONTAL, #$05
                          
       06:D394  A9 01       LDA #$01
       06:D396  8D 23 00    STA PPU_PendingWrite
       06:D399  AD 00 00    LDA temp1
       06:D39C  20 0B CF    JSR WriteToPPUString
       06:D39F  AD 01 00    LDA temp2
       06:D3A2  20 0B CF    JSR WriteToPPUString
       06:D3A5  A9 00       LDA #DRAW_HORIZONTAL
       06:D3A7  20 0B CF    JSR WriteToPPUString
       06:D3AA  A9 05       LDA #$05 
       06:D3AC  20 0B CF    JSR WriteToPPUString
                            
  457  06:D3AF  AD 06 70    LDA GameTime+3
  458  06:D3B2  20 0B CF    JSR WriteToPPUString
  459  06:D3B5  AD 05 70    LDA GameTime+2
  460  06:D3B8  20 0B CF    JSR WriteToPPUString
  461  06:D3BB  A9 61       LDA #$61
  462  06:D3BD  20 0B CF    JSR WriteToPPUString
  463  06:D3C0  AD 04 70    LDA GameTime+1
  464  06:D3C3  20 0B CF    JSR WriteToPPUString
  465  06:D3C6  AD 03 70    LDA GameTime
  466  06:D3C9  20 0B CF    JSR WriteToPPUString
  467                       
  468  06:D3CC  60          RTS
  469                     
  470  06:D3CD            ClearLineDefs:
  471                     
  472  06:D3CD  20 20 20    .db $20, $20, $20, $20, $20, $20, $20, $20, $20, $20, $20
       06:D3D0  20 20 20  
       06:D3D3  20 20 20  
       06:D3D6  20 20     
  473  06:D3D8  0D 0D 0D    .db $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D, $0D
       06:D3DB  0D 0D 0D  
       06:D3DE  0D 0D 0D  
       06:D3E1  0D 0D 0D  
       06:D3E4  0D 0D 0D  
       06:D3E7  0D 0D     
  474  06:D3E9  20 20       .db $20, $20
  475                       
  476  06:D3EB            PuzzleSizes:
  477                       
  478  06:D3EB  05 0A 0F    .db $05, $0A, $0F
  479                       
  480  06:D3EE            PuzzleImageSizes:
  481                     
  482                       ;.db $05, $0A, $0F
  483  06:D3EE  19 64 E1    .db $19, $64, $E1
  484                       
  485  06:D3F1            ImageDrawWrapOffsets:
  486                     
  487  06:D3F1  1B 16 11   .db $1B, $16, $11
#[1]   Picross.asm
   97                       
   98                       
   99                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  100                     ;;     NMI                  ;;
  101                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  102                     
#[2]   Routines/Common/NMI.asm
  103                       .include "Routines/Common/NMI.asm"
    1                      
    2  06:D3F4            NMI:
    3                     
    4  06:D3F4  48          PHA                              ;protect the registers
    5  06:D3F5  8A          TXA
    6  06:D3F6  48          PHA
    7  06:D3F7  98          TYA
    8  06:D3F8  48          PHA
    9                       
   10  06:D3F9            nmi_started:
   11  06:D3F9  A9 00       LDA #$00
   12  06:D3FB  8D 03 20    STA OAM_LO      ; set the low byte (00) of the RAM address
   13  06:D3FE  A9 02       LDA #$02
   14  06:D400  8D 14 40    STA OAM_HI       ; set the high byte (02) of the RAM address, start the transfer
   15                     
   16  06:D403  AD 10 00    LDA NMI_locks
   17  06:D406  F0 03       BEQ update_controllers
   18  06:D408  4C 77 D4    JMP WakeUp
   19                     
   20  06:D40B            update_controllers:
   21                     
#[3]   Routines/Common/ReadControllers.asm
   22                       .include "Routines/Common/ReadControllers.asm"
    1                     
    2  06:D40B  8A            TXA
    3  06:D40C  48                PHA
    4  06:D40D  98                TYA
    5  06:D40E  48                PHA
    6                     
    7  06:D40F  A2 00             LDX #$00
    8                     
    9  06:D411            GamePadCheck:
   10  06:D411  A9 01             LDA #$01        ;load 1
   11  06:D413  8D 16 40          STA $4016       ; turn latch on
   12                             ;STA gamepad2
   13  06:D416  4A                LSR     A               ; move acc it over for a 0 bit, better than loading 0 to the acc, I guess
   14  06:D417  8D 16 40          STA $4016       ;turn latch off
   15                             
   16                             ;do a ring counter technique- load %10000000 into both
   17  06:D41A  A9 80             LDA #$80
   18  06:D41C  8D 1A 00          STA gamepad
   19                     
   20  06:D41F            ReadControllerABytesLoop:
   21  06:D41F  AD 16 40          LDA $4016               ;acc: %00000001 c: 0
   22  06:D422  29 03             AND #%00000011  ;acc: %00000001 c: 0
   23  06:D424  C9 01             CMP #%00000001  ;acc: %00000001 c: 1
   24                             ;ror shifts everything right one position: carry->bit 7, bit 0-> carry
   25  06:D426  6E 1A 00          ROR gamepad             ;gamepad: %11000000
   26                             ;eventually, the ROR sends out the 1 instead of all the leading 0s, BCC (branch carry clear) gets the 1 and does not loop
   27  06:D429  90 F4             BCC ReadControllerABytesLoop
   28                             
   29                             ;;comapre last to current, find the pressed buttons this frame
   30  06:D42B  AD 1B 00          LDA gamepadLast
   31  06:D42E  49 FF             EOR #$FF
   32  06:D430  2D 1A 00          AND gamepad
   33  06:D433  8D 1C 00          STA gamepadPressed
   34                             
   35                             
   36  06:D436  AD 1A 00          LDA gamepad
   37  06:D439  8D 1B 00          STA gamepadLast
   38                             
   39                             ;return x and y... before resetting them all over again- always good to make sure we're clean
   40  06:D43C  68                PLA
   41  06:D43D  A8                TAY
   42  06:D43E  68                PLA
   43  06:D43F  AA                TAX     
#[2]   Routines/Common/NMI.asm
   23                       
   24  06:D440  20 48 CE    JSR ProcessPPUString
   25                       
   26                       
   27  06:D443  A9 00       LDA #$00        ;;tell the ppu there is no background scrolling
   28  06:D445  8D 05 20    STA PPU_SCROLL
   29  06:D448  8D 05 20    STA PPU_SCROLL
   30                       
   31                       ; enable NMI, sprites from Pattern Table 0, background from Pattern Table 1
   32                       ; enable sprites, enable background, no clipping on left side 
   33  06:D44B  20 65 CF    JSR UpdatePPUControl
   34                     
   35  06:D44E            NMIUpdate:
   36                     
   37  06:D44E  20 6B D4    JSR StateNMIUpdate
   38                       
   39  06:D451  AD 1D 00    LDA PPU_Control
   40  06:D454  29 FC       AND #$FC
   41  06:D456  0D 21 00    ORA PPU_ScrollNT
   42  06:D459  8D 00 20    STA PPU_CTRL
   43                       
   44  06:D45C  AD 1F 00    LDA PPU_ScrollX     ;;tell the ppu there is no background scrolling
   45  06:D45F  8D 05 20    STA PPU_SCROLL
   46  06:D462  AD 20 00    LDA PPU_ScrollY
   47  06:D465  8D 05 20    STA PPU_SCROLL
   48                     
   49  06:D468  4C 77 D4    JMP WakeUp
   50                     
   51  06:D46B            StateNMIUpdate:
   52                     
   53                       MACROCallDynamicJump game_mode
                          
       06:D46B  AD 0E 00    LDA game_mode
       06:D46E  20 89 CD    JSR Dynamic_Jump
                                  
   54                     
   55  06:D471            NMIJumpTable:
   56                     
   57  06:D471  82 D4       .word UpdateTitleNMI
   58  06:D473  86 D4       .word UpdateGameNMI
   59  06:D475  87 D4       .word UpdateGameOverNMI
   60                     
   61  06:D477            WakeUp:
   62  06:D477  A9 00       LDA #$00
   63  06:D479  8D 0C 00    STA sleeping
   64                       
   65  06:D47C  68          PLA             ;restore the registers
   66  06:D47D  A8          TAY 
   67  06:D47E  68          PLA
   68  06:D47F  AA          TAX
   69  06:D480  68          PLA
   70                     
   71  06:D481  40          RTI             ; return from interrupt
   72                       
#[3]   Routines/NMI_States/UpdateTitleNMI.asm
   73                       .include "Routines/NMI_States/UpdateTitleNMI.asm"
    1  06:D482            UpdateTitleNMI:
    2                     
    3                       ;;load bank 0 for BG tiles, so we start with the right tile set
    4                       ;JSR ResetMapper
    5                       ;LDA #$01
    6                       ;JSR LoadCHRBankB
    7                     
    8                     
    9  06:D482  20 2B CF    JSR DetectSprite0
   10                     
   11                       ;JSR ResetMapper
   12                       ;LDA #$03
   13                       ;JSR LoadCHRBankB
   14                       
   15                     
   16                        
   17  06:D485  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameNMI.asm
   74                       .include "Routines/NMI_States/UpdateGameNMI.asm"
    1  06:D486            UpdateGameNMI:
    2  06:D486  60          RTS
#[2]   Routines/Common/NMI.asm
#[3]   Routines/NMI_States/UpdateGameOverNMI.asm
   75                       .include "Routines/NMI_States/UpdateGameOverNMI.asm"
    1  06:D487            UpdateGameOverNMI:
    2  06:D487  60          RTS
#[2]   Routines/Common/NMI.asm
#[1]   Picross.asm
  104                       
  105                     ;;**************************;;
  106                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  107                     ;;       PRG ROM DATA       ;;
  108                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  109                     ;;**************************;; 
  110                       
  111           0007        .bank 7
  112           E000        .org $E000
  113                     
#[2]   NameTables/Tables.asm
  114                       .include "NameTables/Tables.asm"
    1  07:E000            Palettes:
    2                     
    3  07:E000  1C E0       .word Title_Palette, Game_Palette, GameOver_Palette
       07:E002  3C E0     
       07:E004  5C E0     
    4                     
    5  07:E006            NameTables:
    6                     
    7  07:E006  12 E0       .word Title_Screens, Game_Screens, GameOver_Screens
       07:E008  14 E0     
       07:E00A  1A E0     
    8                       
    9  07:E00C            NameTables2:
   10                     
   11  07:E00C  7C E4       .word Title_Second, Blank_Screen, Blank_Screen
       07:E00E  7C F8     
       07:E010  7C F8     
   12                       
   13  07:E012            Title_Screens:
   14                     
   15  07:E012  7C E0       .word Title_Screen
   16                       
   17  07:E014            Game_Screens:
   18                     
   19  07:E014  7C E8       .word Game_5, Game_10, Game_15
       07:E016  7C EC     
       07:E018  7C F0     
   20                       
   21  07:E01A            GameOver_Screens:
   22                     
   23  07:E01A  7C F4       .word GameOver_Screen
   24                     
   25  07:E01C            Title_Palette:
   26                     
   27  07:E01C              .incbin "NameTables/Title_PAL.pal"
   28  07:E02C              .incbin "NameTables/Title_PAL.pal"
   29                       
   30  07:E03C            Game_Palette:
   31                     
   32  07:E03C              .incbin "NameTables/Game_PAL.pal"
   33  07:E04C              .incbin "NameTables/Game_PAL.pal"
   34                       
   35  07:E05C            GameOver_Palette:
   36                     
   37  07:E05C              .incbin "NameTables/GameOver_PAL.pal"
   38  07:E06C              .incbin "NameTables/GameOver_PAL.pal"
   39                       
   40  07:E07C            Title_Screen:
   41                     
   42  07:E07C              .incbin "NameTables/Title_NT.nam"
   43                       
   44  07:E47C            Title_Second:
   45                     
   46  07:E47C              .incbin "NameTables/Title_PuzzMen_NT.nam"
   47                       
   48  07:E87C            Game_5: 
   49                     
   50  07:E87C              .incbin "NameTables/Game_NT_5.nam"
   51                       
   52  07:EC7C            Game_10:
   53  07:EC7C              .incbin "NameTables/Game_NT_10.nam"
   54                       
   55  07:F07C            Game_15:
   56  07:F07C              .incbin "NameTables/Game_NT.nam"
   57                       
   58  07:F47C            GameOver_Screen:
   59                     
   60  07:F47C              .incbin "NameTables/GameOver_NT.nam"
   61                       
   62  07:F87C            Blank_Screen:
   63                     
   64  07:F87C              .incbin "NameTables/Blank_NT.nam"
   65                     
   66  07:FC7C            Pause_Menu:
   67  07:FC7C  28 2A 2A    .db $28,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$2a,$29
       07:FC7F  2A 2A 2A  
       07:FC82  2A 2A 2A  
       07:FC85  2A 2A 2A  
       07:FC88  29        
   68  07:FC89  2B 24 1C    .db $2b,$24,$1c,$0a,$1f,$0e,$62,$0e,$21,$12,$1d,$24,$3b
       07:FC8C  0A 1F 0E  
       07:FC8F  62 0E 21  
       07:FC92  12 1D 24  
       07:FC95  3B        
   69  07:FC96  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FC99  24 24 24  
       07:FC9C  24 24 24  
       07:FC9F  24 24 24  
       07:FCA2  3B        
   70  07:FCA3  2B 24 24    .db $2b,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$24,$3b
       07:FCA6  24 24 24  
       07:FCA9  24 24 24  
       07:FCAC  24 24 24  
       07:FCAF  3B        
   71  07:FCB0  2B 24 24    .db $2b,$24,$24,$22,$0e,$1c,$24,$24,$17,$18,$24,$24,$3b
       07:FCB3  22 0E 1C  
       07:FCB6  24 24 17  
       07:FCB9  18 24 24  
       07:FCBC  3B        
   72  07:FCBD  38 3A 3A    .db $38,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$3a,$39
       07:FCC0  3A 3A 3A  
       07:FCC3  3A 3A 3A  
       07:FCC6  3A 3A 3A  
       07:FCC9  39        
   73                     
   74  07:FCCA            EndScreens:
   75                     
   76  07:FCCA  CE FC       .word PuzzleClearLines, PuzzleSavedLines
       07:FCCC  FD FC     
   77                       
   78  07:FCCE            PuzzleClearLines:
   79                     
   80  07:FCCE  EA 20       .db $EA, $20
   81  07:FCD0  0D 19 1E    .db $0D, $19,$1e,$23,$23,$15,$0e,$24,$0c,$15,$0e,$0a,$1b,$64
       07:FCD3  23 23 15  
       07:FCD6  0E 24 0C  
       07:FCD9  15 0E 0A  
       07:FCDC  1B 64     
   82  07:FCDE  07 1D 12    .db $07, $1d,$12,$16,$0e,$61,$24,$24 ;print the time here as a separate call, similar to how it's printed in update game at 2131
       07:FCE1  16 0E 61  
       07:FCE4  24 24     
   83  07:FCE6  0C 17 0E    .db $0C, $17,$0e,$21,$1d,$24,$19,$1e,$23,$23,$15,$0e,$63
       07:FCE9  21 1D 24  
       07:FCEC  19 1E 23  
       07:FCEF  23 15 0E  
       07:FCF2  63        
   84  07:FCF3  09 24 24    .db $09, $24,$24,$22,$0e,$1c,$24,$24,$17,$18
       07:FCF6  22 0E 1C  
       07:FCF9  24 24 17  
       07:FCFC  18        
   85                     
   86  07:FCFD            PuzzleSavedLines:
   87                       
   88  07:FCFD  2A 21       .db $2A, $21 
   89  07:FCFF  0D 19 1E    .db $0D, $19,$1e,$23,$23,$15,$0e,$24,$1c,$0a,$1f,$0e,$0d,$64
       07:FD02  23 23 15  
       07:FD05  0E 24 1C  
       07:FD08  0A 1F 0E  
       07:FD0B  0D 64     
   90                       
   91  07:FD0D            SelectDefaultName:
   92                      
   93  07:FD0D  47 26       .db $47, $26 
   94  07:FD0F  10 63 63    .db $10, $63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63,$63
       07:FD12  63 63 63  
       07:FD15  63 63 63  
       07:FD18  63 63 63  
       07:FD1B  63 63 63  
       07:FD1E  63 63     
   95                     
   96  07:FD20            SelectDefaultTime:
   97                     
   98  07:FD20  8F 26       .db $8F, $26 
   99  07:FD22            DefaultTimeString:
  100  07:FD22  05 60 60    .db $05, $60,$60,$61,$60,$60
       07:FD25  61 60 60  
  101                     
  102                     
  103                      
  104                             
#[1]   Picross.asm
#[2]   Sprites/Sprites.asm
  115                       .include "Sprites/Sprites.asm"
    1                     
    2                     ;;Byte0
    3                     ;;Y position of top of sprite
    4                     ;;Sprite data is delayed by one scanline; 
    5                     ;;you must subtract 1 from the sprite's 
    6                     ;;Y coordinate before writing it here. 
    7                     ;;Hide a sprite by moving it down offscreen, 
    8                     ;;by writing any values between #$EF-#$FF here. 
    9                     ;;Sprites are never displayed on the first line of the picture, 
   10                     ;;and it is impossible to place a sprite partially off the top of the screen.
   11                     
   12                     ;;Byte 1
   13                     ;;Tile index number
   14                     ;;For 8x8 sprites, this is the tile number of this sprite within the pattern table selected in bit 3 of PPUCTRL ($2000).
   15                     ;;For 8x16 sprites (bit 5 of PPUCTRL set), the PPU ignores the pattern table selection and selects a pattern table from bit 0 of this number.
   16                     ;;76543210
   17                     ;;||||||||
   18                     ;;|||||||+- Bank ($0000 or $1000) of tiles
   19                     ;;+++++++-- Tile number of top of sprite (0 to 254; bottom half gets the next tile)
   20                     
   21                     ;;Byte 2
   22                     ;;Attributes
   23                     ;;76543210
   24                     ;;||||||||
   25                     ;;||||||++- Palette (4 to 7) of sprite
   26                     ;;|||+++--- Unimplemented (read 0)
   27                     ;;||+------ Priority (0: in front of background; 1: behind background)
   28                     ;;|+------- Flip sprite horizontally
   29                     ;;+-------- Flip sprite vertically
   30                     
   31                     ;;Byte 3
   32                     ;;X position of left side of sprite.
   33                     ;;X-scroll values of $F9-FF results in parts of the 
   34                     ;;sprite to be past the right edge of the screen, thus invisible.
   35                     ;;It is not possible to have a sprite partially visible on the left edge. 
   36                     ;;Instead, left-clipping through PPUMASK ($2001) can be used to simulate this effect.
   37  07:FD28            Sprites:
   38  07:FD28  2E FD             .word Title_Sprites, Game_Sprites, GameOver_Sprites
       07:FD2A  37 FD     
       07:FD2C  40 FD     
   39                     
   40  07:FD2E            Title_Sprites:
   41  07:FD2E  02            .db $02
   42  07:FD2F  85 00 00          .db $85,$00,$00,$E8
       07:FD32  E8        
   43  07:FD33  A0 01 00          .db $A0,$01,$00,$60
       07:FD36  60        
   44  07:FD37            Game_Sprites:
   45  07:FD37  02            .db $02
   46  07:FD38  62 02 03          .db $62,$02,$03,$72
       07:FD3B  72        
   47  07:FD3C  5F FF 00          .db $5F,$FF,$00,$60
       07:FD3F  60        
   48  07:FD40            GameOver_Sprites:
   49  07:FD40  01                .db $01
   50  07:FD41  67 FF 00          .db $67,$FF,$00,$58
       07:FD44  58        
#[1]   Picross.asm
  116                     
  117           FFFA        .org $FFFA     ;first of the three vectors starts here
  118  07:FFFA  F4 D3       .dw NMI        ;when an NMI happens (once per frame if enabled) the 
  119                                        ;processor will jump to the label NMI:
  120  07:FFFC  00 C0       .dw RESET      ;when the processor first turns on or is reset, it will jump
  121                                        ;to the label RESET:
  122  07:FFFE  00 00       .dw 0          ;external interrupt IRQ is not used in this tutorial
  123                       
  124                     ;;**************************;;
  125                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  126                     ;;      CHR ROM DATA        ;;
  127                     ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  128                     ;;**************************;; 
  129                       
  130           0008        .bank 8
  131           0000        .org $0000
  132  08:0000              .incbin "CHRROM/Bank0.chr"   ;includes 8KB graphics file from SMB1
  133                       
  134           0009        .bank 9
  135           0000        .org $0000
  136  09:0000              .incbin "CHRROM/Bank1.chr"
  137                       
  138           000A        .bank 10
  139           0000        .org $0000
  140  0A:0000              .incbin "CHRROM/Bank2.chr"
  141                       
  142           000B        .bank 11
  143           0000        .org $0000
  144  0B:0000              .incbin "CHRROM/Bank3.chr"
